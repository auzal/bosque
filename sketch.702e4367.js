// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/p5/lib/p5.min.js":[function(require,module,exports) {
var define;
var global = arguments[3];
/*! p5.js v1.2.0 December 19, 2020 */
!function (e) {
  if ("object" == typeof exports && "undefined" != typeof module) module.exports = e();else if ("function" == typeof define && define.amd) define([], e);else {
    ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).p5 = e();
  }
}(function () {
  return function a(o, s, l) {
    function u(t, e) {
      if (!s[t]) {
        if (!o[t]) {
          var r = "function" == typeof require && require;
          if (!e && r) return r(t, !0);
          if (h) return h(t, !0);
          var i = new Error("Cannot find module '" + t + "'");
          throw i.code = "MODULE_NOT_FOUND", i;
        }

        var n = s[t] = {
          exports: {}
        };
        o[t][0].call(n.exports, function (e) {
          return u(o[t][1][e] || e);
        }, n, n.exports, a, o, s, l);
      }

      return s[t].exports;
    }

    for (var h = "function" == typeof require && require, e = 0; e < l.length; e++) u(l[e]);

    return u;
  }({
    1: [function (e, t, r) {
      "use strict";

      r.byteLength = function (e) {
        var t = c(e),
            r = t[0],
            i = t[1];
        return 3 * (r + i) / 4 - i;
      }, r.toByteArray = function (e) {
        var t,
            r,
            i = c(e),
            n = i[0],
            a = i[1],
            o = new h(function (e, t) {
          return 3 * (e + t) / 4 - t;
        }(n, a)),
            s = 0,
            l = 0 < a ? n - 4 : n;

        for (r = 0; r < l; r += 4) t = u[e.charCodeAt(r)] << 18 | u[e.charCodeAt(r + 1)] << 12 | u[e.charCodeAt(r + 2)] << 6 | u[e.charCodeAt(r + 3)], o[s++] = t >> 16 & 255, o[s++] = t >> 8 & 255, o[s++] = 255 & t;

        2 === a && (t = u[e.charCodeAt(r)] << 2 | u[e.charCodeAt(r + 1)] >> 4, o[s++] = 255 & t);
        1 === a && (t = u[e.charCodeAt(r)] << 10 | u[e.charCodeAt(r + 1)] << 4 | u[e.charCodeAt(r + 2)] >> 2, o[s++] = t >> 8 & 255, o[s++] = 255 & t);
        return o;
      }, r.fromByteArray = function (e) {
        for (var t, r = e.length, i = r % 3, n = [], a = 0, o = r - i; a < o; a += 16383) n.push(l(e, a, o < a + 16383 ? o : a + 16383));

        1 == i ? (t = e[r - 1], n.push(s[t >> 2] + s[t << 4 & 63] + "==")) : 2 == i && (t = (e[r - 2] << 8) + e[r - 1], n.push(s[t >> 10] + s[t >> 4 & 63] + s[t << 2 & 63] + "="));
        return n.join("");
      };

      for (var s = [], u = [], h = "undefined" != typeof Uint8Array ? Uint8Array : Array, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = 0, a = i.length; n < a; ++n) s[n] = i[n], u[i.charCodeAt(n)] = n;

      function c(e) {
        var t = e.length;
        if (0 < t % 4) throw new Error("Invalid string. Length must be a multiple of 4");
        var r = e.indexOf("=");
        return -1 === r && (r = t), [r, r === t ? 0 : 4 - r % 4];
      }

      function l(e, t, r) {
        for (var i, n, a = [], o = t; o < r; o += 3) i = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (255 & e[o + 2]), a.push(s[(n = i) >> 18 & 63] + s[n >> 12 & 63] + s[n >> 6 & 63] + s[63 & n]);

        return a.join("");
      }

      u["-".charCodeAt(0)] = 62, u["_".charCodeAt(0)] = 63;
    }, {}],
    2: [function (e, t, r) {}, {}],
    3: [function (e, t, r) {
      arguments[4][2][0].apply(r, arguments);
    }, {
      dup: 2
    }],
    4: [function (N, e, F) {
      (function (c) {
        "use strict";

        var i = N("base64-js"),
            a = N("ieee754"),
            e = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
        F.Buffer = c, F.SlowBuffer = function (e) {
          +e != e && (e = 0);
          return c.alloc(+e);
        }, F.INSPECT_MAX_BYTES = 50;
        var r = 2147483647;

        function o(e) {
          if (r < e) throw new RangeError('The value "' + e + '" is invalid for option "size"');
          var t = new Uint8Array(e);
          return Object.setPrototypeOf(t, c.prototype), t;
        }

        function c(e, t, r) {
          if ("number" != typeof e) return n(e, t, r);
          if ("string" == typeof t) throw new TypeError('The "string" argument must be of type string. Received type number');
          return l(e);
        }

        function n(e, t, r) {
          if ("string" == typeof e) return function (e, t) {
            "string" == typeof t && "" !== t || (t = "utf8");
            if (!c.isEncoding(t)) throw new TypeError("Unknown encoding: " + t);
            var r = 0 | f(e, t),
                i = o(r),
                n = i.write(e, t);
            n !== r && (i = i.slice(0, n));
            return i;
          }(e, t);
          if (ArrayBuffer.isView(e)) return u(e);
          if (null == e) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
          if (A(e, ArrayBuffer) || e && A(e.buffer, ArrayBuffer)) return function (e, t, r) {
            if (t < 0 || e.byteLength < t) throw new RangeError('"offset" is outside of buffer bounds');
            if (e.byteLength < t + (r || 0)) throw new RangeError('"length" is outside of buffer bounds');
            var i;
            i = void 0 === t && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e, t) : new Uint8Array(e, t, r);
            return Object.setPrototypeOf(i, c.prototype), i;
          }(e, t, r);
          if ("number" == typeof e) throw new TypeError('The "value" argument must not be of type number. Received type number');
          var i = e.valueOf && e.valueOf();
          if (null != i && i !== e) return c.from(i, t, r);

          var n = function (e) {
            if (c.isBuffer(e)) {
              var t = 0 | h(e.length),
                  r = o(t);
              return 0 === r.length || e.copy(r, 0, 0, t), r;
            }

            if (void 0 !== e.length) return "number" != typeof e.length || I(e.length) ? o(0) : u(e);
            if ("Buffer" === e.type && Array.isArray(e.data)) return u(e.data);
          }(e);

          if (n) return n;
          if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e[Symbol.toPrimitive]) return c.from(e[Symbol.toPrimitive]("string"), t, r);
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
        }

        function s(e) {
          if ("number" != typeof e) throw new TypeError('"size" argument must be of type number');
          if (e < 0) throw new RangeError('The value "' + e + '" is invalid for option "size"');
        }

        function l(e) {
          return s(e), o(e < 0 ? 0 : 0 | h(e));
        }

        function u(e) {
          for (var t = e.length < 0 ? 0 : 0 | h(e.length), r = o(t), i = 0; i < t; i += 1) r[i] = 255 & e[i];

          return r;
        }

        function h(e) {
          if (r <= e) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + r.toString(16) + " bytes");
          return 0 | e;
        }

        function f(e, t) {
          if (c.isBuffer(e)) return e.length;
          if (ArrayBuffer.isView(e) || A(e, ArrayBuffer)) return e.byteLength;
          if ("string" != typeof e) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
          var r = e.length,
              i = 2 < arguments.length && !0 === arguments[2];
          if (!i && 0 === r) return 0;

          for (var n = !1;;) switch (t) {
            case "ascii":
            case "latin1":
            case "binary":
              return r;

            case "utf8":
            case "utf-8":
              return R(e).length;

            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * r;

            case "hex":
              return r >>> 1;

            case "base64":
              return D(e).length;

            default:
              if (n) return i ? -1 : R(e).length;
              t = ("" + t).toLowerCase(), n = !0;
          }
        }

        function d(e, t, r) {
          var i = e[t];
          e[t] = e[r], e[r] = i;
        }

        function p(e, t, r, i, n) {
          if (0 === e.length) return -1;

          if ("string" == typeof r ? (i = r, r = 0) : 2147483647 < r ? r = 2147483647 : r < -2147483648 && (r = -2147483648), I(r = +r) && (r = n ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
            if (n) return -1;
            r = e.length - 1;
          } else if (r < 0) {
            if (!n) return -1;
            r = 0;
          }

          if ("string" == typeof t && (t = c.from(t, i)), c.isBuffer(t)) return 0 === t.length ? -1 : m(e, t, r, i, n);
          if ("number" == typeof t) return t &= 255, "function" == typeof Uint8Array.prototype.indexOf ? n ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : m(e, [t], r, i, n);
          throw new TypeError("val must be string, number or Buffer");
        }

        function m(e, t, r, i, n) {
          var a,
              o = 1,
              s = e.length,
              l = t.length;

          if (void 0 !== i && ("ucs2" === (i = String(i).toLowerCase()) || "ucs-2" === i || "utf16le" === i || "utf-16le" === i)) {
            if (e.length < 2 || t.length < 2) return -1;
            s /= o = 2, l /= 2, r /= 2;
          }

          function u(e, t) {
            return 1 === o ? e[t] : e.readUInt16BE(t * o);
          }

          if (n) {
            var h = -1;

            for (a = r; a < s; a++) if (u(e, a) === u(t, -1 === h ? 0 : a - h)) {
              if (-1 === h && (h = a), a - h + 1 === l) return h * o;
            } else -1 !== h && (a -= a - h), h = -1;
          } else for (s < r + l && (r = s - l), a = r; 0 <= a; a--) {
            for (var c = !0, f = 0; f < l; f++) if (u(e, a + f) !== u(t, f)) {
              c = !1;
              break;
            }

            if (c) return a;
          }

          return -1;
        }

        function v(e, t, r, i) {
          r = Number(r) || 0;
          var n = e.length - r;
          i ? n < (i = Number(i)) && (i = n) : i = n;
          var a = t.length;
          a / 2 < i && (i = a / 2);

          for (var o = 0; o < i; ++o) {
            var s = parseInt(t.substr(2 * o, 2), 16);
            if (I(s)) return o;
            e[r + o] = s;
          }

          return o;
        }

        function y(e, t, r, i) {
          return k(function (e) {
            for (var t = [], r = 0; r < e.length; ++r) t.push(255 & e.charCodeAt(r));

            return t;
          }(t), e, r, i);
        }

        function g(e, t, r, i) {
          return k(function (e, t) {
            for (var r, i, n, a = [], o = 0; o < e.length && !((t -= 2) < 0); ++o) r = e.charCodeAt(o), i = r >> 8, n = r % 256, a.push(n), a.push(i);

            return a;
          }(t, e.length - r), e, r, i);
        }

        function b(e, t, r) {
          return 0 === t && r === e.length ? i.fromByteArray(e) : i.fromByteArray(e.slice(t, r));
        }

        function _(e, t, r) {
          r = Math.min(e.length, r);

          for (var i = [], n = t; n < r;) {
            var a,
                o,
                s,
                l,
                u = e[n],
                h = null,
                c = 239 < u ? 4 : 223 < u ? 3 : 191 < u ? 2 : 1;
            if (n + c <= r) switch (c) {
              case 1:
                u < 128 && (h = u);
                break;

              case 2:
                128 == (192 & (a = e[n + 1])) && 127 < (l = (31 & u) << 6 | 63 & a) && (h = l);
                break;

              case 3:
                a = e[n + 1], o = e[n + 2], 128 == (192 & a) && 128 == (192 & o) && 2047 < (l = (15 & u) << 12 | (63 & a) << 6 | 63 & o) && (l < 55296 || 57343 < l) && (h = l);
                break;

              case 4:
                a = e[n + 1], o = e[n + 2], s = e[n + 3], 128 == (192 & a) && 128 == (192 & o) && 128 == (192 & s) && 65535 < (l = (15 & u) << 18 | (63 & a) << 12 | (63 & o) << 6 | 63 & s) && l < 1114112 && (h = l);
            }
            null === h ? (h = 65533, c = 1) : 65535 < h && (h -= 65536, i.push(h >>> 10 & 1023 | 55296), h = 56320 | 1023 & h), i.push(h), n += c;
          }

          return function (e) {
            var t = e.length;
            if (t <= x) return String.fromCharCode.apply(String, e);
            var r = "",
                i = 0;

            for (; i < t;) r += String.fromCharCode.apply(String, e.slice(i, i += x));

            return r;
          }(i);
        }

        F.kMaxLength = r, (c.TYPED_ARRAY_SUPPORT = function () {
          try {
            var e = new Uint8Array(1),
                t = {
              foo: function () {
                return 42;
              }
            };
            return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), 42 === e.foo();
          } catch (e) {
            return !1;
          }
        }()) || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(c.prototype, "parent", {
          enumerable: !0,
          get: function () {
            if (c.isBuffer(this)) return this.buffer;
          }
        }), Object.defineProperty(c.prototype, "offset", {
          enumerable: !0,
          get: function () {
            if (c.isBuffer(this)) return this.byteOffset;
          }
        }), "undefined" != typeof Symbol && null != Symbol.species && c[Symbol.species] === c && Object.defineProperty(c, Symbol.species, {
          value: null,
          configurable: !0,
          enumerable: !1,
          writable: !1
        }), c.poolSize = 8192, c.from = function (e, t, r) {
          return n(e, t, r);
        }, Object.setPrototypeOf(c.prototype, Uint8Array.prototype), Object.setPrototypeOf(c, Uint8Array), c.alloc = function (e, t, r) {
          return n = t, a = r, s(i = e), i <= 0 ? o(i) : void 0 !== n ? "string" == typeof a ? o(i).fill(n, a) : o(i).fill(n) : o(i);
          var i, n, a;
        }, c.allocUnsafe = function (e) {
          return l(e);
        }, c.allocUnsafeSlow = function (e) {
          return l(e);
        }, c.isBuffer = function (e) {
          return null != e && !0 === e._isBuffer && e !== c.prototype;
        }, c.compare = function (e, t) {
          if (A(e, Uint8Array) && (e = c.from(e, e.offset, e.byteLength)), A(t, Uint8Array) && (t = c.from(t, t.offset, t.byteLength)), !c.isBuffer(e) || !c.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (e === t) return 0;

          for (var r = e.length, i = t.length, n = 0, a = Math.min(r, i); n < a; ++n) if (e[n] !== t[n]) {
            r = e[n], i = t[n];
            break;
          }

          return r < i ? -1 : i < r ? 1 : 0;
        }, c.isEncoding = function (e) {
          switch (String(e).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;

            default:
              return !1;
          }
        }, c.concat = function (e, t) {
          if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
          if (0 === e.length) return c.alloc(0);
          var r;
          if (void 0 === t) for (r = t = 0; r < e.length; ++r) t += e[r].length;
          var i = c.allocUnsafe(t),
              n = 0;

          for (r = 0; r < e.length; ++r) {
            var a = e[r];
            if (A(a, Uint8Array) && (a = c.from(a)), !c.isBuffer(a)) throw new TypeError('"list" argument must be an Array of Buffers');
            a.copy(i, n), n += a.length;
          }

          return i;
        }, c.byteLength = f, c.prototype._isBuffer = !0, c.prototype.swap16 = function () {
          var e = this.length;
          if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");

          for (var t = 0; t < e; t += 2) d(this, t, t + 1);

          return this;
        }, c.prototype.swap32 = function () {
          var e = this.length;
          if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");

          for (var t = 0; t < e; t += 4) d(this, t, t + 3), d(this, t + 1, t + 2);

          return this;
        }, c.prototype.swap64 = function () {
          var e = this.length;
          if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");

          for (var t = 0; t < e; t += 8) d(this, t, t + 7), d(this, t + 1, t + 6), d(this, t + 2, t + 5), d(this, t + 3, t + 4);

          return this;
        }, c.prototype.toLocaleString = c.prototype.toString = function () {
          var e = this.length;
          return 0 === e ? "" : 0 === arguments.length ? _(this, 0, e) : function (e, t, r) {
            var i = !1;
            if ((void 0 === t || t < 0) && (t = 0), t > this.length) return "";
            if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return "";
            if ((r >>>= 0) <= (t >>>= 0)) return "";

            for (e = e || "utf8";;) switch (e) {
              case "hex":
                return M(this, t, r);

              case "utf8":
              case "utf-8":
                return _(this, t, r);

              case "ascii":
                return w(this, t, r);

              case "latin1":
              case "binary":
                return S(this, t, r);

              case "base64":
                return b(this, t, r);

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return T(this, t, r);

              default:
                if (i) throw new TypeError("Unknown encoding: " + e);
                e = (e + "").toLowerCase(), i = !0;
            }
          }.apply(this, arguments);
        }, c.prototype.equals = function (e) {
          if (!c.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
          return this === e || 0 === c.compare(this, e);
        }, c.prototype.inspect = function () {
          var e = "",
              t = F.INSPECT_MAX_BYTES;
          return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buffer " + e + ">";
        }, e && (c.prototype[e] = c.prototype.inspect), c.prototype.compare = function (e, t, r, i, n) {
          if (A(e, Uint8Array) && (e = c.from(e, e.offset, e.byteLength)), !c.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
          if (void 0 === t && (t = 0), void 0 === r && (r = e ? e.length : 0), void 0 === i && (i = 0), void 0 === n && (n = this.length), t < 0 || r > e.length || i < 0 || n > this.length) throw new RangeError("out of range index");
          if (n <= i && r <= t) return 0;
          if (n <= i) return -1;
          if (r <= t) return 1;
          if (this === e) return 0;

          for (var a = (n >>>= 0) - (i >>>= 0), o = (r >>>= 0) - (t >>>= 0), s = Math.min(a, o), l = this.slice(i, n), u = e.slice(t, r), h = 0; h < s; ++h) if (l[h] !== u[h]) {
            a = l[h], o = u[h];
            break;
          }

          return a < o ? -1 : o < a ? 1 : 0;
        }, c.prototype.includes = function (e, t, r) {
          return -1 !== this.indexOf(e, t, r);
        }, c.prototype.indexOf = function (e, t, r) {
          return p(this, e, t, r, !0);
        }, c.prototype.lastIndexOf = function (e, t, r) {
          return p(this, e, t, r, !1);
        }, c.prototype.write = function (e, t, r, i) {
          if (void 0 === t) i = "utf8", r = this.length, t = 0;else if (void 0 === r && "string" == typeof t) i = t, r = this.length, t = 0;else {
            if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            t >>>= 0, isFinite(r) ? (r >>>= 0, void 0 === i && (i = "utf8")) : (i = r, r = void 0);
          }
          var n = this.length - t;
          if ((void 0 === r || n < r) && (r = n), 0 < e.length && (r < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
          i = i || "utf8";

          for (var a, o, s, l, u, h, c = !1;;) switch (i) {
            case "hex":
              return v(this, e, t, r);

            case "utf8":
            case "utf-8":
              return u = t, h = r, k(R(e, (l = this).length - u), l, u, h);

            case "ascii":
              return y(this, e, t, r);

            case "latin1":
            case "binary":
              return y(this, e, t, r);

            case "base64":
              return a = this, o = t, s = r, k(D(e), a, o, s);

            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return g(this, e, t, r);

            default:
              if (c) throw new TypeError("Unknown encoding: " + i);
              i = ("" + i).toLowerCase(), c = !0;
          }
        }, c.prototype.toJSON = function () {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
          };
        };
        var x = 4096;

        function w(e, t, r) {
          var i = "";
          r = Math.min(e.length, r);

          for (var n = t; n < r; ++n) i += String.fromCharCode(127 & e[n]);

          return i;
        }

        function S(e, t, r) {
          var i = "";
          r = Math.min(e.length, r);

          for (var n = t; n < r; ++n) i += String.fromCharCode(e[n]);

          return i;
        }

        function M(e, t, r) {
          var i = e.length;
          (!t || t < 0) && (t = 0), (!r || r < 0 || i < r) && (r = i);

          for (var n = "", a = t; a < r; ++a) n += U[e[a]];

          return n;
        }

        function T(e, t, r) {
          for (var i = e.slice(t, r), n = "", a = 0; a < i.length; a += 2) n += String.fromCharCode(i[a] + 256 * i[a + 1]);

          return n;
        }

        function E(e, t, r) {
          if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
          if (r < e + t) throw new RangeError("Trying to access beyond buffer length");
        }

        function C(e, t, r, i, n, a) {
          if (!c.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (n < t || t < a) throw new RangeError('"value" argument is out of bounds');
          if (r + i > e.length) throw new RangeError("Index out of range");
        }

        function L(e, t, r, i) {
          if (r + i > e.length) throw new RangeError("Index out of range");
          if (r < 0) throw new RangeError("Index out of range");
        }

        function O(e, t, r, i, n) {
          return t = +t, r >>>= 0, n || L(e, 0, r, 4), a.write(e, t, r, i, 23, 4), r + 4;
        }

        function P(e, t, r, i, n) {
          return t = +t, r >>>= 0, n || L(e, 0, r, 8), a.write(e, t, r, i, 52, 8), r + 8;
        }

        c.prototype.slice = function (e, t) {
          var r = this.length;
          (e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : r < e && (e = r), (t = void 0 === t ? r : ~~t) < 0 ? (t += r) < 0 && (t = 0) : r < t && (t = r), t < e && (t = e);
          var i = this.subarray(e, t);
          return Object.setPrototypeOf(i, c.prototype), i;
        }, c.prototype.readUIntLE = function (e, t, r) {
          e >>>= 0, t >>>= 0, r || E(e, t, this.length);

          for (var i = this[e], n = 1, a = 0; ++a < t && (n *= 256);) i += this[e + a] * n;

          return i;
        }, c.prototype.readUIntBE = function (e, t, r) {
          e >>>= 0, t >>>= 0, r || E(e, t, this.length);

          for (var i = this[e + --t], n = 1; 0 < t && (n *= 256);) i += this[e + --t] * n;

          return i;
        }, c.prototype.readUInt8 = function (e, t) {
          return e >>>= 0, t || E(e, 1, this.length), this[e];
        }, c.prototype.readUInt16LE = function (e, t) {
          return e >>>= 0, t || E(e, 2, this.length), this[e] | this[e + 1] << 8;
        }, c.prototype.readUInt16BE = function (e, t) {
          return e >>>= 0, t || E(e, 2, this.length), this[e] << 8 | this[e + 1];
        }, c.prototype.readUInt32LE = function (e, t) {
          return e >>>= 0, t || E(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3];
        }, c.prototype.readUInt32BE = function (e, t) {
          return e >>>= 0, t || E(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
        }, c.prototype.readIntLE = function (e, t, r) {
          e >>>= 0, t >>>= 0, r || E(e, t, this.length);

          for (var i = this[e], n = 1, a = 0; ++a < t && (n *= 256);) i += this[e + a] * n;

          return (n *= 128) <= i && (i -= Math.pow(2, 8 * t)), i;
        }, c.prototype.readIntBE = function (e, t, r) {
          e >>>= 0, t >>>= 0, r || E(e, t, this.length);

          for (var i = t, n = 1, a = this[e + --i]; 0 < i && (n *= 256);) a += this[e + --i] * n;

          return (n *= 128) <= a && (a -= Math.pow(2, 8 * t)), a;
        }, c.prototype.readInt8 = function (e, t) {
          return e >>>= 0, t || E(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e];
        }, c.prototype.readInt16LE = function (e, t) {
          e >>>= 0, t || E(e, 2, this.length);
          var r = this[e] | this[e + 1] << 8;
          return 32768 & r ? 4294901760 | r : r;
        }, c.prototype.readInt16BE = function (e, t) {
          e >>>= 0, t || E(e, 2, this.length);
          var r = this[e + 1] | this[e] << 8;
          return 32768 & r ? 4294901760 | r : r;
        }, c.prototype.readInt32LE = function (e, t) {
          return e >>>= 0, t || E(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
        }, c.prototype.readInt32BE = function (e, t) {
          return e >>>= 0, t || E(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
        }, c.prototype.readFloatLE = function (e, t) {
          return e >>>= 0, t || E(e, 4, this.length), a.read(this, e, !0, 23, 4);
        }, c.prototype.readFloatBE = function (e, t) {
          return e >>>= 0, t || E(e, 4, this.length), a.read(this, e, !1, 23, 4);
        }, c.prototype.readDoubleLE = function (e, t) {
          return e >>>= 0, t || E(e, 8, this.length), a.read(this, e, !0, 52, 8);
        }, c.prototype.readDoubleBE = function (e, t) {
          return e >>>= 0, t || E(e, 8, this.length), a.read(this, e, !1, 52, 8);
        }, c.prototype.writeUIntLE = function (e, t, r, i) {
          e = +e, t >>>= 0, r >>>= 0, i || C(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
          var n = 1,
              a = 0;

          for (this[t] = 255 & e; ++a < r && (n *= 256);) this[t + a] = e / n & 255;

          return t + r;
        }, c.prototype.writeUIntBE = function (e, t, r, i) {
          e = +e, t >>>= 0, r >>>= 0, i || C(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
          var n = r - 1,
              a = 1;

          for (this[t + n] = 255 & e; 0 <= --n && (a *= 256);) this[t + n] = e / a & 255;

          return t + r;
        }, c.prototype.writeUInt8 = function (e, t, r) {
          return e = +e, t >>>= 0, r || C(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1;
        }, c.prototype.writeUInt16LE = function (e, t, r) {
          return e = +e, t >>>= 0, r || C(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2;
        }, c.prototype.writeUInt16BE = function (e, t, r) {
          return e = +e, t >>>= 0, r || C(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2;
        }, c.prototype.writeUInt32LE = function (e, t, r) {
          return e = +e, t >>>= 0, r || C(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4;
        }, c.prototype.writeUInt32BE = function (e, t, r) {
          return e = +e, t >>>= 0, r || C(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4;
        }, c.prototype.writeIntLE = function (e, t, r, i) {
          if (e = +e, t >>>= 0, !i) {
            var n = Math.pow(2, 8 * r - 1);
            C(this, e, t, r, n - 1, -n);
          }

          var a = 0,
              o = 1,
              s = 0;

          for (this[t] = 255 & e; ++a < r && (o *= 256);) e < 0 && 0 === s && 0 !== this[t + a - 1] && (s = 1), this[t + a] = (e / o >> 0) - s & 255;

          return t + r;
        }, c.prototype.writeIntBE = function (e, t, r, i) {
          if (e = +e, t >>>= 0, !i) {
            var n = Math.pow(2, 8 * r - 1);
            C(this, e, t, r, n - 1, -n);
          }

          var a = r - 1,
              o = 1,
              s = 0;

          for (this[t + a] = 255 & e; 0 <= --a && (o *= 256);) e < 0 && 0 === s && 0 !== this[t + a + 1] && (s = 1), this[t + a] = (e / o >> 0) - s & 255;

          return t + r;
        }, c.prototype.writeInt8 = function (e, t, r) {
          return e = +e, t >>>= 0, r || C(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1;
        }, c.prototype.writeInt16LE = function (e, t, r) {
          return e = +e, t >>>= 0, r || C(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2;
        }, c.prototype.writeInt16BE = function (e, t, r) {
          return e = +e, t >>>= 0, r || C(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2;
        }, c.prototype.writeInt32LE = function (e, t, r) {
          return e = +e, t >>>= 0, r || C(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4;
        }, c.prototype.writeInt32BE = function (e, t, r) {
          return e = +e, t >>>= 0, r || C(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4;
        }, c.prototype.writeFloatLE = function (e, t, r) {
          return O(this, e, t, !0, r);
        }, c.prototype.writeFloatBE = function (e, t, r) {
          return O(this, e, t, !1, r);
        }, c.prototype.writeDoubleLE = function (e, t, r) {
          return P(this, e, t, !0, r);
        }, c.prototype.writeDoubleBE = function (e, t, r) {
          return P(this, e, t, !1, r);
        }, c.prototype.copy = function (e, t, r, i) {
          if (!c.isBuffer(e)) throw new TypeError("argument should be a Buffer");
          if (r = r || 0, i || 0 === i || (i = this.length), t >= e.length && (t = e.length), t = t || 0, 0 < i && i < r && (i = r), i === r) return 0;
          if (0 === e.length || 0 === this.length) return 0;
          if (t < 0) throw new RangeError("targetStart out of bounds");
          if (r < 0 || r >= this.length) throw new RangeError("Index out of range");
          if (i < 0) throw new RangeError("sourceEnd out of bounds");
          i > this.length && (i = this.length), e.length - t < i - r && (i = e.length - t + r);
          var n = i - r;
          if (this === e && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(t, r, i);else if (this === e && r < t && t < i) for (var a = n - 1; 0 <= a; --a) e[a + t] = this[a + r];else Uint8Array.prototype.set.call(e, this.subarray(r, i), t);
          return n;
        }, c.prototype.fill = function (e, t, r, i) {
          if ("string" == typeof e) {
            if ("string" == typeof t ? (i = t, t = 0, r = this.length) : "string" == typeof r && (i = r, r = this.length), void 0 !== i && "string" != typeof i) throw new TypeError("encoding must be a string");
            if ("string" == typeof i && !c.isEncoding(i)) throw new TypeError("Unknown encoding: " + i);

            if (1 === e.length) {
              var n = e.charCodeAt(0);
              ("utf8" === i && n < 128 || "latin1" === i) && (e = n);
            }
          } else "number" == typeof e ? e &= 255 : "boolean" == typeof e && (e = Number(e));

          if (t < 0 || this.length < t || this.length < r) throw new RangeError("Out of range index");
          if (r <= t) return this;
          var a;
          if (t >>>= 0, r = void 0 === r ? this.length : r >>> 0, "number" == typeof (e = e || 0)) for (a = t; a < r; ++a) this[a] = e;else {
            var o = c.isBuffer(e) ? e : c.from(e, i),
                s = o.length;
            if (0 === s) throw new TypeError('The value "' + e + '" is invalid for argument "value"');

            for (a = 0; a < r - t; ++a) this[a + t] = o[a % s];
          }
          return this;
        };
        var t = /[^+/0-9A-Za-z-_]/g;

        function R(e, t) {
          var r;
          t = t || 1 / 0;

          for (var i = e.length, n = null, a = [], o = 0; o < i; ++o) {
            if (55295 < (r = e.charCodeAt(o)) && r < 57344) {
              if (!n) {
                if (56319 < r) {
                  -1 < (t -= 3) && a.push(239, 191, 189);
                  continue;
                }

                if (o + 1 === i) {
                  -1 < (t -= 3) && a.push(239, 191, 189);
                  continue;
                }

                n = r;
                continue;
              }

              if (r < 56320) {
                -1 < (t -= 3) && a.push(239, 191, 189), n = r;
                continue;
              }

              r = 65536 + (n - 55296 << 10 | r - 56320);
            } else n && -1 < (t -= 3) && a.push(239, 191, 189);

            if (n = null, r < 128) {
              if (--t < 0) break;
              a.push(r);
            } else if (r < 2048) {
              if ((t -= 2) < 0) break;
              a.push(r >> 6 | 192, 63 & r | 128);
            } else if (r < 65536) {
              if ((t -= 3) < 0) break;
              a.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128);
            } else {
              if (!(r < 1114112)) throw new Error("Invalid code point");
              if ((t -= 4) < 0) break;
              a.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128);
            }
          }

          return a;
        }

        function D(e) {
          return i.toByteArray(function (e) {
            if ((e = (e = e.split("=")[0]).trim().replace(t, "")).length < 2) return "";

            for (; e.length % 4 != 0;) e += "=";

            return e;
          }(e));
        }

        function k(e, t, r, i) {
          for (var n = 0; n < i && !(n + r >= t.length || n >= e.length); ++n) t[n + r] = e[n];

          return n;
        }

        function A(e, t) {
          return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name;
        }

        function I(e) {
          return e != e;
        }

        var U = function () {
          for (var e = "0123456789abcdef", t = new Array(256), r = 0; r < 16; ++r) for (var i = 16 * r, n = 0; n < 16; ++n) t[i + n] = e[r] + e[n];

          return t;
        }();
      }).call(this, N("buffer").Buffer);
    }, {
      "base64-js": 1,
      buffer: 4,
      ieee754: 9
    }],
    5: [function (e, t, r) {
      "use strict";

      t.exports = e("./").polyfill();
    }, {
      "./": 6
    }],
    6: [function (z, r, i) {
      (function (j, V) {
        var e, t;
        e = this, t = function () {
          "use strict";

          function l(e) {
            return "function" == typeof e;
          }

          var r = Array.isArray ? Array.isArray : function (e) {
            return "[object Array]" === Object.prototype.toString.call(e);
          },
              i = 0,
              t = void 0,
              n = void 0,
              o = function (e, t) {
            f[i] = e, f[i + 1] = t, 2 === (i += 2) && (n ? n(d) : g());
          };

          var e = "undefined" != typeof window ? window : void 0,
              a = e || {},
              s = a.MutationObserver || a.WebKitMutationObserver,
              u = "undefined" == typeof self && void 0 !== j && "[object process]" === {}.toString.call(j),
              h = "undefined" != typeof Uint8ClampedArray && "undefined" != typeof importScripts && "undefined" != typeof MessageChannel;

          function c() {
            var e = setTimeout;
            return function () {
              return e(d, 1);
            };
          }

          var f = new Array(1e3);

          function d() {
            for (var e = 0; e < i; e += 2) {
              (0, f[e])(f[e + 1]), f[e] = void 0, f[e + 1] = void 0;
            }

            i = 0;
          }

          var p,
              m,
              v,
              y,
              g = void 0;

          function b(e, t) {
            var r = this,
                i = new this.constructor(w);
            void 0 === i[x] && U(i);
            var n = r._state;

            if (n) {
              var a = arguments[n - 1];
              o(function () {
                return A(n, i, a, r._result);
              });
            } else D(r, i, e, t);

            return i;
          }

          function _(e) {
            if (e && "object" == typeof e && e.constructor === this) return e;
            var t = new this(w);
            return L(t, e), t;
          }

          g = u ? function () {
            return j.nextTick(d);
          } : s ? (m = 0, v = new s(d), y = document.createTextNode(""), v.observe(y, {
            characterData: !0
          }), function () {
            y.data = m = ++m % 2;
          }) : h ? ((p = new MessageChannel()).port1.onmessage = d, function () {
            return p.port2.postMessage(0);
          }) : void 0 === e && "function" == typeof z ? function () {
            try {
              var e = Function("return this")().require("vertx");

              return void 0 !== (t = e.runOnLoop || e.runOnContext) ? function () {
                t(d);
              } : c();
            } catch (e) {
              return c();
            }
          }() : c();
          var x = Math.random().toString(36).substring(2);

          function w() {}

          var S = void 0,
              M = 1,
              T = 2;

          function E(e, i, n) {
            o(function (t) {
              var r = !1,
                  e = function (e, t, r, i) {
                try {
                  e.call(t, r, i);
                } catch (e) {
                  return e;
                }
              }(n, i, function (e) {
                r || (r = !0, i !== e ? L(t, e) : P(t, e));
              }, function (e) {
                r || (r = !0, R(t, e));
              }, t._label);

              !r && e && (r = !0, R(t, e));
            }, e);
          }

          function C(e, t, r) {
            var i, n;
            t.constructor === e.constructor && r === b && t.constructor.resolve === _ ? (i = e, (n = t)._state === M ? P(i, n._result) : n._state === T ? R(i, n._result) : D(n, void 0, function (e) {
              return L(i, e);
            }, function (e) {
              return R(i, e);
            })) : void 0 === r ? P(e, t) : l(r) ? E(e, t, r) : P(e, t);
          }

          function L(t, e) {
            if (t === e) R(t, new TypeError("You cannot resolve a promise with itself"));else if (n = typeof (i = e), null === i || "object" != n && "function" != n) P(t, e);else {
              var r = void 0;

              try {
                r = e.then;
              } catch (e) {
                return void R(t, e);
              }

              C(t, e, r);
            }
            var i, n;
          }

          function O(e) {
            e._onerror && e._onerror(e._result), k(e);
          }

          function P(e, t) {
            e._state === S && (e._result = t, e._state = M, 0 !== e._subscribers.length && o(k, e));
          }

          function R(e, t) {
            e._state === S && (e._state = T, e._result = t, o(O, e));
          }

          function D(e, t, r, i) {
            var n = e._subscribers,
                a = n.length;
            e._onerror = null, n[a] = t, n[a + M] = r, n[a + T] = i, 0 === a && e._state && o(k, e);
          }

          function k(e) {
            var t = e._subscribers,
                r = e._state;

            if (0 !== t.length) {
              for (var i = void 0, n = void 0, a = e._result, o = 0; o < t.length; o += 3) i = t[o], n = t[o + r], i ? A(r, i, n, a) : n(a);

              e._subscribers.length = 0;
            }
          }

          function A(e, t, r, i) {
            var n = l(r),
                a = void 0,
                o = void 0,
                s = !0;

            if (n) {
              try {
                a = r(i);
              } catch (e) {
                s = !1, o = e;
              }

              if (t === a) return void R(t, new TypeError("A promises callback cannot return that same promise."));
            } else a = i;

            t._state !== S || (n && s ? L(t, a) : !1 === s ? R(t, o) : e === M ? P(t, a) : e === T && R(t, a));
          }

          var I = 0;

          function U(e) {
            e[x] = I++, e._state = void 0, e._result = void 0, e._subscribers = [];
          }

          var N = (F.prototype._enumerate = function (e) {
            for (var t = 0; this._state === S && t < e.length; t++) this._eachEntry(e[t], t);
          }, F.prototype._eachEntry = function (t, e) {
            var r = this._instanceConstructor,
                i = r.resolve;

            if (i === _) {
              var n = void 0,
                  a = void 0,
                  o = !1;

              try {
                n = t.then;
              } catch (e) {
                o = !0, a = e;
              }

              if (n === b && t._state !== S) this._settledAt(t._state, e, t._result);else if ("function" != typeof n) this._remaining--, this._result[e] = t;else if (r === B) {
                var s = new r(w);
                o ? R(s, a) : C(s, t, n), this._willSettleAt(s, e);
              } else this._willSettleAt(new r(function (e) {
                return e(t);
              }), e);
            } else this._willSettleAt(i(t), e);
          }, F.prototype._settledAt = function (e, t, r) {
            var i = this.promise;
            i._state === S && (this._remaining--, e === T ? R(i, r) : this._result[t] = r), 0 === this._remaining && P(i, this._result);
          }, F.prototype._willSettleAt = function (e, t) {
            var r = this;
            D(e, void 0, function (e) {
              return r._settledAt(M, t, e);
            }, function (e) {
              return r._settledAt(T, t, e);
            });
          }, F);

          function F(e, t) {
            this._instanceConstructor = e, this.promise = new e(w), this.promise[x] || U(this.promise), r(t) ? (this.length = t.length, this._remaining = t.length, this._result = new Array(this.length), 0 === this.length ? P(this.promise, this._result) : (this.length = this.length || 0, this._enumerate(t), 0 === this._remaining && P(this.promise, this._result))) : R(this.promise, new Error("Array Methods must be provided an Array"));
          }

          var B = (G.prototype.catch = function (e) {
            return this.then(null, e);
          }, G.prototype.finally = function (t) {
            var r = this.constructor;
            return l(t) ? this.then(function (e) {
              return r.resolve(t()).then(function () {
                return e;
              });
            }, function (e) {
              return r.resolve(t()).then(function () {
                throw e;
              });
            }) : this.then(t, t);
          }, G);

          function G(e) {
            this[x] = I++, this._result = this._state = void 0, this._subscribers = [], w !== e && ("function" != typeof e && function () {
              throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
            }(), this instanceof G ? function (t, e) {
              try {
                e(function (e) {
                  L(t, e);
                }, function (e) {
                  R(t, e);
                });
              } catch (e) {
                R(t, e);
              }
            }(this, e) : function () {
              throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
            }());
          }

          return B.prototype.then = b, B.all = function (e) {
            return new N(this, e).promise;
          }, B.race = function (n) {
            var a = this;
            return r(n) ? new a(function (e, t) {
              for (var r = n.length, i = 0; i < r; i++) a.resolve(n[i]).then(e, t);
            }) : new a(function (e, t) {
              return t(new TypeError("You must pass an array to race."));
            });
          }, B.resolve = _, B.reject = function (e) {
            var t = new this(w);
            return R(t, e), t;
          }, B._setScheduler = function (e) {
            n = e;
          }, B._setAsap = function (e) {
            o = e;
          }, B._asap = o, B.polyfill = function () {
            var e = void 0;
            if (void 0 !== V) e = V;else if ("undefined" != typeof self) e = self;else try {
              e = Function("return this")();
            } catch (e) {
              throw new Error("polyfill failed because global object is unavailable in this environment");
            }
            var t = e.Promise;

            if (t) {
              var r = null;

              try {
                r = Object.prototype.toString.call(t.resolve());
              } catch (e) {}

              if ("[object Promise]" === r && !t.cast) return;
            }

            e.Promise = B;
          }, B.Promise = B;
        }, "object" == typeof i && void 0 !== r ? r.exports = t() : e.ES6Promise = t();
      }).call(this, z("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {
      _process: 14
    }],
    7: [function (e, i, n) {
      !function (e, t) {
        if (0, void 0 !== n && void 0 !== i) t(n, i);else {
          var r = {
            exports: {}
          };
          t(r.exports, r), e.fetchJsonp = r.exports;
        }
      }(this, function (e, t) {
        "use strict";

        var r = 5e3,
            i = "callback";

        function c(t) {
          try {
            delete window[t];
          } catch (e) {
            window[t] = void 0;
          }
        }

        function f(e) {
          var t = document.getElementById(e);
          t && document.getElementsByTagName("head")[0].removeChild(t);
        }

        t.exports = function (a) {
          var o = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],
              s = a,
              l = o.timeout || r,
              u = o.jsonpCallback || i,
              h = void 0;
          return new Promise(function (t, e) {
            var r = o.jsonpCallbackFunction || "jsonp_" + Date.now() + "_" + Math.ceil(1e5 * Math.random()),
                i = u + "_" + r;
            window[r] = function (e) {
              t({
                ok: !0,
                json: function () {
                  return Promise.resolve(e);
                }
              }), h && clearTimeout(h), f(i), c(r);
            }, s += -1 === s.indexOf("?") ? "?" : "&";
            var n = document.createElement("script");
            n.setAttribute("src", "" + s + u + "=" + r), o.charset && n.setAttribute("charset", o.charset), n.id = i, document.getElementsByTagName("head")[0].appendChild(n), h = setTimeout(function () {
              e(new Error("JSONP request to " + a + " timed out")), c(r), f(i), window[r] = function () {
                c(r);
              };
            }, l), n.onerror = function () {
              e(new Error("JSONP request to " + a + " failed")), c(r), f(i), h && clearTimeout(h);
            };
          });
        };
      });
    }, {}],
    8: [function (e, t, r) {
      var i = i || function (s) {
        "use strict";

        if (!(void 0 === s || "undefined" != typeof navigator && /MSIE [1-9]\./.test(navigator.userAgent))) {
          var e = s.document,
              l = function () {
            return s.URL || s.webkitURL || s;
          },
              u = e.createElementNS("http://www.w3.org/1999/xhtml", "a"),
              h = ("download" in u),
              c = /constructor/i.test(s.HTMLElement) || s.safari,
              f = /CriOS\/[\d]+/.test(navigator.userAgent),
              d = function (e) {
            (s.setImmediate || s.setTimeout)(function () {
              throw e;
            }, 0);
          },
              p = function (e) {
            setTimeout(function () {
              "string" == typeof e ? l().revokeObjectURL(e) : e.remove();
            }, 4e4);
          },
              m = function (e) {
            return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type) ? new Blob([String.fromCharCode(65279), e], {
              type: e.type
            }) : e;
          },
              i = function (e, r, t) {
            t || (e = m(e));

            function i() {
              !function (e, t, r) {
                for (var i = (t = [].concat(t)).length; i--;) {
                  var n = e["on" + t[i]];
                  if ("function" == typeof n) try {
                    n.call(e, r || e);
                  } catch (e) {
                    d(e);
                  }
                }
              }(a, "writestart progress write writeend".split(" "));
            }

            var n,
                a = this,
                o = "application/octet-stream" === e.type;
            if (a.readyState = a.INIT, h) return n = l().createObjectURL(e), void setTimeout(function () {
              var e, t;
              u.href = n, u.download = r, e = u, t = new MouseEvent("click"), e.dispatchEvent(t), i(), p(n), a.readyState = a.DONE;
            });
            !function () {
              if ((f || o && c) && s.FileReader) {
                var t = new FileReader();
                return t.onloadend = function () {
                  var e = f ? t.result : t.result.replace(/^data:[^;]*;/, "data:attachment/file;");
                  s.open(e, "_blank") || (s.location.href = e), e = void 0, a.readyState = a.DONE, i();
                }, t.readAsDataURL(e), a.readyState = a.INIT;
              }

              (n = n || l().createObjectURL(e), o) ? s.location.href = n : s.open(n, "_blank") || (s.location.href = n);
              a.readyState = a.DONE, i(), p(n);
            }();
          },
              t = i.prototype;

          return "undefined" != typeof navigator && navigator.msSaveOrOpenBlob ? function (e, t, r) {
            return t = t || e.name || "download", r || (e = m(e)), navigator.msSaveOrOpenBlob(e, t);
          } : (t.abort = function () {}, t.readyState = t.INIT = 0, t.WRITING = 1, t.DONE = 2, t.error = t.onwritestart = t.onprogress = t.onwrite = t.onabort = t.onerror = t.onwriteend = null, function (e, t, r) {
            return new i(e, t || e.name || "download", r);
          });
        }
      }("undefined" != typeof self && self || "undefined" != typeof window && window || this.content);

      void 0 !== t && t.exports && (t.exports.saveAs = i);
    }, {}],
    9: [function (e, t, r) {
      r.read = function (e, t, r, i, n) {
        var a,
            o,
            s = 8 * n - i - 1,
            l = (1 << s) - 1,
            u = l >> 1,
            h = -7,
            c = r ? n - 1 : 0,
            f = r ? -1 : 1,
            d = e[t + c];

        for (c += f, a = d & (1 << -h) - 1, d >>= -h, h += s; 0 < h; a = 256 * a + e[t + c], c += f, h -= 8);

        for (o = a & (1 << -h) - 1, a >>= -h, h += i; 0 < h; o = 256 * o + e[t + c], c += f, h -= 8);

        if (0 === a) a = 1 - u;else {
          if (a === l) return o ? NaN : 1 / 0 * (d ? -1 : 1);
          o += Math.pow(2, i), a -= u;
        }
        return (d ? -1 : 1) * o * Math.pow(2, a - i);
      }, r.write = function (e, t, r, i, n, a) {
        var o,
            s,
            l,
            u = 8 * a - n - 1,
            h = (1 << u) - 1,
            c = h >> 1,
            f = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
            d = i ? 0 : a - 1,
            p = i ? 1 : -1,
            m = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;

        for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, o = h) : (o = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), 2 <= (t += 1 <= o + c ? f / l : f * Math.pow(2, 1 - c)) * l && (o++, l /= 2), h <= o + c ? (s = 0, o = h) : 1 <= o + c ? (s = (t * l - 1) * Math.pow(2, n), o += c) : (s = t * Math.pow(2, c - 1) * Math.pow(2, n), o = 0)); 8 <= n; e[r + d] = 255 & s, d += p, s /= 256, n -= 8);

        for (o = o << n | s, u += n; 0 < u; e[r + d] = 255 & o, d += p, o /= 256, u -= 8);

        e[r + d - p] |= 128 * m;
      };
    }, {}],
    10: [function (e, t, r) {
      "use strict";

      var i;

      function v(e, t) {
        return e.b === t.b && e.a === t.a;
      }

      function y(e, t) {
        return e.b < t.b || e.b === t.b && e.a <= t.a;
      }

      function g(e, t, r) {
        var i = t.b - e.b,
            n = r.b - t.b;
        return 0 < i + n ? i < n ? t.a - e.a + i / (i + n) * (e.a - r.a) : t.a - r.a + n / (i + n) * (r.a - e.a) : 0;
      }

      function b(e, t, r) {
        var i = t.b - e.b,
            n = r.b - t.b;
        return 0 < i + n ? (t.a - r.a) * i + (t.a - e.a) * n : 0;
      }

      function _(e, t) {
        return e.a < t.a || e.a === t.a && e.b <= t.b;
      }

      function x(e, t, r) {
        var i = t.a - e.a,
            n = r.a - t.a;
        return 0 < i + n ? i < n ? t.b - e.b + i / (i + n) * (e.b - r.b) : t.b - r.b + n / (i + n) * (r.b - e.b) : 0;
      }

      function w(e, t, r) {
        var i = t.a - e.a,
            n = r.a - t.a;
        return 0 < i + n ? (t.b - r.b) * i + (t.b - e.b) * n : 0;
      }

      function S(e, t, r, i) {
        return (e = e < 0 ? 0 : e) <= (r = r < 0 ? 0 : r) ? 0 === r ? (t + i) / 2 : t + e / (e + r) * (i - t) : i + r / (e + r) * (t - i);
      }

      function o(e) {
        var t = a(e.b);
        return n(t, e.c), n(t.b, e.c), s(t, e.a), t;
      }

      function M(e, t) {
        var r = !1,
            i = !1;
        e !== t && (t.a !== e.a && (i = !0, m(t.a, e.a)), t.d !== e.d && (r = !0, l(t.d, e.d)), d(t, e), i || (n(t, e.a), e.a.c = e), r || (s(t, e.d), e.d.a = e));
      }

      function c(e) {
        var t = e.b,
            r = !1;
        e.d !== e.b.d && (r = !0, l(e.d, e.b.d)), e.c === e ? m(e.a, null) : (e.b.d.a = J(e), e.a.c = e.c, d(e, J(e)), r || s(e, e.d)), t.c === t ? (m(t.a, null), l(t.d, null)) : (e.d.a = J(t), t.a.c = t.c, d(t, J(t))), p(e);
      }

      function T(e) {
        var t = a(e),
            r = t.b;
        return d(t, e.e), t.a = e.b.a, n(r, t.a), t.d = r.d = e.d, t = t.b, d(e.b, J(e.b)), d(e.b, t), e.b.a = t.a, t.b.a.c = t.b, t.b.d = e.b.d, t.f = e.f, t.b.f = e.b.f, t;
      }

      function f(e, t) {
        var r = !1,
            i = a(e),
            n = i.b;
        return t.d !== e.d && (r = !0, l(t.d, e.d)), d(i, e.e), d(n, t), i.a = e.b.a, n.a = t.a, i.d = n.d = e.d, e.d.a = n, r || s(i, e.d), i;
      }

      function a(e) {
        var t = new K(),
            r = new K(),
            i = e.b.h;
        return (((r.h = i).b.h = t).h = e).b.h = r, t.b = r, ((t.c = t).e = r).b = t, (r.c = r).e = t;
      }

      function d(e, t) {
        var r = e.c,
            i = t.c;
        r.b.e = t, (i.b.e = e).c = i, t.c = r;
      }

      function n(e, t) {
        var r = t.f,
            i = new ee(t, r);

        for (r.e = i, r = (t.f = i).c = e; r.a = i, (r = r.c) !== e;);
      }

      function s(e, t) {
        var r = t.d,
            i = new Q(t, r);

        for (r.b = i, (t.d = i).a = e, i.c = t.c, r = e; r.d = i, (r = r.e) !== e;);
      }

      function p(e) {
        var t = e.h;
        e = e.b.h, (t.b.h = e).b.h = t;
      }

      function m(e, t) {
        for (var r = e.c, i = r; i.a = t, (i = i.c) !== r;);

        r = e.f, ((i = e.e).f = r).e = i;
      }

      function l(e, t) {
        for (var r = e.a, i = r; i.d = t, (i = i.e) !== r;);

        r = e.d, ((i = e.b).d = r).b = i;
      }

      function E(e) {
        var t = 0;
        return Math.abs(e[1]) > Math.abs(e[0]) && (t = 1), Math.abs(e[2]) > Math.abs(e[t]) && (t = 2), t;
      }

      var C = 4e150;

      function L(e, t) {
        e.f += t.f, e.b.f += t.b.f;
      }

      function u(e, t, r) {
        return e = e.a, t = t.a, r = r.a, t.b.a === e ? r.b.a === e ? y(t.a, r.a) ? b(r.b.a, t.a, r.a) <= 0 : 0 <= b(t.b.a, r.a, t.a) : b(r.b.a, e, r.a) <= 0 : r.b.a === e ? 0 <= b(t.b.a, e, t.a) : (t = g(t.b.a, e, t.a), (e = g(r.b.a, e, r.a)) <= t);
      }

      function O(e) {
        e.a.i = null;
        var t = e.e;
        t.a.c = t.c, t.c.a = t.a, e.e = null;
      }

      function h(e, t) {
        c(e.a), e.c = !1, (e.a = t).i = e;
      }

      function P(e) {
        for (var t = e.a.a; (e = fe(e)).a.a === t;);

        return e.c && (h(e, t = f(ce(e).a.b, e.a.e)), e = fe(e)), e;
      }

      function R(e, t, r) {
        var i = new he();
        return i.a = r, i.e = W(e.f, t.e, i), r.i = i;
      }

      function D(e, t) {
        switch (e.s) {
          case 100130:
            return 0 != (1 & t);

          case 100131:
            return 0 !== t;

          case 100132:
            return 0 < t;

          case 100133:
            return t < 0;

          case 100134:
            return 2 <= t || t <= -2;
        }

        return !1;
      }

      function k(e) {
        var t = e.a,
            r = t.d;
        r.c = e.d, r.a = t, O(e);
      }

      function A(e, t, r) {
        for (t = (e = t).a; e !== r;) {
          e.c = !1;
          var i = ce(e),
              n = i.a;

          if (n.a !== t.a) {
            if (!i.c) {
              k(e);
              break;
            }

            h(i, n = f(t.c.b, n.b));
          }

          t.c !== n && (M(J(n), n), M(t, n)), k(e), t = i.a, e = i;
        }

        return t;
      }

      function I(e, t, r, i, n, a) {
        for (var o = !0; R(e, t, r.b), (r = r.c) !== i;);

        for (null === n && (n = ce(t).a.b.c); (r = (i = ce(t)).a.b).a === n.a;) r.c !== n && (M(J(r), r), M(J(n), r)), i.f = t.f - r.f, i.d = D(e, i.f), t.b = !0, !o && B(e, t) && (L(r, n), O(t), c(n)), o = !1, t = i, n = r;

        t.b = !0, a && j(e, t);
      }

      function U(e, t, r, i, n) {
        var a = [t.g[0], t.g[1], t.g[2]];
        t.d = null, t.d = e.o && e.o(a, r, i, e.c) || null, null === t.d && (n ? e.n || (Z(e, 100156), e.n = !0) : t.d = r[0]);
      }

      function N(e, t, r) {
        var i = [null, null, null, null];
        i[0] = t.a.d, i[1] = r.a.d, U(e, t.a, i, [.5, .5, 0, 0], !1), M(t, r);
      }

      function F(e, t, r, i, n) {
        var a = Math.abs(t.b - e.b) + Math.abs(t.a - e.a),
            o = Math.abs(r.b - e.b) + Math.abs(r.a - e.a),
            s = n + 1;
        i[n] = .5 * o / (a + o), i[s] = .5 * a / (a + o), e.g[0] += i[n] * t.g[0] + i[s] * r.g[0], e.g[1] += i[n] * t.g[1] + i[s] * r.g[1], e.g[2] += i[n] * t.g[2] + i[s] * r.g[2];
      }

      function B(e, t) {
        var r = ce(t),
            i = t.a,
            n = r.a;

        if (y(i.a, n.a)) {
          if (0 < b(n.b.a, i.a, n.a)) return !1;

          if (v(i.a, n.a)) {
            if (i.a !== n.a) {
              r = e.e;
              var a = i.a.h;

              if (0 <= a) {
                var o = (r = r.b).d,
                    s = r.e,
                    l = r.c,
                    u = l[a];
                o[u] = o[r.a], (l[o[u]] = u) <= --r.a && (u <= 1 ? le(r, u) : y(s[o[u >> 1]], s[o[u]]) ? le(r, u) : ue(r, u)), s[a] = null, l[a] = r.b, r.b = a;
              } else for (r.c[-(a + 1)] = null; 0 < r.a && null === r.c[r.d[r.a - 1]];) --r.a;

              N(e, J(n), i);
            }
          } else T(n.b), M(i, J(n)), t.b = r.b = !0;
        } else {
          if (b(i.b.a, n.a, i.a) < 0) return !1;
          fe(t).b = t.b = !0, T(i.b), M(J(n), i);
        }

        return !0;
      }

      function G(e, t) {
        var r = ce(t),
            i = t.a,
            n = r.a,
            a = i.a,
            o = n.a,
            s = i.b.a,
            l = n.b.a,
            u = new ee();
        if (b(s, e.a, a), b(l, e.a, o), a === o || Math.min(a.a, s.a) > Math.max(o.a, l.a)) return !1;

        if (y(a, o)) {
          if (0 < b(l, a, o)) return !1;
        } else if (b(s, o, a) < 0) return !1;

        var h,
            c,
            f = s,
            d = a,
            p = l,
            m = o;
        if (y(f, d) || (h = f, f = d, d = h), y(p, m) || (h = p, p = m, m = h), y(f, p) || (h = f, f = p, p = h, h = d, d = m, m = h), y(p, d) ? y(d, m) ? ((h = g(f, p, d)) + (c = g(p, d, m)) < 0 && (h = -h, c = -c), u.b = S(h, p.b, c, d.b)) : ((h = b(f, p, d)) + (c = -b(f, m, d)) < 0 && (h = -h, c = -c), u.b = S(h, p.b, c, m.b)) : u.b = (p.b + d.b) / 2, _(f, d) || (h = f, f = d, d = h), _(p, m) || (h = p, p = m, m = h), _(f, p) || (h = f, f = p, p = h, h = d, d = m, m = h), _(p, d) ? _(d, m) ? ((h = x(f, p, d)) + (c = x(p, d, m)) < 0 && (h = -h, c = -c), u.a = S(h, p.a, c, d.a)) : ((h = w(f, p, d)) + (c = -w(f, m, d)) < 0 && (h = -h, c = -c), u.a = S(h, p.a, c, m.a)) : u.a = (p.a + d.a) / 2, y(u, e.a) && (u.b = e.a.b, u.a = e.a.a), f = y(a, o) ? a : o, y(f, u) && (u.b = f.b, u.a = f.a), v(u, a) || v(u, o)) return B(e, t), !1;

        if (!v(s, e.a) && 0 <= b(s, e.a, u) || !v(l, e.a) && b(l, e.a, u) <= 0) {
          if (l === e.a) return T(i.b), M(n.b, i), i = ce(t = P(t)).a, A(e, ce(t), r), I(e, t, J(i), i, i, !0), !0;
          if (s !== e.a) return 0 <= b(s, e.a, u) && (fe(t).b = t.b = !0, T(i.b), i.a.b = e.a.b, i.a.a = e.a.a), b(l, e.a, u) <= 0 && (t.b = r.b = !0, T(n.b), n.a.b = e.a.b, n.a.a = e.a.a), !1;

          for (T(n.b), M(i.e, J(n)), o = (a = r = t).a.b.a; (a = fe(a)).a.b.a === o;);

          return a = ce(t = a).a.b.c, r.a = J(n), I(e, t, (n = A(e, r, null)).c, i.b.c, a, !0), !0;
        }

        return T(i.b), T(n.b), M(J(n), i), i.a.b = u.b, i.a.a = u.a, i.a.h = re(e.e, i.a), i = i.a, n = [0, 0, 0, 0], u = [a.d, s.d, o.d, l.d], i.g[0] = i.g[1] = i.g[2] = 0, F(i, a, s, n, 0), F(i, o, l, n, 2), U(e, i, u, n, !0), fe(t).b = t.b = r.b = !0, !1;
      }

      function j(e, t) {
        for (var r = ce(t);;) {
          for (; r.b;) r = ce(t = r);

          if (!t.b && (null === (t = fe(r = t)) || !t.b)) break;
          t.b = !1;
          var i,
              n = t.a,
              a = r.a;
          if (i = n.b.a !== a.b.a) e: {
            var o = ce(i = t),
                s = i.a,
                l = o.a,
                u = void 0;

            if (y(s.b.a, l.b.a)) {
              if (b(s.b.a, l.b.a, s.a) < 0) {
                i = !1;
                break e;
              }

              fe(i).b = i.b = !0, u = T(s), M(l.b, u), u.d.c = i.d;
            } else {
              if (0 < b(l.b.a, s.b.a, l.a)) {
                i = !1;
                break e;
              }

              i.b = o.b = !0, u = T(l), M(s.e, l.b), u.b.d.c = i.d;
            }

            i = !0;
          }
          if (i && (r.c ? (O(r), c(a), a = (r = ce(t)).a) : t.c && (O(t), c(n), n = (t = fe(r)).a)), n.a !== a.a) if (n.b.a === a.b.a || t.c || r.c || n.b.a !== e.a && a.b.a !== e.a) B(e, t);else if (G(e, t)) break;
          n.a === a.a && n.b.a === a.b.a && (L(a, n), O(t), c(n), t = fe(r));
        }
      }

      function V(e, t) {
        for (var r = (e.a = t).c; null === r.i;) if ((r = r.c) === t.c) {
          r = e;
          var i = t;
          (o = new he()).a = i.c.b;

          for (var n = (l = r.f).a; null !== (n = n.a).b && !l.c(l.b, o, n.b););

          var a = ce(l = n.b),
              o = l.a;
          n = a.a;
          if (0 === b(o.b.a, i, o.a)) v((o = l.a).a, i) || v(o.b.a, i) || (T(o.b), l.c && (c(o.c), l.c = !1), M(i.c, o), V(r, i));else {
            var s = y(n.b.a, o.b.a) ? l : a;
            a = void 0;
            l.d || s.c ? (a = s === l ? f(i.c.b, o.e) : f(n.b.c.b, i.c).b, s.c ? h(s, a) : ((l = R(o = r, l, a)).f = fe(l).f + l.a.f, l.d = D(o, l.f)), V(r, i)) : I(r, l, i.c, i.c, null, !0);
          }
          return;
        }

        if (l = (o = ce(r = P(r.i))).a, (o = A(e, o, null)).c === l) {
          o = (l = o).c, n = ce(r), a = r.a, s = n.a;
          var l,
              u = !1;
          a.b.a !== s.b.a && G(e, r), v(a.a, e.a) && (M(J(o), a), o = ce(r = P(r)).a, A(e, ce(r), n), u = !0), v(s.a, e.a) && (M(l, J(s)), l = A(e, n, null), u = !0), u ? I(e, r, l.c, o, o, !0) : (i = y(s.a, a.a) ? J(s) : a, I(e, r, i = f(l.c.b, i), i.c, i.c, !1), i.b.i.c = !0, j(e, r));
        } else I(e, r, o.c, l, l, !0);
      }

      function z(e, t) {
        var r = new he(),
            i = o(e.b);
        i.a.b = C, i.a.a = t, i.b.a.b = -C, i.b.a.a = t, e.a = i.b.a, r.a = i, r.f = 0, r.d = !1, r.c = !1, r.h = !0, r.b = !1, i = W(i = e.f, i.a, r), r.e = i;
      }

      function H(e) {
        this.a = new q(), this.b = e, this.c = u;
      }

      function W(e, t, r) {
        for (; null !== (t = t.c).b && !e.c(e.b, t.b, r););

        return e = new q(r, t.a, t), t.a.c = e, t.a = e;
      }

      function q(e, t, r) {
        this.b = e || null, this.a = t || this, this.c = r || this;
      }

      function X() {
        this.d = 0, this.p = this.b = this.q = null, this.j = [0, 0, 0], this.s = 100130, this.n = !1, this.o = this.a = this.e = this.f = null, this.m = !1, this.c = this.r = this.i = this.k = this.l = this.h = null;
      }

      function Y(e, t) {
        if (e.d !== t) for (; e.d !== t;) if (e.d < t) switch (e.d) {
          case 0:
            Z(e, 100151), e.u(null);
            break;

          case 1:
            Z(e, 100152), e.t();
        } else switch (e.d) {
          case 2:
            Z(e, 100154), e.v();
            break;

          case 1:
            Z(e, 100153), e.w();
        }
      }

      function Z(e, t) {
        e.p && e.p(t, e.c);
      }

      function Q(e, t) {
        this.b = e || this, this.d = t || this, this.a = null, this.c = !1;
      }

      function K() {
        (this.h = this).i = this.d = this.a = this.e = this.c = this.b = null, this.f = 0;
      }

      function J(e) {
        return e.b.e;
      }

      function $() {
        this.c = new ee(), this.a = new Q(), this.b = new K(), this.d = new K(), this.b.b = this.d, this.d.b = this.b;
      }

      function ee(e, t) {
        this.e = e || this, this.f = t || this, this.d = this.c = null, this.g = [0, 0, 0], this.h = this.a = this.b = 0;
      }

      function te() {
        this.c = [], this.d = null, this.a = 0, this.e = !1, this.b = new ne();
      }

      function re(e, t) {
        if (e.e) {
          var r,
              i = e.b,
              n = ++i.a;
          return 2 * n > i.f && (i.f *= 2, i.c = ae(i.c, i.f + 1)), 0 === i.b ? r = n : (r = i.b, i.b = i.c[i.b]), i.e[r] = t, i.c[r] = n, i.d[n] = r, i.h && ue(i, n), r;
        }

        return i = e.a++, e.c[i] = t, -(i + 1);
      }

      function ie(e) {
        if (0 === e.a) return se(e.b);
        var t = e.c[e.d[e.a - 1]];
        if (0 !== e.b.a && y(oe(e.b), t)) return se(e.b);

        for (; --e.a, 0 < e.a && null === e.c[e.d[e.a - 1]];);

        return t;
      }

      function ne() {
        this.d = ae([0], 33), this.e = [null, null], this.c = [0, 0], this.a = 0, this.f = 32, this.b = 0, this.h = !1, this.d[1] = 1;
      }

      function ae(e, t) {
        for (var r = Array(t), i = 0; i < e.length; i++) r[i] = e[i];

        for (; i < t; i++) r[i] = 0;

        return r;
      }

      function oe(e) {
        return e.e[e.d[1]];
      }

      function se(e) {
        var t = e.d,
            r = e.e,
            i = e.c,
            n = t[1],
            a = r[n];
        return 0 < e.a && (t[1] = t[e.a], i[t[1]] = 1, r[n] = null, i[n] = e.b, e.b = n, 0 < --e.a && le(e, 1)), a;
      }

      function le(e, t) {
        for (var r = e.d, i = e.e, n = e.c, a = t, o = r[a];;) {
          var s = a << 1;
          s < e.a && y(i[r[s + 1]], i[r[s]]) && (s += 1);
          var l = r[s];

          if (s > e.a || y(i[o], i[l])) {
            n[r[a] = o] = a;
            break;
          }

          n[r[a] = l] = a, a = s;
        }
      }

      function ue(e, t) {
        for (var r = e.d, i = e.e, n = e.c, a = t, o = r[a];;) {
          var s = a >> 1,
              l = r[s];

          if (0 == s || y(i[l], i[o])) {
            n[r[a] = o] = a;
            break;
          }

          n[r[a] = l] = a, a = s;
        }
      }

      function he() {
        this.e = this.a = null, this.f = 0, this.c = this.b = this.h = this.d = !1;
      }

      function ce(e) {
        return e.e.c.b;
      }

      function fe(e) {
        return e.e.a.b;
      }

      (i = X.prototype).x = function () {
        Y(this, 0);
      }, i.B = function (e, t) {
        switch (e) {
          case 100142:
            return;

          case 100140:
            switch (t) {
              case 100130:
              case 100131:
              case 100132:
              case 100133:
              case 100134:
                return void (this.s = t);
            }

            break;

          case 100141:
            return void (this.m = !!t);

          default:
            return void Z(this, 100900);
        }

        Z(this, 100901);
      }, i.y = function (e) {
        switch (e) {
          case 100142:
            return 0;

          case 100140:
            return this.s;

          case 100141:
            return this.m;

          default:
            Z(this, 100900);
        }

        return !1;
      }, i.A = function (e, t, r) {
        this.j[0] = e, this.j[1] = t, this.j[2] = r;
      }, i.z = function (e, t) {
        var r = t || null;

        switch (e) {
          case 100100:
          case 100106:
            this.h = r;
            break;

          case 100104:
          case 100110:
            this.l = r;
            break;

          case 100101:
          case 100107:
            this.k = r;
            break;

          case 100102:
          case 100108:
            this.i = r;
            break;

          case 100103:
          case 100109:
            this.p = r;
            break;

          case 100105:
          case 100111:
            this.o = r;
            break;

          case 100112:
            this.r = r;
            break;

          default:
            Z(this, 100900);
        }
      }, i.C = function (e, t) {
        var r = !1,
            i = [0, 0, 0];
        Y(this, 2);

        for (var n = 0; n < 3; ++n) {
          var a = e[n];
          a < -1e150 && (a = -1e150, r = !0), 1e150 < a && (a = 1e150, r = !0), i[n] = a;
        }

        r && Z(this, 100155), null === (r = this.q) ? M(r = o(this.b), r.b) : (T(r), r = r.e), r.a.d = t, r.a.g[0] = i[0], r.a.g[1] = i[1], r.a.g[2] = i[2], r.f = 1, r.b.f = -1, this.q = r;
      }, i.u = function (e) {
        Y(this, 0), this.d = 1, this.b = new $(), this.c = e;
      }, i.t = function () {
        Y(this, 1), this.d = 2, this.q = null;
      }, i.v = function () {
        Y(this, 2), this.d = 1;
      }, i.w = function () {
        Y(this, 1), this.d = 0;
        var e,
            t,
            r = !1,
            i = [l = this.j[0], n = this.j[1], o = this.j[2]];

        if (0 === l && 0 === n && 0 === o) {
          for (var n = [-2e150, -2e150, -2e150], a = [2e150, 2e150, 2e150], o = [], s = [], l = (r = this.b.c).e; l !== r; l = l.e) for (var u = 0; u < 3; ++u) {
            var h = l.g[u];
            h < a[u] && (a[u] = h, s[u] = l), h > n[u] && (n[u] = h, o[u] = l);
          }

          if (l = 0, n[1] - a[1] > n[0] - a[0] && (l = 1), n[2] - a[2] > n[l] - a[l] && (l = 2), a[l] >= n[l]) i[0] = 0, i[1] = 0, i[2] = 1;else {
            for (n = 0, a = s[l], o = o[l], s = [0, 0, 0], a = [a.g[0] - o.g[0], a.g[1] - o.g[1], a.g[2] - o.g[2]], u = [0, 0, 0], l = r.e; l !== r; l = l.e) u[0] = l.g[0] - o.g[0], u[1] = l.g[1] - o.g[1], u[2] = l.g[2] - o.g[2], s[0] = a[1] * u[2] - a[2] * u[1], s[1] = a[2] * u[0] - a[0] * u[2], s[2] = a[0] * u[1] - a[1] * u[0], n < (h = s[0] * s[0] + s[1] * s[1] + s[2] * s[2]) && (n = h, i[0] = s[0], i[1] = s[1], i[2] = s[2]);

            n <= 0 && (i[0] = i[1] = i[2] = 0, i[E(a)] = 1);
          }
          r = !0;
        }

        for (s = E(i), l = this.b.c, n = (s + 1) % 3, o = (s + 2) % 3, s = 0 < i[s] ? 1 : -1, i = l.e; i !== l; i = i.e) i.b = i.g[n], i.a = s * i.g[o];

        if (r) {
          for (i = 0, l = (r = this.b.a).b; l !== r; l = l.b) if (!((n = l.a).f <= 0)) for (; i += (n.a.b - n.b.a.b) * (n.a.a + n.b.a.a), (n = n.e) !== l.a;);

          if (i < 0) for (r = (i = this.b.c).e; r !== i; r = r.e) r.a = -r.a;
        }

        for (this.n = !1, l = (i = this.b.b).h; l !== i; l = r) r = l.h, n = l.e, v(l.a, l.b.a) && l.e.e !== l && (N(this, n, l), c(l), n = (l = n).e), n.e === l && (n !== l && (n !== r && n !== r.b || (r = r.h), c(n)), l !== r && l !== r.b || (r = r.h), c(l));

        for (this.e = i = new te(), l = (r = this.b.c).e; l !== r; l = l.e) l.h = re(i, l);

        for (!function (e) {
          e.d = [];

          for (var t = 0; t < e.a; t++) e.d[t] = t;

          e.d.sort(function (r) {
            return function (e, t) {
              return y(r[e], r[t]) ? 1 : -1;
            };
          }(e.c)), e.e = !0, function (e) {
            for (var t = e.a; 1 <= t; --t) le(e, t);

            e.h = !0;
          }(e.b);
        }(i), this.f = new H(this), z(this, -C), z(this, C); null !== (i = ie(this.e));) {
          for (;;) {
            e: if (l = this.e, 0 === l.a) r = oe(l.b);else if (r = l.c[l.d[l.a - 1]], 0 !== l.b.a && (l = oe(l.b), y(l, r))) {
              r = l;
              break e;
            }

            if (null === r || !v(r, i)) break;
            r = ie(this.e), N(this, i.c, r.c);
          }

          V(this, i);
        }

        for (this.a = this.f.a.a.b.a.a, i = 0; null !== (r = this.f.a.a.b);) r.h || ++i, O(r);

        for (this.f = null, (i = this.e).b = null, i.d = null, this.e = i.c = null, l = (i = this.b).a.b; l !== i.a; l = r) r = l.b, (l = l.a).e.e === l && (L(l.c, l), c(l));

        if (!this.n) {
          if (i = this.b, this.m) for (l = i.b.h; l !== i.b; l = r) r = l.h, l.b.d.c !== l.d.c ? l.f = l.d.c ? 1 : -1 : c(l);else for (l = i.a.b; l !== i.a; l = r) if (r = l.b, l.c) {
            for (l = l.a; y(l.b.a, l.a); l = l.c.b);

            for (; y(l.a, l.b.a); l = l.e);

            for (n = l.c.b, o = void 0; l.e !== n;) if (y(l.b.a, n.a)) {
              for (; n.e !== l && (y((t = n.e).b.a, t.a) || b(n.a, n.b.a, n.e.b.a) <= 0);) n = (o = f(n.e, n)).b;

              n = n.c.b;
            } else {
              for (; n.e !== l && (y((e = l.c.b).a, e.b.a) || 0 <= b(l.b.a, l.a, l.c.b.a));) l = (o = f(l, l.c.b)).b;

              l = l.e;
            }

            for (; n.e.e !== l;) n = (o = f(n.e, n)).b;
          }
          if (this.h || this.i || this.k || this.l) if (this.m) {
            for (r = (i = this.b).a.b; r !== i.a; r = r.b) if (r.c) {
              for (this.h && this.h(2, this.c), l = r.a; this.k && this.k(l.a.d, this.c), (l = l.e) !== r.a;);

              this.i && this.i(this.c);
            }
          } else {
            for (i = this.b, r = !!this.l, l = !1, n = -1, o = i.a.d; o !== i.a; o = o.d) if (o.c) for (l || (this.h && this.h(4, this.c), l = !0), s = o.a; r && n !== (a = s.b.d.c ? 0 : 1) && (n = a, this.l && this.l(!!n, this.c)), this.k && this.k(s.a.d, this.c), (s = s.e) !== o.a;);

            l && this.i && this.i(this.c);
          }

          if (this.r) {
            for (l = (i = this.b).a.b; l !== i.a; l = r) if (r = l.b, !l.c) {
              for (o = (n = l.a).e, s = void 0; o = (s = o).e, (s.d = null) === s.b.d && (s.c === s ? m(s.a, null) : (s.a.c = s.c, d(s, J(s))), (a = s.b).c === a ? m(a.a, null) : (a.a.c = a.c, d(a, J(a))), p(s)), s !== n;);

              n = l.d, ((l = l.b).d = n).b = l;
            }

            return this.r(this.b), void (this.c = this.b = null);
          }
        }

        this.b = this.c = null;
      }, this.libtess = {
        GluTesselator: X,
        windingRule: {
          GLU_TESS_WINDING_ODD: 100130,
          GLU_TESS_WINDING_NONZERO: 100131,
          GLU_TESS_WINDING_POSITIVE: 100132,
          GLU_TESS_WINDING_NEGATIVE: 100133,
          GLU_TESS_WINDING_ABS_GEQ_TWO: 100134
        },
        primitiveType: {
          GL_LINE_LOOP: 2,
          GL_TRIANGLES: 4,
          GL_TRIANGLE_STRIP: 5,
          GL_TRIANGLE_FAN: 6
        },
        errorType: {
          GLU_TESS_MISSING_BEGIN_POLYGON: 100151,
          GLU_TESS_MISSING_END_POLYGON: 100153,
          GLU_TESS_MISSING_BEGIN_CONTOUR: 100152,
          GLU_TESS_MISSING_END_CONTOUR: 100154,
          GLU_TESS_COORD_TOO_LARGE: 100155,
          GLU_TESS_NEED_COMBINE_CALLBACK: 100156
        },
        gluEnum: {
          GLU_TESS_MESH: 100112,
          GLU_TESS_TOLERANCE: 100142,
          GLU_TESS_WINDING_RULE: 100140,
          GLU_TESS_BOUNDARY_ONLY: 100141,
          GLU_INVALID_ENUM: 100900,
          GLU_INVALID_VALUE: 100901,
          GLU_TESS_BEGIN: 100100,
          GLU_TESS_VERTEX: 100101,
          GLU_TESS_END: 100102,
          GLU_TESS_ERROR: 100103,
          GLU_TESS_EDGE_FLAG: 100104,
          GLU_TESS_COMBINE: 100105,
          GLU_TESS_BEGIN_DATA: 100106,
          GLU_TESS_VERTEX_DATA: 100107,
          GLU_TESS_END_DATA: 100108,
          GLU_TESS_ERROR_DATA: 100109,
          GLU_TESS_EDGE_FLAG_DATA: 100110,
          GLU_TESS_COMBINE_DATA: 100111
        }
      }, X.prototype.gluDeleteTess = X.prototype.x, X.prototype.gluTessProperty = X.prototype.B, X.prototype.gluGetTessProperty = X.prototype.y, X.prototype.gluTessNormal = X.prototype.A, X.prototype.gluTessCallback = X.prototype.z, X.prototype.gluTessVertex = X.prototype.C, X.prototype.gluTessBeginPolygon = X.prototype.u, X.prototype.gluTessBeginContour = X.prototype.t, X.prototype.gluTessEndContour = X.prototype.v, X.prototype.gluTessEndPolygon = X.prototype.w, void 0 !== t && (t.exports = this.libtess);
    }, {}],
    11: [function (e, t, r) {
      "use strict";

      function L(e, t, r, i) {
        for (var n = e[t++], a = 1 << n, o = 1 + a, s = 1 + o, l = n + 1, u = (1 << l) - 1, h = 0, c = 0, f = 0, d = e[t++], p = new Int32Array(4096), m = null;;) {
          for (; h < 16 && 0 !== d;) c |= e[t++] << h, h += 8, 1 === d ? d = e[t++] : --d;

          if (h < l) break;
          var v = c & u;

          if (c >>= l, h -= l, v != a) {
            if (v == o) break;

            for (var y = v < s ? v : m, g = 0, b = y; a < b;) b = p[b] >> 8, ++g;

            var _ = b;
            if (i < f + g + (y !== v ? 1 : 0)) return void console.log("Warning, gif stream longer than expected.");
            r[f++] = _;
            var x = f += g;

            for (y !== v && (r[f++] = _), b = y; g--;) b = p[b], r[--x] = 255 & b, b >>= 8;

            null !== m && s < 4096 && (p[s++] = m << 8 | _, u + 1 <= s && l < 12 && (++l, u = u << 1 | 1)), m = v;
          } else s = 1 + o, u = (1 << (l = n + 1)) - 1, m = null;
        }

        return f !== i && console.log("Warning, gif stream shorter than expected."), r;
      }

      try {
        r.GifWriter = function (y, e, t, r) {
          var g = 0,
              i = void 0 === (r = void 0 === r ? {} : r).loop ? null : r.loop,
              b = void 0 === r.palette ? null : r.palette;
          if (e <= 0 || t <= 0 || 65535 < e || 65535 < t) throw new Error("Width/Height invalid.");

          function _(e) {
            var t = e.length;
            if (t < 2 || 256 < t || t & t - 1) throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
            return t;
          }

          y[g++] = 71, y[g++] = 73, y[g++] = 70, y[g++] = 56, y[g++] = 57, y[g++] = 97;
          var n = 0,
              a = 0;

          if (null !== b) {
            for (var o = _(b); o >>= 1;) ++n;

            if (o = 1 << n, --n, void 0 !== r.background) {
              if (o <= (a = r.background)) throw new Error("Background index out of range.");
              if (0 === a) throw new Error("Background index explicitly passed as 0.");
            }
          }

          if (y[g++] = 255 & e, y[g++] = e >> 8 & 255, y[g++] = 255 & t, y[g++] = t >> 8 & 255, y[g++] = (null !== b ? 128 : 0) | n, y[g++] = a, y[g++] = 0, null !== b) for (var s = 0, l = b.length; s < l; ++s) {
            var u = b[s];
            y[g++] = u >> 16 & 255, y[g++] = u >> 8 & 255, y[g++] = 255 & u;
          }

          if (null !== i) {
            if (i < 0 || 65535 < i) throw new Error("Loop count invalid.");
            y[g++] = 33, y[g++] = 255, y[g++] = 11, y[g++] = 78, y[g++] = 69, y[g++] = 84, y[g++] = 83, y[g++] = 67, y[g++] = 65, y[g++] = 80, y[g++] = 69, y[g++] = 50, y[g++] = 46, y[g++] = 48, y[g++] = 3, y[g++] = 1, y[g++] = 255 & i, y[g++] = i >> 8 & 255, y[g++] = 0;
          }

          var x = !1;
          this.addFrame = function (e, t, r, i, n, a) {
            if (!0 === x && (--g, x = !1), a = void 0 === a ? {} : a, e < 0 || t < 0 || 65535 < e || 65535 < t) throw new Error("x/y invalid.");
            if (r <= 0 || i <= 0 || 65535 < r || 65535 < i) throw new Error("Width/Height invalid.");
            if (n.length < r * i) throw new Error("Not enough pixels for the frame size.");
            var o = !0,
                s = a.palette;
            if (null == s && (o = !1, s = b), null == s) throw new Error("Must supply either a local or global palette.");

            for (var l = _(s), u = 0; l >>= 1;) ++u;

            l = 1 << u;
            var h = void 0 === a.delay ? 0 : a.delay,
                c = void 0 === a.disposal ? 0 : a.disposal;
            if (c < 0 || 3 < c) throw new Error("Disposal out of range.");
            var f = !1,
                d = 0;
            if (void 0 !== a.transparent && null !== a.transparent && (f = !0, (d = a.transparent) < 0 || l <= d)) throw new Error("Transparent color index.");
            if (0 === c && !f && 0 === h || (y[g++] = 33, y[g++] = 249, y[g++] = 4, y[g++] = c << 2 | (!0 === f ? 1 : 0), y[g++] = 255 & h, y[g++] = h >> 8 & 255, y[g++] = d, y[g++] = 0), y[g++] = 44, y[g++] = 255 & e, y[g++] = e >> 8 & 255, y[g++] = 255 & t, y[g++] = t >> 8 & 255, y[g++] = 255 & r, y[g++] = r >> 8 & 255, y[g++] = 255 & i, y[g++] = i >> 8 & 255, y[g++] = !0 === o ? 128 | u - 1 : 0, !0 === o) for (var p = 0, m = s.length; p < m; ++p) {
              var v = s[p];
              y[g++] = v >> 16 & 255, y[g++] = v >> 8 & 255, y[g++] = 255 & v;
            }
            return g = function (t, r, e, i) {
              t[r++] = e;
              var n = r++,
                  a = 1 << e,
                  o = a - 1,
                  s = 1 + a,
                  l = 1 + s,
                  u = e + 1,
                  h = 0,
                  c = 0;

              function f(e) {
                for (; e <= h;) t[r++] = 255 & c, c >>= 8, h -= 8, r === n + 256 && (t[n] = 255, n = r++);
              }

              function d(e) {
                c |= e << h, h += u, f(8);
              }

              var p = i[0] & o,
                  m = {};
              d(a);

              for (var v = 1, y = i.length; v < y; ++v) {
                var g = i[v] & o,
                    b = p << 8 | g,
                    _ = m[b];

                if (void 0 === _) {
                  for (c |= p << h, h += u; 8 <= h;) t[r++] = 255 & c, c >>= 8, h -= 8, r === n + 256 && (t[n] = 255, n = r++);

                  4096 === l ? (d(a), l = 1 + s, u = e + 1, m = {}) : (1 << u <= l && ++u, m[b] = l++), p = g;
                } else p = _;
              }

              d(p), d(s), f(1), n + 1 === r ? t[n] = 0 : (t[n] = r - n - 1, t[r++] = 0);
              return r;
            }(y, g, u < 2 ? 2 : u, n);
          }, this.end = function () {
            return !1 === x && (y[g++] = 59, x = !0), g;
          }, this.getOutputBuffer = function () {
            return y;
          }, this.setOutputBuffer = function (e) {
            y = e;
          }, this.getOutputBufferPosition = function () {
            return g;
          }, this.setOutputBufferPosition = function (e) {
            g = e;
          };
        }, r.GifReader = function (x) {
          var e = 0;
          if (71 !== x[e++] || 73 !== x[e++] || 70 !== x[e++] || 56 !== x[e++] || 56 != (x[e++] + 1 & 253) || 97 !== x[e++]) throw new Error("Invalid GIF 87a/89a header.");
          var w = x[e++] | x[e++] << 8,
              t = x[e++] | x[e++] << 8,
              r = x[e++],
              i = r >> 7,
              n = 1 << 1 + (7 & r);
          x[e++], x[e++];
          var a = null,
              o = null;
          i && (a = e, e += 3 * (o = n));
          var s = !0,
              l = [],
              u = 0,
              h = null,
              c = 0,
              f = null;

          for (this.width = w, this.height = t; s && e < x.length;) switch (x[e++]) {
            case 33:
              switch (x[e++]) {
                case 255:
                  if (11 !== x[e] || 78 == x[e + 1] && 69 == x[e + 2] && 84 == x[e + 3] && 83 == x[e + 4] && 67 == x[e + 5] && 65 == x[e + 6] && 80 == x[e + 7] && 69 == x[e + 8] && 50 == x[e + 9] && 46 == x[e + 10] && 48 == x[e + 11] && 3 == x[e + 12] && 1 == x[e + 13] && 0 == x[e + 16]) e += 14, f = x[e++] | x[e++] << 8, e++;else for (e += 12;;) {
                    if (!(0 <= (C = x[e++]))) throw Error("Invalid block size");
                    if (0 === C) break;
                    e += C;
                  }
                  break;

                case 249:
                  if (4 !== x[e++] || 0 !== x[e + 4]) throw new Error("Invalid graphics extension block.");
                  var d = x[e++];
                  u = x[e++] | x[e++] << 8, h = x[e++], 0 == (1 & d) && (h = null), c = d >> 2 & 7, e++;
                  break;

                case 254:
                  for (;;) {
                    if (!(0 <= (C = x[e++]))) throw Error("Invalid block size");
                    if (0 === C) break;
                    e += C;
                  }

                  break;

                default:
                  throw new Error("Unknown graphic control label: 0x" + x[e - 1].toString(16));
              }

              break;

            case 44:
              var p = x[e++] | x[e++] << 8,
                  m = x[e++] | x[e++] << 8,
                  v = x[e++] | x[e++] << 8,
                  y = x[e++] | x[e++] << 8,
                  g = x[e++],
                  b = g >> 6 & 1,
                  _ = 1 << 1 + (7 & g),
                  S = a,
                  M = o,
                  T = !1;

              if (g >> 7) {
                T = !0;
                S = e, e += 3 * (M = _);
              }

              var E = e;

              for (e++;;) {
                var C;
                if (!(0 <= (C = x[e++]))) throw Error("Invalid block size");
                if (0 === C) break;
                e += C;
              }

              l.push({
                x: p,
                y: m,
                width: v,
                height: y,
                has_local_palette: T,
                palette_offset: S,
                palette_size: M,
                data_offset: E,
                data_length: e - E,
                transparent_index: h,
                interlaced: !!b,
                delay: u,
                disposal: c
              });
              break;

            case 59:
              s = !1;
              break;

            default:
              throw new Error("Unknown gif block: 0x" + x[e - 1].toString(16));
          }

          this.numFrames = function () {
            return l.length;
          }, this.loopCount = function () {
            return f;
          }, this.frameInfo = function (e) {
            if (e < 0 || e >= l.length) throw new Error("Frame index out of range.");
            return l[e];
          }, this.decodeAndBlitFrameBGRA = function (e, t) {
            var r = this.frameInfo(e),
                i = r.width * r.height,
                n = new Uint8Array(i);
            L(x, r.data_offset, n, i);
            var a = r.palette_offset,
                o = r.transparent_index;
            null === o && (o = 256);
            var s = r.width,
                l = w - s,
                u = s,
                h = 4 * (r.y * w + r.x),
                c = 4 * ((r.y + r.height) * w + r.x),
                f = h,
                d = 4 * l;
            !0 === r.interlaced && (d += 4 * w * 7);

            for (var p = 8, m = 0, v = n.length; m < v; ++m) {
              var y = n[m];
              if (0 === u && (u = s, c <= (f += d) && (d = 4 * l + 4 * w * (p - 1), f = h + (s + l) * (p << 1), p >>= 1)), y === o) f += 4;else {
                var g = x[a + 3 * y],
                    b = x[a + 3 * y + 1],
                    _ = x[a + 3 * y + 2];
                t[f++] = _, t[f++] = b, t[f++] = g, t[f++] = 255;
              }
              --u;
            }
          }, this.decodeAndBlitFrameRGBA = function (e, t) {
            var r = this.frameInfo(e),
                i = r.width * r.height,
                n = new Uint8Array(i);
            L(x, r.data_offset, n, i);
            var a = r.palette_offset,
                o = r.transparent_index;
            null === o && (o = 256);
            var s = r.width,
                l = w - s,
                u = s,
                h = 4 * (r.y * w + r.x),
                c = 4 * ((r.y + r.height) * w + r.x),
                f = h,
                d = 4 * l;
            !0 === r.interlaced && (d += 4 * w * 7);

            for (var p = 8, m = 0, v = n.length; m < v; ++m) {
              var y = n[m];
              if (0 === u && (u = s, c <= (f += d) && (d = 4 * l + 4 * w * (p - 1), f = h + (s + l) * (p << 1), p >>= 1)), y === o) f += 4;else {
                var g = x[a + 3 * y],
                    b = x[a + 3 * y + 1],
                    _ = x[a + 3 * y + 2];
                t[f++] = g, t[f++] = b, t[f++] = _, t[f++] = 255;
              }
              --u;
            }
          };
        };
      } catch (e) {}
    }, {}],
    12: [function (jr, t, r) {
      (function (Gr) {
        var e;
        e = this, function (T) {
          "use strict";

          function e(e) {
            if (null == this) throw TypeError();
            var t = String(this),
                r = t.length,
                i = e ? Number(e) : 0;

            if (i != i && (i = 0), !(i < 0 || r <= i)) {
              var n,
                  a = t.charCodeAt(i);
              return 55296 <= a && a <= 56319 && i + 1 < r && 56320 <= (n = t.charCodeAt(i + 1)) && n <= 57343 ? 1024 * (a - 55296) + n - 56320 + 65536 : a;
            }
          }

          var t;
          String.prototype.codePointAt || ((t = function () {
            try {
              var e = {},
                  t = Object.defineProperty,
                  r = t(e, e, e) && t;
            } catch (e) {}

            return r;
          }()) ? t(String.prototype, "codePointAt", {
            value: e,
            configurable: !0,
            writable: !0
          }) : String.prototype.codePointAt = e);
          var l = 0,
              a = -3;

          function r() {
            this.table = new Uint16Array(16), this.trans = new Uint16Array(288);
          }

          function o(e, t) {
            this.source = e, this.sourceIndex = 0, this.tag = 0, this.bitcount = 0, this.dest = t, this.destLen = 0, this.ltree = new r(), this.dtree = new r();
          }

          var s = new r(),
              u = new r(),
              h = new Uint8Array(30),
              c = new Uint16Array(30),
              f = new Uint8Array(30),
              d = new Uint16Array(30),
              p = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
              m = new r(),
              v = new Uint8Array(320);

          function i(e, t, r, i) {
            var n, a;

            for (n = 0; n < r; ++n) e[n] = 0;

            for (n = 0; n < 30 - r; ++n) e[n + r] = n / r | 0;

            for (a = i, n = 0; n < 30; ++n) t[n] = a, a += 1 << e[n];
          }

          var y = new Uint16Array(16);

          function g(e, t, r, i) {
            var n, a;

            for (n = 0; n < 16; ++n) e.table[n] = 0;

            for (n = 0; n < i; ++n) e.table[t[r + n]]++;

            for (n = a = e.table[0] = 0; n < 16; ++n) y[n] = a, a += e.table[n];

            for (n = 0; n < i; ++n) t[r + n] && (e.trans[y[t[r + n]]++] = n);
          }

          function b(e) {
            e.bitcount-- || (e.tag = e.source[e.sourceIndex++], e.bitcount = 7);
            var t = 1 & e.tag;
            return e.tag >>>= 1, t;
          }

          function _(e, t, r) {
            if (!t) return r;

            for (; e.bitcount < 24;) e.tag |= e.source[e.sourceIndex++] << e.bitcount, e.bitcount += 8;

            var i = e.tag & 65535 >>> 16 - t;
            return e.tag >>>= t, e.bitcount -= t, i + r;
          }

          function x(e, t) {
            for (; e.bitcount < 24;) e.tag |= e.source[e.sourceIndex++] << e.bitcount, e.bitcount += 8;

            for (var r = 0, i = 0, n = 0, a = e.tag; i = 2 * i + (1 & a), a >>>= 1, ++n, r += t.table[n], 0 <= (i -= t.table[n]););

            return e.tag = a, e.bitcount -= n, t.trans[r + i];
          }

          function w(e, t, r) {
            var i, n, a, o, s, l;

            for (i = _(e, 5, 257), n = _(e, 5, 1), a = _(e, 4, 4), o = 0; o < 19; ++o) v[o] = 0;

            for (o = 0; o < a; ++o) {
              var u = _(e, 3, 0);

              v[p[o]] = u;
            }

            for (g(m, v, 0, 19), s = 0; s < i + n;) {
              var h = x(e, m);

              switch (h) {
                case 16:
                  var c = v[s - 1];

                  for (l = _(e, 2, 3); l; --l) v[s++] = c;

                  break;

                case 17:
                  for (l = _(e, 3, 3); l; --l) v[s++] = 0;

                  break;

                case 18:
                  for (l = _(e, 7, 11); l; --l) v[s++] = 0;

                  break;

                default:
                  v[s++] = h;
              }
            }

            g(t, v, 0, i), g(r, v, i, n);
          }

          function S(e, t, r) {
            for (;;) {
              var i,
                  n,
                  a,
                  o,
                  s = x(e, t);
              if (256 === s) return l;
              if (s < 256) e.dest[e.destLen++] = s;else for (i = _(e, h[s -= 257], c[s]), n = x(e, r), o = a = e.destLen - _(e, f[n], d[n]); o < a + i; ++o) e.dest[e.destLen++] = e.dest[o];
            }
          }

          function M(e) {
            for (var t, r; 8 < e.bitcount;) e.sourceIndex--, e.bitcount -= 8;

            if ((t = 256 * (t = e.source[e.sourceIndex + 1]) + e.source[e.sourceIndex]) !== (65535 & ~(256 * e.source[e.sourceIndex + 3] + e.source[e.sourceIndex + 2]))) return a;

            for (e.sourceIndex += 4, r = t; r; --r) e.dest[e.destLen++] = e.source[e.sourceIndex++];

            return e.bitcount = 0, l;
          }

          !function (e, t) {
            var r;

            for (r = 0; r < 7; ++r) e.table[r] = 0;

            for (e.table[7] = 24, e.table[8] = 152, e.table[9] = 112, r = 0; r < 24; ++r) e.trans[r] = 256 + r;

            for (r = 0; r < 144; ++r) e.trans[24 + r] = r;

            for (r = 0; r < 8; ++r) e.trans[168 + r] = 280 + r;

            for (r = 0; r < 112; ++r) e.trans[176 + r] = 144 + r;

            for (r = 0; r < 5; ++r) t.table[r] = 0;

            for (t.table[5] = 32, r = 0; r < 32; ++r) t.trans[r] = r;
          }(s, u), i(h, c, 4, 3), i(f, d, 2, 1), h[28] = 0, c[28] = 258;

          var n = function (e, t) {
            var r,
                i,
                n = new o(e, t);

            do {
              switch (r = b(n), _(n, 2, 0)) {
                case 0:
                  i = M(n);
                  break;

                case 1:
                  i = S(n, s, u);
                  break;

                case 2:
                  w(n, n.ltree, n.dtree), i = S(n, n.ltree, n.dtree);
                  break;

                default:
                  i = a;
              }

              if (i !== l) throw new Error("Data error");
            } while (!r);

            return n.destLen < n.dest.length ? "function" == typeof n.dest.slice ? n.dest.slice(0, n.destLen) : n.dest.subarray(0, n.destLen) : n.dest;
          };

          function E(e, t, r, i, n) {
            return Math.pow(1 - n, 3) * e + 3 * Math.pow(1 - n, 2) * n * t + 3 * (1 - n) * Math.pow(n, 2) * r + Math.pow(n, 3) * i;
          }

          function C() {
            this.x1 = Number.NaN, this.y1 = Number.NaN, this.x2 = Number.NaN, this.y2 = Number.NaN;
          }

          function I() {
            this.commands = [], this.fill = "black", this.stroke = null, this.strokeWidth = 1;
          }

          function L(e) {
            throw new Error(e);
          }

          function O(e, t) {
            e || L(t);
          }

          C.prototype.isEmpty = function () {
            return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
          }, C.prototype.addPoint = function (e, t) {
            "number" == typeof e && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = e, this.x2 = e), e < this.x1 && (this.x1 = e), e > this.x2 && (this.x2 = e)), "number" == typeof t && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = t, this.y2 = t), t < this.y1 && (this.y1 = t), t > this.y2 && (this.y2 = t));
          }, C.prototype.addX = function (e) {
            this.addPoint(e, null);
          }, C.prototype.addY = function (e) {
            this.addPoint(null, e);
          }, C.prototype.addBezier = function (e, t, r, i, n, a, o, s) {
            var l = this,
                u = [e, t],
                h = [r, i],
                c = [n, a],
                f = [o, s];
            this.addPoint(e, t), this.addPoint(o, s);

            for (var d = 0; d <= 1; d++) {
              var p = 6 * u[d] - 12 * h[d] + 6 * c[d],
                  m = -3 * u[d] + 9 * h[d] - 9 * c[d] + 3 * f[d],
                  v = 3 * h[d] - 3 * u[d];

              if (0 != m) {
                var y = Math.pow(p, 2) - 4 * v * m;

                if (!(y < 0)) {
                  var g = (-p + Math.sqrt(y)) / (2 * m);
                  0 < g && g < 1 && (0 === d && l.addX(E(u[d], h[d], c[d], f[d], g)), 1 === d && l.addY(E(u[d], h[d], c[d], f[d], g)));
                  var b = (-p - Math.sqrt(y)) / (2 * m);
                  0 < b && b < 1 && (0 === d && l.addX(E(u[d], h[d], c[d], f[d], b)), 1 === d && l.addY(E(u[d], h[d], c[d], f[d], b)));
                }
              } else {
                if (0 == p) continue;

                var _ = -v / p;

                0 < _ && _ < 1 && (0 === d && l.addX(E(u[d], h[d], c[d], f[d], _)), 1 === d && l.addY(E(u[d], h[d], c[d], f[d], _)));
              }
            }
          }, C.prototype.addQuad = function (e, t, r, i, n, a) {
            var o = e + 2 / 3 * (r - e),
                s = t + 2 / 3 * (i - t),
                l = o + 1 / 3 * (n - e),
                u = s + 1 / 3 * (a - t);
            this.addBezier(e, t, o, s, l, u, n, a);
          }, I.prototype.moveTo = function (e, t) {
            this.commands.push({
              type: "M",
              x: e,
              y: t
            });
          }, I.prototype.lineTo = function (e, t) {
            this.commands.push({
              type: "L",
              x: e,
              y: t
            });
          }, I.prototype.curveTo = I.prototype.bezierCurveTo = function (e, t, r, i, n, a) {
            this.commands.push({
              type: "C",
              x1: e,
              y1: t,
              x2: r,
              y2: i,
              x: n,
              y: a
            });
          }, I.prototype.quadTo = I.prototype.quadraticCurveTo = function (e, t, r, i) {
            this.commands.push({
              type: "Q",
              x1: e,
              y1: t,
              x: r,
              y: i
            });
          }, I.prototype.close = I.prototype.closePath = function () {
            this.commands.push({
              type: "Z"
            });
          }, I.prototype.extend = function (e) {
            if (e.commands) e = e.commands;else if (e instanceof C) {
              var t = e;
              return this.moveTo(t.x1, t.y1), this.lineTo(t.x2, t.y1), this.lineTo(t.x2, t.y2), this.lineTo(t.x1, t.y2), void this.close();
            }
            Array.prototype.push.apply(this.commands, e);
          }, I.prototype.getBoundingBox = function () {
            for (var e = new C(), t = 0, r = 0, i = 0, n = 0, a = 0; a < this.commands.length; a++) {
              var o = this.commands[a];

              switch (o.type) {
                case "M":
                  e.addPoint(o.x, o.y), t = i = o.x, r = n = o.y;
                  break;

                case "L":
                  e.addPoint(o.x, o.y), i = o.x, n = o.y;
                  break;

                case "Q":
                  e.addQuad(i, n, o.x1, o.y1, o.x, o.y), i = o.x, n = o.y;
                  break;

                case "C":
                  e.addBezier(i, n, o.x1, o.y1, o.x2, o.y2, o.x, o.y), i = o.x, n = o.y;
                  break;

                case "Z":
                  i = t, n = r;
                  break;

                default:
                  throw new Error("Unexpected path command " + o.type);
              }
            }

            return e.isEmpty() && e.addPoint(0, 0), e;
          }, I.prototype.draw = function (e) {
            e.beginPath();

            for (var t = 0; t < this.commands.length; t += 1) {
              var r = this.commands[t];
              "M" === r.type ? e.moveTo(r.x, r.y) : "L" === r.type ? e.lineTo(r.x, r.y) : "C" === r.type ? e.bezierCurveTo(r.x1, r.y1, r.x2, r.y2, r.x, r.y) : "Q" === r.type ? e.quadraticCurveTo(r.x1, r.y1, r.x, r.y) : "Z" === r.type && e.closePath();
            }

            this.fill && (e.fillStyle = this.fill, e.fill()), this.stroke && (e.strokeStyle = this.stroke, e.lineWidth = this.strokeWidth, e.stroke());
          }, I.prototype.toPathData = function (a) {
            function e() {
              for (var e, t = arguments, r = "", i = 0; i < arguments.length; i += 1) {
                var n = t[i];
                0 <= n && 0 < i && (r += " "), r += (e = n, Math.round(e) === e ? "" + Math.round(e) : e.toFixed(a));
              }

              return r;
            }

            a = void 0 !== a ? a : 2;

            for (var t = "", r = 0; r < this.commands.length; r += 1) {
              var i = this.commands[r];
              "M" === i.type ? t += "M" + e(i.x, i.y) : "L" === i.type ? t += "L" + e(i.x, i.y) : "C" === i.type ? t += "C" + e(i.x1, i.y1, i.x2, i.y2, i.x, i.y) : "Q" === i.type ? t += "Q" + e(i.x1, i.y1, i.x, i.y) : "Z" === i.type && (t += "Z");
            }

            return t;
          }, I.prototype.toSVG = function (e) {
            var t = '<path d="';
            return t += this.toPathData(e), t += '"', this.fill && "black" !== this.fill && (null === this.fill ? t += ' fill="none"' : t += ' fill="' + this.fill + '"'), this.stroke && (t += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"'), t += "/>";
          }, I.prototype.toDOMElement = function (e) {
            var t = this.toPathData(e),
                r = document.createElementNS("http://www.w3.org/2000/svg", "path");
            return r.setAttribute("d", t), r;
          };
          var P = {
            fail: L,
            argument: O,
            assert: O
          },
              R = 2147483648,
              D = {},
              k = {},
              A = {};

          function U(e) {
            return function () {
              return e;
            };
          }

          k.BYTE = function (e) {
            return P.argument(0 <= e && e <= 255, "Byte value should be between 0 and 255."), [e];
          }, A.BYTE = U(1), k.CHAR = function (e) {
            return [e.charCodeAt(0)];
          }, A.CHAR = U(1), k.CHARARRAY = function (e) {
            for (var t = [], r = 0; r < e.length; r += 1) t[r] = e.charCodeAt(r);

            return t;
          }, A.CHARARRAY = function (e) {
            return e.length;
          }, k.USHORT = function (e) {
            return [e >> 8 & 255, 255 & e];
          }, A.USHORT = U(2), k.SHORT = function (e) {
            return 32768 <= e && (e = -(65536 - e)), [e >> 8 & 255, 255 & e];
          }, A.SHORT = U(2), k.UINT24 = function (e) {
            return [e >> 16 & 255, e >> 8 & 255, 255 & e];
          }, A.UINT24 = U(3), k.ULONG = function (e) {
            return [e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e];
          }, A.ULONG = U(4), k.LONG = function (e) {
            return R <= e && (e = -(2 * R - e)), [e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e];
          }, A.LONG = U(4), k.FIXED = k.ULONG, A.FIXED = A.ULONG, k.FWORD = k.SHORT, A.FWORD = A.SHORT, k.UFWORD = k.USHORT, A.UFWORD = A.USHORT, k.LONGDATETIME = function (e) {
            return [0, 0, 0, 0, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e];
          }, A.LONGDATETIME = U(8), k.TAG = function (e) {
            return P.argument(4 === e.length, "Tag should be exactly 4 ASCII characters."), [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)];
          }, A.TAG = U(4), k.Card8 = k.BYTE, A.Card8 = A.BYTE, k.Card16 = k.USHORT, A.Card16 = A.USHORT, k.OffSize = k.BYTE, A.OffSize = A.BYTE, k.SID = k.USHORT, A.SID = A.USHORT, k.NUMBER = function (e) {
            return -107 <= e && e <= 107 ? [e + 139] : 108 <= e && e <= 1131 ? [247 + ((e -= 108) >> 8), 255 & e] : -1131 <= e && e <= -108 ? [251 + ((e = -e - 108) >> 8), 255 & e] : -32768 <= e && e <= 32767 ? k.NUMBER16(e) : k.NUMBER32(e);
          }, A.NUMBER = function (e) {
            return k.NUMBER(e).length;
          }, k.NUMBER16 = function (e) {
            return [28, e >> 8 & 255, 255 & e];
          }, A.NUMBER16 = U(3), k.NUMBER32 = function (e) {
            return [29, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e];
          }, A.NUMBER32 = U(5), k.REAL = function (e) {
            var t = e.toString(),
                r = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(t);

            if (r) {
              var i = parseFloat("1e" + ((r[2] ? +r[2] : 0) + r[1].length));
              t = (Math.round(e * i) / i).toString();
            }

            for (var n = "", a = 0, o = t.length; a < o; a += 1) {
              var s = t[a];
              n += "e" === s ? "-" === t[++a] ? "c" : "b" : "." === s ? "a" : "-" === s ? "e" : s;
            }

            for (var l = [30], u = 0, h = (n += 1 & n.length ? "f" : "ff").length; u < h; u += 2) l.push(parseInt(n.substr(u, 2), 16));

            return l;
          }, A.REAL = function (e) {
            return k.REAL(e).length;
          }, k.NAME = k.CHARARRAY, A.NAME = A.CHARARRAY, k.STRING = k.CHARARRAY, A.STRING = A.CHARARRAY, D.UTF8 = function (e, t, r) {
            for (var i = [], n = r, a = 0; a < n; a++, t += 1) i[a] = e.getUint8(t);

            return String.fromCharCode.apply(null, i);
          }, D.UTF16 = function (e, t, r) {
            for (var i = [], n = r / 2, a = 0; a < n; a++, t += 2) i[a] = e.getUint16(t);

            return String.fromCharCode.apply(null, i);
          }, k.UTF16 = function (e) {
            for (var t = [], r = 0; r < e.length; r += 1) {
              var i = e.charCodeAt(r);
              t[t.length] = i >> 8 & 255, t[t.length] = 255 & i;
            }

            return t;
          }, A.UTF16 = function (e) {
            return 2 * e.length;
          };
          var N = {
            "x-mac-croatian": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ",
            "x-mac-cyrillic": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю",
            "x-mac-gaelic": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæøṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ",
            "x-mac-greek": "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ­",
            "x-mac-icelandic": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
            "x-mac-inuit": "ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł",
            "x-mac-ce": "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ",
            macintosh: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
            "x-mac-romanian": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
            "x-mac-turkish": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ"
          };

          D.MACSTRING = function (e, t, r, i) {
            var n = N[i];

            if (void 0 !== n) {
              for (var a = "", o = 0; o < r; o++) {
                var s = e.getUint8(t + o);
                a += s <= 127 ? String.fromCharCode(s) : n[127 & s];
              }

              return a;
            }
          };

          var F,
              B = "function" == typeof WeakMap && new WeakMap();

          function G(e) {
            return -128 <= e && e <= 127;
          }

          function j(e, t, r) {
            for (var i = 0, n = e.length; t < n && i < 64 && 0 === e[t];) ++t, ++i;

            return r.push(128 | i - 1), t;
          }

          function V(e, t, r) {
            for (var i = 0, n = e.length, a = t; a < n && i < 64;) {
              var o = e[a];
              if (!G(o)) break;
              if (0 === o && a + 1 < n && 0 === e[a + 1]) break;
              ++a, ++i;
            }

            r.push(i - 1);

            for (var s = t; s < a; ++s) r.push(e[s] + 256 & 255);

            return a;
          }

          function z(e, t, r) {
            for (var i = 0, n = e.length, a = t; a < n && i < 64;) {
              var o = e[a];
              if (0 === o) break;
              if (G(o) && a + 1 < n && G(e[a + 1])) break;
              ++a, ++i;
            }

            r.push(64 | i - 1);

            for (var s = t; s < a; ++s) {
              var l = e[s];
              r.push(l + 65536 >> 8 & 255, l + 256 & 255);
            }

            return a;
          }

          k.MACSTRING = function (e, t) {
            var r = function (e) {
              if (!F) for (var t in F = {}, N) F[t] = new String(t);
              var r = F[e];

              if (void 0 !== r) {
                if (B) {
                  var i = B.get(r);
                  if (void 0 !== i) return i;
                }

                var n = N[e];

                if (void 0 !== n) {
                  for (var a = {}, o = 0; o < n.length; o++) a[n.charCodeAt(o)] = o + 128;

                  return B && B.set(r, a), a;
                }
              }
            }(t);

            if (void 0 !== r) {
              for (var i = [], n = 0; n < e.length; n++) {
                var a = e.charCodeAt(n);
                if (128 <= a && void 0 === (a = r[a])) return;
                i[n] = a;
              }

              return i;
            }
          }, A.MACSTRING = function (e, t) {
            var r = k.MACSTRING(e, t);
            return void 0 !== r ? r.length : 0;
          }, k.VARDELTAS = function (e) {
            for (var t = 0, r = []; t < e.length;) {
              var i = e[t];
              t = 0 === i ? j(e, t, r) : -128 <= i && i <= 127 ? V(e, t, r) : z(e, t, r);
            }

            return r;
          }, k.INDEX = function (e) {
            for (var t = 1, r = [t], i = [], n = 0; n < e.length; n += 1) {
              var a = k.OBJECT(e[n]);
              Array.prototype.push.apply(i, a), t += a.length, r.push(t);
            }

            if (0 === i.length) return [0, 0];

            for (var o = [], s = 1 + Math.floor(Math.log(t) / Math.log(2)) / 8 | 0, l = [void 0, k.BYTE, k.USHORT, k.UINT24, k.ULONG][s], u = 0; u < r.length; u += 1) {
              var h = l(r[u]);
              Array.prototype.push.apply(o, h);
            }

            return Array.prototype.concat(k.Card16(e.length), k.OffSize(s), o, i);
          }, A.INDEX = function (e) {
            return k.INDEX(e).length;
          }, k.DICT = function (e) {
            for (var t = [], r = Object.keys(e), i = r.length, n = 0; n < i; n += 1) {
              var a = parseInt(r[n], 0),
                  o = e[a];
              t = (t = t.concat(k.OPERAND(o.value, o.type))).concat(k.OPERATOR(a));
            }

            return t;
          }, A.DICT = function (e) {
            return k.DICT(e).length;
          }, k.OPERATOR = function (e) {
            return e < 1200 ? [e] : [12, e - 1200];
          }, k.OPERAND = function (e, t) {
            var r = [];
            if (Array.isArray(t)) for (var i = 0; i < t.length; i += 1) P.argument(e.length === t.length, "Not enough arguments given for type" + t), r = r.concat(k.OPERAND(e[i], t[i]));else if ("SID" === t) r = r.concat(k.NUMBER(e));else if ("offset" === t) r = r.concat(k.NUMBER32(e));else if ("number" === t) r = r.concat(k.NUMBER(e));else {
              if ("real" !== t) throw new Error("Unknown operand type " + t);
              r = r.concat(k.REAL(e));
            }
            return r;
          }, k.OP = k.BYTE, A.OP = A.BYTE;
          var H = "function" == typeof WeakMap && new WeakMap();

          function W(e, t, r) {
            for (var i = 0; i < t.length; i += 1) {
              var n = t[i];
              this[n.name] = n.value;
            }

            if (this.tableName = e, this.fields = t, r) for (var a = Object.keys(r), o = 0; o < a.length; o += 1) {
              var s = a[o],
                  l = r[s];
              void 0 !== this[s] && (this[s] = l);
            }
          }

          function q(e, t, r) {
            void 0 === r && (r = t.length);
            var i = new Array(t.length + 1);
            i[0] = {
              name: e + "Count",
              type: "USHORT",
              value: r
            };

            for (var n = 0; n < t.length; n++) i[n + 1] = {
              name: e + n,
              type: "USHORT",
              value: t[n]
            };

            return i;
          }

          function X(e, t, r) {
            var i = t.length,
                n = new Array(i + 1);
            n[0] = {
              name: e + "Count",
              type: "USHORT",
              value: i
            };

            for (var a = 0; a < i; a++) n[a + 1] = {
              name: e + a,
              type: "TABLE",
              value: r(t[a], a)
            };

            return n;
          }

          function Y(e, t, r) {
            var i = t.length,
                n = [];
            n[0] = {
              name: e + "Count",
              type: "USHORT",
              value: i
            };

            for (var a = 0; a < i; a++) n = n.concat(r(t[a], a));

            return n;
          }

          function Z(e) {
            1 === e.format ? W.call(this, "coverageTable", [{
              name: "coverageFormat",
              type: "USHORT",
              value: 1
            }].concat(q("glyph", e.glyphs))) : P.assert(!1, "Can't create coverage table format 2 yet.");
          }

          function Q(e) {
            W.call(this, "scriptListTable", Y("scriptRecord", e, function (e, t) {
              var r = e.script,
                  i = r.defaultLangSys;
              return P.assert(!!i, "Unable to write GSUB: script " + e.tag + " has no default language system."), [{
                name: "scriptTag" + t,
                type: "TAG",
                value: e.tag
              }, {
                name: "script" + t,
                type: "TABLE",
                value: new W("scriptTable", [{
                  name: "defaultLangSys",
                  type: "TABLE",
                  value: new W("defaultLangSys", [{
                    name: "lookupOrder",
                    type: "USHORT",
                    value: 0
                  }, {
                    name: "reqFeatureIndex",
                    type: "USHORT",
                    value: i.reqFeatureIndex
                  }].concat(q("featureIndex", i.featureIndexes)))
                }].concat(Y("langSys", r.langSysRecords, function (e, t) {
                  var r = e.langSys;
                  return [{
                    name: "langSysTag" + t,
                    type: "TAG",
                    value: e.tag
                  }, {
                    name: "langSys" + t,
                    type: "TABLE",
                    value: new W("langSys", [{
                      name: "lookupOrder",
                      type: "USHORT",
                      value: 0
                    }, {
                      name: "reqFeatureIndex",
                      type: "USHORT",
                      value: r.reqFeatureIndex
                    }].concat(q("featureIndex", r.featureIndexes)))
                  }];
                })))
              }];
            }));
          }

          function K(e) {
            W.call(this, "featureListTable", Y("featureRecord", e, function (e, t) {
              var r = e.feature;
              return [{
                name: "featureTag" + t,
                type: "TAG",
                value: e.tag
              }, {
                name: "feature" + t,
                type: "TABLE",
                value: new W("featureTable", [{
                  name: "featureParams",
                  type: "USHORT",
                  value: r.featureParams
                }].concat(q("lookupListIndex", r.lookupListIndexes)))
              }];
            }));
          }

          function J(e, r) {
            W.call(this, "lookupListTable", X("lookup", e, function (e) {
              var t = r[e.lookupType];
              return P.assert(!!t, "Unable to write GSUB lookup type " + e.lookupType + " tables."), new W("lookupTable", [{
                name: "lookupType",
                type: "USHORT",
                value: e.lookupType
              }, {
                name: "lookupFlag",
                type: "USHORT",
                value: e.lookupFlag
              }].concat(X("subtable", e.subtables, t)));
            }));
          }

          k.CHARSTRING = function (e) {
            if (H) {
              var t = H.get(e);
              if (void 0 !== t) return t;
            }

            for (var r = [], i = e.length, n = 0; n < i; n += 1) {
              var a = e[n];
              r = r.concat(k[a.type](a.value));
            }

            return H && H.set(e, r), r;
          }, A.CHARSTRING = function (e) {
            return k.CHARSTRING(e).length;
          }, k.OBJECT = function (e) {
            var t = k[e.type];
            return P.argument(void 0 !== t, "No encoding function for type " + e.type), t(e.value);
          }, A.OBJECT = function (e) {
            var t = A[e.type];
            return P.argument(void 0 !== t, "No sizeOf function for type " + e.type), t(e.value);
          }, k.TABLE = function (e) {
            for (var t = [], r = e.fields.length, i = [], n = [], a = 0; a < r; a += 1) {
              var o = e.fields[a],
                  s = k[o.type];
              P.argument(void 0 !== s, "No encoding function for field type " + o.type + " (" + o.name + ")");
              var l = e[o.name];
              void 0 === l && (l = o.value);
              var u = s(l);
              "TABLE" === o.type ? (n.push(t.length), t = t.concat([0, 0]), i.push(u)) : t = t.concat(u);
            }

            for (var h = 0; h < i.length; h += 1) {
              var c = n[h],
                  f = t.length;
              P.argument(f < 65536, "Table " + e.tableName + " too big."), t[c] = f >> 8, t[c + 1] = 255 & f, t = t.concat(i[h]);
            }

            return t;
          }, A.TABLE = function (e) {
            for (var t = 0, r = e.fields.length, i = 0; i < r; i += 1) {
              var n = e.fields[i],
                  a = A[n.type];
              P.argument(void 0 !== a, "No sizeOf function for field type " + n.type + " (" + n.name + ")");
              var o = e[n.name];
              void 0 === o && (o = n.value), t += a(o), "TABLE" === n.type && (t += 2);
            }

            return t;
          }, k.RECORD = k.TABLE, A.RECORD = A.TABLE, k.LITERAL = function (e) {
            return e;
          }, A.LITERAL = function (e) {
            return e.length;
          }, W.prototype.encode = function () {
            return k.TABLE(this);
          }, W.prototype.sizeOf = function () {
            return A.TABLE(this);
          };
          var $ = {
            Table: W,
            Record: W,
            Coverage: (Z.prototype = Object.create(W.prototype)).constructor = Z,
            ScriptList: (Q.prototype = Object.create(W.prototype)).constructor = Q,
            FeatureList: (K.prototype = Object.create(W.prototype)).constructor = K,
            LookupList: (J.prototype = Object.create(W.prototype)).constructor = J,
            ushortList: q,
            tableList: X,
            recordList: Y
          };

          function ee(e, t) {
            return e.getUint8(t);
          }

          function te(e, t) {
            return e.getUint16(t, !1);
          }

          function re(e, t) {
            return e.getUint32(t, !1);
          }

          function ie(e, t) {
            return e.getInt16(t, !1) + e.getUint16(t + 2, !1) / 65535;
          }

          var ne = {
            byte: 1,
            uShort: 2,
            short: 2,
            uLong: 4,
            fixed: 4,
            longDateTime: 8,
            tag: 4
          };

          function ae(e, t) {
            this.data = e, this.offset = t, this.relativeOffset = 0;
          }

          ae.prototype.parseByte = function () {
            var e = this.data.getUint8(this.offset + this.relativeOffset);
            return this.relativeOffset += 1, e;
          }, ae.prototype.parseChar = function () {
            var e = this.data.getInt8(this.offset + this.relativeOffset);
            return this.relativeOffset += 1, e;
          }, ae.prototype.parseCard8 = ae.prototype.parseByte, ae.prototype.parseCard16 = ae.prototype.parseUShort = function () {
            var e = this.data.getUint16(this.offset + this.relativeOffset);
            return this.relativeOffset += 2, e;
          }, ae.prototype.parseSID = ae.prototype.parseUShort, ae.prototype.parseOffset16 = ae.prototype.parseUShort, ae.prototype.parseShort = function () {
            var e = this.data.getInt16(this.offset + this.relativeOffset);
            return this.relativeOffset += 2, e;
          }, ae.prototype.parseF2Dot14 = function () {
            var e = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
            return this.relativeOffset += 2, e;
          }, ae.prototype.parseOffset32 = ae.prototype.parseULong = function () {
            var e = re(this.data, this.offset + this.relativeOffset);
            return this.relativeOffset += 4, e;
          }, ae.prototype.parseFixed = function () {
            var e = ie(this.data, this.offset + this.relativeOffset);
            return this.relativeOffset += 4, e;
          }, ae.prototype.parseString = function (e) {
            var t = this.data,
                r = this.offset + this.relativeOffset,
                i = "";
            this.relativeOffset += e;

            for (var n = 0; n < e; n++) i += String.fromCharCode(t.getUint8(r + n));

            return i;
          }, ae.prototype.parseTag = function () {
            return this.parseString(4);
          }, ae.prototype.parseLongDateTime = function () {
            var e = re(this.data, this.offset + this.relativeOffset + 4);
            return e -= 2082844800, this.relativeOffset += 8, e;
          }, ae.prototype.parseVersion = function (e) {
            var t = te(this.data, this.offset + this.relativeOffset),
                r = te(this.data, this.offset + this.relativeOffset + 2);
            return this.relativeOffset += 4, void 0 === e && (e = 4096), t + r / e / 10;
          }, ae.prototype.skip = function (e, t) {
            void 0 === t && (t = 1), this.relativeOffset += ne[e] * t;
          }, ae.prototype.parseULongList = function (e) {
            void 0 === e && (e = this.parseULong());

            for (var t = new Array(e), r = this.data, i = this.offset + this.relativeOffset, n = 0; n < e; n++) t[n] = r.getUint32(i), i += 4;

            return this.relativeOffset += 4 * e, t;
          }, ae.prototype.parseOffset16List = ae.prototype.parseUShortList = function (e) {
            void 0 === e && (e = this.parseUShort());

            for (var t = new Array(e), r = this.data, i = this.offset + this.relativeOffset, n = 0; n < e; n++) t[n] = r.getUint16(i), i += 2;

            return this.relativeOffset += 2 * e, t;
          }, ae.prototype.parseShortList = function (e) {
            for (var t = new Array(e), r = this.data, i = this.offset + this.relativeOffset, n = 0; n < e; n++) t[n] = r.getInt16(i), i += 2;

            return this.relativeOffset += 2 * e, t;
          }, ae.prototype.parseByteList = function (e) {
            for (var t = new Array(e), r = this.data, i = this.offset + this.relativeOffset, n = 0; n < e; n++) t[n] = r.getUint8(i++);

            return this.relativeOffset += e, t;
          }, ae.prototype.parseList = function (e, t) {
            t || (t = e, e = this.parseUShort());

            for (var r = new Array(e), i = 0; i < e; i++) r[i] = t.call(this);

            return r;
          }, ae.prototype.parseList32 = function (e, t) {
            t || (t = e, e = this.parseULong());

            for (var r = new Array(e), i = 0; i < e; i++) r[i] = t.call(this);

            return r;
          }, ae.prototype.parseRecordList = function (e, t) {
            t || (t = e, e = this.parseUShort());

            for (var r = new Array(e), i = Object.keys(t), n = 0; n < e; n++) {
              for (var a = {}, o = 0; o < i.length; o++) {
                var s = i[o],
                    l = t[s];
                a[s] = l.call(this);
              }

              r[n] = a;
            }

            return r;
          }, ae.prototype.parseRecordList32 = function (e, t) {
            t || (t = e, e = this.parseULong());

            for (var r = new Array(e), i = Object.keys(t), n = 0; n < e; n++) {
              for (var a = {}, o = 0; o < i.length; o++) {
                var s = i[o],
                    l = t[s];
                a[s] = l.call(this);
              }

              r[n] = a;
            }

            return r;
          }, ae.prototype.parseStruct = function (e) {
            if ("function" == typeof e) return e.call(this);

            for (var t = Object.keys(e), r = {}, i = 0; i < t.length; i++) {
              var n = t[i],
                  a = e[n];
              r[n] = a.call(this);
            }

            return r;
          }, ae.prototype.parseValueRecord = function (e) {
            if (void 0 === e && (e = this.parseUShort()), 0 !== e) {
              var t = {};
              return 1 & e && (t.xPlacement = this.parseShort()), 2 & e && (t.yPlacement = this.parseShort()), 4 & e && (t.xAdvance = this.parseShort()), 8 & e && (t.yAdvance = this.parseShort()), 16 & e && (t.xPlaDevice = void 0, this.parseShort()), 32 & e && (t.yPlaDevice = void 0, this.parseShort()), 64 & e && (t.xAdvDevice = void 0, this.parseShort()), 128 & e && (t.yAdvDevice = void 0, this.parseShort()), t;
            }
          }, ae.prototype.parseValueRecordList = function () {
            for (var e = this.parseUShort(), t = this.parseUShort(), r = new Array(t), i = 0; i < t; i++) r[i] = this.parseValueRecord(e);

            return r;
          }, ae.prototype.parsePointer = function (e) {
            var t = this.parseOffset16();
            if (0 < t) return new ae(this.data, this.offset + t).parseStruct(e);
          }, ae.prototype.parsePointer32 = function (e) {
            var t = this.parseOffset32();
            if (0 < t) return new ae(this.data, this.offset + t).parseStruct(e);
          }, ae.prototype.parseListOfLists = function (e) {
            for (var t = this, r = this.parseOffset16List(), i = r.length, n = this.relativeOffset, a = new Array(i), o = 0; o < i; o++) {
              var s = r[o];
              if (0 !== s) {
                if (t.relativeOffset = s, e) {
                  for (var l = t.parseOffset16List(), u = new Array(l.length), h = 0; h < l.length; h++) t.relativeOffset = s + l[h], u[h] = e.call(t);

                  a[o] = u;
                } else a[o] = t.parseUShortList();
              } else a[o] = void 0;
            }

            return this.relativeOffset = n, a;
          }, ae.prototype.parseCoverage = function () {
            var e = this.offset + this.relativeOffset,
                t = this.parseUShort(),
                r = this.parseUShort();
            if (1 === t) return {
              format: 1,
              glyphs: this.parseUShortList(r)
            };
            if (2 !== t) throw new Error("0x" + e.toString(16) + ": Coverage format must be 1 or 2.");

            for (var i = new Array(r), n = 0; n < r; n++) i[n] = {
              start: this.parseUShort(),
              end: this.parseUShort(),
              index: this.parseUShort()
            };

            return {
              format: 2,
              ranges: i
            };
          }, ae.prototype.parseClassDef = function () {
            var e = this.offset + this.relativeOffset,
                t = this.parseUShort();
            if (1 === t) return {
              format: 1,
              startGlyph: this.parseUShort(),
              classes: this.parseUShortList()
            };
            if (2 === t) return {
              format: 2,
              ranges: this.parseRecordList({
                start: ae.uShort,
                end: ae.uShort,
                classId: ae.uShort
              })
            };
            throw new Error("0x" + e.toString(16) + ": ClassDef format must be 1 or 2.");
          }, ae.list = function (e, t) {
            return function () {
              return this.parseList(e, t);
            };
          }, ae.list32 = function (e, t) {
            return function () {
              return this.parseList32(e, t);
            };
          }, ae.recordList = function (e, t) {
            return function () {
              return this.parseRecordList(e, t);
            };
          }, ae.recordList32 = function (e, t) {
            return function () {
              return this.parseRecordList32(e, t);
            };
          }, ae.pointer = function (e) {
            return function () {
              return this.parsePointer(e);
            };
          }, ae.pointer32 = function (e) {
            return function () {
              return this.parsePointer32(e);
            };
          }, ae.tag = ae.prototype.parseTag, ae.byte = ae.prototype.parseByte, ae.uShort = ae.offset16 = ae.prototype.parseUShort, ae.uShortList = ae.prototype.parseUShortList, ae.uLong = ae.offset32 = ae.prototype.parseULong, ae.uLongList = ae.prototype.parseULongList, ae.struct = ae.prototype.parseStruct, ae.coverage = ae.prototype.parseCoverage, ae.classDef = ae.prototype.parseClassDef;
          var oe = {
            reserved: ae.uShort,
            reqFeatureIndex: ae.uShort,
            featureIndexes: ae.uShortList
          };
          ae.prototype.parseScriptList = function () {
            return this.parsePointer(ae.recordList({
              tag: ae.tag,
              script: ae.pointer({
                defaultLangSys: ae.pointer(oe),
                langSysRecords: ae.recordList({
                  tag: ae.tag,
                  langSys: ae.pointer(oe)
                })
              })
            })) || [];
          }, ae.prototype.parseFeatureList = function () {
            return this.parsePointer(ae.recordList({
              tag: ae.tag,
              feature: ae.pointer({
                featureParams: ae.offset16,
                lookupListIndexes: ae.uShortList
              })
            })) || [];
          }, ae.prototype.parseLookupList = function (i) {
            return this.parsePointer(ae.list(ae.pointer(function () {
              var e = this.parseUShort();
              P.argument(1 <= e && e <= 9, "GPOS/GSUB lookup type " + e + " unknown.");
              var t = this.parseUShort(),
                  r = 16 & t;
              return {
                lookupType: e,
                lookupFlag: t,
                subtables: this.parseList(ae.pointer(i[e])),
                markFilteringSet: r ? this.parseUShort() : void 0
              };
            }))) || [];
          }, ae.prototype.parseFeatureVariationsList = function () {
            return this.parsePointer32(function () {
              var e = this.parseUShort(),
                  t = this.parseUShort();
              return P.argument(1 === e && t < 1, "GPOS/GSUB feature variations table unknown."), this.parseRecordList32({
                conditionSetOffset: ae.offset32,
                featureTableSubstitutionOffset: ae.offset32
              });
            }) || [];
          };
          var se = {
            getByte: ee,
            getCard8: ee,
            getUShort: te,
            getCard16: te,
            getShort: function (e, t) {
              return e.getInt16(t, !1);
            },
            getULong: re,
            getFixed: ie,
            getTag: function (e, t) {
              for (var r = "", i = t; i < t + 4; i += 1) r += String.fromCharCode(e.getInt8(i));

              return r;
            },
            getOffset: function (e, t, r) {
              for (var i = 0, n = 0; n < r; n += 1) i <<= 8, i += e.getUint8(t + n);

              return i;
            },
            getBytes: function (e, t, r) {
              for (var i = [], n = t; n < r; n += 1) i.push(e.getUint8(n));

              return i;
            },
            bytesToString: function (e) {
              for (var t = "", r = 0; r < e.length; r += 1) t += String.fromCharCode(e[r]);

              return t;
            },
            Parser: ae
          };
          var le = {
            parse: function (e, t) {
              var r = {};
              r.version = se.getUShort(e, t), P.argument(0 === r.version, "cmap table version should be 0."), r.numTables = se.getUShort(e, t + 2);

              for (var i = -1, n = r.numTables - 1; 0 <= n; --n) {
                var a = se.getUShort(e, t + 4 + 8 * n),
                    o = se.getUShort(e, t + 4 + 8 * n + 2);

                if (3 === a && (0 === o || 1 === o || 10 === o) || 0 === a && (0 === o || 1 === o || 2 === o || 3 === o || 4 === o)) {
                  i = se.getULong(e, t + 4 + 8 * n + 4);
                  break;
                }
              }

              if (-1 === i) throw new Error("No valid cmap sub-tables found.");
              var s = new se.Parser(e, t + i);
              if (r.format = s.parseUShort(), 12 === r.format) !function (e, t) {
                var r;
                t.parseUShort(), e.length = t.parseULong(), e.language = t.parseULong(), e.groupCount = r = t.parseULong(), e.glyphIndexMap = {};

                for (var i = 0; i < r; i += 1) for (var n = t.parseULong(), a = t.parseULong(), o = t.parseULong(), s = n; s <= a; s += 1) e.glyphIndexMap[s] = o, o++;
              }(r, s);else {
                if (4 !== r.format) throw new Error("Only format 4 and 12 cmap tables are supported (found format " + r.format + ").");
                !function (e, t, r, i, n) {
                  var a;
                  e.length = t.parseUShort(), e.language = t.parseUShort(), e.segCount = a = t.parseUShort() >> 1, t.skip("uShort", 3), e.glyphIndexMap = {};

                  for (var o = new se.Parser(r, i + n + 14), s = new se.Parser(r, i + n + 16 + 2 * a), l = new se.Parser(r, i + n + 16 + 4 * a), u = new se.Parser(r, i + n + 16 + 6 * a), h = i + n + 16 + 8 * a, c = 0; c < a - 1; c += 1) for (var f = void 0, d = o.parseUShort(), p = s.parseUShort(), m = l.parseShort(), v = u.parseUShort(), y = p; y <= d; y += 1) 0 !== v ? (h = u.offset + u.relativeOffset - 2, h += v, h += 2 * (y - p), 0 !== (f = se.getUShort(r, h)) && (f = f + m & 65535)) : f = y + m & 65535, e.glyphIndexMap[y] = f;
                }(r, s, e, t, i);
              }
              return r;
            },
            make: function (e) {
              var t,
                  r = !0;

              for (t = e.length - 1; 0 < t; --t) {
                if (65535 < e.get(t).unicode) {
                  console.log("Adding CMAP format 12 (needed!)"), r = !1;
                  break;
                }
              }

              var i = [{
                name: "version",
                type: "USHORT",
                value: 0
              }, {
                name: "numTables",
                type: "USHORT",
                value: r ? 1 : 2
              }, {
                name: "platformID",
                type: "USHORT",
                value: 3
              }, {
                name: "encodingID",
                type: "USHORT",
                value: 1
              }, {
                name: "offset",
                type: "ULONG",
                value: r ? 12 : 20
              }];
              r || (i = i.concat([{
                name: "cmap12PlatformID",
                type: "USHORT",
                value: 3
              }, {
                name: "cmap12EncodingID",
                type: "USHORT",
                value: 10
              }, {
                name: "cmap12Offset",
                type: "ULONG",
                value: 0
              }])), i = i.concat([{
                name: "format",
                type: "USHORT",
                value: 4
              }, {
                name: "cmap4Length",
                type: "USHORT",
                value: 0
              }, {
                name: "language",
                type: "USHORT",
                value: 0
              }, {
                name: "segCountX2",
                type: "USHORT",
                value: 0
              }, {
                name: "searchRange",
                type: "USHORT",
                value: 0
              }, {
                name: "entrySelector",
                type: "USHORT",
                value: 0
              }, {
                name: "rangeShift",
                type: "USHORT",
                value: 0
              }]);
              var n,
                  a,
                  o,
                  s = new $.Table("cmap", i);

              for (s.segments = [], t = 0; t < e.length; t += 1) {
                for (var l = e.get(t), u = 0; u < l.unicodes.length; u += 1) n = s, a = l.unicodes[u], o = t, n.segments.push({
                  end: a,
                  start: a,
                  delta: -(a - o),
                  offset: 0,
                  glyphIndex: o
                });

                s.segments = s.segments.sort(function (e, t) {
                  return e.start - t.start;
                });
              }

              s.segments.push({
                end: 65535,
                start: 65535,
                delta: 1,
                offset: 0
              });
              var h = s.segments.length,
                  c = 0,
                  f = [],
                  d = [],
                  p = [],
                  m = [],
                  v = [],
                  y = [];

              for (t = 0; t < h; t += 1) {
                var g = s.segments[t];
                g.end <= 65535 && g.start <= 65535 ? (f = f.concat({
                  name: "end_" + t,
                  type: "USHORT",
                  value: g.end
                }), d = d.concat({
                  name: "start_" + t,
                  type: "USHORT",
                  value: g.start
                }), p = p.concat({
                  name: "idDelta_" + t,
                  type: "SHORT",
                  value: g.delta
                }), m = m.concat({
                  name: "idRangeOffset_" + t,
                  type: "USHORT",
                  value: g.offset
                }), void 0 !== g.glyphId && (v = v.concat({
                  name: "glyph_" + t,
                  type: "USHORT",
                  value: g.glyphId
                }))) : c += 1, r || void 0 === g.glyphIndex || (y = (y = (y = y.concat({
                  name: "cmap12Start_" + t,
                  type: "ULONG",
                  value: g.start
                })).concat({
                  name: "cmap12End_" + t,
                  type: "ULONG",
                  value: g.end
                })).concat({
                  name: "cmap12Glyph_" + t,
                  type: "ULONG",
                  value: g.glyphIndex
                }));
              }

              if (s.segCountX2 = 2 * (h - c), s.searchRange = 2 * Math.pow(2, Math.floor(Math.log(h - c) / Math.log(2))), s.entrySelector = Math.log(s.searchRange / 2) / Math.log(2), s.rangeShift = s.segCountX2 - s.searchRange, s.fields = s.fields.concat(f), s.fields.push({
                name: "reservedPad",
                type: "USHORT",
                value: 0
              }), s.fields = s.fields.concat(d), s.fields = s.fields.concat(p), s.fields = s.fields.concat(m), s.fields = s.fields.concat(v), s.cmap4Length = 14 + 2 * f.length + 2 + 2 * d.length + 2 * p.length + 2 * m.length + 2 * v.length, !r) {
                var b = 16 + 4 * y.length;
                s.cmap12Offset = 20 + s.cmap4Length, s.fields = s.fields.concat([{
                  name: "cmap12Format",
                  type: "USHORT",
                  value: 12
                }, {
                  name: "cmap12Reserved",
                  type: "USHORT",
                  value: 0
                }, {
                  name: "cmap12Length",
                  type: "ULONG",
                  value: b
                }, {
                  name: "cmap12Language",
                  type: "ULONG",
                  value: 0
                }, {
                  name: "cmap12nGroups",
                  type: "ULONG",
                  value: y.length / 3
                }]), s.fields = s.fields.concat(y);
              }

              return s;
            }
          },
              ue = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "266 ff", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"],
              he = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls"],
              ce = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"],
              fe = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];

          function de(e) {
            this.font = e;
          }

          function pe(e) {
            this.cmap = e;
          }

          function me(e, t) {
            this.encoding = e, this.charset = t;
          }

          function ve(e) {
            switch (e.version) {
              case 1:
                this.names = fe.slice();
                break;

              case 2:
                this.names = new Array(e.numberOfGlyphs);

                for (var t = 0; t < e.numberOfGlyphs; t++) e.glyphNameIndex[t] < fe.length ? this.names[t] = fe[e.glyphNameIndex[t]] : this.names[t] = e.names[e.glyphNameIndex[t] - fe.length];

                break;

              case 2.5:
                this.names = new Array(e.numberOfGlyphs);

                for (var r = 0; r < e.numberOfGlyphs; r++) this.names[r] = fe[r + e.glyphNameIndex[r]];

                break;

              case 3:
              default:
                this.names = [];
            }
          }

          de.prototype.charToGlyphIndex = function (e) {
            var t = e.codePointAt(0),
                r = this.font.glyphs;
            if (r) for (var i = 0; i < r.length; i += 1) for (var n = r.get(i), a = 0; a < n.unicodes.length; a += 1) if (n.unicodes[a] === t) return i;
            return null;
          }, pe.prototype.charToGlyphIndex = function (e) {
            return this.cmap.glyphIndexMap[e.codePointAt(0)] || 0;
          }, me.prototype.charToGlyphIndex = function (e) {
            var t = e.codePointAt(0),
                r = this.encoding[t];
            return this.charset.indexOf(r);
          }, ve.prototype.nameToGlyphIndex = function (e) {
            return this.names.indexOf(e);
          }, ve.prototype.glyphIndexToName = function (e) {
            return this.names[e];
          };
          var ye = {
            line: function (e, t, r, i, n) {
              e.beginPath(), e.moveTo(t, r), e.lineTo(i, n), e.stroke();
            }
          };

          function ge(e) {
            this.bindConstructorValues(e);
          }

          function be(t, e, r) {
            Object.defineProperty(t, e, {
              get: function () {
                return t.path, t[r];
              },
              set: function (e) {
                t[r] = e;
              },
              enumerable: !0,
              configurable: !0
            });
          }

          function _e(e, t) {
            if (this.font = e, this.glyphs = {}, Array.isArray(t)) for (var r = 0; r < t.length; r++) this.glyphs[r] = t[r];
            this.length = t && t.length || 0;
          }

          ge.prototype.bindConstructorValues = function (e) {
            var t, r;
            this.index = e.index || 0, this.name = e.name || null, this.unicode = e.unicode || void 0, this.unicodes = e.unicodes || void 0 !== e.unicode ? [e.unicode] : [], e.xMin && (this.xMin = e.xMin), e.yMin && (this.yMin = e.yMin), e.xMax && (this.xMax = e.xMax), e.yMax && (this.yMax = e.yMax), e.advanceWidth && (this.advanceWidth = e.advanceWidth), Object.defineProperty(this, "path", (t = e.path, r = t || new I(), {
              configurable: !0,
              get: function () {
                return "function" == typeof r && (r = r()), r;
              },
              set: function (e) {
                r = e;
              }
            }));
          }, ge.prototype.addUnicode = function (e) {
            0 === this.unicodes.length && (this.unicode = e), this.unicodes.push(e);
          }, ge.prototype.getBoundingBox = function () {
            return this.path.getBoundingBox();
          }, ge.prototype.getPath = function (e, t, r, i, n) {
            var a, o;
            e = void 0 !== e ? e : 0, t = void 0 !== t ? t : 0, r = void 0 !== r ? r : 72;
            var s = (i = i || {}).xScale,
                l = i.yScale;
            if (i.hinting && n && n.hinting && (o = this.path && n.hinting.exec(this, r)), o) a = n.hinting.getCommands(o), e = Math.round(e), t = Math.round(t), s = l = 1;else {
              a = this.path.commands;
              var u = 1 / this.path.unitsPerEm * r;
              void 0 === s && (s = u), void 0 === l && (l = u);
            }

            for (var h = new I(), c = 0; c < a.length; c += 1) {
              var f = a[c];
              "M" === f.type ? h.moveTo(e + f.x * s, t + -f.y * l) : "L" === f.type ? h.lineTo(e + f.x * s, t + -f.y * l) : "Q" === f.type ? h.quadraticCurveTo(e + f.x1 * s, t + -f.y1 * l, e + f.x * s, t + -f.y * l) : "C" === f.type ? h.curveTo(e + f.x1 * s, t + -f.y1 * l, e + f.x2 * s, t + -f.y2 * l, e + f.x * s, t + -f.y * l) : "Z" === f.type && h.closePath();
            }

            return h;
          }, ge.prototype.getContours = function () {
            if (void 0 === this.points) return [];

            for (var e = [], t = [], r = 0; r < this.points.length; r += 1) {
              var i = this.points[r];
              t.push(i), i.lastPointOfContour && (e.push(t), t = []);
            }

            return P.argument(0 === t.length, "There are still points left in the current contour."), e;
          }, ge.prototype.getMetrics = function () {
            for (var e = this.path.commands, t = [], r = [], i = 0; i < e.length; i += 1) {
              var n = e[i];
              "Z" !== n.type && (t.push(n.x), r.push(n.y)), "Q" !== n.type && "C" !== n.type || (t.push(n.x1), r.push(n.y1)), "C" === n.type && (t.push(n.x2), r.push(n.y2));
            }

            var a = {
              xMin: Math.min.apply(null, t),
              yMin: Math.min.apply(null, r),
              xMax: Math.max.apply(null, t),
              yMax: Math.max.apply(null, r),
              leftSideBearing: this.leftSideBearing
            };
            return isFinite(a.xMin) || (a.xMin = 0), isFinite(a.xMax) || (a.xMax = this.advanceWidth), isFinite(a.yMin) || (a.yMin = 0), isFinite(a.yMax) || (a.yMax = 0), a.rightSideBearing = this.advanceWidth - a.leftSideBearing - (a.xMax - a.xMin), a;
          }, ge.prototype.draw = function (e, t, r, i, n) {
            this.getPath(t, r, i, n).draw(e);
          }, ge.prototype.drawPoints = function (o, e, t, r) {
            function i(e, t, r, i) {
              var n = 2 * Math.PI;
              o.beginPath();

              for (var a = 0; a < e.length; a += 1) o.moveTo(t + e[a].x * i, r + e[a].y * i), o.arc(t + e[a].x * i, r + e[a].y * i, 2, 0, n, !1);

              o.closePath(), o.fill();
            }

            e = void 0 !== e ? e : 0, t = void 0 !== t ? t : 0, r = void 0 !== r ? r : 24;

            for (var n = 1 / this.path.unitsPerEm * r, a = [], s = [], l = this.path, u = 0; u < l.commands.length; u += 1) {
              var h = l.commands[u];
              void 0 !== h.x && a.push({
                x: h.x,
                y: -h.y
              }), void 0 !== h.x1 && s.push({
                x: h.x1,
                y: -h.y1
              }), void 0 !== h.x2 && s.push({
                x: h.x2,
                y: -h.y2
              });
            }

            o.fillStyle = "blue", i(a, e, t, n), o.fillStyle = "red", i(s, e, t, n);
          }, ge.prototype.drawMetrics = function (e, t, r, i) {
            var n;
            t = void 0 !== t ? t : 0, r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 24, n = 1 / this.path.unitsPerEm * i, e.lineWidth = 1, e.strokeStyle = "black", ye.line(e, t, -1e4, t, 1e4), ye.line(e, -1e4, r, 1e4, r);
            var a = this.xMin || 0,
                o = this.yMin || 0,
                s = this.xMax || 0,
                l = this.yMax || 0,
                u = this.advanceWidth || 0;
            e.strokeStyle = "blue", ye.line(e, t + a * n, -1e4, t + a * n, 1e4), ye.line(e, t + s * n, -1e4, t + s * n, 1e4), ye.line(e, -1e4, r + -o * n, 1e4, r + -o * n), ye.line(e, -1e4, r + -l * n, 1e4, r + -l * n), e.strokeStyle = "green", ye.line(e, t + u * n, -1e4, t + u * n, 1e4);
          }, _e.prototype.get = function (e) {
            return "function" == typeof this.glyphs[e] && (this.glyphs[e] = this.glyphs[e]()), this.glyphs[e];
          }, _e.prototype.push = function (e, t) {
            this.glyphs[e] = t, this.length++;
          };
          var xe = {
            GlyphSet: _e,
            glyphLoader: function (e, t) {
              return new ge({
                index: t,
                font: e
              });
            },
            ttfGlyphLoader: function (r, e, i, n, a, o) {
              return function () {
                var t = new ge({
                  index: e,
                  font: r
                });
                return t.path = function () {
                  i(t, n, a);
                  var e = o(r.glyphs, t);
                  return e.unitsPerEm = r.unitsPerEm, e;
                }, be(t, "xMin", "_xMin"), be(t, "xMax", "_xMax"), be(t, "yMin", "_yMin"), be(t, "yMax", "_yMax"), t;
              };
            },
            cffGlyphLoader: function (r, e, i, n) {
              return function () {
                var t = new ge({
                  index: e,
                  font: r
                });
                return t.path = function () {
                  var e = i(r, t, n);
                  return e.unitsPerEm = r.unitsPerEm, e;
                }, t;
              };
            }
          };

          function we(e, t) {
            if (e === t) return !0;

            if (Array.isArray(e) && Array.isArray(t)) {
              if (e.length !== t.length) return !1;

              for (var r = 0; r < e.length; r += 1) if (!we(e[r], t[r])) return !1;

              return !0;
            }

            return !1;
          }

          function Se(e) {
            return e.length < 1240 ? 107 : e.length < 33900 ? 1131 : 32768;
          }

          function Me(e, t, r) {
            var i,
                n,
                a = [],
                o = [],
                s = se.getCard16(e, t);

            if (0 !== s) {
              var l = se.getByte(e, t + 2);
              i = t + (s + 1) * l + 2;

              for (var u = t + 3, h = 0; h < s + 1; h += 1) a.push(se.getOffset(e, u, l)), u += l;

              n = i + a[s];
            } else n = t + 2;

            for (var c = 0; c < a.length - 1; c += 1) {
              var f = se.getBytes(e, i + a[c], i + a[c + 1]);
              r && (f = r(f)), o.push(f);
            }

            return {
              objects: o,
              startOffset: t,
              endOffset: n
            };
          }

          function Te(e, t) {
            if (28 === t) return e.parseByte() << 8 | e.parseByte();
            if (29 === t) return e.parseByte() << 24 | e.parseByte() << 16 | e.parseByte() << 8 | e.parseByte();
            if (30 === t) return function (e) {
              for (var t = "", r = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];;) {
                var i = e.parseByte(),
                    n = i >> 4,
                    a = 15 & i;
                if (15 == n) break;
                if (t += r[n], 15 == a) break;
                t += r[a];
              }

              return parseFloat(t);
            }(e);
            if (32 <= t && t <= 246) return t - 139;
            if (247 <= t && t <= 250) return 256 * (t - 247) + e.parseByte() + 108;
            if (251 <= t && t <= 254) return 256 * -(t - 251) - e.parseByte() - 108;
            throw new Error("Invalid b0 " + t);
          }

          function Ee(e, t, r) {
            t = void 0 !== t ? t : 0;
            var i = new se.Parser(e, t),
                n = [],
                a = [];

            for (r = void 0 !== r ? r : e.length; i.relativeOffset < r;) {
              var o = i.parseByte();
              o <= 21 ? (12 === o && (o = 1200 + i.parseByte()), n.push([o, a]), a = []) : a.push(Te(i, o));
            }

            return function (e) {
              for (var t = {}, r = 0; r < e.length; r += 1) {
                var i = e[r][0],
                    n = e[r][1],
                    a = void 0;
                if (a = 1 === n.length ? n[0] : n, t.hasOwnProperty(i) && !isNaN(t[i])) throw new Error("Object " + t + " already has key " + i);
                t[i] = a;
              }

              return t;
            }(n);
          }

          function Ce(e, t) {
            return t = t <= 390 ? ue[t] : e[t - 391];
          }

          function Le(e, t, r) {
            for (var i, n = {}, a = 0; a < t.length; a += 1) {
              var o = t[a];

              if (Array.isArray(o.type)) {
                var s = [];
                s.length = o.type.length;

                for (var l = 0; l < o.type.length; l++) void 0 === (i = void 0 !== e[o.op] ? e[o.op][l] : void 0) && (i = void 0 !== o.value && void 0 !== o.value[l] ? o.value[l] : null), "SID" === o.type[l] && (i = Ce(r, i)), s[l] = i;

                n[o.name] = s;
              } else void 0 === (i = e[o.op]) && (i = void 0 !== o.value ? o.value : null), "SID" === o.type && (i = Ce(r, i)), n[o.name] = i;
            }

            return n;
          }

          var Oe = [{
            name: "version",
            op: 0,
            type: "SID"
          }, {
            name: "notice",
            op: 1,
            type: "SID"
          }, {
            name: "copyright",
            op: 1200,
            type: "SID"
          }, {
            name: "fullName",
            op: 2,
            type: "SID"
          }, {
            name: "familyName",
            op: 3,
            type: "SID"
          }, {
            name: "weight",
            op: 4,
            type: "SID"
          }, {
            name: "isFixedPitch",
            op: 1201,
            type: "number",
            value: 0
          }, {
            name: "italicAngle",
            op: 1202,
            type: "number",
            value: 0
          }, {
            name: "underlinePosition",
            op: 1203,
            type: "number",
            value: -100
          }, {
            name: "underlineThickness",
            op: 1204,
            type: "number",
            value: 50
          }, {
            name: "paintType",
            op: 1205,
            type: "number",
            value: 0
          }, {
            name: "charstringType",
            op: 1206,
            type: "number",
            value: 2
          }, {
            name: "fontMatrix",
            op: 1207,
            type: ["real", "real", "real", "real", "real", "real"],
            value: [.001, 0, 0, .001, 0, 0]
          }, {
            name: "uniqueId",
            op: 13,
            type: "number"
          }, {
            name: "fontBBox",
            op: 5,
            type: ["number", "number", "number", "number"],
            value: [0, 0, 0, 0]
          }, {
            name: "strokeWidth",
            op: 1208,
            type: "number",
            value: 0
          }, {
            name: "xuid",
            op: 14,
            type: [],
            value: null
          }, {
            name: "charset",
            op: 15,
            type: "offset",
            value: 0
          }, {
            name: "encoding",
            op: 16,
            type: "offset",
            value: 0
          }, {
            name: "charStrings",
            op: 17,
            type: "offset",
            value: 0
          }, {
            name: "private",
            op: 18,
            type: ["number", "offset"],
            value: [0, 0]
          }, {
            name: "ros",
            op: 1230,
            type: ["SID", "SID", "number"]
          }, {
            name: "cidFontVersion",
            op: 1231,
            type: "number",
            value: 0
          }, {
            name: "cidFontRevision",
            op: 1232,
            type: "number",
            value: 0
          }, {
            name: "cidFontType",
            op: 1233,
            type: "number",
            value: 0
          }, {
            name: "cidCount",
            op: 1234,
            type: "number",
            value: 8720
          }, {
            name: "uidBase",
            op: 1235,
            type: "number"
          }, {
            name: "fdArray",
            op: 1236,
            type: "offset"
          }, {
            name: "fdSelect",
            op: 1237,
            type: "offset"
          }, {
            name: "fontName",
            op: 1238,
            type: "SID"
          }],
              Pe = [{
            name: "subrs",
            op: 19,
            type: "offset",
            value: 0
          }, {
            name: "defaultWidthX",
            op: 20,
            type: "number",
            value: 0
          }, {
            name: "nominalWidthX",
            op: 21,
            type: "number",
            value: 0
          }];

          function Re(e, t, r, i) {
            return Le(Ee(e, t, r), Pe, i);
          }

          function De(e, t, r, i) {
            for (var n, a, o = [], s = 0; s < r.length; s += 1) {
              var l = new DataView(new Uint8Array(r[s]).buffer),
                  u = (a = i, Le(Ee(n = l, 0, n.byteLength), Oe, a));
              u._subrs = [], u._subrsBias = 0;
              var h = u.private[0],
                  c = u.private[1];

              if (0 !== h && 0 !== c) {
                var f = Re(e, c + t, h, i);

                if (u._defaultWidthX = f.defaultWidthX, u._nominalWidthX = f.nominalWidthX, 0 !== f.subrs) {
                  var d = Me(e, c + f.subrs + t);
                  u._subrs = d.objects, u._subrsBias = Se(u._subrs);
                }

                u._privateDict = f;
              }

              o.push(u);
            }

            return o;
          }

          function ke(v, y, e) {
            var g,
                b,
                _,
                x,
                w,
                S,
                t,
                M,
                T = new I(),
                E = [],
                C = 0,
                L = !1,
                O = !1,
                P = 0,
                R = 0;

            if (v.isCIDFont) {
              var r = v.tables.cff.topDict._fdSelect[y.index],
                  i = v.tables.cff.topDict._fdArray[r];
              w = i._subrs, S = i._subrsBias, t = i._defaultWidthX, M = i._nominalWidthX;
            } else w = v.tables.cff.topDict._subrs, S = v.tables.cff.topDict._subrsBias, t = v.tables.cff.topDict._defaultWidthX, M = v.tables.cff.topDict._nominalWidthX;

            var D = t;

            function k(e, t) {
              O && T.closePath(), T.moveTo(e, t), O = !0;
            }

            function A() {
              E.length % 2 == 0 || L || (D = E.shift() + M), C += E.length >> 1, E.length = 0, L = !0;
            }

            return function e(t) {
              for (var r, i, n, a, o, s, l, u, h, c, f, d, p = 0; p < t.length;) {
                var m = t[p];

                switch (p += 1, m) {
                  case 1:
                  case 3:
                    A();
                    break;

                  case 4:
                    1 < E.length && !L && (D = E.shift() + M, L = !0), R += E.pop(), k(P, R);
                    break;

                  case 5:
                    for (; 0 < E.length;) P += E.shift(), R += E.shift(), T.lineTo(P, R);

                    break;

                  case 6:
                    for (; 0 < E.length && (P += E.shift(), T.lineTo(P, R), 0 !== E.length);) R += E.shift(), T.lineTo(P, R);

                    break;

                  case 7:
                    for (; 0 < E.length && (R += E.shift(), T.lineTo(P, R), 0 !== E.length);) P += E.shift(), T.lineTo(P, R);

                    break;

                  case 8:
                    for (; 0 < E.length;) g = P + E.shift(), b = R + E.shift(), _ = g + E.shift(), x = b + E.shift(), P = _ + E.shift(), R = x + E.shift(), T.curveTo(g, b, _, x, P, R);

                    break;

                  case 10:
                    o = E.pop() + S, (s = w[o]) && e(s);
                    break;

                  case 11:
                    return;

                  case 12:
                    switch (m = t[p], p += 1, m) {
                      case 35:
                        g = P + E.shift(), b = R + E.shift(), _ = g + E.shift(), x = b + E.shift(), l = _ + E.shift(), u = x + E.shift(), h = l + E.shift(), c = u + E.shift(), f = h + E.shift(), d = c + E.shift(), P = f + E.shift(), R = d + E.shift(), E.shift(), T.curveTo(g, b, _, x, l, u), T.curveTo(h, c, f, d, P, R);
                        break;

                      case 34:
                        g = P + E.shift(), b = R, _ = g + E.shift(), x = b + E.shift(), l = _ + E.shift(), u = x, h = l + E.shift(), c = x, f = h + E.shift(), d = R, P = f + E.shift(), T.curveTo(g, b, _, x, l, u), T.curveTo(h, c, f, d, P, R);
                        break;

                      case 36:
                        g = P + E.shift(), b = R + E.shift(), _ = g + E.shift(), x = b + E.shift(), l = _ + E.shift(), u = x, h = l + E.shift(), c = x, f = h + E.shift(), d = c + E.shift(), P = f + E.shift(), T.curveTo(g, b, _, x, l, u), T.curveTo(h, c, f, d, P, R);
                        break;

                      case 37:
                        g = P + E.shift(), b = R + E.shift(), _ = g + E.shift(), x = b + E.shift(), l = _ + E.shift(), u = x + E.shift(), h = l + E.shift(), c = u + E.shift(), f = h + E.shift(), d = c + E.shift(), Math.abs(f - P) > Math.abs(d - R) ? P = f + E.shift() : R = d + E.shift(), T.curveTo(g, b, _, x, l, u), T.curveTo(h, c, f, d, P, R);
                        break;

                      default:
                        console.log("Glyph " + y.index + ": unknown operator 1200" + m), E.length = 0;
                    }

                    break;

                  case 14:
                    0 < E.length && !L && (D = E.shift() + M, L = !0), O && (T.closePath(), O = !1);
                    break;

                  case 18:
                    A();
                    break;

                  case 19:
                  case 20:
                    A(), p += C + 7 >> 3;
                    break;

                  case 21:
                    2 < E.length && !L && (D = E.shift() + M, L = !0), R += E.pop(), k(P += E.pop(), R);
                    break;

                  case 22:
                    1 < E.length && !L && (D = E.shift() + M, L = !0), k(P += E.pop(), R);
                    break;

                  case 23:
                    A();
                    break;

                  case 24:
                    for (; 2 < E.length;) g = P + E.shift(), b = R + E.shift(), _ = g + E.shift(), x = b + E.shift(), P = _ + E.shift(), R = x + E.shift(), T.curveTo(g, b, _, x, P, R);

                    P += E.shift(), R += E.shift(), T.lineTo(P, R);
                    break;

                  case 25:
                    for (; 6 < E.length;) P += E.shift(), R += E.shift(), T.lineTo(P, R);

                    g = P + E.shift(), b = R + E.shift(), _ = g + E.shift(), x = b + E.shift(), P = _ + E.shift(), R = x + E.shift(), T.curveTo(g, b, _, x, P, R);
                    break;

                  case 26:
                    for (E.length % 2 && (P += E.shift()); 0 < E.length;) g = P, b = R + E.shift(), _ = g + E.shift(), x = b + E.shift(), P = _, R = x + E.shift(), T.curveTo(g, b, _, x, P, R);

                    break;

                  case 27:
                    for (E.length % 2 && (R += E.shift()); 0 < E.length;) g = P + E.shift(), b = R, _ = g + E.shift(), x = b + E.shift(), P = _ + E.shift(), R = x, T.curveTo(g, b, _, x, P, R);

                    break;

                  case 28:
                    r = t[p], i = t[p + 1], E.push((r << 24 | i << 16) >> 16), p += 2;
                    break;

                  case 29:
                    o = E.pop() + v.gsubrsBias, (s = v.gsubrs[o]) && e(s);
                    break;

                  case 30:
                    for (; 0 < E.length && (g = P, b = R + E.shift(), _ = g + E.shift(), x = b + E.shift(), P = _ + E.shift(), R = x + (1 === E.length ? E.shift() : 0), T.curveTo(g, b, _, x, P, R), 0 !== E.length);) g = P + E.shift(), b = R, _ = g + E.shift(), x = b + E.shift(), R = x + E.shift(), P = _ + (1 === E.length ? E.shift() : 0), T.curveTo(g, b, _, x, P, R);

                    break;

                  case 31:
                    for (; 0 < E.length && (g = P + E.shift(), b = R, _ = g + E.shift(), x = b + E.shift(), R = x + E.shift(), P = _ + (1 === E.length ? E.shift() : 0), T.curveTo(g, b, _, x, P, R), 0 !== E.length);) g = P, b = R + E.shift(), _ = g + E.shift(), x = b + E.shift(), P = _ + E.shift(), R = x + (1 === E.length ? E.shift() : 0), T.curveTo(g, b, _, x, P, R);

                    break;

                  default:
                    m < 32 ? console.log("Glyph " + y.index + ": unknown operator " + m) : m < 247 ? E.push(m - 139) : m < 251 ? (r = t[p], p += 1, E.push(256 * (m - 247) + r + 108)) : m < 255 ? (r = t[p], p += 1, E.push(256 * -(m - 251) - r - 108)) : (r = t[p], i = t[p + 1], n = t[p + 2], a = t[p + 3], p += 4, E.push((r << 24 | i << 16 | n << 8 | a) / 65536));
                }
              }
            }(e), y.advanceWidth = D, T;
          }

          function Ae(e, t) {
            var r,
                i = ue.indexOf(e);
            return 0 <= i && (r = i), 0 <= (i = t.indexOf(e)) ? r = i + ue.length : (r = ue.length + t.length, t.push(e)), r;
          }

          function Ie(e, t, r) {
            for (var i = {}, n = 0; n < e.length; n += 1) {
              var a = e[n],
                  o = t[a.name];
              void 0 === o || we(o, a.value) || ("SID" === a.type && (o = Ae(o, r)), i[a.op] = {
                name: a.name,
                type: a.type,
                value: o
              });
            }

            return i;
          }

          function Ue(e, t) {
            var r = new $.Record("Top DICT", [{
              name: "dict",
              type: "DICT",
              value: {}
            }]);
            return r.dict = Ie(Oe, e, t), r;
          }

          function Ne(e) {
            var t = new $.Record("Top DICT INDEX", [{
              name: "topDicts",
              type: "INDEX",
              value: []
            }]);
            return t.topDicts = [{
              name: "topDict_0",
              type: "TABLE",
              value: e
            }], t;
          }

          function Fe(e) {
            var t = [],
                r = e.path;
            t.push({
              name: "width",
              type: "NUMBER",
              value: e.advanceWidth
            });

            for (var i = 0, n = 0, a = 0; a < r.commands.length; a += 1) {
              var o = void 0,
                  s = void 0,
                  l = r.commands[a];

              if ("Q" === l.type) {
                l = {
                  type: "C",
                  x: l.x,
                  y: l.y,
                  x1: 1 / 3 * i + 2 / 3 * l.x1,
                  y1: 1 / 3 * n + 2 / 3 * l.y1,
                  x2: 1 / 3 * l.x + 2 / 3 * l.x1,
                  y2: 1 / 3 * l.y + 2 / 3 * l.y1
                };
              }

              if ("M" === l.type) o = Math.round(l.x - i), s = Math.round(l.y - n), t.push({
                name: "dx",
                type: "NUMBER",
                value: o
              }), t.push({
                name: "dy",
                type: "NUMBER",
                value: s
              }), t.push({
                name: "rmoveto",
                type: "OP",
                value: 21
              }), i = Math.round(l.x), n = Math.round(l.y);else if ("L" === l.type) o = Math.round(l.x - i), s = Math.round(l.y - n), t.push({
                name: "dx",
                type: "NUMBER",
                value: o
              }), t.push({
                name: "dy",
                type: "NUMBER",
                value: s
              }), t.push({
                name: "rlineto",
                type: "OP",
                value: 5
              }), i = Math.round(l.x), n = Math.round(l.y);else if ("C" === l.type) {
                var u = Math.round(l.x1 - i),
                    h = Math.round(l.y1 - n),
                    c = Math.round(l.x2 - l.x1),
                    f = Math.round(l.y2 - l.y1);
                o = Math.round(l.x - l.x2), s = Math.round(l.y - l.y2), t.push({
                  name: "dx1",
                  type: "NUMBER",
                  value: u
                }), t.push({
                  name: "dy1",
                  type: "NUMBER",
                  value: h
                }), t.push({
                  name: "dx2",
                  type: "NUMBER",
                  value: c
                }), t.push({
                  name: "dy2",
                  type: "NUMBER",
                  value: f
                }), t.push({
                  name: "dx",
                  type: "NUMBER",
                  value: o
                }), t.push({
                  name: "dy",
                  type: "NUMBER",
                  value: s
                }), t.push({
                  name: "rrcurveto",
                  type: "OP",
                  value: 8
                }), i = Math.round(l.x), n = Math.round(l.y);
              }
            }

            return t.push({
              name: "endchar",
              type: "OP",
              value: 14
            }), t;
          }

          var Be = {
            parse: function (e, t, r) {
              r.tables.cff = {};
              var i,
                  n,
                  a,
                  o = Me(e, (i = e, n = t, (a = {}).formatMajor = se.getCard8(i, n), a.formatMinor = se.getCard8(i, n + 1), a.size = se.getCard8(i, n + 2), a.offsetSize = se.getCard8(i, n + 3), a.startOffset = n, a.endOffset = n + 4, a).endOffset, se.bytesToString),
                  s = Me(e, o.endOffset),
                  l = Me(e, s.endOffset, se.bytesToString),
                  u = Me(e, l.endOffset);
              r.gsubrs = u.objects, r.gsubrsBias = Se(r.gsubrs);
              var h = De(e, t, s.objects, l.objects);
              if (1 !== h.length) throw new Error("CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = " + h.length);
              var c = h[0];

              if ((r.tables.cff.topDict = c)._privateDict && (r.defaultWidthX = c._privateDict.defaultWidthX, r.nominalWidthX = c._privateDict.nominalWidthX), void 0 !== c.ros[0] && void 0 !== c.ros[1] && (r.isCIDFont = !0), r.isCIDFont) {
                var f = c.fdArray,
                    d = c.fdSelect;
                if (0 === f || 0 === d) throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing");
                var p = De(e, t, Me(e, f += t).objects, l.objects);
                c._fdArray = p, d += t, c._fdSelect = function (e, t, r, i) {
                  var n,
                      a = [],
                      o = new se.Parser(e, t),
                      s = o.parseCard8();
                  if (0 === s) for (var l = 0; l < r; l++) {
                    if (i <= (n = o.parseCard8())) throw new Error("CFF table CID Font FDSelect has bad FD index value " + n + " (FD count " + i + ")");
                    a.push(n);
                  } else {
                    if (3 !== s) throw new Error("CFF Table CID Font FDSelect table has unsupported format " + s);
                    var u,
                        h = o.parseCard16(),
                        c = o.parseCard16();
                    if (0 !== c) throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID " + c);

                    for (var f = 0; f < h; f++) {
                      if (n = o.parseCard8(), u = o.parseCard16(), i <= n) throw new Error("CFF table CID Font FDSelect has bad FD index value " + n + " (FD count " + i + ")");
                      if (r < u) throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID " + u);

                      for (; c < u; c++) a.push(n);

                      c = u;
                    }

                    if (u !== r) throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID " + u);
                  }
                  return a;
                }(e, d, r.numGlyphs, p.length);
              }

              var m = t + c.private[1],
                  v = Re(e, m, c.private[0], l.objects);

              if (r.defaultWidthX = v.defaultWidthX, r.nominalWidthX = v.nominalWidthX, 0 !== v.subrs) {
                var y = Me(e, m + v.subrs);
                r.subrs = y.objects, r.subrsBias = Se(r.subrs);
              } else r.subrs = [], r.subrsBias = 0;

              var g = Me(e, t + c.charStrings);
              r.nGlyphs = g.objects.length;

              var b = function (e, t, r, i) {
                var n,
                    a,
                    o = new se.Parser(e, t);
                --r;
                var s = [".notdef"],
                    l = o.parseCard8();
                if (0 === l) for (var u = 0; u < r; u += 1) n = o.parseSID(), s.push(Ce(i, n));else if (1 === l) for (; s.length <= r;) {
                  n = o.parseSID(), a = o.parseCard8();

                  for (var h = 0; h <= a; h += 1) s.push(Ce(i, n)), n += 1;
                } else {
                  if (2 !== l) throw new Error("Unknown charset format " + l);

                  for (; s.length <= r;) {
                    n = o.parseSID(), a = o.parseCard16();

                    for (var c = 0; c <= a; c += 1) s.push(Ce(i, n)), n += 1;
                  }
                }
                return s;
              }(e, t + c.charset, r.nGlyphs, l.objects);

              0 === c.encoding ? r.cffEncoding = new me(he, b) : 1 === c.encoding ? r.cffEncoding = new me(ce, b) : r.cffEncoding = function (e, t, r) {
                var i,
                    n = {},
                    a = new se.Parser(e, t),
                    o = a.parseCard8();
                if (0 === o) for (var s = a.parseCard8(), l = 0; l < s; l += 1) n[i = a.parseCard8()] = l;else {
                  if (1 !== o) throw new Error("Unknown encoding format " + o);
                  var u = a.parseCard8();
                  i = 1;

                  for (var h = 0; h < u; h += 1) for (var c = a.parseCard8(), f = a.parseCard8(), d = c; d <= c + f; d += 1) n[d] = i, i += 1;
                }
                return new me(n, r);
              }(e, t + c.encoding, b), r.encoding = r.encoding || r.cffEncoding, r.glyphs = new xe.GlyphSet(r);

              for (var _ = 0; _ < r.nGlyphs; _ += 1) {
                var x = g.objects[_];
                r.glyphs.push(_, xe.cffGlyphLoader(r, _, ke, x));
              }
            },
            make: function (e, t) {
              for (var r, i = new $.Table("CFF ", [{
                name: "header",
                type: "RECORD"
              }, {
                name: "nameIndex",
                type: "RECORD"
              }, {
                name: "topDictIndex",
                type: "RECORD"
              }, {
                name: "stringIndex",
                type: "RECORD"
              }, {
                name: "globalSubrIndex",
                type: "RECORD"
              }, {
                name: "charsets",
                type: "RECORD"
              }, {
                name: "charStringsIndex",
                type: "RECORD"
              }, {
                name: "privateDict",
                type: "RECORD"
              }]), n = 1 / t.unitsPerEm, a = {
                version: t.version,
                fullName: t.fullName,
                familyName: t.familyName,
                weight: t.weightName,
                fontBBox: t.fontBBox || [0, 0, 0, 0],
                fontMatrix: [n, 0, 0, n, 0, 0],
                charset: 999,
                encoding: 0,
                charStrings: 999,
                private: [0, 999]
              }, o = [], s = 1; s < e.length; s += 1) r = e.get(s), o.push(r.name);

              var l = [];
              i.header = new $.Record("Header", [{
                name: "major",
                type: "Card8",
                value: 1
              }, {
                name: "minor",
                type: "Card8",
                value: 0
              }, {
                name: "hdrSize",
                type: "Card8",
                value: 4
              }, {
                name: "major",
                type: "Card8",
                value: 1
              }]), i.nameIndex = function (e) {
                var t = new $.Record("Name INDEX", [{
                  name: "names",
                  type: "INDEX",
                  value: []
                }]);
                t.names = [];

                for (var r = 0; r < e.length; r += 1) t.names.push({
                  name: "name_" + r,
                  type: "NAME",
                  value: e[r]
                });

                return t;
              }([t.postScriptName]);
              var u,
                  h,
                  c,
                  f = Ue(a, l);
              i.topDictIndex = Ne(f), i.globalSubrIndex = new $.Record("Global Subr INDEX", [{
                name: "subrs",
                type: "INDEX",
                value: []
              }]), i.charsets = function (e, t) {
                for (var r = new $.Record("Charsets", [{
                  name: "format",
                  type: "Card8",
                  value: 0
                }]), i = 0; i < e.length; i += 1) {
                  var n = Ae(e[i], t);
                  r.fields.push({
                    name: "glyph_" + i,
                    type: "SID",
                    value: n
                  });
                }

                return r;
              }(o, l), i.charStringsIndex = function (e) {
                for (var t = new $.Record("CharStrings INDEX", [{
                  name: "charStrings",
                  type: "INDEX",
                  value: []
                }]), r = 0; r < e.length; r += 1) {
                  var i = e.get(r),
                      n = Fe(i);
                  t.charStrings.push({
                    name: i.name,
                    type: "CHARSTRING",
                    value: n
                  });
                }

                return t;
              }(e), i.privateDict = (u = {}, h = l, (c = new $.Record("Private DICT", [{
                name: "dict",
                type: "DICT",
                value: {}
              }])).dict = Ie(Pe, u, h), c), i.stringIndex = function (e) {
                var t = new $.Record("String INDEX", [{
                  name: "strings",
                  type: "INDEX",
                  value: []
                }]);
                t.strings = [];

                for (var r = 0; r < e.length; r += 1) t.strings.push({
                  name: "string_" + r,
                  type: "STRING",
                  value: e[r]
                });

                return t;
              }(l);
              var d = i.header.sizeOf() + i.nameIndex.sizeOf() + i.topDictIndex.sizeOf() + i.stringIndex.sizeOf() + i.globalSubrIndex.sizeOf();
              return a.charset = d, a.encoding = 0, a.charStrings = a.charset + i.charsets.sizeOf(), a.private[1] = a.charStrings + i.charStringsIndex.sizeOf(), f = Ue(a, l), i.topDictIndex = Ne(f), i;
            }
          };
          var Ge = {
            parse: function (e, t) {
              var r = {},
                  i = new se.Parser(e, t);
              return r.version = i.parseVersion(), r.fontRevision = Math.round(1e3 * i.parseFixed()) / 1e3, r.checkSumAdjustment = i.parseULong(), r.magicNumber = i.parseULong(), P.argument(1594834165 === r.magicNumber, "Font header has wrong magic number."), r.flags = i.parseUShort(), r.unitsPerEm = i.parseUShort(), r.created = i.parseLongDateTime(), r.modified = i.parseLongDateTime(), r.xMin = i.parseShort(), r.yMin = i.parseShort(), r.xMax = i.parseShort(), r.yMax = i.parseShort(), r.macStyle = i.parseUShort(), r.lowestRecPPEM = i.parseUShort(), r.fontDirectionHint = i.parseShort(), r.indexToLocFormat = i.parseShort(), r.glyphDataFormat = i.parseShort(), r;
            },
            make: function (e) {
              var t = Math.round(new Date().getTime() / 1e3) + 2082844800,
                  r = t;
              return e.createdTimestamp && (r = e.createdTimestamp + 2082844800), new $.Table("head", [{
                name: "version",
                type: "FIXED",
                value: 65536
              }, {
                name: "fontRevision",
                type: "FIXED",
                value: 65536
              }, {
                name: "checkSumAdjustment",
                type: "ULONG",
                value: 0
              }, {
                name: "magicNumber",
                type: "ULONG",
                value: 1594834165
              }, {
                name: "flags",
                type: "USHORT",
                value: 0
              }, {
                name: "unitsPerEm",
                type: "USHORT",
                value: 1e3
              }, {
                name: "created",
                type: "LONGDATETIME",
                value: r
              }, {
                name: "modified",
                type: "LONGDATETIME",
                value: t
              }, {
                name: "xMin",
                type: "SHORT",
                value: 0
              }, {
                name: "yMin",
                type: "SHORT",
                value: 0
              }, {
                name: "xMax",
                type: "SHORT",
                value: 0
              }, {
                name: "yMax",
                type: "SHORT",
                value: 0
              }, {
                name: "macStyle",
                type: "USHORT",
                value: 0
              }, {
                name: "lowestRecPPEM",
                type: "USHORT",
                value: 0
              }, {
                name: "fontDirectionHint",
                type: "SHORT",
                value: 2
              }, {
                name: "indexToLocFormat",
                type: "SHORT",
                value: 0
              }, {
                name: "glyphDataFormat",
                type: "SHORT",
                value: 0
              }], e);
            }
          };
          var je = {
            parse: function (e, t) {
              var r = {},
                  i = new se.Parser(e, t);
              return r.version = i.parseVersion(), r.ascender = i.parseShort(), r.descender = i.parseShort(), r.lineGap = i.parseShort(), r.advanceWidthMax = i.parseUShort(), r.minLeftSideBearing = i.parseShort(), r.minRightSideBearing = i.parseShort(), r.xMaxExtent = i.parseShort(), r.caretSlopeRise = i.parseShort(), r.caretSlopeRun = i.parseShort(), r.caretOffset = i.parseShort(), i.relativeOffset += 8, r.metricDataFormat = i.parseShort(), r.numberOfHMetrics = i.parseUShort(), r;
            },
            make: function (e) {
              return new $.Table("hhea", [{
                name: "version",
                type: "FIXED",
                value: 65536
              }, {
                name: "ascender",
                type: "FWORD",
                value: 0
              }, {
                name: "descender",
                type: "FWORD",
                value: 0
              }, {
                name: "lineGap",
                type: "FWORD",
                value: 0
              }, {
                name: "advanceWidthMax",
                type: "UFWORD",
                value: 0
              }, {
                name: "minLeftSideBearing",
                type: "FWORD",
                value: 0
              }, {
                name: "minRightSideBearing",
                type: "FWORD",
                value: 0
              }, {
                name: "xMaxExtent",
                type: "FWORD",
                value: 0
              }, {
                name: "caretSlopeRise",
                type: "SHORT",
                value: 1
              }, {
                name: "caretSlopeRun",
                type: "SHORT",
                value: 0
              }, {
                name: "caretOffset",
                type: "SHORT",
                value: 0
              }, {
                name: "reserved1",
                type: "SHORT",
                value: 0
              }, {
                name: "reserved2",
                type: "SHORT",
                value: 0
              }, {
                name: "reserved3",
                type: "SHORT",
                value: 0
              }, {
                name: "reserved4",
                type: "SHORT",
                value: 0
              }, {
                name: "metricDataFormat",
                type: "SHORT",
                value: 0
              }, {
                name: "numberOfHMetrics",
                type: "USHORT",
                value: 0
              }], e);
            }
          };
          var Ve = {
            parse: function (e, t, r, i, n) {
              for (var a, o, s = new se.Parser(e, t), l = 0; l < i; l += 1) {
                l < r && (a = s.parseUShort(), o = s.parseShort());
                var u = n.get(l);
                u.advanceWidth = a, u.leftSideBearing = o;
              }
            },
            make: function (e) {
              for (var t = new $.Table("hmtx", []), r = 0; r < e.length; r += 1) {
                var i = e.get(r),
                    n = i.advanceWidth || 0,
                    a = i.leftSideBearing || 0;
                t.fields.push({
                  name: "advanceWidth_" + r,
                  type: "USHORT",
                  value: n
                }), t.fields.push({
                  name: "leftSideBearing_" + r,
                  type: "SHORT",
                  value: a
                });
              }

              return t;
            }
          };
          var ze = {
            make: function (e) {
              for (var t = new $.Table("ltag", [{
                name: "version",
                type: "ULONG",
                value: 1
              }, {
                name: "flags",
                type: "ULONG",
                value: 0
              }, {
                name: "numTags",
                type: "ULONG",
                value: e.length
              }]), r = "", i = 12 + 4 * e.length, n = 0; n < e.length; ++n) {
                var a = r.indexOf(e[n]);
                a < 0 && (a = r.length, r += e[n]), t.fields.push({
                  name: "offset " + n,
                  type: "USHORT",
                  value: i + a
                }), t.fields.push({
                  name: "length " + n,
                  type: "USHORT",
                  value: e[n].length
                });
              }

              return t.fields.push({
                name: "stringPool",
                type: "CHARARRAY",
                value: r
              }), t;
            },
            parse: function (e, t) {
              var r = new se.Parser(e, t),
                  i = r.parseULong();
              P.argument(1 === i, "Unsupported ltag table version."), r.skip("uLong", 1);

              for (var n = r.parseULong(), a = [], o = 0; o < n; o++) {
                for (var s = "", l = t + r.parseUShort(), u = r.parseUShort(), h = l; h < l + u; ++h) s += String.fromCharCode(e.getInt8(h));

                a.push(s);
              }

              return a;
            }
          };
          var He = {
            parse: function (e, t) {
              var r = {},
                  i = new se.Parser(e, t);
              return r.version = i.parseVersion(), r.numGlyphs = i.parseUShort(), 1 === r.version && (r.maxPoints = i.parseUShort(), r.maxContours = i.parseUShort(), r.maxCompositePoints = i.parseUShort(), r.maxCompositeContours = i.parseUShort(), r.maxZones = i.parseUShort(), r.maxTwilightPoints = i.parseUShort(), r.maxStorage = i.parseUShort(), r.maxFunctionDefs = i.parseUShort(), r.maxInstructionDefs = i.parseUShort(), r.maxStackElements = i.parseUShort(), r.maxSizeOfInstructions = i.parseUShort(), r.maxComponentElements = i.parseUShort(), r.maxComponentDepth = i.parseUShort()), r;
            },
            make: function (e) {
              return new $.Table("maxp", [{
                name: "version",
                type: "FIXED",
                value: 20480
              }, {
                name: "numGlyphs",
                type: "USHORT",
                value: e
              }]);
            }
          },
              We = ["copyright", "fontFamily", "fontSubfamily", "uniqueID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "manufacturerURL", "designerURL", "license", "licenseURL", "reserved", "preferredFamily", "preferredSubfamily", "compatibleFullName", "sampleText", "postScriptFindFontName", "wwsFamily", "wwsSubfamily"],
              qe = {
            0: "en",
            1: "fr",
            2: "de",
            3: "it",
            4: "nl",
            5: "sv",
            6: "es",
            7: "da",
            8: "pt",
            9: "no",
            10: "he",
            11: "ja",
            12: "ar",
            13: "fi",
            14: "el",
            15: "is",
            16: "mt",
            17: "tr",
            18: "hr",
            19: "zh-Hant",
            20: "ur",
            21: "hi",
            22: "th",
            23: "ko",
            24: "lt",
            25: "pl",
            26: "hu",
            27: "es",
            28: "lv",
            29: "se",
            30: "fo",
            31: "fa",
            32: "ru",
            33: "zh",
            34: "nl-BE",
            35: "ga",
            36: "sq",
            37: "ro",
            38: "cz",
            39: "sk",
            40: "si",
            41: "yi",
            42: "sr",
            43: "mk",
            44: "bg",
            45: "uk",
            46: "be",
            47: "uz",
            48: "kk",
            49: "az-Cyrl",
            50: "az-Arab",
            51: "hy",
            52: "ka",
            53: "mo",
            54: "ky",
            55: "tg",
            56: "tk",
            57: "mn-CN",
            58: "mn",
            59: "ps",
            60: "ks",
            61: "ku",
            62: "sd",
            63: "bo",
            64: "ne",
            65: "sa",
            66: "mr",
            67: "bn",
            68: "as",
            69: "gu",
            70: "pa",
            71: "or",
            72: "ml",
            73: "kn",
            74: "ta",
            75: "te",
            76: "si",
            77: "my",
            78: "km",
            79: "lo",
            80: "vi",
            81: "id",
            82: "tl",
            83: "ms",
            84: "ms-Arab",
            85: "am",
            86: "ti",
            87: "om",
            88: "so",
            89: "sw",
            90: "rw",
            91: "rn",
            92: "ny",
            93: "mg",
            94: "eo",
            128: "cy",
            129: "eu",
            130: "ca",
            131: "la",
            132: "qu",
            133: "gn",
            134: "ay",
            135: "tt",
            136: "ug",
            137: "dz",
            138: "jv",
            139: "su",
            140: "gl",
            141: "af",
            142: "br",
            143: "iu",
            144: "gd",
            145: "gv",
            146: "ga",
            147: "to",
            148: "el-polyton",
            149: "kl",
            150: "az",
            151: "nn"
          },
              Xe = {
            0: 0,
            1: 0,
            2: 0,
            3: 0,
            4: 0,
            5: 0,
            6: 0,
            7: 0,
            8: 0,
            9: 0,
            10: 5,
            11: 1,
            12: 4,
            13: 0,
            14: 6,
            15: 0,
            16: 0,
            17: 0,
            18: 0,
            19: 2,
            20: 4,
            21: 9,
            22: 21,
            23: 3,
            24: 29,
            25: 29,
            26: 29,
            27: 29,
            28: 29,
            29: 0,
            30: 0,
            31: 4,
            32: 7,
            33: 25,
            34: 0,
            35: 0,
            36: 0,
            37: 0,
            38: 29,
            39: 29,
            40: 0,
            41: 5,
            42: 7,
            43: 7,
            44: 7,
            45: 7,
            46: 7,
            47: 7,
            48: 7,
            49: 7,
            50: 4,
            51: 24,
            52: 23,
            53: 7,
            54: 7,
            55: 7,
            56: 7,
            57: 27,
            58: 7,
            59: 4,
            60: 4,
            61: 4,
            62: 4,
            63: 26,
            64: 9,
            65: 9,
            66: 9,
            67: 13,
            68: 13,
            69: 11,
            70: 10,
            71: 12,
            72: 17,
            73: 16,
            74: 14,
            75: 15,
            76: 18,
            77: 19,
            78: 20,
            79: 22,
            80: 30,
            81: 0,
            82: 0,
            83: 0,
            84: 4,
            85: 28,
            86: 28,
            87: 28,
            88: 0,
            89: 0,
            90: 0,
            91: 0,
            92: 0,
            93: 0,
            94: 0,
            128: 0,
            129: 0,
            130: 0,
            131: 0,
            132: 0,
            133: 0,
            134: 0,
            135: 7,
            136: 4,
            137: 26,
            138: 0,
            139: 0,
            140: 0,
            141: 0,
            142: 0,
            143: 28,
            144: 0,
            145: 0,
            146: 0,
            147: 0,
            148: 6,
            149: 0,
            150: 0,
            151: 0
          },
              Ye = {
            1078: "af",
            1052: "sq",
            1156: "gsw",
            1118: "am",
            5121: "ar-DZ",
            15361: "ar-BH",
            3073: "ar",
            2049: "ar-IQ",
            11265: "ar-JO",
            13313: "ar-KW",
            12289: "ar-LB",
            4097: "ar-LY",
            6145: "ary",
            8193: "ar-OM",
            16385: "ar-QA",
            1025: "ar-SA",
            10241: "ar-SY",
            7169: "aeb",
            14337: "ar-AE",
            9217: "ar-YE",
            1067: "hy",
            1101: "as",
            2092: "az-Cyrl",
            1068: "az",
            1133: "ba",
            1069: "eu",
            1059: "be",
            2117: "bn",
            1093: "bn-IN",
            8218: "bs-Cyrl",
            5146: "bs",
            1150: "br",
            1026: "bg",
            1027: "ca",
            3076: "zh-HK",
            5124: "zh-MO",
            2052: "zh",
            4100: "zh-SG",
            1028: "zh-TW",
            1155: "co",
            1050: "hr",
            4122: "hr-BA",
            1029: "cs",
            1030: "da",
            1164: "prs",
            1125: "dv",
            2067: "nl-BE",
            1043: "nl",
            3081: "en-AU",
            10249: "en-BZ",
            4105: "en-CA",
            9225: "en-029",
            16393: "en-IN",
            6153: "en-IE",
            8201: "en-JM",
            17417: "en-MY",
            5129: "en-NZ",
            13321: "en-PH",
            18441: "en-SG",
            7177: "en-ZA",
            11273: "en-TT",
            2057: "en-GB",
            1033: "en",
            12297: "en-ZW",
            1061: "et",
            1080: "fo",
            1124: "fil",
            1035: "fi",
            2060: "fr-BE",
            3084: "fr-CA",
            1036: "fr",
            5132: "fr-LU",
            6156: "fr-MC",
            4108: "fr-CH",
            1122: "fy",
            1110: "gl",
            1079: "ka",
            3079: "de-AT",
            1031: "de",
            5127: "de-LI",
            4103: "de-LU",
            2055: "de-CH",
            1032: "el",
            1135: "kl",
            1095: "gu",
            1128: "ha",
            1037: "he",
            1081: "hi",
            1038: "hu",
            1039: "is",
            1136: "ig",
            1057: "id",
            1117: "iu",
            2141: "iu-Latn",
            2108: "ga",
            1076: "xh",
            1077: "zu",
            1040: "it",
            2064: "it-CH",
            1041: "ja",
            1099: "kn",
            1087: "kk",
            1107: "km",
            1158: "quc",
            1159: "rw",
            1089: "sw",
            1111: "kok",
            1042: "ko",
            1088: "ky",
            1108: "lo",
            1062: "lv",
            1063: "lt",
            2094: "dsb",
            1134: "lb",
            1071: "mk",
            2110: "ms-BN",
            1086: "ms",
            1100: "ml",
            1082: "mt",
            1153: "mi",
            1146: "arn",
            1102: "mr",
            1148: "moh",
            1104: "mn",
            2128: "mn-CN",
            1121: "ne",
            1044: "nb",
            2068: "nn",
            1154: "oc",
            1096: "or",
            1123: "ps",
            1045: "pl",
            1046: "pt",
            2070: "pt-PT",
            1094: "pa",
            1131: "qu-BO",
            2155: "qu-EC",
            3179: "qu",
            1048: "ro",
            1047: "rm",
            1049: "ru",
            9275: "smn",
            4155: "smj-NO",
            5179: "smj",
            3131: "se-FI",
            1083: "se",
            2107: "se-SE",
            8251: "sms",
            6203: "sma-NO",
            7227: "sms",
            1103: "sa",
            7194: "sr-Cyrl-BA",
            3098: "sr",
            6170: "sr-Latn-BA",
            2074: "sr-Latn",
            1132: "nso",
            1074: "tn",
            1115: "si",
            1051: "sk",
            1060: "sl",
            11274: "es-AR",
            16394: "es-BO",
            13322: "es-CL",
            9226: "es-CO",
            5130: "es-CR",
            7178: "es-DO",
            12298: "es-EC",
            17418: "es-SV",
            4106: "es-GT",
            18442: "es-HN",
            2058: "es-MX",
            19466: "es-NI",
            6154: "es-PA",
            15370: "es-PY",
            10250: "es-PE",
            20490: "es-PR",
            3082: "es",
            1034: "es",
            21514: "es-US",
            14346: "es-UY",
            8202: "es-VE",
            2077: "sv-FI",
            1053: "sv",
            1114: "syr",
            1064: "tg",
            2143: "tzm",
            1097: "ta",
            1092: "tt",
            1098: "te",
            1054: "th",
            1105: "bo",
            1055: "tr",
            1090: "tk",
            1152: "ug",
            1058: "uk",
            1070: "hsb",
            1056: "ur",
            2115: "uz-Cyrl",
            1091: "uz",
            1066: "vi",
            1106: "cy",
            1160: "wo",
            1157: "sah",
            1144: "ii",
            1130: "yo"
          };

          function Ze(e, t, r) {
            switch (e) {
              case 0:
                if (65535 === t) return "und";
                if (r) return r[t];
                break;

              case 1:
                return qe[t];

              case 3:
                return Ye[t];
            }
          }

          var Qe = "utf-16",
              Ke = {
            0: "macintosh",
            1: "x-mac-japanese",
            2: "x-mac-chinesetrad",
            3: "x-mac-korean",
            6: "x-mac-greek",
            7: "x-mac-cyrillic",
            9: "x-mac-devanagai",
            10: "x-mac-gurmukhi",
            11: "x-mac-gujarati",
            12: "x-mac-oriya",
            13: "x-mac-bengali",
            14: "x-mac-tamil",
            15: "x-mac-telugu",
            16: "x-mac-kannada",
            17: "x-mac-malayalam",
            18: "x-mac-sinhalese",
            19: "x-mac-burmese",
            20: "x-mac-khmer",
            21: "x-mac-thai",
            22: "x-mac-lao",
            23: "x-mac-georgian",
            24: "x-mac-armenian",
            25: "x-mac-chinesesimp",
            26: "x-mac-tibetan",
            27: "x-mac-mongolian",
            28: "x-mac-ethiopic",
            29: "x-mac-ce",
            30: "x-mac-vietnamese",
            31: "x-mac-extarabic"
          },
              Je = {
            15: "x-mac-icelandic",
            17: "x-mac-turkish",
            18: "x-mac-croatian",
            24: "x-mac-ce",
            25: "x-mac-ce",
            26: "x-mac-ce",
            27: "x-mac-ce",
            28: "x-mac-ce",
            30: "x-mac-icelandic",
            37: "x-mac-romanian",
            38: "x-mac-ce",
            39: "x-mac-ce",
            40: "x-mac-ce",
            143: "x-mac-inuit",
            146: "x-mac-gaelic"
          };

          function $e(e, t, r) {
            switch (e) {
              case 0:
                return Qe;

              case 1:
                return Je[r] || Ke[t];

              case 3:
                if (1 === t || 10 === t) return Qe;
            }
          }

          function et(e) {
            var t = {};

            for (var r in e) t[e[r]] = parseInt(r);

            return t;
          }

          function tt(e, t, r, i, n, a) {
            return new $.Record("NameRecord", [{
              name: "platformID",
              type: "USHORT",
              value: e
            }, {
              name: "encodingID",
              type: "USHORT",
              value: t
            }, {
              name: "languageID",
              type: "USHORT",
              value: r
            }, {
              name: "nameID",
              type: "USHORT",
              value: i
            }, {
              name: "length",
              type: "USHORT",
              value: n
            }, {
              name: "offset",
              type: "USHORT",
              value: a
            }]);
          }

          function rt(e, t) {
            var r = function (e, t) {
              var r = e.length,
                  i = t.length - r + 1;

              e: for (var n = 0; n < i; n++) for (; n < i; n++) {
                for (var a = 0; a < r; a++) if (t[n + a] !== e[a]) continue e;

                return n;
              }

              return -1;
            }(e, t);

            if (r < 0) {
              r = t.length;

              for (var i = 0, n = e.length; i < n; ++i) t.push(e[i]);
            }

            return r;
          }

          var it = {
            parse: function (e, t, r) {
              for (var i = {}, n = new se.Parser(e, t), a = n.parseUShort(), o = n.parseUShort(), s = n.offset + n.parseUShort(), l = 0; l < o; l++) {
                var u = n.parseUShort(),
                    h = n.parseUShort(),
                    c = n.parseUShort(),
                    f = n.parseUShort(),
                    d = We[f] || f,
                    p = n.parseUShort(),
                    m = n.parseUShort(),
                    v = Ze(u, c, r),
                    y = $e(u, h, c);

                if (void 0 !== y && void 0 !== v) {
                  var g = void 0;

                  if (g = y === Qe ? D.UTF16(e, s + m, p) : D.MACSTRING(e, s + m, p, y)) {
                    var b = i[d];
                    void 0 === b && (b = i[d] = {}), b[v] = g;
                  }
                }
              }

              return 1 === a && n.parseUShort(), i;
            },
            make: function (e, t) {
              var r,
                  i = [],
                  n = {},
                  a = et(We);

              for (var o in e) {
                var s = a[o];
                if (void 0 === s && (s = o), r = parseInt(s), isNaN(r)) throw new Error('Name table entry "' + o + '" does not exist, see nameTableNames for complete list.');
                n[r] = e[o], i.push(r);
              }

              for (var l = et(qe), u = et(Ye), h = [], c = [], f = 0; f < i.length; f++) {
                var d = n[r = i[f]];

                for (var p in d) {
                  var m = d[p],
                      v = 1,
                      y = l[p],
                      g = Xe[y],
                      b = $e(v, g, y),
                      _ = k.MACSTRING(m, b);

                  void 0 === _ && (v = 0, (y = t.indexOf(p)) < 0 && (y = t.length, t.push(p)), g = 4, _ = k.UTF16(m));
                  var x = rt(_, c);
                  h.push(tt(v, g, y, r, _.length, x));
                  var w = u[p];

                  if (void 0 !== w) {
                    var S = k.UTF16(m),
                        M = rt(S, c);
                    h.push(tt(3, 1, w, r, S.length, M));
                  }
                }
              }

              h.sort(function (e, t) {
                return e.platformID - t.platformID || e.encodingID - t.encodingID || e.languageID - t.languageID || e.nameID - t.nameID;
              });

              for (var T = new $.Table("name", [{
                name: "format",
                type: "USHORT",
                value: 0
              }, {
                name: "count",
                type: "USHORT",
                value: h.length
              }, {
                name: "stringOffset",
                type: "USHORT",
                value: 6 + 12 * h.length
              }]), E = 0; E < h.length; E++) T.fields.push({
                name: "record_" + E,
                type: "RECORD",
                value: h[E]
              });

              return T.fields.push({
                name: "strings",
                type: "LITERAL",
                value: c
              }), T;
            }
          },
              nt = [{
            begin: 0,
            end: 127
          }, {
            begin: 128,
            end: 255
          }, {
            begin: 256,
            end: 383
          }, {
            begin: 384,
            end: 591
          }, {
            begin: 592,
            end: 687
          }, {
            begin: 688,
            end: 767
          }, {
            begin: 768,
            end: 879
          }, {
            begin: 880,
            end: 1023
          }, {
            begin: 11392,
            end: 11519
          }, {
            begin: 1024,
            end: 1279
          }, {
            begin: 1328,
            end: 1423
          }, {
            begin: 1424,
            end: 1535
          }, {
            begin: 42240,
            end: 42559
          }, {
            begin: 1536,
            end: 1791
          }, {
            begin: 1984,
            end: 2047
          }, {
            begin: 2304,
            end: 2431
          }, {
            begin: 2432,
            end: 2559
          }, {
            begin: 2560,
            end: 2687
          }, {
            begin: 2688,
            end: 2815
          }, {
            begin: 2816,
            end: 2943
          }, {
            begin: 2944,
            end: 3071
          }, {
            begin: 3072,
            end: 3199
          }, {
            begin: 3200,
            end: 3327
          }, {
            begin: 3328,
            end: 3455
          }, {
            begin: 3584,
            end: 3711
          }, {
            begin: 3712,
            end: 3839
          }, {
            begin: 4256,
            end: 4351
          }, {
            begin: 6912,
            end: 7039
          }, {
            begin: 4352,
            end: 4607
          }, {
            begin: 7680,
            end: 7935
          }, {
            begin: 7936,
            end: 8191
          }, {
            begin: 8192,
            end: 8303
          }, {
            begin: 8304,
            end: 8351
          }, {
            begin: 8352,
            end: 8399
          }, {
            begin: 8400,
            end: 8447
          }, {
            begin: 8448,
            end: 8527
          }, {
            begin: 8528,
            end: 8591
          }, {
            begin: 8592,
            end: 8703
          }, {
            begin: 8704,
            end: 8959
          }, {
            begin: 8960,
            end: 9215
          }, {
            begin: 9216,
            end: 9279
          }, {
            begin: 9280,
            end: 9311
          }, {
            begin: 9312,
            end: 9471
          }, {
            begin: 9472,
            end: 9599
          }, {
            begin: 9600,
            end: 9631
          }, {
            begin: 9632,
            end: 9727
          }, {
            begin: 9728,
            end: 9983
          }, {
            begin: 9984,
            end: 10175
          }, {
            begin: 12288,
            end: 12351
          }, {
            begin: 12352,
            end: 12447
          }, {
            begin: 12448,
            end: 12543
          }, {
            begin: 12544,
            end: 12591
          }, {
            begin: 12592,
            end: 12687
          }, {
            begin: 43072,
            end: 43135
          }, {
            begin: 12800,
            end: 13055
          }, {
            begin: 13056,
            end: 13311
          }, {
            begin: 44032,
            end: 55215
          }, {
            begin: 55296,
            end: 57343
          }, {
            begin: 67840,
            end: 67871
          }, {
            begin: 19968,
            end: 40959
          }, {
            begin: 57344,
            end: 63743
          }, {
            begin: 12736,
            end: 12783
          }, {
            begin: 64256,
            end: 64335
          }, {
            begin: 64336,
            end: 65023
          }, {
            begin: 65056,
            end: 65071
          }, {
            begin: 65040,
            end: 65055
          }, {
            begin: 65104,
            end: 65135
          }, {
            begin: 65136,
            end: 65279
          }, {
            begin: 65280,
            end: 65519
          }, {
            begin: 65520,
            end: 65535
          }, {
            begin: 3840,
            end: 4095
          }, {
            begin: 1792,
            end: 1871
          }, {
            begin: 1920,
            end: 1983
          }, {
            begin: 3456,
            end: 3583
          }, {
            begin: 4096,
            end: 4255
          }, {
            begin: 4608,
            end: 4991
          }, {
            begin: 5024,
            end: 5119
          }, {
            begin: 5120,
            end: 5759
          }, {
            begin: 5760,
            end: 5791
          }, {
            begin: 5792,
            end: 5887
          }, {
            begin: 6016,
            end: 6143
          }, {
            begin: 6144,
            end: 6319
          }, {
            begin: 10240,
            end: 10495
          }, {
            begin: 40960,
            end: 42127
          }, {
            begin: 5888,
            end: 5919
          }, {
            begin: 66304,
            end: 66351
          }, {
            begin: 66352,
            end: 66383
          }, {
            begin: 66560,
            end: 66639
          }, {
            begin: 118784,
            end: 119039
          }, {
            begin: 119808,
            end: 120831
          }, {
            begin: 1044480,
            end: 1048573
          }, {
            begin: 65024,
            end: 65039
          }, {
            begin: 917504,
            end: 917631
          }, {
            begin: 6400,
            end: 6479
          }, {
            begin: 6480,
            end: 6527
          }, {
            begin: 6528,
            end: 6623
          }, {
            begin: 6656,
            end: 6687
          }, {
            begin: 11264,
            end: 11359
          }, {
            begin: 11568,
            end: 11647
          }, {
            begin: 19904,
            end: 19967
          }, {
            begin: 43008,
            end: 43055
          }, {
            begin: 65536,
            end: 65663
          }, {
            begin: 65856,
            end: 65935
          }, {
            begin: 66432,
            end: 66463
          }, {
            begin: 66464,
            end: 66527
          }, {
            begin: 66640,
            end: 66687
          }, {
            begin: 66688,
            end: 66735
          }, {
            begin: 67584,
            end: 67647
          }, {
            begin: 68096,
            end: 68191
          }, {
            begin: 119552,
            end: 119647
          }, {
            begin: 73728,
            end: 74751
          }, {
            begin: 119648,
            end: 119679
          }, {
            begin: 7040,
            end: 7103
          }, {
            begin: 7168,
            end: 7247
          }, {
            begin: 7248,
            end: 7295
          }, {
            begin: 43136,
            end: 43231
          }, {
            begin: 43264,
            end: 43311
          }, {
            begin: 43312,
            end: 43359
          }, {
            begin: 43520,
            end: 43615
          }, {
            begin: 65936,
            end: 65999
          }, {
            begin: 66e3,
            end: 66047
          }, {
            begin: 66208,
            end: 66271
          }, {
            begin: 127024,
            end: 127135
          }];
          var at = {
            parse: function (e, t) {
              var r = {},
                  i = new se.Parser(e, t);
              r.version = i.parseUShort(), r.xAvgCharWidth = i.parseShort(), r.usWeightClass = i.parseUShort(), r.usWidthClass = i.parseUShort(), r.fsType = i.parseUShort(), r.ySubscriptXSize = i.parseShort(), r.ySubscriptYSize = i.parseShort(), r.ySubscriptXOffset = i.parseShort(), r.ySubscriptYOffset = i.parseShort(), r.ySuperscriptXSize = i.parseShort(), r.ySuperscriptYSize = i.parseShort(), r.ySuperscriptXOffset = i.parseShort(), r.ySuperscriptYOffset = i.parseShort(), r.yStrikeoutSize = i.parseShort(), r.yStrikeoutPosition = i.parseShort(), r.sFamilyClass = i.parseShort(), r.panose = [];

              for (var n = 0; n < 10; n++) r.panose[n] = i.parseByte();

              return r.ulUnicodeRange1 = i.parseULong(), r.ulUnicodeRange2 = i.parseULong(), r.ulUnicodeRange3 = i.parseULong(), r.ulUnicodeRange4 = i.parseULong(), r.achVendID = String.fromCharCode(i.parseByte(), i.parseByte(), i.parseByte(), i.parseByte()), r.fsSelection = i.parseUShort(), r.usFirstCharIndex = i.parseUShort(), r.usLastCharIndex = i.parseUShort(), r.sTypoAscender = i.parseShort(), r.sTypoDescender = i.parseShort(), r.sTypoLineGap = i.parseShort(), r.usWinAscent = i.parseUShort(), r.usWinDescent = i.parseUShort(), 1 <= r.version && (r.ulCodePageRange1 = i.parseULong(), r.ulCodePageRange2 = i.parseULong()), 2 <= r.version && (r.sxHeight = i.parseShort(), r.sCapHeight = i.parseShort(), r.usDefaultChar = i.parseUShort(), r.usBreakChar = i.parseUShort(), r.usMaxContent = i.parseUShort()), r;
            },
            make: function (e) {
              return new $.Table("OS/2", [{
                name: "version",
                type: "USHORT",
                value: 3
              }, {
                name: "xAvgCharWidth",
                type: "SHORT",
                value: 0
              }, {
                name: "usWeightClass",
                type: "USHORT",
                value: 0
              }, {
                name: "usWidthClass",
                type: "USHORT",
                value: 0
              }, {
                name: "fsType",
                type: "USHORT",
                value: 0
              }, {
                name: "ySubscriptXSize",
                type: "SHORT",
                value: 650
              }, {
                name: "ySubscriptYSize",
                type: "SHORT",
                value: 699
              }, {
                name: "ySubscriptXOffset",
                type: "SHORT",
                value: 0
              }, {
                name: "ySubscriptYOffset",
                type: "SHORT",
                value: 140
              }, {
                name: "ySuperscriptXSize",
                type: "SHORT",
                value: 650
              }, {
                name: "ySuperscriptYSize",
                type: "SHORT",
                value: 699
              }, {
                name: "ySuperscriptXOffset",
                type: "SHORT",
                value: 0
              }, {
                name: "ySuperscriptYOffset",
                type: "SHORT",
                value: 479
              }, {
                name: "yStrikeoutSize",
                type: "SHORT",
                value: 49
              }, {
                name: "yStrikeoutPosition",
                type: "SHORT",
                value: 258
              }, {
                name: "sFamilyClass",
                type: "SHORT",
                value: 0
              }, {
                name: "bFamilyType",
                type: "BYTE",
                value: 0
              }, {
                name: "bSerifStyle",
                type: "BYTE",
                value: 0
              }, {
                name: "bWeight",
                type: "BYTE",
                value: 0
              }, {
                name: "bProportion",
                type: "BYTE",
                value: 0
              }, {
                name: "bContrast",
                type: "BYTE",
                value: 0
              }, {
                name: "bStrokeVariation",
                type: "BYTE",
                value: 0
              }, {
                name: "bArmStyle",
                type: "BYTE",
                value: 0
              }, {
                name: "bLetterform",
                type: "BYTE",
                value: 0
              }, {
                name: "bMidline",
                type: "BYTE",
                value: 0
              }, {
                name: "bXHeight",
                type: "BYTE",
                value: 0
              }, {
                name: "ulUnicodeRange1",
                type: "ULONG",
                value: 0
              }, {
                name: "ulUnicodeRange2",
                type: "ULONG",
                value: 0
              }, {
                name: "ulUnicodeRange3",
                type: "ULONG",
                value: 0
              }, {
                name: "ulUnicodeRange4",
                type: "ULONG",
                value: 0
              }, {
                name: "achVendID",
                type: "CHARARRAY",
                value: "XXXX"
              }, {
                name: "fsSelection",
                type: "USHORT",
                value: 0
              }, {
                name: "usFirstCharIndex",
                type: "USHORT",
                value: 0
              }, {
                name: "usLastCharIndex",
                type: "USHORT",
                value: 0
              }, {
                name: "sTypoAscender",
                type: "SHORT",
                value: 0
              }, {
                name: "sTypoDescender",
                type: "SHORT",
                value: 0
              }, {
                name: "sTypoLineGap",
                type: "SHORT",
                value: 0
              }, {
                name: "usWinAscent",
                type: "USHORT",
                value: 0
              }, {
                name: "usWinDescent",
                type: "USHORT",
                value: 0
              }, {
                name: "ulCodePageRange1",
                type: "ULONG",
                value: 0
              }, {
                name: "ulCodePageRange2",
                type: "ULONG",
                value: 0
              }, {
                name: "sxHeight",
                type: "SHORT",
                value: 0
              }, {
                name: "sCapHeight",
                type: "SHORT",
                value: 0
              }, {
                name: "usDefaultChar",
                type: "USHORT",
                value: 0
              }, {
                name: "usBreakChar",
                type: "USHORT",
                value: 0
              }, {
                name: "usMaxContext",
                type: "USHORT",
                value: 0
              }], e);
            },
            unicodeRanges: nt,
            getUnicodeRange: function (e) {
              for (var t = 0; t < nt.length; t += 1) {
                var r = nt[t];
                if (e >= r.begin && e < r.end) return t;
              }

              return -1;
            }
          };
          var ot = {
            parse: function (e, t) {
              var r = {},
                  i = new se.Parser(e, t);

              switch (r.version = i.parseVersion(), r.italicAngle = i.parseFixed(), r.underlinePosition = i.parseShort(), r.underlineThickness = i.parseShort(), r.isFixedPitch = i.parseULong(), r.minMemType42 = i.parseULong(), r.maxMemType42 = i.parseULong(), r.minMemType1 = i.parseULong(), r.maxMemType1 = i.parseULong(), r.version) {
                case 1:
                  r.names = fe.slice();
                  break;

                case 2:
                  r.numberOfGlyphs = i.parseUShort(), r.glyphNameIndex = new Array(r.numberOfGlyphs);

                  for (var n = 0; n < r.numberOfGlyphs; n++) r.glyphNameIndex[n] = i.parseUShort();

                  r.names = [];

                  for (var a = 0; a < r.numberOfGlyphs; a++) if (r.glyphNameIndex[a] >= fe.length) {
                    var o = i.parseChar();
                    r.names.push(i.parseString(o));
                  }

                  break;

                case 2.5:
                  r.numberOfGlyphs = i.parseUShort(), r.offset = new Array(r.numberOfGlyphs);

                  for (var s = 0; s < r.numberOfGlyphs; s++) r.offset[s] = i.parseChar();

              }

              return r;
            },
            make: function () {
              return new $.Table("post", [{
                name: "version",
                type: "FIXED",
                value: 196608
              }, {
                name: "italicAngle",
                type: "FIXED",
                value: 0
              }, {
                name: "underlinePosition",
                type: "FWORD",
                value: 0
              }, {
                name: "underlineThickness",
                type: "FWORD",
                value: 0
              }, {
                name: "isFixedPitch",
                type: "ULONG",
                value: 0
              }, {
                name: "minMemType42",
                type: "ULONG",
                value: 0
              }, {
                name: "maxMemType42",
                type: "ULONG",
                value: 0
              }, {
                name: "minMemType1",
                type: "ULONG",
                value: 0
              }, {
                name: "maxMemType1",
                type: "ULONG",
                value: 0
              }]);
            }
          },
              st = new Array(9);
          st[1] = function () {
            var e = this.offset + this.relativeOffset,
                t = this.parseUShort();
            return 1 === t ? {
              substFormat: 1,
              coverage: this.parsePointer(ae.coverage),
              deltaGlyphId: this.parseUShort()
            } : 2 === t ? {
              substFormat: 2,
              coverage: this.parsePointer(ae.coverage),
              substitute: this.parseOffset16List()
            } : void P.assert(!1, "0x" + e.toString(16) + ": lookup type 1 format must be 1 or 2.");
          }, st[2] = function () {
            var e = this.parseUShort();
            return P.argument(1 === e, "GSUB Multiple Substitution Subtable identifier-format must be 1"), {
              substFormat: e,
              coverage: this.parsePointer(ae.coverage),
              sequences: this.parseListOfLists()
            };
          }, st[3] = function () {
            var e = this.parseUShort();
            return P.argument(1 === e, "GSUB Alternate Substitution Subtable identifier-format must be 1"), {
              substFormat: e,
              coverage: this.parsePointer(ae.coverage),
              alternateSets: this.parseListOfLists()
            };
          }, st[4] = function () {
            var e = this.parseUShort();
            return P.argument(1 === e, "GSUB ligature table identifier-format must be 1"), {
              substFormat: e,
              coverage: this.parsePointer(ae.coverage),
              ligatureSets: this.parseListOfLists(function () {
                return {
                  ligGlyph: this.parseUShort(),
                  components: this.parseUShortList(this.parseUShort() - 1)
                };
              })
            };
          };
          var lt = {
            sequenceIndex: ae.uShort,
            lookupListIndex: ae.uShort
          };
          st[5] = function () {
            var e = this.offset + this.relativeOffset,
                t = this.parseUShort();
            if (1 === t) return {
              substFormat: t,
              coverage: this.parsePointer(ae.coverage),
              ruleSets: this.parseListOfLists(function () {
                var e = this.parseUShort(),
                    t = this.parseUShort();
                return {
                  input: this.parseUShortList(e - 1),
                  lookupRecords: this.parseRecordList(t, lt)
                };
              })
            };
            if (2 === t) return {
              substFormat: t,
              coverage: this.parsePointer(ae.coverage),
              classDef: this.parsePointer(ae.classDef),
              classSets: this.parseListOfLists(function () {
                var e = this.parseUShort(),
                    t = this.parseUShort();
                return {
                  classes: this.parseUShortList(e - 1),
                  lookupRecords: this.parseRecordList(t, lt)
                };
              })
            };

            if (3 === t) {
              var r = this.parseUShort(),
                  i = this.parseUShort();
              return {
                substFormat: t,
                coverages: this.parseList(r, ae.pointer(ae.coverage)),
                lookupRecords: this.parseRecordList(i, lt)
              };
            }

            P.assert(!1, "0x" + e.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
          }, st[6] = function () {
            var e = this.offset + this.relativeOffset,
                t = this.parseUShort();
            return 1 === t ? {
              substFormat: 1,
              coverage: this.parsePointer(ae.coverage),
              chainRuleSets: this.parseListOfLists(function () {
                return {
                  backtrack: this.parseUShortList(),
                  input: this.parseUShortList(this.parseShort() - 1),
                  lookahead: this.parseUShortList(),
                  lookupRecords: this.parseRecordList(lt)
                };
              })
            } : 2 === t ? {
              substFormat: 2,
              coverage: this.parsePointer(ae.coverage),
              backtrackClassDef: this.parsePointer(ae.classDef),
              inputClassDef: this.parsePointer(ae.classDef),
              lookaheadClassDef: this.parsePointer(ae.classDef),
              chainClassSet: this.parseListOfLists(function () {
                return {
                  backtrack: this.parseUShortList(),
                  input: this.parseUShortList(this.parseShort() - 1),
                  lookahead: this.parseUShortList(),
                  lookupRecords: this.parseRecordList(lt)
                };
              })
            } : 3 === t ? {
              substFormat: 3,
              backtrackCoverage: this.parseList(ae.pointer(ae.coverage)),
              inputCoverage: this.parseList(ae.pointer(ae.coverage)),
              lookaheadCoverage: this.parseList(ae.pointer(ae.coverage)),
              lookupRecords: this.parseRecordList(lt)
            } : void P.assert(!1, "0x" + e.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
          }, st[7] = function () {
            var e = this.parseUShort();
            P.argument(1 === e, "GSUB Extension Substitution subtable identifier-format must be 1");
            var t = this.parseUShort(),
                r = new ae(this.data, this.offset + this.parseULong());
            return {
              substFormat: 1,
              lookupType: t,
              extension: st[t].call(r)
            };
          }, st[8] = function () {
            var e = this.parseUShort();
            return P.argument(1 === e, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"), {
              substFormat: e,
              coverage: this.parsePointer(ae.coverage),
              backtrackCoverage: this.parseList(ae.pointer(ae.coverage)),
              lookaheadCoverage: this.parseList(ae.pointer(ae.coverage)),
              substitutes: this.parseUShortList()
            };
          };
          var ut = new Array(9);
          ut[1] = function (e) {
            return 1 === e.substFormat ? new $.Table("substitutionTable", [{
              name: "substFormat",
              type: "USHORT",
              value: 1
            }, {
              name: "coverage",
              type: "TABLE",
              value: new $.Coverage(e.coverage)
            }, {
              name: "deltaGlyphID",
              type: "USHORT",
              value: e.deltaGlyphId
            }]) : new $.Table("substitutionTable", [{
              name: "substFormat",
              type: "USHORT",
              value: 2
            }, {
              name: "coverage",
              type: "TABLE",
              value: new $.Coverage(e.coverage)
            }].concat($.ushortList("substitute", e.substitute)));
          }, ut[3] = function (e) {
            return P.assert(1 === e.substFormat, "Lookup type 3 substFormat must be 1."), new $.Table("substitutionTable", [{
              name: "substFormat",
              type: "USHORT",
              value: 1
            }, {
              name: "coverage",
              type: "TABLE",
              value: new $.Coverage(e.coverage)
            }].concat($.tableList("altSet", e.alternateSets, function (e) {
              return new $.Table("alternateSetTable", $.ushortList("alternate", e));
            })));
          }, ut[4] = function (e) {
            return P.assert(1 === e.substFormat, "Lookup type 4 substFormat must be 1."), new $.Table("substitutionTable", [{
              name: "substFormat",
              type: "USHORT",
              value: 1
            }, {
              name: "coverage",
              type: "TABLE",
              value: new $.Coverage(e.coverage)
            }].concat($.tableList("ligSet", e.ligatureSets, function (e) {
              return new $.Table("ligatureSetTable", $.tableList("ligature", e, function (e) {
                return new $.Table("ligatureTable", [{
                  name: "ligGlyph",
                  type: "USHORT",
                  value: e.ligGlyph
                }].concat($.ushortList("component", e.components, e.components.length + 1)));
              }));
            })));
          };
          var ht = {
            parse: function (e, t) {
              var r = new ae(e, t = t || 0),
                  i = r.parseVersion(1);
              return P.argument(1 === i || 1.1 === i, "Unsupported GSUB table version."), 1 === i ? {
                version: i,
                scripts: r.parseScriptList(),
                features: r.parseFeatureList(),
                lookups: r.parseLookupList(st)
              } : {
                version: i,
                scripts: r.parseScriptList(),
                features: r.parseFeatureList(),
                lookups: r.parseLookupList(st),
                variations: r.parseFeatureVariationsList()
              };
            },
            make: function (e) {
              return new $.Table("GSUB", [{
                name: "version",
                type: "ULONG",
                value: 65536
              }, {
                name: "scripts",
                type: "TABLE",
                value: new $.ScriptList(e.scripts)
              }, {
                name: "features",
                type: "TABLE",
                value: new $.FeatureList(e.features)
              }, {
                name: "lookups",
                type: "TABLE",
                value: new $.LookupList(e.lookups, ut)
              }]);
            }
          };
          var ct = {
            parse: function (e, t) {
              var r = new se.Parser(e, t),
                  i = r.parseULong();
              P.argument(1 === i, "Unsupported META table version."), r.parseULong(), r.parseULong();

              for (var n = r.parseULong(), a = {}, o = 0; o < n; o++) {
                var s = r.parseTag(),
                    l = r.parseULong(),
                    u = r.parseULong(),
                    h = D.UTF8(e, t + l, u);
                a[s] = h;
              }

              return a;
            },
            make: function (e) {
              var t = Object.keys(e).length,
                  r = "",
                  i = 16 + 12 * t,
                  n = new $.Table("meta", [{
                name: "version",
                type: "ULONG",
                value: 1
              }, {
                name: "flags",
                type: "ULONG",
                value: 0
              }, {
                name: "offset",
                type: "ULONG",
                value: i
              }, {
                name: "numTags",
                type: "ULONG",
                value: t
              }]);

              for (var a in e) {
                var o = r.length;
                r += e[a], n.fields.push({
                  name: "tag " + a,
                  type: "TAG",
                  value: a
                }), n.fields.push({
                  name: "offset " + a,
                  type: "ULONG",
                  value: i + o
                }), n.fields.push({
                  name: "length " + a,
                  type: "ULONG",
                  value: e[a].length
                });
              }

              return n.fields.push({
                name: "stringPool",
                type: "CHARARRAY",
                value: r
              }), n;
            }
          };

          function ft(e) {
            return Math.log(e) / Math.log(2) | 0;
          }

          function dt(e) {
            for (; e.length % 4 != 0;) e.push(0);

            for (var t = 0, r = 0; r < e.length; r += 4) t += (e[r] << 24) + (e[r + 1] << 16) + (e[r + 2] << 8) + e[r + 3];

            return t %= Math.pow(2, 32);
          }

          function pt(e, t, r, i) {
            return new $.Record("Table Record", [{
              name: "tag",
              type: "TAG",
              value: void 0 !== e ? e : ""
            }, {
              name: "checkSum",
              type: "ULONG",
              value: void 0 !== t ? t : 0
            }, {
              name: "offset",
              type: "ULONG",
              value: void 0 !== r ? r : 0
            }, {
              name: "length",
              type: "ULONG",
              value: void 0 !== i ? i : 0
            }]);
          }

          function mt(e) {
            var t = new $.Table("sfnt", [{
              name: "version",
              type: "TAG",
              value: "OTTO"
            }, {
              name: "numTables",
              type: "USHORT",
              value: 0
            }, {
              name: "searchRange",
              type: "USHORT",
              value: 0
            }, {
              name: "entrySelector",
              type: "USHORT",
              value: 0
            }, {
              name: "rangeShift",
              type: "USHORT",
              value: 0
            }]);
            t.tables = e, t.numTables = e.length;
            var r = Math.pow(2, ft(t.numTables));
            t.searchRange = 16 * r, t.entrySelector = ft(r), t.rangeShift = 16 * t.numTables - t.searchRange;

            for (var i = [], n = [], a = t.sizeOf() + pt().sizeOf() * t.numTables; a % 4 != 0;) a += 1, n.push({
              name: "padding",
              type: "BYTE",
              value: 0
            });

            for (var o = 0; o < e.length; o += 1) {
              var s = e[o];
              P.argument(4 === s.tableName.length, "Table name" + s.tableName + " is invalid.");
              var l = s.sizeOf(),
                  u = pt(s.tableName, dt(s.encode()), a, l);

              for (i.push({
                name: u.tag + " Table Record",
                type: "RECORD",
                value: u
              }), n.push({
                name: s.tableName + " table",
                type: "RECORD",
                value: s
              }), a += l, P.argument(!isNaN(a), "Something went wrong calculating the offset."); a % 4 != 0;) a += 1, n.push({
                name: "padding",
                type: "BYTE",
                value: 0
              });
            }

            return i.sort(function (e, t) {
              return e.value.tag > t.value.tag ? 1 : -1;
            }), t.fields = t.fields.concat(i), t.fields = t.fields.concat(n), t;
          }

          function vt(e, t, r) {
            for (var i = 0; i < t.length; i += 1) {
              var n = e.charToGlyphIndex(t[i]);
              if (0 < n) return e.glyphs.get(n).getMetrics();
            }

            return r;
          }

          var yt = {
            make: mt,
            fontToTable: function (e) {
              for (var t, r = [], i = [], n = [], a = [], o = [], s = [], l = [], u = 0, h = 0, c = 0, f = 0, d = 0, p = 0; p < e.glyphs.length; p += 1) {
                var m = e.glyphs.get(p),
                    v = 0 | m.unicode;
                if (isNaN(m.advanceWidth)) throw new Error("Glyph " + m.name + " (" + p + "): advanceWidth is not a number.");
                (v < t || void 0 === t) && 0 < v && (t = v), u < v && (u = v);
                var y = at.getUnicodeRange(v);
                if (y < 32) h |= 1 << y;else if (y < 64) c |= 1 << y - 32;else if (y < 96) f |= 1 << y - 64;else {
                  if (!(y < 123)) throw new Error("Unicode ranges bits > 123 are reserved for internal usage");
                  d |= 1 << y - 96;
                }

                if (".notdef" !== m.name) {
                  var g = m.getMetrics();
                  r.push(g.xMin), i.push(g.yMin), n.push(g.xMax), a.push(g.yMax), s.push(g.leftSideBearing), l.push(g.rightSideBearing), o.push(m.advanceWidth);
                }
              }

              var b = {
                xMin: Math.min.apply(null, r),
                yMin: Math.min.apply(null, i),
                xMax: Math.max.apply(null, n),
                yMax: Math.max.apply(null, a),
                advanceWidthMax: Math.max.apply(null, o),
                advanceWidthAvg: function (e) {
                  for (var t = 0, r = 0; r < e.length; r += 1) t += e[r];

                  return t / e.length;
                }(o),
                minLeftSideBearing: Math.min.apply(null, s),
                maxLeftSideBearing: Math.max.apply(null, s),
                minRightSideBearing: Math.min.apply(null, l)
              };
              b.ascender = e.ascender, b.descender = e.descender;

              var _ = Ge.make({
                flags: 3,
                unitsPerEm: e.unitsPerEm,
                xMin: b.xMin,
                yMin: b.yMin,
                xMax: b.xMax,
                yMax: b.yMax,
                lowestRecPPEM: 3,
                createdTimestamp: e.createdTimestamp
              }),
                  x = je.make({
                ascender: b.ascender,
                descender: b.descender,
                advanceWidthMax: b.advanceWidthMax,
                minLeftSideBearing: b.minLeftSideBearing,
                minRightSideBearing: b.minRightSideBearing,
                xMaxExtent: b.maxLeftSideBearing + (b.xMax - b.xMin),
                numberOfHMetrics: e.glyphs.length
              }),
                  w = He.make(e.glyphs.length),
                  S = at.make({
                xAvgCharWidth: Math.round(b.advanceWidthAvg),
                usWeightClass: e.tables.os2.usWeightClass,
                usWidthClass: e.tables.os2.usWidthClass,
                usFirstCharIndex: t,
                usLastCharIndex: u,
                ulUnicodeRange1: h,
                ulUnicodeRange2: c,
                ulUnicodeRange3: f,
                ulUnicodeRange4: d,
                fsSelection: e.tables.os2.fsSelection,
                sTypoAscender: b.ascender,
                sTypoDescender: b.descender,
                sTypoLineGap: 0,
                usWinAscent: b.yMax,
                usWinDescent: Math.abs(b.yMin),
                ulCodePageRange1: 1,
                sxHeight: vt(e, "xyvw", {
                  yMax: Math.round(b.ascender / 2)
                }).yMax,
                sCapHeight: vt(e, "HIKLEFJMNTZBDPRAGOQSUVWXY", b).yMax,
                usDefaultChar: e.hasChar(" ") ? 32 : 0,
                usBreakChar: e.hasChar(" ") ? 32 : 0
              }),
                  M = Ve.make(e.glyphs),
                  T = le.make(e.glyphs),
                  E = e.getEnglishName("fontFamily"),
                  C = e.getEnglishName("fontSubfamily"),
                  L = E + " " + C,
                  O = e.getEnglishName("postScriptName");

              O = O || E.replace(/\s/g, "") + "-" + C;
              var P = {};

              for (var R in e.names) P[R] = e.names[R];

              P.uniqueID || (P.uniqueID = {
                en: e.getEnglishName("manufacturer") + ":" + L
              }), P.postScriptName || (P.postScriptName = {
                en: O
              }), P.preferredFamily || (P.preferredFamily = e.names.fontFamily), P.preferredSubfamily || (P.preferredSubfamily = e.names.fontSubfamily);
              var D = [],
                  k = it.make(P, D),
                  A = 0 < D.length ? ze.make(D) : void 0,
                  I = ot.make(),
                  U = Be.make(e.glyphs, {
                version: e.getEnglishName("version"),
                fullName: L,
                familyName: E,
                weightName: C,
                postScriptName: O,
                unitsPerEm: e.unitsPerEm,
                fontBBox: [0, b.yMin, b.ascender, b.advanceWidthMax]
              }),
                  N = e.metas && 0 < Object.keys(e.metas).length ? ct.make(e.metas) : void 0,
                  F = [_, x, w, S, k, T, I, U, M];
              A && F.push(A), e.tables.gsub && F.push(ht.make(e.tables.gsub)), N && F.push(N);

              for (var B = mt(F), G = dt(B.encode()), j = B.fields, V = !1, z = 0; z < j.length; z += 1) if ("head table" === j[z].name) {
                j[z].value.checkSumAdjustment = 2981146554 - G, V = !0;
                break;
              }

              if (!V) throw new Error("Could not find head table with checkSum to adjust.");
              return B;
            },
            computeCheckSum: dt
          };

          function gt(e, t) {
            for (var r = 0, i = e.length - 1; r <= i;) {
              var n = r + i >>> 1,
                  a = e[n].tag;
              if (a === t) return n;
              a < t ? r = 1 + n : i = n - 1;
            }

            return -r - 1;
          }

          function bt(e, t) {
            for (var r = 0, i = e.length - 1; r <= i;) {
              var n = r + i >>> 1,
                  a = e[n];
              if (a === t) return n;
              a < t ? r = 1 + n : i = n - 1;
            }

            return -r - 1;
          }

          function _t(e, t) {
            for (var r, i = 0, n = e.length - 1; i <= n;) {
              var a = i + n >>> 1,
                  o = (r = e[a]).start;
              if (o === t) return r;
              o < t ? i = 1 + a : n = a - 1;
            }

            if (0 < i) return t > (r = e[i - 1]).end ? 0 : r;
          }

          function xt(e, t) {
            this.font = e, this.tableName = t;
          }

          function wt(e) {
            xt.call(this, e, "gpos");
          }

          function St(e) {
            xt.call(this, e, "gsub");
          }

          function Mt(e, t) {
            var r = e.length;
            if (r !== t.length) return !1;

            for (var i = 0; i < r; i++) if (e[i] !== t[i]) return !1;

            return !0;
          }

          function Tt(e, t, r) {
            for (var i = e.subtables, n = 0; n < i.length; n++) {
              var a = i[n];
              if (a.substFormat === t) return a;
            }

            if (r) return i.push(r), r;
          }

          function Et(e) {
            for (var t = new ArrayBuffer(e.length), r = new Uint8Array(t), i = 0; i < e.length; ++i) r[i] = e[i];

            return t;
          }

          function Ct(e, t) {
            if (!e) throw t;
          }

          function Lt(e, t, r, i, n) {
            var a;
            return a = 0 < (t & i) ? (a = e.parseByte(), 0 == (t & n) && (a = -a), r + a) : 0 < (t & n) ? r : r + e.parseShort();
          }

          function Ot(e, t, r) {
            var i,
                n,
                a = new se.Parser(t, r);

            if (e.numberOfContours = a.parseShort(), e._xMin = a.parseShort(), e._yMin = a.parseShort(), e._xMax = a.parseShort(), e._yMax = a.parseShort(), 0 < e.numberOfContours) {
              for (var o = e.endPointIndices = [], s = 0; s < e.numberOfContours; s += 1) o.push(a.parseUShort());

              e.instructionLength = a.parseUShort(), e.instructions = [];

              for (var l = 0; l < e.instructionLength; l += 1) e.instructions.push(a.parseByte());

              var u = o[o.length - 1] + 1;
              i = [];

              for (var h = 0; h < u; h += 1) if (n = a.parseByte(), i.push(n), 0 < (8 & n)) for (var c = a.parseByte(), f = 0; f < c; f += 1) i.push(n), h += 1;

              if (P.argument(i.length === u, "Bad flags."), 0 < o.length) {
                var d,
                    p = [];

                if (0 < u) {
                  for (var m = 0; m < u; m += 1) n = i[m], (d = {}).onCurve = !!(1 & n), d.lastPointOfContour = 0 <= o.indexOf(m), p.push(d);

                  for (var v = 0, y = 0; y < u; y += 1) n = i[y], (d = p[y]).x = Lt(a, n, v, 2, 16), v = d.x;

                  for (var g = 0, b = 0; b < u; b += 1) n = i[b], (d = p[b]).y = Lt(a, n, g, 4, 32), g = d.y;
                }

                e.points = p;
              } else e.points = [];
            } else if (0 === e.numberOfContours) e.points = [];else {
              e.isComposite = !0, e.points = [], e.components = [];

              for (var _ = !0; _;) {
                i = a.parseUShort();
                var x = {
                  glyphIndex: a.parseUShort(),
                  xScale: 1,
                  scale01: 0,
                  scale10: 0,
                  yScale: 1,
                  dx: 0,
                  dy: 0
                };
                0 < (1 & i) ? 0 < (2 & i) ? (x.dx = a.parseShort(), x.dy = a.parseShort()) : x.matchedPoints = [a.parseUShort(), a.parseUShort()] : 0 < (2 & i) ? (x.dx = a.parseChar(), x.dy = a.parseChar()) : x.matchedPoints = [a.parseByte(), a.parseByte()], 0 < (8 & i) ? x.xScale = x.yScale = a.parseF2Dot14() : 0 < (64 & i) ? (x.xScale = a.parseF2Dot14(), x.yScale = a.parseF2Dot14()) : 0 < (128 & i) && (x.xScale = a.parseF2Dot14(), x.scale01 = a.parseF2Dot14(), x.scale10 = a.parseF2Dot14(), x.yScale = a.parseF2Dot14()), e.components.push(x), _ = !!(32 & i);
              }

              if (256 & i) {
                e.instructionLength = a.parseUShort(), e.instructions = [];

                for (var w = 0; w < e.instructionLength; w += 1) e.instructions.push(a.parseByte());
              }
            }
          }

          function Pt(e, t) {
            for (var r = [], i = 0; i < e.length; i += 1) {
              var n = e[i],
                  a = {
                x: t.xScale * n.x + t.scale01 * n.y + t.dx,
                y: t.scale10 * n.x + t.yScale * n.y + t.dy,
                onCurve: n.onCurve,
                lastPointOfContour: n.lastPointOfContour
              };
              r.push(a);
            }

            return r;
          }

          function Rt(e) {
            var t = new I();
            if (!e) return t;

            for (var r = function (e) {
              for (var t = [], r = [], i = 0; i < e.length; i += 1) {
                var n = e[i];
                r.push(n), n.lastPointOfContour && (t.push(r), r = []);
              }

              return P.argument(0 === r.length, "There are still points left in the current contour."), t;
            }(e), i = 0; i < r.length; ++i) {
              var n = r[i],
                  a = null,
                  o = n[n.length - 1],
                  s = n[0];
              if (o.onCurve) t.moveTo(o.x, o.y);else if (s.onCurve) t.moveTo(s.x, s.y);else {
                var l = {
                  x: .5 * (o.x + s.x),
                  y: .5 * (o.y + s.y)
                };
                t.moveTo(l.x, l.y);
              }

              for (var u = 0; u < n.length; ++u) if (a = o, o = s, s = n[(u + 1) % n.length], o.onCurve) t.lineTo(o.x, o.y);else {
                var h = s;
                a.onCurve || {
                  x: .5 * (o.x + a.x),
                  y: .5 * (o.y + a.y)
                }, s.onCurve || (h = {
                  x: .5 * (o.x + s.x),
                  y: .5 * (o.y + s.y)
                }), t.quadraticCurveTo(o.x, o.y, h.x, h.y);
              }

              t.closePath();
            }

            return t;
          }

          function Dt(e, t) {
            if (t.isComposite) for (var r = 0; r < t.components.length; r += 1) {
              var i = t.components[r],
                  n = e.get(i.glyphIndex);

              if (n.getPath(), n.points) {
                var a = void 0;
                if (void 0 === i.matchedPoints) a = Pt(n.points, i);else {
                  if (i.matchedPoints[0] > t.points.length - 1 || i.matchedPoints[1] > n.points.length - 1) throw Error("Matched points out of range in " + t.name);
                  var o = t.points[i.matchedPoints[0]],
                      s = n.points[i.matchedPoints[1]],
                      l = {
                    xScale: i.xScale,
                    scale01: i.scale01,
                    scale10: i.scale10,
                    yScale: i.yScale,
                    dx: 0,
                    dy: 0
                  };
                  s = Pt([s], l)[0], l.dx = o.x - s.x, l.dy = o.y - s.y, a = Pt(n.points, l);
                }
                t.points = t.points.concat(a);
              }
            }
            return Rt(t.points);
          }

          (wt.prototype = xt.prototype = {
            searchTag: gt,
            binSearch: bt,
            getTable: function (e) {
              var t = this.font.tables[this.tableName];
              return !t && e && (t = this.font.tables[this.tableName] = this.createDefaultTable()), t;
            },
            getScriptNames: function () {
              var e = this.getTable();
              return e ? e.scripts.map(function (e) {
                return e.tag;
              }) : [];
            },
            getDefaultScriptName: function () {
              var e = this.getTable();

              if (e) {
                for (var t = !1, r = 0; r < e.scripts.length; r++) {
                  var i = e.scripts[r].tag;
                  if ("DFLT" === i) return i;
                  "latn" === i && (t = !0);
                }

                return t ? "latn" : void 0;
              }
            },
            getScriptTable: function (e, t) {
              var r = this.getTable(t);

              if (r) {
                e = e || "DFLT";
                var i = r.scripts,
                    n = gt(r.scripts, e);
                if (0 <= n) return i[n].script;

                if (t) {
                  var a = {
                    tag: e,
                    script: {
                      defaultLangSys: {
                        reserved: 0,
                        reqFeatureIndex: 65535,
                        featureIndexes: []
                      },
                      langSysRecords: []
                    }
                  };
                  return i.splice(-1 - n, 0, a), a.script;
                }
              }
            },
            getLangSysTable: function (e, t, r) {
              var i = this.getScriptTable(e, r);

              if (i) {
                if (!t || "dflt" === t || "DFLT" === t) return i.defaultLangSys;
                var n = gt(i.langSysRecords, t);
                if (0 <= n) return i.langSysRecords[n].langSys;

                if (r) {
                  var a = {
                    tag: t,
                    langSys: {
                      reserved: 0,
                      reqFeatureIndex: 65535,
                      featureIndexes: []
                    }
                  };
                  return i.langSysRecords.splice(-1 - n, 0, a), a.langSys;
                }
              }
            },
            getFeatureTable: function (e, t, r, i) {
              var n = this.getLangSysTable(e, t, i);

              if (n) {
                for (var a, o = n.featureIndexes, s = this.font.tables[this.tableName].features, l = 0; l < o.length; l++) if ((a = s[o[l]]).tag === r) return a.feature;

                if (i) {
                  var u = s.length;
                  return P.assert(0 === u || r >= s[u - 1].tag, "Features must be added in alphabetical order."), a = {
                    tag: r,
                    feature: {
                      params: 0,
                      lookupListIndexes: []
                    }
                  }, s.push(a), o.push(u), a.feature;
                }
              }
            },
            getLookupTables: function (e, t, r, i, n) {
              var a = this.getFeatureTable(e, t, r, n),
                  o = [];

              if (a) {
                for (var s, l = a.lookupListIndexes, u = this.font.tables[this.tableName].lookups, h = 0; h < l.length; h++) (s = u[l[h]]).lookupType === i && o.push(s);

                if (0 === o.length && n) {
                  s = {
                    lookupType: i,
                    lookupFlag: 0,
                    subtables: [],
                    markFilteringSet: void 0
                  };
                  var c = u.length;
                  return u.push(s), l.push(c), [s];
                }
              }

              return o;
            },
            getGlyphClass: function (e, t) {
              switch (e.format) {
                case 1:
                  return e.startGlyph <= t && t < e.startGlyph + e.classes.length ? e.classes[t - e.startGlyph] : 0;

                case 2:
                  var r = _t(e.ranges, t);

                  return r ? r.classId : 0;
              }
            },
            getCoverageIndex: function (e, t) {
              switch (e.format) {
                case 1:
                  var r = bt(e.glyphs, t);
                  return 0 <= r ? r : -1;

                case 2:
                  var i = _t(e.ranges, t);

                  return i ? i.index + t - i.start : -1;
              }
            },
            expandCoverage: function (e) {
              if (1 === e.format) return e.glyphs;

              for (var t = [], r = e.ranges, i = 0; i < r.length; i++) for (var n = r[i], a = n.start, o = n.end, s = a; s <= o; s++) t.push(s);

              return t;
            }
          }).init = function () {
            var e = this.getDefaultScriptName();
            this.defaultKerningTables = this.getKerningTables(e);
          }, wt.prototype.getKerningValue = function (e, t, r) {
            for (var i = 0; i < e.length; i++) for (var n = e[i].subtables, a = 0; a < n.length; a++) {
              var o = n[a],
                  s = this.getCoverageIndex(o.coverage, t);
              if (!(s < 0)) switch (o.posFormat) {
                case 1:
                  for (var l = o.pairSets[s], u = 0; u < l.length; u++) {
                    var h = l[u];
                    if (h.secondGlyph === r) return h.value1 && h.value1.xAdvance || 0;
                  }

                  break;

                case 2:
                  var c = this.getGlyphClass(o.classDef1, t),
                      f = this.getGlyphClass(o.classDef2, r),
                      d = o.classRecords[c][f];
                  return d.value1 && d.value1.xAdvance || 0;
              }
            }

            return 0;
          }, wt.prototype.getKerningTables = function (e, t) {
            if (this.font.tables.gpos) return this.getLookupTables(e, t, "kern", 2);
          }, (St.prototype = xt.prototype).createDefaultTable = function () {
            return {
              version: 1,
              scripts: [{
                tag: "DFLT",
                script: {
                  defaultLangSys: {
                    reserved: 0,
                    reqFeatureIndex: 65535,
                    featureIndexes: []
                  },
                  langSysRecords: []
                }
              }],
              features: [],
              lookups: []
            };
          }, St.prototype.getSingle = function (e, t, r) {
            for (var i = [], n = this.getLookupTables(t, r, e, 1), a = 0; a < n.length; a++) for (var o = n[a].subtables, s = 0; s < o.length; s++) {
              var l = o[s],
                  u = this.expandCoverage(l.coverage),
                  h = void 0;

              if (1 === l.substFormat) {
                var c = l.deltaGlyphId;

                for (h = 0; h < u.length; h++) {
                  var f = u[h];
                  i.push({
                    sub: f,
                    by: f + c
                  });
                }
              } else {
                var d = l.substitute;

                for (h = 0; h < u.length; h++) i.push({
                  sub: u[h],
                  by: d[h]
                });
              }
            }

            return i;
          }, St.prototype.getAlternates = function (e, t, r) {
            for (var i = [], n = this.getLookupTables(t, r, e, 3), a = 0; a < n.length; a++) for (var o = n[a].subtables, s = 0; s < o.length; s++) for (var l = o[s], u = this.expandCoverage(l.coverage), h = l.alternateSets, c = 0; c < u.length; c++) i.push({
              sub: u[c],
              by: h[c]
            });

            return i;
          }, St.prototype.getLigatures = function (e, t, r) {
            for (var i = [], n = this.getLookupTables(t, r, e, 4), a = 0; a < n.length; a++) for (var o = n[a].subtables, s = 0; s < o.length; s++) for (var l = o[s], u = this.expandCoverage(l.coverage), h = l.ligatureSets, c = 0; c < u.length; c++) for (var f = u[c], d = h[c], p = 0; p < d.length; p++) {
              var m = d[p];
              i.push({
                sub: [f].concat(m.components),
                by: m.ligGlyph
              });
            }

            return i;
          }, St.prototype.addSingle = function (e, t, r, i) {
            var n = Tt(this.getLookupTables(r, i, e, 1, !0)[0], 2, {
              substFormat: 2,
              coverage: {
                format: 1,
                glyphs: []
              },
              substitute: []
            });
            P.assert(1 === n.coverage.format, "Ligature: unable to modify coverage table format " + n.coverage.format);
            var a = t.sub,
                o = this.binSearch(n.coverage.glyphs, a);
            o < 0 && (o = -1 - o, n.coverage.glyphs.splice(o, 0, a), n.substitute.splice(o, 0, 0)), n.substitute[o] = t.by;
          }, St.prototype.addAlternate = function (e, t, r, i) {
            var n = Tt(this.getLookupTables(r, i, e, 3, !0)[0], 1, {
              substFormat: 1,
              coverage: {
                format: 1,
                glyphs: []
              },
              alternateSets: []
            });
            P.assert(1 === n.coverage.format, "Ligature: unable to modify coverage table format " + n.coverage.format);
            var a = t.sub,
                o = this.binSearch(n.coverage.glyphs, a);
            o < 0 && (o = -1 - o, n.coverage.glyphs.splice(o, 0, a), n.alternateSets.splice(o, 0, 0)), n.alternateSets[o] = t.by;
          }, St.prototype.addLigature = function (e, t, r, i) {
            var n = this.getLookupTables(r, i, e, 4, !0)[0],
                a = n.subtables[0];
            a || (a = {
              substFormat: 1,
              coverage: {
                format: 1,
                glyphs: []
              },
              ligatureSets: []
            }, n.subtables[0] = a), P.assert(1 === a.coverage.format, "Ligature: unable to modify coverage table format " + a.coverage.format);
            var o = t.sub[0],
                s = t.sub.slice(1),
                l = {
              ligGlyph: t.by,
              components: s
            },
                u = this.binSearch(a.coverage.glyphs, o);

            if (0 <= u) {
              for (var h = a.ligatureSets[u], c = 0; c < h.length; c++) if (Mt(h[c].components, s)) return;

              h.push(l);
            } else u = -1 - u, a.coverage.glyphs.splice(u, 0, o), a.ligatureSets.splice(u, 0, [l]);
          }, St.prototype.getFeature = function (e, t, r) {
            if (/ss\d\d/.test(e)) return this.getSingle(e, t, r);

            switch (e) {
              case "aalt":
              case "salt":
                return this.getSingle(e, t, r).concat(this.getAlternates(e, t, r));

              case "dlig":
              case "liga":
              case "rlig":
                return this.getLigatures(e, t, r);
            }
          }, St.prototype.add = function (e, t, r, i) {
            if (/ss\d\d/.test(e)) return this.addSingle(e, t, r, i);

            switch (e) {
              case "aalt":
              case "salt":
                return "number" == typeof t.by ? this.addSingle(e, t, r, i) : this.addAlternate(e, t, r, i);

              case "dlig":
              case "liga":
              case "rlig":
                return this.addLigature(e, t, r, i);
            }
          };
          var kt,
              At,
              It,
              Ut,
              Nt = {
            getPath: Rt,
            parse: function (e, t, r, i) {
              for (var n = new xe.GlyphSet(i), a = 0; a < r.length - 1; a += 1) {
                var o = r[a];
                o !== r[a + 1] ? n.push(a, xe.ttfGlyphLoader(i, a, Ot, e, t + o, Dt)) : n.push(a, xe.glyphLoader(i, a));
              }

              return n;
            }
          };

          function Ft(e) {
            this.font = e, this.getCommands = function (e) {
              return Nt.getPath(e).commands;
            }, this._fpgmState = this._prepState = void 0, this._errorState = 0;
          }

          function Bt(e) {
            return e;
          }

          function Gt(e) {
            return Math.sign(e) * Math.round(Math.abs(e));
          }

          function jt(e) {
            return Math.sign(e) * Math.round(Math.abs(2 * e)) / 2;
          }

          function Vt(e) {
            return Math.sign(e) * (Math.round(Math.abs(e) + .5) - .5);
          }

          function zt(e) {
            return Math.sign(e) * Math.ceil(Math.abs(e));
          }

          function Ht(e) {
            return Math.sign(e) * Math.floor(Math.abs(e));
          }

          function Wt(e) {
            var t = this.srPeriod,
                r = this.srPhase,
                i = 1;
            return e < 0 && (e = -e, i = -1), e += this.srThreshold - r, e = Math.trunc(e / t) * t, (e += r) < 0 ? r * i : e * i;
          }

          var qt = {
            x: 1,
            y: 0,
            axis: "x",
            distance: function (e, t, r, i) {
              return (r ? e.xo : e.x) - (i ? t.xo : t.x);
            },
            interpolate: function (e, t, r, i) {
              var n, a, o, s, l, u, h;
              if (!i || i === this) return n = e.xo - t.xo, a = e.xo - r.xo, l = t.x - t.xo, u = r.x - r.xo, 0 === (h = (o = Math.abs(n)) + (s = Math.abs(a))) ? void (e.x = e.xo + (l + u) / 2) : void (e.x = e.xo + (l * s + u * o) / h);
              n = i.distance(e, t, !0, !0), a = i.distance(e, r, !0, !0), l = i.distance(t, t, !1, !0), u = i.distance(r, r, !1, !0), 0 !== (h = (o = Math.abs(n)) + (s = Math.abs(a))) ? qt.setRelative(e, e, (l * s + u * o) / h, i, !0) : qt.setRelative(e, e, (l + u) / 2, i, !0);
            },
            normalSlope: Number.NEGATIVE_INFINITY,
            setRelative: function (e, t, r, i, n) {
              if (i && i !== this) {
                var a = n ? t.xo : t.x,
                    o = n ? t.yo : t.y,
                    s = a + r * i.x,
                    l = o + r * i.y;
                e.x = s + (e.y - l) / i.normalSlope;
              } else e.x = (n ? t.xo : t.x) + r;
            },
            slope: 0,
            touch: function (e) {
              e.xTouched = !0;
            },
            touched: function (e) {
              return e.xTouched;
            },
            untouch: function (e) {
              e.xTouched = !1;
            }
          },
              Xt = {
            x: 0,
            y: 1,
            axis: "y",
            distance: function (e, t, r, i) {
              return (r ? e.yo : e.y) - (i ? t.yo : t.y);
            },
            interpolate: function (e, t, r, i) {
              var n, a, o, s, l, u, h;
              if (!i || i === this) return n = e.yo - t.yo, a = e.yo - r.yo, l = t.y - t.yo, u = r.y - r.yo, 0 === (h = (o = Math.abs(n)) + (s = Math.abs(a))) ? void (e.y = e.yo + (l + u) / 2) : void (e.y = e.yo + (l * s + u * o) / h);
              n = i.distance(e, t, !0, !0), a = i.distance(e, r, !0, !0), l = i.distance(t, t, !1, !0), u = i.distance(r, r, !1, !0), 0 !== (h = (o = Math.abs(n)) + (s = Math.abs(a))) ? Xt.setRelative(e, e, (l * s + u * o) / h, i, !0) : Xt.setRelative(e, e, (l + u) / 2, i, !0);
            },
            normalSlope: 0,
            setRelative: function (e, t, r, i, n) {
              if (i && i !== this) {
                var a = n ? t.xo : t.x,
                    o = n ? t.yo : t.y,
                    s = a + r * i.x,
                    l = o + r * i.y;
                e.y = l + i.normalSlope * (e.x - s);
              } else e.y = (n ? t.yo : t.y) + r;
            },
            slope: Number.POSITIVE_INFINITY,
            touch: function (e) {
              e.yTouched = !0;
            },
            touched: function (e) {
              return e.yTouched;
            },
            untouch: function (e) {
              e.yTouched = !1;
            }
          };

          function Yt(e, t) {
            this.x = e, this.y = t, this.axis = void 0, this.slope = t / e, this.normalSlope = -e / t, Object.freeze(this);
          }

          function Zt(e, t) {
            var r = Math.sqrt(e * e + t * t);
            return t /= r, 1 === (e /= r) && 0 === t ? qt : 0 === e && 1 === t ? Xt : new Yt(e, t);
          }

          function Qt(e, t, r, i) {
            this.x = this.xo = Math.round(64 * e) / 64, this.y = this.yo = Math.round(64 * t) / 64, this.lastPointOfContour = r, this.onCurve = i, this.prevPointOnContour = void 0, this.nextPointOnContour = void 0, this.xTouched = !1, this.yTouched = !1, Object.preventExtensions(this);
          }

          Object.freeze(qt), Object.freeze(Xt), Yt.prototype.distance = function (e, t, r, i) {
            return this.x * qt.distance(e, t, r, i) + this.y * Xt.distance(e, t, r, i);
          }, Yt.prototype.interpolate = function (e, t, r, i) {
            var n, a, o, s, l, u, h;
            o = i.distance(e, t, !0, !0), s = i.distance(e, r, !0, !0), n = i.distance(t, t, !1, !0), a = i.distance(r, r, !1, !0), 0 !== (h = (l = Math.abs(o)) + (u = Math.abs(s))) ? this.setRelative(e, e, (n * u + a * l) / h, i, !0) : this.setRelative(e, e, (n + a) / 2, i, !0);
          }, Yt.prototype.setRelative = function (e, t, r, i, n) {
            i = i || this;
            var a = n ? t.xo : t.x,
                o = n ? t.yo : t.y,
                s = a + r * i.x,
                l = o + r * i.y,
                u = i.normalSlope,
                h = this.slope,
                c = e.x,
                f = e.y;
            e.x = (h * c - u * s + l - f) / (h - u), e.y = h * (e.x - c) + f;
          }, Yt.prototype.touch = function (e) {
            e.xTouched = !0, e.yTouched = !0;
          }, Qt.prototype.nextTouched = function (e) {
            for (var t = this.nextPointOnContour; !e.touched(t) && t !== this;) t = t.nextPointOnContour;

            return t;
          }, Qt.prototype.prevTouched = function (e) {
            for (var t = this.prevPointOnContour; !e.touched(t) && t !== this;) t = t.prevPointOnContour;

            return t;
          };
          var Kt = Object.freeze(new Qt(0, 0)),
              Jt = {
            cvCutIn: 17 / 16,
            deltaBase: 9,
            deltaShift: .125,
            loop: 1,
            minDis: 1,
            autoFlip: !0
          };

          function $t(e, t) {
            switch (this.env = e, this.stack = [], this.prog = t, e) {
              case "glyf":
                this.zp0 = this.zp1 = this.zp2 = 1, this.rp0 = this.rp1 = this.rp2 = 0;

              case "prep":
                this.fv = this.pv = this.dpv = qt, this.round = Gt;
            }
          }

          function er(e) {
            for (var t = e.tZone = new Array(e.gZone.length), r = 0; r < t.length; r++) t[r] = new Qt(0, 0);
          }

          function tr(e, t) {
            var r,
                i = e.prog,
                n = e.ip,
                a = 1;

            do {
              if (88 === (r = i[++n])) a++;else if (89 === r) a--;else if (64 === r) n += i[n + 1] + 1;else if (65 === r) n += 2 * i[n + 1] + 1;else if (176 <= r && r <= 183) n += r - 176 + 1;else if (184 <= r && r <= 191) n += 2 * (r - 184 + 1);else if (t && 1 === a && 27 === r) break;
            } while (0 < a);

            e.ip = n;
          }

          function rr(e, t) {
            T.DEBUG && console.log(t.step, "SVTCA[" + e.axis + "]"), t.fv = t.pv = t.dpv = e;
          }

          function ir(e, t) {
            T.DEBUG && console.log(t.step, "SPVTCA[" + e.axis + "]"), t.pv = t.dpv = e;
          }

          function nr(e, t) {
            T.DEBUG && console.log(t.step, "SFVTCA[" + e.axis + "]"), t.fv = e;
          }

          function ar(e, t) {
            var r,
                i,
                n = t.stack,
                a = n.pop(),
                o = n.pop(),
                s = t.z2[a],
                l = t.z1[o];
            T.DEBUG && console.log("SPVTL[" + e + "]", a, o), i = e ? (r = s.y - l.y, l.x - s.x) : (r = l.x - s.x, l.y - s.y), t.pv = t.dpv = Zt(r, i);
          }

          function or(e, t) {
            var r,
                i,
                n = t.stack,
                a = n.pop(),
                o = n.pop(),
                s = t.z2[a],
                l = t.z1[o];
            T.DEBUG && console.log("SFVTL[" + e + "]", a, o), i = e ? (r = s.y - l.y, l.x - s.x) : (r = l.x - s.x, l.y - s.y), t.fv = Zt(r, i);
          }

          function sr(e) {
            T.DEBUG && console.log(e.step, "POP[]"), e.stack.pop();
          }

          function lr(e, t) {
            var r = t.stack.pop(),
                i = t.z0[r],
                n = t.fv,
                a = t.pv;
            T.DEBUG && console.log(t.step, "MDAP[" + e + "]", r);
            var o = a.distance(i, Kt);
            e && (o = t.round(o)), n.setRelative(i, Kt, o, a), n.touch(i), t.rp0 = t.rp1 = r;
          }

          function ur(e, t) {
            var r,
                i,
                n,
                a = t.z2,
                o = a.length - 2;
            T.DEBUG && console.log(t.step, "IUP[" + e.axis + "]");

            for (var s = 0; s < o; s++) r = a[s], e.touched(r) || (i = r.prevTouched(e)) !== r && (i === (n = r.nextTouched(e)) && e.setRelative(r, r, e.distance(i, i, !1, !0), e, !0), e.interpolate(r, i, n, e));
          }

          function hr(e, t) {
            for (var r = t.stack, i = e ? t.rp1 : t.rp2, n = (e ? t.z0 : t.z1)[i], a = t.fv, o = t.pv, s = t.loop, l = t.z2; s--;) {
              var u = r.pop(),
                  h = l[u],
                  c = o.distance(n, n, !1, !0);
              a.setRelative(h, h, c, o), a.touch(h), T.DEBUG && console.log(t.step, (1 < t.loop ? "loop " + (t.loop - s) + ": " : "") + "SHP[" + (e ? "rp1" : "rp2") + "]", u);
            }

            t.loop = 1;
          }

          function cr(e, t) {
            var r = t.stack,
                i = e ? t.rp1 : t.rp2,
                n = (e ? t.z0 : t.z1)[i],
                a = t.fv,
                o = t.pv,
                s = r.pop(),
                l = t.z2[t.contours[s]],
                u = l;
            T.DEBUG && console.log(t.step, "SHC[" + e + "]", s);

            for (var h = o.distance(n, n, !1, !0); u !== n && a.setRelative(u, u, h, o), (u = u.nextPointOnContour) !== l;);
          }

          function fr(e, t) {
            var r,
                i,
                n = t.stack,
                a = e ? t.rp1 : t.rp2,
                o = (e ? t.z0 : t.z1)[a],
                s = t.fv,
                l = t.pv,
                u = n.pop();

            switch (T.DEBUG && console.log(t.step, "SHZ[" + e + "]", u), u) {
              case 0:
                r = t.tZone;
                break;

              case 1:
                r = t.gZone;
                break;

              default:
                throw new Error("Invalid zone");
            }

            for (var h = l.distance(o, o, !1, !0), c = r.length - 2, f = 0; f < c; f++) i = r[f], s.setRelative(i, i, h, l);
          }

          function dr(e, t) {
            var r = t.stack,
                i = r.pop() / 64,
                n = r.pop(),
                a = t.z1[n],
                o = t.z0[t.rp0],
                s = t.fv,
                l = t.pv;
            s.setRelative(a, o, i, l), s.touch(a), T.DEBUG && console.log(t.step, "MSIRP[" + e + "]", i, n), t.rp1 = t.rp0, t.rp2 = n, e && (t.rp0 = n);
          }

          function pr(e, t) {
            var r = t.stack,
                i = r.pop(),
                n = r.pop(),
                a = t.z0[n],
                o = t.fv,
                s = t.pv,
                l = t.cvt[i];
            T.DEBUG && console.log(t.step, "MIAP[" + e + "]", i, "(", l, ")", n);
            var u = s.distance(a, Kt);
            e && (Math.abs(u - l) < t.cvCutIn && (u = l), u = t.round(u)), o.setRelative(a, Kt, u, s), 0 === t.zp0 && (a.xo = a.x, a.yo = a.y), o.touch(a), t.rp0 = t.rp1 = n;
          }

          function mr(e, t) {
            var r = t.stack,
                i = r.pop(),
                n = t.z2[i];
            T.DEBUG && console.log(t.step, "GC[" + e + "]", i), r.push(64 * t.dpv.distance(n, Kt, e, !1));
          }

          function vr(e, t) {
            var r = t.stack,
                i = r.pop(),
                n = r.pop(),
                a = t.z1[i],
                o = t.z0[n],
                s = t.dpv.distance(o, a, e, e);
            T.DEBUG && console.log(t.step, "MD[" + e + "]", i, n, "->", s), t.stack.push(Math.round(64 * s));
          }

          function yr(e, t) {
            var r = t.stack,
                i = r.pop(),
                n = t.fv,
                a = t.pv,
                o = t.ppem,
                s = t.deltaBase + 16 * (e - 1),
                l = t.deltaShift,
                u = t.z0;
            T.DEBUG && console.log(t.step, "DELTAP[" + e + "]", i, r);

            for (var h = 0; h < i; h++) {
              var c = r.pop(),
                  f = r.pop();

              if (s + ((240 & f) >> 4) === o) {
                var d = (15 & f) - 8;
                0 <= d && d++, T.DEBUG && console.log(t.step, "DELTAPFIX", c, "by", d * l);
                var p = u[c];
                n.setRelative(p, p, d * l, a);
              }
            }
          }

          function gr(e, t) {
            var r = t.stack,
                i = r.pop();
            T.DEBUG && console.log(t.step, "ROUND[]"), r.push(64 * t.round(i / 64));
          }

          function br(e, t) {
            var r = t.stack,
                i = r.pop(),
                n = t.ppem,
                a = t.deltaBase + 16 * (e - 1),
                o = t.deltaShift;
            T.DEBUG && console.log(t.step, "DELTAC[" + e + "]", i, r);

            for (var s = 0; s < i; s++) {
              var l = r.pop(),
                  u = r.pop();

              if (a + ((240 & u) >> 4) === n) {
                var h = (15 & u) - 8;
                0 <= h && h++;
                var c = h * o;
                T.DEBUG && console.log(t.step, "DELTACFIX", l, "by", c), t.cvt[l] += c;
              }
            }
          }

          function _r(e, t) {
            var r,
                i,
                n = t.stack,
                a = n.pop(),
                o = n.pop(),
                s = t.z2[a],
                l = t.z1[o];
            T.DEBUG && console.log(t.step, "SDPVTL[" + e + "]", a, o), i = e ? (r = s.y - l.y, l.x - s.x) : (r = l.x - s.x, l.y - s.y), t.dpv = Zt(r, i);
          }

          function xr(e, t) {
            var r = t.stack,
                i = t.prog,
                n = t.ip;
            T.DEBUG && console.log(t.step, "PUSHB[" + e + "]");

            for (var a = 0; a < e; a++) r.push(i[++n]);

            t.ip = n;
          }

          function wr(e, t) {
            var r = t.ip,
                i = t.prog,
                n = t.stack;
            T.DEBUG && console.log(t.ip, "PUSHW[" + e + "]");

            for (var a = 0; a < e; a++) {
              var o = i[++r] << 8 | i[++r];
              32768 & o && (o = -(1 + (65535 ^ o))), n.push(o);
            }

            t.ip = r;
          }

          function Sr(e, t, r, i, n, a) {
            var o,
                s,
                l,
                u,
                h = a.stack,
                c = e && h.pop(),
                f = h.pop(),
                d = a.rp0,
                p = a.z0[d],
                m = a.z1[f],
                v = a.minDis,
                y = a.fv,
                g = a.dpv;
            l = 0 <= (s = o = g.distance(m, p, !0, !0)) ? 1 : -1, s = Math.abs(s), e && (u = a.cvt[c], i && Math.abs(s - u) < a.cvCutIn && (s = u)), r && s < v && (s = v), i && (s = a.round(s)), y.setRelative(m, p, l * s, g), y.touch(m), T.DEBUG && console.log(a.step, (e ? "MIRP[" : "MDRP[") + (t ? "M" : "m") + (r ? ">" : "_") + (i ? "R" : "_") + (0 === n ? "Gr" : 1 === n ? "Bl" : 2 === n ? "Wh" : "") + "]", e ? c + "(" + a.cvt[c] + "," + u + ")" : "", f, "(d =", o, "->", l * s, ")"), a.rp1 = a.rp0, a.rp2 = f, t && (a.rp0 = f);
          }

          Ft.prototype.exec = function (e, t) {
            if ("number" != typeof t) throw new Error("Point size is not a number!");

            if (!(2 < this._errorState)) {
              var r = this.font,
                  i = this._prepState;

              if (!i || i.ppem !== t) {
                var n = this._fpgmState;

                if (!n) {
                  $t.prototype = Jt, (n = this._fpgmState = new $t("fpgm", r.tables.fpgm)).funcs = [], n.font = r, T.DEBUG && (console.log("---EXEC FPGM---"), n.step = -1);

                  try {
                    At(n);
                  } catch (e) {
                    return console.log("Hinting error in FPGM:" + e), void (this._errorState = 3);
                  }
                }

                $t.prototype = n, (i = this._prepState = new $t("prep", r.tables.prep)).ppem = t;
                var a = r.tables.cvt;
                if (a) for (var o = i.cvt = new Array(a.length), s = t / r.unitsPerEm, l = 0; l < a.length; l++) o[l] = a[l] * s;else i.cvt = [];
                T.DEBUG && (console.log("---EXEC PREP---"), i.step = -1);

                try {
                  At(i);
                } catch (e) {
                  this._errorState < 2 && console.log("Hinting error in PREP:" + e), this._errorState = 2;
                }
              }

              if (!(1 < this._errorState)) try {
                return It(e, i);
              } catch (e) {
                return this._errorState < 1 && (console.log("Hinting error:" + e), console.log("Note: further hinting errors are silenced")), void (this._errorState = 1);
              }
            }
          }, It = function (e, t) {
            var r,
                i,
                n,
                a = t.ppem / t.font.unitsPerEm,
                o = a,
                s = e.components;

            if ($t.prototype = t, s) {
              var l = t.font;
              i = [], r = [];

              for (var u = 0; u < s.length; u++) {
                var h = s[u],
                    c = l.glyphs.get(h.glyphIndex);
                n = new $t("glyf", c.instructions), T.DEBUG && (console.log("---EXEC COMP " + u + "---"), n.step = -1), Ut(c, n, a, o);

                for (var f = Math.round(h.dx * a), d = Math.round(h.dy * o), p = n.gZone, m = n.contours, v = 0; v < p.length; v++) {
                  var y = p[v];
                  y.xTouched = y.yTouched = !1, y.xo = y.x = y.x + f, y.yo = y.y = y.y + d;
                }

                var g = i.length;
                i.push.apply(i, p);

                for (var b = 0; b < m.length; b++) r.push(m[b] + g);
              }

              e.instructions && !n.inhibitGridFit && ((n = new $t("glyf", e.instructions)).gZone = n.z0 = n.z1 = n.z2 = i, n.contours = r, i.push(new Qt(0, 0), new Qt(Math.round(e.advanceWidth * a), 0)), T.DEBUG && (console.log("---EXEC COMPOSITE---"), n.step = -1), At(n), i.length -= 2);
            } else n = new $t("glyf", e.instructions), T.DEBUG && (console.log("---EXEC GLYPH---"), n.step = -1), Ut(e, n, a, o), i = n.gZone;

            return i;
          }, Ut = function (e, t, r, i) {
            for (var n, a, o, s = e.points || [], l = s.length, u = t.gZone = t.z0 = t.z1 = t.z2 = [], h = t.contours = [], c = 0; c < l; c++) n = s[c], u[c] = new Qt(n.x * r, n.y * i, n.lastPointOfContour, n.onCurve);

            for (var f = 0; f < l; f++) n = u[f], a || (a = n, h.push(f)), n.lastPointOfContour ? ((n.nextPointOnContour = a).prevPointOnContour = n, a = void 0) : (o = u[f + 1], (n.nextPointOnContour = o).prevPointOnContour = n);

            if (!t.inhibitGridFit) {
              if (T.DEBUG) {
                console.log("PROCESSING GLYPH", t.stack);

                for (var d = 0; d < l; d++) console.log(d, u[d].x, u[d].y);
              }

              if (u.push(new Qt(0, 0), new Qt(Math.round(e.advanceWidth * r), 0)), At(t), u.length -= 2, T.DEBUG) {
                console.log("FINISHED GLYPH", t.stack);

                for (var p = 0; p < l; p++) console.log(p, u[p].x, u[p].y);
              }
            }
          }, At = function (e) {
            var t = e.prog;

            if (t) {
              var r,
                  i = t.length;

              for (e.ip = 0; e.ip < i; e.ip++) {
                if (T.DEBUG && e.step++, !(r = kt[t[e.ip]])) throw new Error("unknown instruction: 0x" + Number(t[e.ip]).toString(16));
                r(e);
              }
            }
          }, kt = [rr.bind(void 0, Xt), rr.bind(void 0, qt), ir.bind(void 0, Xt), ir.bind(void 0, qt), nr.bind(void 0, Xt), nr.bind(void 0, qt), ar.bind(void 0, 0), ar.bind(void 0, 1), or.bind(void 0, 0), or.bind(void 0, 1), function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "SPVFS[]", r, i), e.pv = e.dpv = Zt(i, r);
          }, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "SPVFS[]", r, i), e.fv = Zt(i, r);
          }, function (e) {
            var t = e.stack,
                r = e.pv;
            T.DEBUG && console.log(e.step, "GPV[]"), t.push(16384 * r.x), t.push(16384 * r.y);
          }, function (e) {
            var t = e.stack,
                r = e.fv;
            T.DEBUG && console.log(e.step, "GFV[]"), t.push(16384 * r.x), t.push(16384 * r.y);
          }, function (e) {
            e.fv = e.pv, T.DEBUG && console.log(e.step, "SFVTPV[]");
          }, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop(),
                n = t.pop(),
                a = t.pop(),
                o = t.pop(),
                s = e.z0,
                l = e.z1,
                u = s[r],
                h = s[i],
                c = l[n],
                f = l[a],
                d = e.z2[o];
            T.DEBUG && console.log("ISECT[], ", r, i, n, a, o);
            var p = u.x,
                m = u.y,
                v = h.x,
                y = h.y,
                g = c.x,
                b = c.y,
                _ = f.x,
                x = f.y,
                w = (p - v) * (b - x) - (m - y) * (g - _),
                S = p * y - m * v,
                M = g * x - b * _;
            d.x = (S * (g - _) - M * (p - v)) / w, d.y = (S * (b - x) - M * (m - y)) / w;
          }, function (e) {
            e.rp0 = e.stack.pop(), T.DEBUG && console.log(e.step, "SRP0[]", e.rp0);
          }, function (e) {
            e.rp1 = e.stack.pop(), T.DEBUG && console.log(e.step, "SRP1[]", e.rp1);
          }, function (e) {
            e.rp2 = e.stack.pop(), T.DEBUG && console.log(e.step, "SRP2[]", e.rp2);
          }, function (e) {
            var t = e.stack.pop();

            switch (T.DEBUG && console.log(e.step, "SZP0[]", t), e.zp0 = t) {
              case 0:
                e.tZone || er(e), e.z0 = e.tZone;
                break;

              case 1:
                e.z0 = e.gZone;
                break;

              default:
                throw new Error("Invalid zone pointer");
            }
          }, function (e) {
            var t = e.stack.pop();

            switch (T.DEBUG && console.log(e.step, "SZP1[]", t), e.zp1 = t) {
              case 0:
                e.tZone || er(e), e.z1 = e.tZone;
                break;

              case 1:
                e.z1 = e.gZone;
                break;

              default:
                throw new Error("Invalid zone pointer");
            }
          }, function (e) {
            var t = e.stack.pop();

            switch (T.DEBUG && console.log(e.step, "SZP2[]", t), e.zp2 = t) {
              case 0:
                e.tZone || er(e), e.z2 = e.tZone;
                break;

              case 1:
                e.z2 = e.gZone;
                break;

              default:
                throw new Error("Invalid zone pointer");
            }
          }, function (e) {
            var t = e.stack.pop();

            switch (T.DEBUG && console.log(e.step, "SZPS[]", t), e.zp0 = e.zp1 = e.zp2 = t, t) {
              case 0:
                e.tZone || er(e), e.z0 = e.z1 = e.z2 = e.tZone;
                break;

              case 1:
                e.z0 = e.z1 = e.z2 = e.gZone;
                break;

              default:
                throw new Error("Invalid zone pointer");
            }
          }, function (e) {
            e.loop = e.stack.pop(), T.DEBUG && console.log(e.step, "SLOOP[]", e.loop);
          }, function (e) {
            T.DEBUG && console.log(e.step, "RTG[]"), e.round = Gt;
          }, function (e) {
            T.DEBUG && console.log(e.step, "RTHG[]"), e.round = Vt;
          }, function (e) {
            var t = e.stack.pop();
            T.DEBUG && console.log(e.step, "SMD[]", t), e.minDis = t / 64;
          }, function (e) {
            T.DEBUG && console.log(e.step, "ELSE[]"), tr(e, !1);
          }, function (e) {
            var t = e.stack.pop();
            T.DEBUG && console.log(e.step, "JMPR[]", t), e.ip += t - 1;
          }, function (e) {
            var t = e.stack.pop();
            T.DEBUG && console.log(e.step, "SCVTCI[]", t), e.cvCutIn = t / 64;
          }, void 0, void 0, function (e) {
            var t = e.stack;
            T.DEBUG && console.log(e.step, "DUP[]"), t.push(t[t.length - 1]);
          }, sr, function (e) {
            T.DEBUG && console.log(e.step, "CLEAR[]"), e.stack.length = 0;
          }, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "SWAP[]"), t.push(r), t.push(i);
          }, function (e) {
            var t = e.stack;
            T.DEBUG && console.log(e.step, "DEPTH[]"), t.push(t.length);
          }, function (e) {
            var t = e.stack,
                r = t.pop();
            T.DEBUG && console.log(e.step, "CINDEX[]", r), t.push(t[t.length - r]);
          }, function (e) {
            var t = e.stack,
                r = t.pop();
            T.DEBUG && console.log(e.step, "MINDEX[]", r), t.push(t.splice(t.length - r, 1)[0]);
          }, void 0, void 0, void 0, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "LOOPCALL[]", r, i);
            var n = e.ip,
                a = e.prog;
            e.prog = e.funcs[r];

            for (var o = 0; o < i; o++) At(e), T.DEBUG && console.log(++e.step, o + 1 < i ? "next loopcall" : "done loopcall", o);

            e.ip = n, e.prog = a;
          }, function (e) {
            var t = e.stack.pop();
            T.DEBUG && console.log(e.step, "CALL[]", t);
            var r = e.ip,
                i = e.prog;
            e.prog = e.funcs[t], At(e), e.ip = r, e.prog = i, T.DEBUG && console.log(++e.step, "returning from", t);
          }, function (e) {
            if ("fpgm" !== e.env) throw new Error("FDEF not allowed here");
            var t = e.stack,
                r = e.prog,
                i = e.ip,
                n = t.pop(),
                a = i;

            for (T.DEBUG && console.log(e.step, "FDEF[]", n); 45 !== r[++i];);

            e.ip = i, e.funcs[n] = r.slice(a + 1, i);
          }, void 0, lr.bind(void 0, 0), lr.bind(void 0, 1), ur.bind(void 0, Xt), ur.bind(void 0, qt), hr.bind(void 0, 0), hr.bind(void 0, 1), cr.bind(void 0, 0), cr.bind(void 0, 1), fr.bind(void 0, 0), fr.bind(void 0, 1), function (e) {
            for (var t = e.stack, r = e.loop, i = e.fv, n = t.pop() / 64, a = e.z2; r--;) {
              var o = t.pop(),
                  s = a[o];
              T.DEBUG && console.log(e.step, (1 < e.loop ? "loop " + (e.loop - r) + ": " : "") + "SHPIX[]", o, n), i.setRelative(s, s, n), i.touch(s);
            }

            e.loop = 1;
          }, function (e) {
            for (var t = e.stack, r = e.rp1, i = e.rp2, n = e.loop, a = e.z0[r], o = e.z1[i], s = e.fv, l = e.dpv, u = e.z2; n--;) {
              var h = t.pop(),
                  c = u[h];
              T.DEBUG && console.log(e.step, (1 < e.loop ? "loop " + (e.loop - n) + ": " : "") + "IP[]", h, r, "<->", i), s.interpolate(c, a, o, l), s.touch(c);
            }

            e.loop = 1;
          }, dr.bind(void 0, 0), dr.bind(void 0, 1), function (e) {
            for (var t = e.stack, r = e.rp0, i = e.z0[r], n = e.loop, a = e.fv, o = e.pv, s = e.z1; n--;) {
              var l = t.pop(),
                  u = s[l];
              T.DEBUG && console.log(e.step, (1 < e.loop ? "loop " + (e.loop - n) + ": " : "") + "ALIGNRP[]", l), a.setRelative(u, i, 0, o), a.touch(u);
            }

            e.loop = 1;
          }, function (e) {
            T.DEBUG && console.log(e.step, "RTDG[]"), e.round = jt;
          }, pr.bind(void 0, 0), pr.bind(void 0, 1), function (e) {
            var t = e.prog,
                r = e.ip,
                i = e.stack,
                n = t[++r];
            T.DEBUG && console.log(e.step, "NPUSHB[]", n);

            for (var a = 0; a < n; a++) i.push(t[++r]);

            e.ip = r;
          }, function (e) {
            var t = e.ip,
                r = e.prog,
                i = e.stack,
                n = r[++t];
            T.DEBUG && console.log(e.step, "NPUSHW[]", n);

            for (var a = 0; a < n; a++) {
              var o = r[++t] << 8 | r[++t];
              32768 & o && (o = -(1 + (65535 ^ o))), i.push(o);
            }

            e.ip = t;
          }, function (e) {
            var t = e.stack,
                r = e.store;
            r = r || (e.store = []);
            var i = t.pop(),
                n = t.pop();
            T.DEBUG && console.log(e.step, "WS", i, n), r[n] = i;
          }, function (e) {
            var t = e.stack,
                r = e.store,
                i = t.pop();
            T.DEBUG && console.log(e.step, "RS", i);
            var n = r && r[i] || 0;
            t.push(n);
          }, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "WCVTP", r, i), e.cvt[i] = r / 64;
          }, function (e) {
            var t = e.stack,
                r = t.pop();
            T.DEBUG && console.log(e.step, "RCVT", r), t.push(64 * e.cvt[r]);
          }, mr.bind(void 0, 0), mr.bind(void 0, 1), void 0, vr.bind(void 0, 0), vr.bind(void 0, 1), function (e) {
            T.DEBUG && console.log(e.step, "MPPEM[]"), e.stack.push(e.ppem);
          }, void 0, function (e) {
            T.DEBUG && console.log(e.step, "FLIPON[]"), e.autoFlip = !0;
          }, void 0, void 0, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "LT[]", r, i), t.push(i < r ? 1 : 0);
          }, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "LTEQ[]", r, i), t.push(i <= r ? 1 : 0);
          }, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "GT[]", r, i), t.push(r < i ? 1 : 0);
          }, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "GTEQ[]", r, i), t.push(r <= i ? 1 : 0);
          }, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "EQ[]", r, i), t.push(r === i ? 1 : 0);
          }, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "NEQ[]", r, i), t.push(r !== i ? 1 : 0);
          }, function (e) {
            var t = e.stack,
                r = t.pop();
            T.DEBUG && console.log(e.step, "ODD[]", r), t.push(Math.trunc(r) % 2 ? 1 : 0);
          }, function (e) {
            var t = e.stack,
                r = t.pop();
            T.DEBUG && console.log(e.step, "EVEN[]", r), t.push(Math.trunc(r) % 2 ? 0 : 1);
          }, function (e) {
            var t = e.stack.pop();
            T.DEBUG && console.log(e.step, "IF[]", t), t || (tr(e, !0), T.DEBUG && console.log(e.step, "EIF[]"));
          }, function (e) {
            T.DEBUG && console.log(e.step, "EIF[]");
          }, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "AND[]", r, i), t.push(r && i ? 1 : 0);
          }, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "OR[]", r, i), t.push(r || i ? 1 : 0);
          }, function (e) {
            var t = e.stack,
                r = t.pop();
            T.DEBUG && console.log(e.step, "NOT[]", r), t.push(r ? 0 : 1);
          }, yr.bind(void 0, 1), function (e) {
            var t = e.stack.pop();
            T.DEBUG && console.log(e.step, "SDB[]", t), e.deltaBase = t;
          }, function (e) {
            var t = e.stack.pop();
            T.DEBUG && console.log(e.step, "SDS[]", t), e.deltaShift = Math.pow(.5, t);
          }, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "ADD[]", r, i), t.push(i + r);
          }, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "SUB[]", r, i), t.push(i - r);
          }, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "DIV[]", r, i), t.push(64 * i / r);
          }, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "MUL[]", r, i), t.push(i * r / 64);
          }, function (e) {
            var t = e.stack,
                r = t.pop();
            T.DEBUG && console.log(e.step, "ABS[]", r), t.push(Math.abs(r));
          }, function (e) {
            var t = e.stack,
                r = t.pop();
            T.DEBUG && console.log(e.step, "NEG[]", r), t.push(-r);
          }, function (e) {
            var t = e.stack,
                r = t.pop();
            T.DEBUG && console.log(e.step, "FLOOR[]", r), t.push(64 * Math.floor(r / 64));
          }, function (e) {
            var t = e.stack,
                r = t.pop();
            T.DEBUG && console.log(e.step, "CEILING[]", r), t.push(64 * Math.ceil(r / 64));
          }, gr.bind(void 0, 0), gr.bind(void 0, 1), gr.bind(void 0, 2), gr.bind(void 0, 3), void 0, void 0, void 0, void 0, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "WCVTF[]", r, i), e.cvt[i] = r * e.ppem / e.font.unitsPerEm;
          }, yr.bind(void 0, 2), yr.bind(void 0, 3), br.bind(void 0, 1), br.bind(void 0, 2), br.bind(void 0, 3), function (e) {
            var t,
                r = e.stack.pop();

            switch (T.DEBUG && console.log(e.step, "SROUND[]", r), e.round = Wt, 192 & r) {
              case 0:
                t = .5;
                break;

              case 64:
                t = 1;
                break;

              case 128:
                t = 2;
                break;

              default:
                throw new Error("invalid SROUND value");
            }

            switch (e.srPeriod = t, 48 & r) {
              case 0:
                e.srPhase = 0;
                break;

              case 16:
                e.srPhase = .25 * t;
                break;

              case 32:
                e.srPhase = .5 * t;
                break;

              case 48:
                e.srPhase = .75 * t;
                break;

              default:
                throw new Error("invalid SROUND value");
            }

            r &= 15, e.srThreshold = 0 === r ? 0 : (r / 8 - .5) * t;
          }, function (e) {
            var t,
                r = e.stack.pop();

            switch (T.DEBUG && console.log(e.step, "S45ROUND[]", r), e.round = Wt, 192 & r) {
              case 0:
                t = Math.sqrt(2) / 2;
                break;

              case 64:
                t = Math.sqrt(2);
                break;

              case 128:
                t = 2 * Math.sqrt(2);
                break;

              default:
                throw new Error("invalid S45ROUND value");
            }

            switch (e.srPeriod = t, 48 & r) {
              case 0:
                e.srPhase = 0;
                break;

              case 16:
                e.srPhase = .25 * t;
                break;

              case 32:
                e.srPhase = .5 * t;
                break;

              case 48:
                e.srPhase = .75 * t;
                break;

              default:
                throw new Error("invalid S45ROUND value");
            }

            r &= 15, e.srThreshold = 0 === r ? 0 : (r / 8 - .5) * t;
          }, void 0, void 0, function (e) {
            T.DEBUG && console.log(e.step, "ROFF[]"), e.round = Bt;
          }, void 0, function (e) {
            T.DEBUG && console.log(e.step, "RUTG[]"), e.round = zt;
          }, function (e) {
            T.DEBUG && console.log(e.step, "RDTG[]"), e.round = Ht;
          }, sr, sr, void 0, void 0, void 0, void 0, void 0, function (e) {
            var t = e.stack.pop();
            T.DEBUG && console.log(e.step, "SCANCTRL[]", t);
          }, _r.bind(void 0, 0), _r.bind(void 0, 1), function (e) {
            var t = e.stack,
                r = t.pop(),
                i = 0;
            T.DEBUG && console.log(e.step, "GETINFO[]", r), 1 & r && (i = 35), 32 & r && (i |= 4096), t.push(i);
          }, void 0, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop(),
                n = t.pop();
            T.DEBUG && console.log(e.step, "ROLL[]"), t.push(i), t.push(r), t.push(n);
          }, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "MAX[]", r, i), t.push(Math.max(i, r));
          }, function (e) {
            var t = e.stack,
                r = t.pop(),
                i = t.pop();
            T.DEBUG && console.log(e.step, "MIN[]", r, i), t.push(Math.min(i, r));
          }, function (e) {
            var t = e.stack.pop();
            T.DEBUG && console.log(e.step, "SCANTYPE[]", t);
          }, function (e) {
            var t = e.stack.pop(),
                r = e.stack.pop();

            switch (T.DEBUG && console.log(e.step, "INSTCTRL[]", t, r), t) {
              case 1:
                return void (e.inhibitGridFit = !!r);

              case 2:
                return void (e.ignoreCvt = !!r);

              default:
                throw new Error("invalid INSTCTRL[] selector");
            }
          }, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, xr.bind(void 0, 1), xr.bind(void 0, 2), xr.bind(void 0, 3), xr.bind(void 0, 4), xr.bind(void 0, 5), xr.bind(void 0, 6), xr.bind(void 0, 7), xr.bind(void 0, 8), wr.bind(void 0, 1), wr.bind(void 0, 2), wr.bind(void 0, 3), wr.bind(void 0, 4), wr.bind(void 0, 5), wr.bind(void 0, 6), wr.bind(void 0, 7), wr.bind(void 0, 8), Sr.bind(void 0, 0, 0, 0, 0, 0), Sr.bind(void 0, 0, 0, 0, 0, 1), Sr.bind(void 0, 0, 0, 0, 0, 2), Sr.bind(void 0, 0, 0, 0, 0, 3), Sr.bind(void 0, 0, 0, 0, 1, 0), Sr.bind(void 0, 0, 0, 0, 1, 1), Sr.bind(void 0, 0, 0, 0, 1, 2), Sr.bind(void 0, 0, 0, 0, 1, 3), Sr.bind(void 0, 0, 0, 1, 0, 0), Sr.bind(void 0, 0, 0, 1, 0, 1), Sr.bind(void 0, 0, 0, 1, 0, 2), Sr.bind(void 0, 0, 0, 1, 0, 3), Sr.bind(void 0, 0, 0, 1, 1, 0), Sr.bind(void 0, 0, 0, 1, 1, 1), Sr.bind(void 0, 0, 0, 1, 1, 2), Sr.bind(void 0, 0, 0, 1, 1, 3), Sr.bind(void 0, 0, 1, 0, 0, 0), Sr.bind(void 0, 0, 1, 0, 0, 1), Sr.bind(void 0, 0, 1, 0, 0, 2), Sr.bind(void 0, 0, 1, 0, 0, 3), Sr.bind(void 0, 0, 1, 0, 1, 0), Sr.bind(void 0, 0, 1, 0, 1, 1), Sr.bind(void 0, 0, 1, 0, 1, 2), Sr.bind(void 0, 0, 1, 0, 1, 3), Sr.bind(void 0, 0, 1, 1, 0, 0), Sr.bind(void 0, 0, 1, 1, 0, 1), Sr.bind(void 0, 0, 1, 1, 0, 2), Sr.bind(void 0, 0, 1, 1, 0, 3), Sr.bind(void 0, 0, 1, 1, 1, 0), Sr.bind(void 0, 0, 1, 1, 1, 1), Sr.bind(void 0, 0, 1, 1, 1, 2), Sr.bind(void 0, 0, 1, 1, 1, 3), Sr.bind(void 0, 1, 0, 0, 0, 0), Sr.bind(void 0, 1, 0, 0, 0, 1), Sr.bind(void 0, 1, 0, 0, 0, 2), Sr.bind(void 0, 1, 0, 0, 0, 3), Sr.bind(void 0, 1, 0, 0, 1, 0), Sr.bind(void 0, 1, 0, 0, 1, 1), Sr.bind(void 0, 1, 0, 0, 1, 2), Sr.bind(void 0, 1, 0, 0, 1, 3), Sr.bind(void 0, 1, 0, 1, 0, 0), Sr.bind(void 0, 1, 0, 1, 0, 1), Sr.bind(void 0, 1, 0, 1, 0, 2), Sr.bind(void 0, 1, 0, 1, 0, 3), Sr.bind(void 0, 1, 0, 1, 1, 0), Sr.bind(void 0, 1, 0, 1, 1, 1), Sr.bind(void 0, 1, 0, 1, 1, 2), Sr.bind(void 0, 1, 0, 1, 1, 3), Sr.bind(void 0, 1, 1, 0, 0, 0), Sr.bind(void 0, 1, 1, 0, 0, 1), Sr.bind(void 0, 1, 1, 0, 0, 2), Sr.bind(void 0, 1, 1, 0, 0, 3), Sr.bind(void 0, 1, 1, 0, 1, 0), Sr.bind(void 0, 1, 1, 0, 1, 1), Sr.bind(void 0, 1, 1, 0, 1, 2), Sr.bind(void 0, 1, 1, 0, 1, 3), Sr.bind(void 0, 1, 1, 1, 0, 0), Sr.bind(void 0, 1, 1, 1, 0, 1), Sr.bind(void 0, 1, 1, 1, 0, 2), Sr.bind(void 0, 1, 1, 1, 0, 3), Sr.bind(void 0, 1, 1, 1, 1, 0), Sr.bind(void 0, 1, 1, 1, 1, 1), Sr.bind(void 0, 1, 1, 1, 1, 2), Sr.bind(void 0, 1, 1, 1, 1, 3)];

          var Mr = Array.from || function (e) {
            return e.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]?|[^\uD800-\uDFFF]|./g) || [];
          };

          function Tr(e) {
            (e = e || {}).empty || (Ct(e.familyName, "When creating a new Font object, familyName is required."), Ct(e.styleName, "When creating a new Font object, styleName is required."), Ct(e.unitsPerEm, "When creating a new Font object, unitsPerEm is required."), Ct(e.ascender, "When creating a new Font object, ascender is required."), Ct(e.descender, "When creating a new Font object, descender is required."), Ct(e.descender < 0, "Descender should be negative (e.g. -512)."), this.names = {
              fontFamily: {
                en: e.familyName || " "
              },
              fontSubfamily: {
                en: e.styleName || " "
              },
              fullName: {
                en: e.fullName || e.familyName + " " + e.styleName
              },
              postScriptName: {
                en: e.postScriptName || (e.familyName + e.styleName).replace(/\s/g, "")
              },
              designer: {
                en: e.designer || " "
              },
              designerURL: {
                en: e.designerURL || " "
              },
              manufacturer: {
                en: e.manufacturer || " "
              },
              manufacturerURL: {
                en: e.manufacturerURL || " "
              },
              license: {
                en: e.license || " "
              },
              licenseURL: {
                en: e.licenseURL || " "
              },
              version: {
                en: e.version || "Version 0.1"
              },
              description: {
                en: e.description || " "
              },
              copyright: {
                en: e.copyright || " "
              },
              trademark: {
                en: e.trademark || " "
              }
            }, this.unitsPerEm = e.unitsPerEm || 1e3, this.ascender = e.ascender, this.descender = e.descender, this.createdTimestamp = e.createdTimestamp, this.tables = {
              os2: {
                usWeightClass: e.weightClass || this.usWeightClasses.MEDIUM,
                usWidthClass: e.widthClass || this.usWidthClasses.MEDIUM,
                fsSelection: e.fsSelection || this.fsSelectionValues.REGULAR
              }
            }), this.supported = !0, this.glyphs = new xe.GlyphSet(this, e.glyphs || []), this.encoding = new de(this), this.position = new wt(this), this.substitution = new St(this), this.tables = this.tables || {}, Object.defineProperty(this, "hinting", {
              get: function () {
                return this._hinting ? this._hinting : "truetype" === this.outlinesFormat ? this._hinting = new Ft(this) : void 0;
              }
            });
          }

          function Er(e, t) {
            var r = JSON.stringify(e),
                i = 256;

            for (var n in t) {
              var a = parseInt(n);

              if (a && !(a < 256)) {
                if (JSON.stringify(t[n]) === r) return a;
                i <= a && (i = a + 1);
              }
            }

            return t[i] = e, i;
          }

          function Cr(e, t, r, i) {
            for (var n = [{
              name: "nameID_" + e,
              type: "USHORT",
              value: Er(t.name, i)
            }, {
              name: "flags_" + e,
              type: "USHORT",
              value: 0
            }], a = 0; a < r.length; ++a) {
              var o = r[a].tag;
              n.push({
                name: "axis_" + e + " " + o,
                type: "FIXED",
                value: t.coordinates[o] << 16
              });
            }

            return n;
          }

          function Lr(e, t, r, i) {
            var n = {},
                a = new se.Parser(e, t);
            n.name = i[a.parseUShort()] || {}, a.skip("uShort", 1), n.coordinates = {};

            for (var o = 0; o < r.length; ++o) n.coordinates[r[o].tag] = a.parseFixed();

            return n;
          }

          Tr.prototype.hasChar = function (e) {
            return null !== this.encoding.charToGlyphIndex(e);
          }, Tr.prototype.charToGlyphIndex = function (e) {
            return this.encoding.charToGlyphIndex(e);
          }, Tr.prototype.charToGlyph = function (e) {
            var t = this.charToGlyphIndex(e),
                r = this.glyphs.get(t);
            return r = r || this.glyphs.get(0);
          }, Tr.prototype.stringToGlyphs = function (e, t) {
            t = t || this.defaultRenderOptions;

            for (var r = Mr(e), i = [], n = 0; n < r.length; n += 1) {
              var a = r[n];
              i.push(this.charToGlyphIndex(a));
            }

            var o = i.length;

            if (t.features) {
              var s = t.script || this.substitution.getDefaultScriptName(),
                  l = [];
              t.features.liga && (l = l.concat(this.substitution.getFeature("liga", s, t.language))), t.features.rlig && (l = l.concat(this.substitution.getFeature("rlig", s, t.language)));

              for (var u = 0; u < o; u += 1) for (var h = 0; h < l.length; h++) {
                for (var c = l[h], f = c.sub, d = f.length, p = 0; p < d && f[p] === i[u + p];) p++;

                p === d && (i.splice(u, d, c.by), o = o - d + 1);
              }
            }

            for (var m = new Array(o), v = this.glyphs.get(0), y = 0; y < o; y += 1) m[y] = this.glyphs.get(i[y]) || v;

            return m;
          }, Tr.prototype.nameToGlyphIndex = function (e) {
            return this.glyphNames.nameToGlyphIndex(e);
          }, Tr.prototype.nameToGlyph = function (e) {
            var t = this.nameToGlyphIndex(e),
                r = this.glyphs.get(t);
            return r = r || this.glyphs.get(0);
          }, Tr.prototype.glyphIndexToName = function (e) {
            return this.glyphNames.glyphIndexToName ? this.glyphNames.glyphIndexToName(e) : "";
          }, Tr.prototype.getKerningValue = function (e, t) {
            e = e.index || e, t = t.index || t;
            var r = this.position.defaultKerningTables;
            return r ? this.position.getKerningValue(r, e, t) : this.kerningPairs[e + "," + t] || 0;
          }, Tr.prototype.defaultRenderOptions = {
            kerning: !0,
            features: {
              liga: !0,
              rlig: !0
            }
          }, Tr.prototype.forEachGlyph = function (e, t, r, i, n, a) {
            t = void 0 !== t ? t : 0, r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 72, n = n || this.defaultRenderOptions;
            var o,
                s = 1 / this.unitsPerEm * i,
                l = this.stringToGlyphs(e, n);

            if (n.kerning) {
              var u = n.script || this.position.getDefaultScriptName();
              o = this.position.getKerningTables(u, n.language);
            }

            for (var h = 0; h < l.length; h += 1) {
              var c = l[h];
              if (a.call(this, c, t, r, i, n), c.advanceWidth && (t += c.advanceWidth * s), n.kerning && h < l.length - 1) t += (o ? this.position.getKerningValue(o, c.index, l[h + 1].index) : this.getKerningValue(c, l[h + 1])) * s;
              n.letterSpacing ? t += n.letterSpacing * i : n.tracking && (t += n.tracking / 1e3 * i);
            }

            return t;
          }, Tr.prototype.getPath = function (e, t, r, i, a) {
            var o = new I();
            return this.forEachGlyph(e, t, r, i, a, function (e, t, r, i) {
              var n = e.getPath(t, r, i, a, this);
              o.extend(n);
            }), o;
          }, Tr.prototype.getPaths = function (e, t, r, i, a) {
            var o = [];
            return this.forEachGlyph(e, t, r, i, a, function (e, t, r, i) {
              var n = e.getPath(t, r, i, a, this);
              o.push(n);
            }), o;
          }, Tr.prototype.getAdvanceWidth = function (e, t, r) {
            return this.forEachGlyph(e, 0, 0, t, r, function () {});
          }, Tr.prototype.draw = function (e, t, r, i, n, a) {
            this.getPath(t, r, i, n, a).draw(e);
          }, Tr.prototype.drawPoints = function (n, e, t, r, i, a) {
            this.forEachGlyph(e, t, r, i, a, function (e, t, r, i) {
              e.drawPoints(n, t, r, i);
            });
          }, Tr.prototype.drawMetrics = function (n, e, t, r, i, a) {
            this.forEachGlyph(e, t, r, i, a, function (e, t, r, i) {
              e.drawMetrics(n, t, r, i);
            });
          }, Tr.prototype.getEnglishName = function (e) {
            var t = this.names[e];
            if (t) return t.en;
          }, Tr.prototype.validate = function () {
            var r = this;

            function e(e) {
              var t = r.getEnglishName(e);
              t && t.trim().length;
            }

            e("fontFamily"), e("weightName"), e("manufacturer"), e("copyright"), e("version"), this.unitsPerEm;
          }, Tr.prototype.toTables = function () {
            return yt.fontToTable(this);
          }, Tr.prototype.toBuffer = function () {
            return console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead."), this.toArrayBuffer();
          }, Tr.prototype.toArrayBuffer = function () {
            for (var e = this.toTables().encode(), t = new ArrayBuffer(e.length), r = new Uint8Array(t), i = 0; i < e.length; i++) r[i] = e[i];

            return t;
          }, Tr.prototype.download = function (t) {
            var e = this.getEnglishName("fontFamily"),
                r = this.getEnglishName("fontSubfamily");
            t = t || e.replace(/\s/g, "") + "-" + r + ".otf";
            var n = this.toArrayBuffer();
            if ("undefined" != typeof window) window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem, window.requestFileSystem(window.TEMPORARY, n.byteLength, function (e) {
              e.root.getFile(t, {
                create: !0
              }, function (i) {
                i.createWriter(function (e) {
                  var t = new DataView(n),
                      r = new Blob([t], {
                    type: "font/opentype"
                  });
                  e.write(r), e.addEventListener("writeend", function () {
                    location.href = i.toURL();
                  }, !1);
                });
              });
            }, function (e) {
              throw new Error(e.name + ": " + e.message);
            });else {
              var i = jr("fs"),
                  a = function (e) {
                for (var t = new Gr(e.byteLength), r = new Uint8Array(e), i = 0; i < t.length; ++i) t[i] = r[i];

                return t;
              }(n);

              i.writeFileSync(t, a);
            }
          }, Tr.prototype.fsSelectionValues = {
            ITALIC: 1,
            UNDERSCORE: 2,
            NEGATIVE: 4,
            OUTLINED: 8,
            STRIKEOUT: 16,
            BOLD: 32,
            REGULAR: 64,
            USER_TYPO_METRICS: 128,
            WWS: 256,
            OBLIQUE: 512
          }, Tr.prototype.usWidthClasses = {
            ULTRA_CONDENSED: 1,
            EXTRA_CONDENSED: 2,
            CONDENSED: 3,
            SEMI_CONDENSED: 4,
            MEDIUM: 5,
            SEMI_EXPANDED: 6,
            EXPANDED: 7,
            EXTRA_EXPANDED: 8,
            ULTRA_EXPANDED: 9
          }, Tr.prototype.usWeightClasses = {
            THIN: 100,
            EXTRA_LIGHT: 200,
            LIGHT: 300,
            NORMAL: 400,
            MEDIUM: 500,
            SEMI_BOLD: 600,
            BOLD: 700,
            EXTRA_BOLD: 800,
            BLACK: 900
          };
          var Or = {
            make: function (e, t) {
              var r,
                  i,
                  n,
                  a,
                  o = new $.Table("fvar", [{
                name: "version",
                type: "ULONG",
                value: 65536
              }, {
                name: "offsetToData",
                type: "USHORT",
                value: 0
              }, {
                name: "countSizePairs",
                type: "USHORT",
                value: 2
              }, {
                name: "axisCount",
                type: "USHORT",
                value: e.axes.length
              }, {
                name: "axisSize",
                type: "USHORT",
                value: 20
              }, {
                name: "instanceCount",
                type: "USHORT",
                value: e.instances.length
              }, {
                name: "instanceSize",
                type: "USHORT",
                value: 4 + 4 * e.axes.length
              }]);
              o.offsetToData = o.sizeOf();

              for (var s = 0; s < e.axes.length; s++) o.fields = o.fields.concat((r = s, i = e.axes[s], n = t, a = Er(i.name, n), [{
                name: "tag_" + r,
                type: "TAG",
                value: i.tag
              }, {
                name: "minValue_" + r,
                type: "FIXED",
                value: i.minValue << 16
              }, {
                name: "defaultValue_" + r,
                type: "FIXED",
                value: i.defaultValue << 16
              }, {
                name: "maxValue_" + r,
                type: "FIXED",
                value: i.maxValue << 16
              }, {
                name: "flags_" + r,
                type: "USHORT",
                value: 0
              }, {
                name: "nameID_" + r,
                type: "USHORT",
                value: a
              }]));

              for (var l = 0; l < e.instances.length; l++) o.fields = o.fields.concat(Cr(l, e.instances[l], e.axes, t));

              return o;
            },
            parse: function (e, t, r) {
              var i = new se.Parser(e, t),
                  n = i.parseULong();
              P.argument(65536 === n, "Unsupported fvar table version.");
              var a = i.parseOffset16();
              i.skip("uShort", 1);

              for (var o, s, l, u, h, c = i.parseUShort(), f = i.parseUShort(), d = i.parseUShort(), p = i.parseUShort(), m = [], v = 0; v < c; v++) m.push((o = e, s = t + a + v * f, l = r, h = u = void 0, u = {}, h = new se.Parser(o, s), u.tag = h.parseTag(), u.minValue = h.parseFixed(), u.defaultValue = h.parseFixed(), u.maxValue = h.parseFixed(), h.skip("uShort", 1), u.name = l[h.parseUShort()] || {}, u));

              for (var y = [], g = t + a + c * f, b = 0; b < d; b++) y.push(Lr(e, g + b * p, m, r));

              return {
                axes: m,
                instances: y
              };
            }
          },
              Pr = new Array(10);
          Pr[1] = function () {
            var e = this.offset + this.relativeOffset,
                t = this.parseUShort();
            return 1 === t ? {
              posFormat: 1,
              coverage: this.parsePointer(ae.coverage),
              value: this.parseValueRecord()
            } : 2 === t ? {
              posFormat: 2,
              coverage: this.parsePointer(ae.coverage),
              values: this.parseValueRecordList()
            } : void P.assert(!1, "0x" + e.toString(16) + ": GPOS lookup type 1 format must be 1 or 2.");
          }, Pr[2] = function () {
            var e = this.offset + this.relativeOffset,
                t = this.parseUShort();
            P.assert(1 === t || 2 === t, "0x" + e.toString(16) + ": GPOS lookup type 2 format must be 1 or 2.");
            var r = this.parsePointer(ae.coverage),
                i = this.parseUShort(),
                n = this.parseUShort();
            if (1 === t) return {
              posFormat: t,
              coverage: r,
              valueFormat1: i,
              valueFormat2: n,
              pairSets: this.parseList(ae.pointer(ae.list(function () {
                return {
                  secondGlyph: this.parseUShort(),
                  value1: this.parseValueRecord(i),
                  value2: this.parseValueRecord(n)
                };
              })))
            };

            if (2 === t) {
              var a = this.parsePointer(ae.classDef),
                  o = this.parsePointer(ae.classDef),
                  s = this.parseUShort(),
                  l = this.parseUShort();
              return {
                posFormat: t,
                coverage: r,
                valueFormat1: i,
                valueFormat2: n,
                classDef1: a,
                classDef2: o,
                class1Count: s,
                class2Count: l,
                classRecords: this.parseList(s, ae.list(l, function () {
                  return {
                    value1: this.parseValueRecord(i),
                    value2: this.parseValueRecord(n)
                  };
                }))
              };
            }
          }, Pr[3] = function () {
            return {
              error: "GPOS Lookup 3 not supported"
            };
          }, Pr[4] = function () {
            return {
              error: "GPOS Lookup 4 not supported"
            };
          }, Pr[5] = function () {
            return {
              error: "GPOS Lookup 5 not supported"
            };
          }, Pr[6] = function () {
            return {
              error: "GPOS Lookup 6 not supported"
            };
          }, Pr[7] = function () {
            return {
              error: "GPOS Lookup 7 not supported"
            };
          }, Pr[8] = function () {
            return {
              error: "GPOS Lookup 8 not supported"
            };
          }, Pr[9] = function () {
            return {
              error: "GPOS Lookup 9 not supported"
            };
          };
          var Rr = new Array(10);
          var Dr = {
            parse: function (e, t) {
              var r = new ae(e, t = t || 0),
                  i = r.parseVersion(1);
              return P.argument(1 === i || 1.1 === i, "Unsupported GPOS table version " + i), 1 === i ? {
                version: i,
                scripts: r.parseScriptList(),
                features: r.parseFeatureList(),
                lookups: r.parseLookupList(Pr)
              } : {
                version: i,
                scripts: r.parseScriptList(),
                features: r.parseFeatureList(),
                lookups: r.parseLookupList(Pr),
                variations: r.parseFeatureVariationsList()
              };
            },
            make: function (e) {
              return new $.Table("GPOS", [{
                name: "version",
                type: "ULONG",
                value: 65536
              }, {
                name: "scripts",
                type: "TABLE",
                value: new $.ScriptList(e.scripts)
              }, {
                name: "features",
                type: "TABLE",
                value: new $.FeatureList(e.features)
              }, {
                name: "lookups",
                type: "TABLE",
                value: new $.LookupList(e.lookups, Rr)
              }]);
            }
          };
          var kr = {
            parse: function (e, t) {
              var r = new se.Parser(e, t),
                  i = r.parseUShort();
              if (0 === i) return function (e) {
                var t = {};
                e.skip("uShort");
                var r = e.parseUShort();
                P.argument(0 === r, "Unsupported kern sub-table version."), e.skip("uShort", 2);
                var i = e.parseUShort();
                e.skip("uShort", 3);

                for (var n = 0; n < i; n += 1) {
                  var a = e.parseUShort(),
                      o = e.parseUShort(),
                      s = e.parseShort();
                  t[a + "," + o] = s;
                }

                return t;
              }(r);
              if (1 === i) return function (e) {
                var t = {};
                e.skip("uShort"), 1 < e.parseULong() && console.warn("Only the first kern subtable is supported."), e.skip("uLong");
                var r = 255 & e.parseUShort();

                if (e.skip("uShort"), 0 == r) {
                  var i = e.parseUShort();
                  e.skip("uShort", 3);

                  for (var n = 0; n < i; n += 1) {
                    var a = e.parseUShort(),
                        o = e.parseUShort(),
                        s = e.parseShort();
                    t[a + "," + o] = s;
                  }
                }

                return t;
              }(r);
              throw new Error("Unsupported kern table version (" + i + ").");
            }
          };
          var Ar = {
            parse: function (e, t, r, i) {
              for (var n = new se.Parser(e, t), a = i ? n.parseUShort : n.parseULong, o = [], s = 0; s < r + 1; s += 1) {
                var l = a.call(n);
                i && (l *= 2), o.push(l);
              }

              return o;
            }
          };

          function Ir(e, r) {
            jr("fs").readFile(e, function (e, t) {
              if (e) return r(e.message);
              r(null, Et(t));
            });
          }

          function Ur(e, t) {
            var r = new XMLHttpRequest();
            r.open("get", e, !0), r.responseType = "arraybuffer", r.onload = function () {
              return r.response ? t(null, r.response) : t("Font could not be loaded: " + r.statusText);
            }, r.onerror = function () {
              t("Font could not be loaded");
            }, r.send();
          }

          function Nr(e, t) {
            for (var r = [], i = 12, n = 0; n < t; n += 1) {
              var a = se.getTag(e, i),
                  o = se.getULong(e, i + 4),
                  s = se.getULong(e, i + 8),
                  l = se.getULong(e, i + 12);
              r.push({
                tag: a,
                checksum: o,
                offset: s,
                length: l,
                compression: !1
              }), i += 16;
            }

            return r;
          }

          function Fr(e, t) {
            if ("WOFF" !== t.compression) return {
              data: e,
              offset: t.offset
            };
            var r = new Uint8Array(e.buffer, t.offset + 2, t.compressedLength - 2),
                i = new Uint8Array(t.length);
            if (n(r, i), i.byteLength !== t.length) throw new Error("Decompression error: " + t.tag + " decompressed length doesn't match recorded length");
            return {
              data: new DataView(i.buffer, 0),
              offset: 0
            };
          }

          function Br(e) {
            var t,
                r,
                i,
                n,
                a,
                o,
                s,
                l,
                u,
                h,
                c,
                f,
                d,
                p,
                m = new Tr({
              empty: !0
            }),
                v = new DataView(e, 0),
                y = [],
                g = se.getTag(v, 0);
            if (g === String.fromCharCode(0, 1, 0, 0) || "true" === g || "typ1" === g) m.outlinesFormat = "truetype", y = Nr(v, i = se.getUShort(v, 4));else if ("OTTO" === g) m.outlinesFormat = "cff", y = Nr(v, i = se.getUShort(v, 4));else {
              if ("wOFF" !== g) throw new Error("Unsupported OpenType signature " + g);
              var b = se.getTag(v, 4);
              if (b === String.fromCharCode(0, 1, 0, 0)) m.outlinesFormat = "truetype";else {
                if ("OTTO" !== b) throw new Error("Unsupported OpenType flavor " + g);
                m.outlinesFormat = "cff";
              }

              y = function (e, t) {
                for (var r = [], i = 44, n = 0; n < t; n += 1) {
                  var a = se.getTag(e, i),
                      o = se.getULong(e, i + 4),
                      s = se.getULong(e, i + 8),
                      l = se.getULong(e, i + 12),
                      u = void 0;
                  u = s < l && "WOFF", r.push({
                    tag: a,
                    offset: o,
                    compression: u,
                    compressedLength: s,
                    length: l
                  }), i += 20;
                }

                return r;
              }(v, i = se.getUShort(v, 12));
            }

            for (var _ = 0; _ < i; _ += 1) {
              var x = y[_],
                  w = void 0;

              switch (x.tag) {
                case "cmap":
                  w = Fr(v, x), m.tables.cmap = le.parse(w.data, w.offset), m.encoding = new pe(m.tables.cmap);
                  break;

                case "cvt ":
                  w = Fr(v, x), p = new se.Parser(w.data, w.offset), m.tables.cvt = p.parseShortList(x.length / 2);
                  break;

                case "fvar":
                  a = x;
                  break;

                case "fpgm":
                  w = Fr(v, x), p = new se.Parser(w.data, w.offset), m.tables.fpgm = p.parseByteList(x.length);
                  break;

                case "head":
                  w = Fr(v, x), m.tables.head = Ge.parse(w.data, w.offset), m.unitsPerEm = m.tables.head.unitsPerEm, t = m.tables.head.indexToLocFormat;
                  break;

                case "hhea":
                  w = Fr(v, x), m.tables.hhea = je.parse(w.data, w.offset), m.ascender = m.tables.hhea.ascender, m.descender = m.tables.hhea.descender, m.numberOfHMetrics = m.tables.hhea.numberOfHMetrics;
                  break;

                case "hmtx":
                  u = x;
                  break;

                case "ltag":
                  w = Fr(v, x), r = ze.parse(w.data, w.offset);
                  break;

                case "maxp":
                  w = Fr(v, x), m.tables.maxp = He.parse(w.data, w.offset), m.numGlyphs = m.tables.maxp.numGlyphs;
                  break;

                case "name":
                  f = x;
                  break;

                case "OS/2":
                  w = Fr(v, x), m.tables.os2 = at.parse(w.data, w.offset);
                  break;

                case "post":
                  w = Fr(v, x), m.tables.post = ot.parse(w.data, w.offset), m.glyphNames = new ve(m.tables.post);
                  break;

                case "prep":
                  w = Fr(v, x), p = new se.Parser(w.data, w.offset), m.tables.prep = p.parseByteList(x.length);
                  break;

                case "glyf":
                  o = x;
                  break;

                case "loca":
                  c = x;
                  break;

                case "CFF ":
                  n = x;
                  break;

                case "kern":
                  h = x;
                  break;

                case "GPOS":
                  s = x;
                  break;

                case "GSUB":
                  l = x;
                  break;

                case "meta":
                  d = x;
              }
            }

            var S = Fr(v, f);

            if (m.tables.name = it.parse(S.data, S.offset, r), m.names = m.tables.name, o && c) {
              var M = 0 === t,
                  T = Fr(v, c),
                  E = Ar.parse(T.data, T.offset, m.numGlyphs, M),
                  C = Fr(v, o);
              m.glyphs = Nt.parse(C.data, C.offset, E, m);
            } else {
              if (!n) throw new Error("Font doesn't contain TrueType or CFF outlines.");
              var L = Fr(v, n);
              Be.parse(L.data, L.offset, m);
            }

            var O = Fr(v, u);

            if (Ve.parse(O.data, O.offset, m.numberOfHMetrics, m.numGlyphs, m.glyphs), function (e) {
              for (var t, r = e.tables.cmap.glyphIndexMap, i = Object.keys(r), n = 0; n < i.length; n += 1) {
                var a = i[n],
                    o = r[a];
                (t = e.glyphs.get(o)).addUnicode(parseInt(a));
              }

              for (var s = 0; s < e.glyphs.length; s += 1) t = e.glyphs.get(s), e.cffEncoding ? e.isCIDFont ? t.name = "gid" + s : t.name = e.cffEncoding.charset[s] : e.glyphNames.names && (t.name = e.glyphNames.glyphIndexToName(s));
            }(m), h) {
              var P = Fr(v, h);
              m.kerningPairs = kr.parse(P.data, P.offset);
            } else m.kerningPairs = {};

            if (s) {
              var R = Fr(v, s);
              m.tables.gpos = Dr.parse(R.data, R.offset), m.position.init();
            }

            if (l) {
              var D = Fr(v, l);
              m.tables.gsub = ht.parse(D.data, D.offset);
            }

            if (a) {
              var k = Fr(v, a);
              m.tables.fvar = Or.parse(k.data, k.offset, m.names);
            }

            if (d) {
              var A = Fr(v, d);
              m.tables.meta = ct.parse(A.data, A.offset), m.metas = m.tables.meta;
            }

            return m;
          }

          T.Font = Tr, T.Glyph = ge, T.Path = I, T.BoundingBox = C, T._parse = se, T.parse = Br, T.load = function (e, i) {
            ("undefined" == typeof window ? Ir : Ur)(e, function (e, t) {
              if (e) return i(e);
              var r;

              try {
                r = Br(t);
              } catch (e) {
                return i(e, null);
              }

              return i(null, r);
            });
          }, T.loadSync = function (e) {
            return Br(Et(jr("fs").readFileSync(e)));
          }, Object.defineProperty(T, "__esModule", {
            value: !0
          });
        }("object" == typeof r && void 0 !== t ? r : e.opentype = {});
      }).call(this, jr("buffer").Buffer);
    }, {
      buffer: 4,
      fs: 2
    }],
    13: [function (e, t, u) {
      (function (n) {
        function a(e, t) {
          for (var r = 0, i = e.length - 1; 0 <= i; i--) {
            var n = e[i];
            "." === n ? e.splice(i, 1) : ".." === n ? (e.splice(i, 1), r++) : r && (e.splice(i, 1), r--);
          }

          if (t) for (; r--;) e.unshift("..");
          return e;
        }

        function o(e, t) {
          if (e.filter) return e.filter(t);

          for (var r = [], i = 0; i < e.length; i++) t(e[i], i, e) && r.push(e[i]);

          return r;
        }

        u.resolve = function () {
          for (var e = "", t = !1, r = arguments.length - 1; -1 <= r && !t; r--) {
            var i = 0 <= r ? arguments[r] : n.cwd();
            if ("string" != typeof i) throw new TypeError("Arguments to path.resolve must be strings");
            i && (e = i + "/" + e, t = "/" === i.charAt(0));
          }

          return (t ? "/" : "") + (e = a(o(e.split("/"), function (e) {
            return !!e;
          }), !t).join("/")) || ".";
        }, u.normalize = function (e) {
          var t = u.isAbsolute(e),
              r = "/" === i(e, -1);
          return (e = a(o(e.split("/"), function (e) {
            return !!e;
          }), !t).join("/")) || t || (e = "."), e && r && (e += "/"), (t ? "/" : "") + e;
        }, u.isAbsolute = function (e) {
          return "/" === e.charAt(0);
        }, u.join = function () {
          var e = Array.prototype.slice.call(arguments, 0);
          return u.normalize(o(e, function (e, t) {
            if ("string" != typeof e) throw new TypeError("Arguments to path.join must be strings");
            return e;
          }).join("/"));
        }, u.relative = function (e, t) {
          function r(e) {
            for (var t = 0; t < e.length && "" === e[t]; t++);

            for (var r = e.length - 1; 0 <= r && "" === e[r]; r--);

            return r < t ? [] : e.slice(t, r - t + 1);
          }

          e = u.resolve(e).substr(1), t = u.resolve(t).substr(1);

          for (var i = r(e.split("/")), n = r(t.split("/")), a = Math.min(i.length, n.length), o = a, s = 0; s < a; s++) if (i[s] !== n[s]) {
            o = s;
            break;
          }

          var l = [];

          for (s = o; s < i.length; s++) l.push("..");

          return (l = l.concat(n.slice(o))).join("/");
        }, u.sep = "/", u.delimiter = ":", u.dirname = function (e) {
          if ("string" != typeof e && (e += ""), 0 === e.length) return ".";

          for (var t = e.charCodeAt(0), r = 47 === t, i = -1, n = !0, a = e.length - 1; 1 <= a; --a) if (47 === (t = e.charCodeAt(a))) {
            if (!n) {
              i = a;
              break;
            }
          } else n = !1;

          return -1 === i ? r ? "/" : "." : r && 1 === i ? "/" : e.slice(0, i);
        }, u.basename = function (e, t) {
          var r = function (e) {
            "string" != typeof e && (e += "");
            var t,
                r = 0,
                i = -1,
                n = !0;

            for (t = e.length - 1; 0 <= t; --t) if (47 === e.charCodeAt(t)) {
              if (!n) {
                r = t + 1;
                break;
              }
            } else -1 === i && (n = !1, i = t + 1);

            return -1 === i ? "" : e.slice(r, i);
          }(e);

          return t && r.substr(-1 * t.length) === t && (r = r.substr(0, r.length - t.length)), r;
        }, u.extname = function (e) {
          "string" != typeof e && (e += "");

          for (var t = -1, r = 0, i = -1, n = !0, a = 0, o = e.length - 1; 0 <= o; --o) {
            var s = e.charCodeAt(o);

            if (47 === s) {
              if (n) continue;
              r = o + 1;
              break;
            }

            -1 === i && (n = !1, i = o + 1), 46 === s ? -1 === t ? t = o : 1 !== a && (a = 1) : -1 !== t && (a = -1);
          }

          return -1 === t || -1 === i || 0 === a || 1 === a && t === i - 1 && t === r + 1 ? "" : e.slice(t, i);
        };
        var i = "b" === "ab".substr(-1) ? function (e, t, r) {
          return e.substr(t, r);
        } : function (e, t, r) {
          return t < 0 && (t = e.length + t), e.substr(t, r);
        };
      }).call(this, e("_process"));
    }, {
      _process: 14
    }],
    14: [function (e, t, r) {
      var i,
          n,
          a = t.exports = {};

      function o() {
        throw new Error("setTimeout has not been defined");
      }

      function s() {
        throw new Error("clearTimeout has not been defined");
      }

      function l(t) {
        if (i === setTimeout) return setTimeout(t, 0);
        if ((i === o || !i) && setTimeout) return i = setTimeout, setTimeout(t, 0);

        try {
          return i(t, 0);
        } catch (e) {
          try {
            return i.call(null, t, 0);
          } catch (e) {
            return i.call(this, t, 0);
          }
        }
      }

      !function () {
        try {
          i = "function" == typeof setTimeout ? setTimeout : o;
        } catch (e) {
          i = o;
        }

        try {
          n = "function" == typeof clearTimeout ? clearTimeout : s;
        } catch (e) {
          n = s;
        }
      }();
      var u,
          h = [],
          c = !1,
          f = -1;

      function d() {
        c && u && (c = !1, u.length ? h = u.concat(h) : f = -1, h.length && p());
      }

      function p() {
        if (!c) {
          var e = l(d);
          c = !0;

          for (var t = h.length; t;) {
            for (u = h, h = []; ++f < t;) u && u[f].run();

            f = -1, t = h.length;
          }

          u = null, c = !1, function (t) {
            if (n === clearTimeout) return clearTimeout(t);
            if ((n === s || !n) && clearTimeout) return n = clearTimeout, clearTimeout(t);

            try {
              n(t);
            } catch (e) {
              try {
                return n.call(null, t);
              } catch (e) {
                return n.call(this, t);
              }
            }
          }(e);
        }
      }

      function m(e, t) {
        this.fun = e, this.array = t;
      }

      function v() {}

      a.nextTick = function (e) {
        var t = new Array(arguments.length - 1);
        if (1 < arguments.length) for (var r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
        h.push(new m(e, t)), 1 !== h.length || c || l(p);
      }, m.prototype.run = function () {
        this.fun.apply(null, this.array);
      }, a.title = "browser", a.browser = !0, a.env = {}, a.argv = [], a.version = "", a.versions = {}, a.on = v, a.addListener = v, a.once = v, a.off = v, a.removeListener = v, a.removeAllListeners = v, a.emit = v, a.prependListener = v, a.prependOnceListener = v, a.listeners = function (e) {
        return [];
      }, a.binding = function (e) {
        throw new Error("process.binding is not supported");
      }, a.cwd = function () {
        return "/";
      }, a.chdir = function (e) {
        throw new Error("process.chdir is not supported");
      }, a.umask = function () {
        return 0;
      };
    }, {}],
    15: [function (e, t, r) {
      !function (e) {
        "use strict";

        if (!e.fetch) {
          var t = ("URLSearchParams" in e),
              r = "Symbol" in e && "iterator" in Symbol,
              o = "FileReader" in e && "Blob" in e && function () {
            try {
              return new Blob(), !0;
            } catch (e) {
              return !1;
            }
          }(),
              i = ("FormData" in e),
              n = ("ArrayBuffer" in e);

          if (n) var a = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
              s = function (e) {
            return e && DataView.prototype.isPrototypeOf(e);
          },
              l = ArrayBuffer.isView || function (e) {
            return e && -1 < a.indexOf(Object.prototype.toString.call(e));
          };
          p.prototype.append = function (e, t) {
            e = c(e), t = f(t);
            var r = this.map[e];
            this.map[e] = r ? r + "," + t : t;
          }, p.prototype.delete = function (e) {
            delete this.map[c(e)];
          }, p.prototype.get = function (e) {
            return e = c(e), this.has(e) ? this.map[e] : null;
          }, p.prototype.has = function (e) {
            return this.map.hasOwnProperty(c(e));
          }, p.prototype.set = function (e, t) {
            this.map[c(e)] = f(t);
          }, p.prototype.forEach = function (e, t) {
            for (var r in this.map) this.map.hasOwnProperty(r) && e.call(t, this.map[r], r, this);
          }, p.prototype.keys = function () {
            var r = [];
            return this.forEach(function (e, t) {
              r.push(t);
            }), d(r);
          }, p.prototype.values = function () {
            var t = [];
            return this.forEach(function (e) {
              t.push(e);
            }), d(t);
          }, p.prototype.entries = function () {
            var r = [];
            return this.forEach(function (e, t) {
              r.push([t, e]);
            }), d(r);
          }, r && (p.prototype[Symbol.iterator] = p.prototype.entries);
          var u = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
          _.prototype.clone = function () {
            return new _(this, {
              body: this._bodyInit
            });
          }, b.call(_.prototype), b.call(w.prototype), w.prototype.clone = function () {
            return new w(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new p(this.headers),
              url: this.url
            });
          }, w.error = function () {
            var e = new w(null, {
              status: 0,
              statusText: ""
            });
            return e.type = "error", e;
          };
          var h = [301, 302, 303, 307, 308];
          w.redirect = function (e, t) {
            if (-1 === h.indexOf(t)) throw new RangeError("Invalid status code");
            return new w(null, {
              status: t,
              headers: {
                location: e
              }
            });
          }, e.Headers = p, e.Request = _, e.Response = w, e.fetch = function (r, n) {
            return new Promise(function (i, e) {
              var t = new _(r, n),
                  a = new XMLHttpRequest();
              a.onload = function () {
                var e,
                    n,
                    t = {
                  status: a.status,
                  statusText: a.statusText,
                  headers: (e = a.getAllResponseHeaders() || "", n = new p(), e.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach(function (e) {
                    var t = e.split(":"),
                        r = t.shift().trim();

                    if (r) {
                      var i = t.join(":").trim();
                      n.append(r, i);
                    }
                  }), n)
                };
                t.url = "responseURL" in a ? a.responseURL : t.headers.get("X-Request-URL");
                var r = "response" in a ? a.response : a.responseText;
                i(new w(r, t));
              }, a.onerror = function () {
                e(new TypeError("Network request failed"));
              }, a.ontimeout = function () {
                e(new TypeError("Network request failed"));
              }, a.open(t.method, t.url, !0), "include" === t.credentials ? a.withCredentials = !0 : "omit" === t.credentials && (a.withCredentials = !1), "responseType" in a && o && (a.responseType = "blob"), t.headers.forEach(function (e, t) {
                a.setRequestHeader(t, e);
              }), a.send(void 0 === t._bodyInit ? null : t._bodyInit);
            });
          }, e.fetch.polyfill = !0;
        }

        function c(e) {
          if ("string" != typeof e && (e = String(e)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(e)) throw new TypeError("Invalid character in header field name");
          return e.toLowerCase();
        }

        function f(e) {
          return "string" != typeof e && (e = String(e)), e;
        }

        function d(t) {
          var e = {
            next: function () {
              var e = t.shift();
              return {
                done: void 0 === e,
                value: e
              };
            }
          };
          return r && (e[Symbol.iterator] = function () {
            return e;
          }), e;
        }

        function p(t) {
          this.map = {}, t instanceof p ? t.forEach(function (e, t) {
            this.append(t, e);
          }, this) : Array.isArray(t) ? t.forEach(function (e) {
            this.append(e[0], e[1]);
          }, this) : t && Object.getOwnPropertyNames(t).forEach(function (e) {
            this.append(e, t[e]);
          }, this);
        }

        function m(e) {
          if (e.bodyUsed) return Promise.reject(new TypeError("Already read"));
          e.bodyUsed = !0;
        }

        function v(r) {
          return new Promise(function (e, t) {
            r.onload = function () {
              e(r.result);
            }, r.onerror = function () {
              t(r.error);
            };
          });
        }

        function y(e) {
          var t = new FileReader(),
              r = v(t);
          return t.readAsArrayBuffer(e), r;
        }

        function g(e) {
          if (e.slice) return e.slice(0);
          var t = new Uint8Array(e.byteLength);
          return t.set(new Uint8Array(e)), t.buffer;
        }

        function b() {
          return this.bodyUsed = !1, this._initBody = function (e) {
            if (this._bodyInit = e) {
              if ("string" == typeof e) this._bodyText = e;else if (o && Blob.prototype.isPrototypeOf(e)) this._bodyBlob = e;else if (i && FormData.prototype.isPrototypeOf(e)) this._bodyFormData = e;else if (t && URLSearchParams.prototype.isPrototypeOf(e)) this._bodyText = e.toString();else if (n && o && s(e)) this._bodyArrayBuffer = g(e.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer]);else {
                if (!n || !ArrayBuffer.prototype.isPrototypeOf(e) && !l(e)) throw new Error("unsupported BodyInit type");
                this._bodyArrayBuffer = g(e);
              }
            } else this._bodyText = "";
            this.headers.get("content-type") || ("string" == typeof e ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : t && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
          }, o && (this.blob = function () {
            var e = m(this);
            if (e) return e;
            if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
            if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            if (this._bodyFormData) throw new Error("could not read FormData body as blob");
            return Promise.resolve(new Blob([this._bodyText]));
          }, this.arrayBuffer = function () {
            return this._bodyArrayBuffer ? m(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(y);
          }), this.text = function () {
            var e,
                t,
                r,
                i = m(this);
            if (i) return i;
            if (this._bodyBlob) return e = this._bodyBlob, t = new FileReader(), r = v(t), t.readAsText(e), r;
            if (this._bodyArrayBuffer) return Promise.resolve(function (e) {
              for (var t = new Uint8Array(e), r = new Array(t.length), i = 0; i < t.length; i++) r[i] = String.fromCharCode(t[i]);

              return r.join("");
            }(this._bodyArrayBuffer));
            if (this._bodyFormData) throw new Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
          }, i && (this.formData = function () {
            return this.text().then(x);
          }), this.json = function () {
            return this.text().then(JSON.parse);
          }, this;
        }

        function _(e, t) {
          var r,
              i,
              n = (t = t || {}).body;

          if (e instanceof _) {
            if (e.bodyUsed) throw new TypeError("Already read");
            this.url = e.url, this.credentials = e.credentials, t.headers || (this.headers = new p(e.headers)), this.method = e.method, this.mode = e.mode, n || null == e._bodyInit || (n = e._bodyInit, e.bodyUsed = !0);
          } else this.url = String(e);

          if (this.credentials = t.credentials || this.credentials || "omit", !t.headers && this.headers || (this.headers = new p(t.headers)), this.method = (r = t.method || this.method || "GET", i = r.toUpperCase(), -1 < u.indexOf(i) ? i : r), this.mode = t.mode || this.mode || null, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && n) throw new TypeError("Body not allowed for GET or HEAD requests");

          this._initBody(n);
        }

        function x(e) {
          var n = new FormData();
          return e.trim().split("&").forEach(function (e) {
            if (e) {
              var t = e.split("="),
                  r = t.shift().replace(/\+/g, " "),
                  i = t.join("=").replace(/\+/g, " ");
              n.append(decodeURIComponent(r), decodeURIComponent(i));
            }
          }), n;
        }

        function w(e, t) {
          t = t || {}, this.type = "default", this.status = void 0 === t.status ? 200 : t.status, this.ok = 200 <= this.status && this.status < 300, this.statusText = "statusText" in t ? t.statusText : "OK", this.headers = new p(t.headers), this.url = t.url || "", this._initBody(e);
        }
      }("undefined" != typeof self ? self : this);
    }, {}],
    16: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var l,
          i = a(e("../core/main")),
          n = a(e("../color/color_conversion"));

      function a(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      var u = [{
        h: 0,
        s: 0,
        b: .8275,
        name: "gray"
      }, {
        h: 0,
        s: 0,
        b: .8627,
        name: "gray"
      }, {
        h: 0,
        s: 0,
        b: .7529,
        name: "gray"
      }, {
        h: .0167,
        s: .1176,
        b: 1,
        name: "light pink"
      }],
          h = [{
        h: 0,
        s: 0,
        b: 0,
        name: "black"
      }, {
        h: 0,
        s: 0,
        b: .5,
        name: "gray"
      }, {
        h: 0,
        s: 0,
        b: 1,
        name: "white"
      }, {
        h: 0,
        s: .5,
        b: .5,
        name: "dark maroon"
      }, {
        h: 0,
        s: .5,
        b: 1,
        name: "salmon pink"
      }, {
        h: 0,
        s: 1,
        b: 0,
        name: "black"
      }, {
        h: 0,
        s: 1,
        b: .5,
        name: "dark red"
      }, {
        h: 0,
        s: 1,
        b: 1,
        name: "red"
      }, {
        h: 5,
        s: 0,
        b: 1,
        name: "very light peach"
      }, {
        h: 5,
        s: .5,
        b: .5,
        name: "brown"
      }, {
        h: 5,
        s: .5,
        b: 1,
        name: "peach"
      }, {
        h: 5,
        s: 1,
        b: .5,
        name: "brick red"
      }, {
        h: 5,
        s: 1,
        b: 1,
        name: "crimson"
      }, {
        h: 10,
        s: 0,
        b: 1,
        name: "light peach"
      }, {
        h: 10,
        s: .5,
        b: .5,
        name: "brown"
      }, {
        h: 10,
        s: .5,
        b: 1,
        name: "light orange"
      }, {
        h: 10,
        s: 1,
        b: .5,
        name: "brown"
      }, {
        h: 10,
        s: 1,
        b: 1,
        name: "orange"
      }, {
        h: 15,
        s: 0,
        b: 1,
        name: "very light yellow"
      }, {
        h: 15,
        s: .5,
        b: .5,
        name: "olive green"
      }, {
        h: 15,
        s: .5,
        b: 1,
        name: "light yellow"
      }, {
        h: 15,
        s: 1,
        b: 0,
        name: "dark olive green"
      }, {
        h: 15,
        s: 1,
        b: .5,
        name: "olive green"
      }, {
        h: 15,
        s: 1,
        b: 1,
        name: "yellow"
      }, {
        h: 20,
        s: 0,
        b: 1,
        name: "very light yellow"
      }, {
        h: 20,
        s: .5,
        b: .5,
        name: "olive green"
      }, {
        h: 20,
        s: .5,
        b: 1,
        name: "light yellow green"
      }, {
        h: 20,
        s: 1,
        b: 0,
        name: "dark olive green"
      }, {
        h: 20,
        s: 1,
        b: .5,
        name: "dark yellow green"
      }, {
        h: 20,
        s: 1,
        b: 1,
        name: "yellow green"
      }, {
        h: 25,
        s: .5,
        b: .5,
        name: "dark yellow green"
      }, {
        h: 25,
        s: .5,
        b: 1,
        name: "light green"
      }, {
        h: 25,
        s: 1,
        b: .5,
        name: "dark green"
      }, {
        h: 25,
        s: 1,
        b: 1,
        name: "green"
      }, {
        h: 30,
        s: .5,
        b: 1,
        name: "light green"
      }, {
        h: 30,
        s: 1,
        b: .5,
        name: "dark green"
      }, {
        h: 30,
        s: 1,
        b: 1,
        name: "green"
      }, {
        h: 35,
        s: 0,
        b: .5,
        name: "light green"
      }, {
        h: 35,
        s: 0,
        b: 1,
        name: "very light green"
      }, {
        h: 35,
        s: .5,
        b: .5,
        name: "dark green"
      }, {
        h: 35,
        s: .5,
        b: 1,
        name: "light green"
      }, {
        h: 35,
        s: 1,
        b: 0,
        name: "very dark green"
      }, {
        h: 35,
        s: 1,
        b: .5,
        name: "dark green"
      }, {
        h: 35,
        s: 1,
        b: 1,
        name: "green"
      }, {
        h: 40,
        s: 0,
        b: 1,
        name: "very light green"
      }, {
        h: 40,
        s: .5,
        b: .5,
        name: "dark green"
      }, {
        h: 40,
        s: .5,
        b: 1,
        name: "light green"
      }, {
        h: 40,
        s: 1,
        b: .5,
        name: "dark green"
      }, {
        h: 40,
        s: 1,
        b: 1,
        name: "green"
      }, {
        h: 45,
        s: .5,
        b: 1,
        name: "light turquoise"
      }, {
        h: 45,
        s: 1,
        b: .5,
        name: "dark turquoise"
      }, {
        h: 45,
        s: 1,
        b: 1,
        name: "turquoise"
      }, {
        h: 50,
        s: 0,
        b: 1,
        name: "light sky blue"
      }, {
        h: 50,
        s: .5,
        b: .5,
        name: "dark cyan"
      }, {
        h: 50,
        s: .5,
        b: 1,
        name: "light cyan"
      }, {
        h: 50,
        s: 1,
        b: .5,
        name: "dark cyan"
      }, {
        h: 50,
        s: 1,
        b: 1,
        name: "cyan"
      }, {
        h: 55,
        s: 0,
        b: 1,
        name: "light sky blue"
      }, {
        h: 55,
        s: .5,
        b: 1,
        name: "light sky blue"
      }, {
        h: 55,
        s: 1,
        b: .5,
        name: "dark blue"
      }, {
        h: 55,
        s: 1,
        b: 1,
        name: "sky blue"
      }, {
        h: 60,
        s: 0,
        b: .5,
        name: "gray"
      }, {
        h: 60,
        s: 0,
        b: 1,
        name: "very light blue"
      }, {
        h: 60,
        s: .5,
        b: .5,
        name: "blue"
      }, {
        h: 60,
        s: .5,
        b: 1,
        name: "light blue"
      }, {
        h: 60,
        s: 1,
        b: .5,
        name: "navy blue"
      }, {
        h: 60,
        s: 1,
        b: 1,
        name: "blue"
      }, {
        h: 65,
        s: 0,
        b: 1,
        name: "lavender"
      }, {
        h: 65,
        s: .5,
        b: .5,
        name: "navy blue"
      }, {
        h: 65,
        s: .5,
        b: 1,
        name: "light purple"
      }, {
        h: 65,
        s: 1,
        b: .5,
        name: "dark navy blue"
      }, {
        h: 65,
        s: 1,
        b: 1,
        name: "blue"
      }, {
        h: 70,
        s: 0,
        b: 1,
        name: "lavender"
      }, {
        h: 70,
        s: .5,
        b: .5,
        name: "navy blue"
      }, {
        h: 70,
        s: .5,
        b: 1,
        name: "lavender blue"
      }, {
        h: 70,
        s: 1,
        b: .5,
        name: "dark navy blue"
      }, {
        h: 70,
        s: 1,
        b: 1,
        name: "blue"
      }, {
        h: 75,
        s: .5,
        b: 1,
        name: "lavender"
      }, {
        h: 75,
        s: 1,
        b: .5,
        name: "dark purple"
      }, {
        h: 75,
        s: 1,
        b: 1,
        name: "purple"
      }, {
        h: 80,
        s: .5,
        b: 1,
        name: "pinkish purple"
      }, {
        h: 80,
        s: 1,
        b: .5,
        name: "dark purple"
      }, {
        h: 80,
        s: 1,
        b: 1,
        name: "purple"
      }, {
        h: 85,
        s: 0,
        b: 1,
        name: "light pink"
      }, {
        h: 85,
        s: .5,
        b: .5,
        name: "purple"
      }, {
        h: 85,
        s: .5,
        b: 1,
        name: "light fuchsia"
      }, {
        h: 85,
        s: 1,
        b: .5,
        name: "dark fuchsia"
      }, {
        h: 85,
        s: 1,
        b: 1,
        name: "fuchsia"
      }, {
        h: 90,
        s: .5,
        b: .5,
        name: "dark fuchsia"
      }, {
        h: 90,
        s: .5,
        b: 1,
        name: "hot pink"
      }, {
        h: 90,
        s: 1,
        b: .5,
        name: "dark fuchsia"
      }, {
        h: 90,
        s: 1,
        b: 1,
        name: "fuchsia"
      }, {
        h: 95,
        s: 0,
        b: 1,
        name: "pink"
      }, {
        h: 95,
        s: .5,
        b: 1,
        name: "light pink"
      }, {
        h: 95,
        s: 1,
        b: .5,
        name: "dark magenta"
      }, {
        h: 95,
        s: 1,
        b: 1,
        name: "magenta"
      }];

      i.default.prototype._rgbColorName = function (e) {
        var t = n.default._rgbaToHSBA(e);

        return function (e) {
          var t;

          if (0 !== e[0]) {
            e[0] = Math.round(100 * e[0]);
            var r = e[0].toString().split(""),
                i = r.length - 1;
            r[i] = parseInt(r[i]), r[i] < 2.5 ? r[i] = 0 : 2.5 <= r[i] && r[i] < 7.5 && (r[i] = 5), 2 === r.length ? (r[0] = parseInt(r[0]), 7.5 <= r[i] && (r[i] = 0, r[0] = r[0] + 1), e[0] = 10 * r[0] + r[1]) : 7.5 <= r[i] ? e[0] = 10 : e[0] = r[i];
          }

          e[2] = e[2] / 255;

          for (var n = e.length - 1; 1 <= n; n--) e[n] <= .25 ? e[n] = 0 : .25 < e[n] && e[n] < .75 ? e[n] = .5 : e[n] = 1;

          if (0 === e[0] && 0 === e[1] && 1 === e[2]) {
            for (var a = 2; 0 <= a; a--) l[a] = Math.round(1e4 * l[a]) / 1e4;

            for (var o = 0; o < u.length; o++) {
              if (u[o].h === l[0] && u[o].s === l[1] && u[o].b === l[2]) {
                t = u[o].name;
                break;
              }

              t = "white";
            }
          } else for (var s = 0; s < h.length; s++) if (h[s].h === e[0] && h[s].s === e[1] && h[s].b === e[2]) {
            t = h[s].name;
            break;
          }

          return t;
        }([(l = t)[0], t[1], t[2]]);
      };

      var o = i.default;
      r.default = o;
    }, {
      "../color/color_conversion": 22,
      "../core/main": 36
    }],
    17: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          o = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      var l = "_Description",
          u = "_fallbackDesc",
          h = "_fallbackTable",
          c = "_Label",
          f = "_labelDesc",
          d = "_labelTable";

      function s(e) {
        if ("label" === e || "fallback" === e) throw new Error("description should not be LABEL or FALLBACK");
        return e.endsWith(".") || e.endsWith(";") || e.endsWith(",") || e.endsWith("?") || e.endsWith("!") || (e += "."), e;
      }

      o.default.prototype.describe = function (e, t) {
        if (o.default._validateParameters("describe", arguments), "string" == typeof e) {
          var r = this.canvas.id;
          e = s(e), this.dummyDOM || (this.dummyDOM = document.getElementById(r).parentNode), this.descriptions || (this.descriptions = {}), this.descriptions.fallback ? this.descriptions.fallback.innerHTML !== e && (this.descriptions.fallback.innerHTML = e) : this._describeHTML("fallback", e), t === this.LABEL && (this.descriptions.label ? this.descriptions.label.innerHTML !== e && (this.descriptions.label.innerHTML = e) : this._describeHTML("label", e));
        }
      }, o.default.prototype.describeElement = function (e, t, r) {
        if (o.default._validateParameters("describeElement", arguments), "string" == typeof t && "string" == typeof e) {
          var i = this.canvas.id;
          t = s(t);

          var n = function (e) {
            if ("label" === e || "fallback" === e) throw new Error("element name should not be LABEL or FALLBACK");
            e.endsWith(".") || e.endsWith(";") || e.endsWith(",") ? e = e.replace(/.$/, ":") : e.endsWith(":") || (e += ":");
            return e;
          }(e);

          e = e.replace(/[^a-zA-Z0-9 ]/g, "");
          var a = '<th scope="row">'.concat(n, "</th><td>").concat(t, "</td>");
          this.dummyDOM || (this.dummyDOM = document.getElementById(i).parentNode), this.descriptions ? this.descriptions.fallbackElements || (this.descriptions.fallbackElements = {}) : this.descriptions = {
            fallbackElements: {}
          }, this.descriptions.fallbackElements[e] ? this.descriptions.fallbackElements[e].innerHTML !== a && (this.descriptions.fallbackElements[e].innerHTML = a) : this._describeElementHTML("fallback", e, a), r === this.LABEL && (this.descriptions.labelElements || (this.descriptions.labelElements = {}), this.descriptions.labelElements[e] ? this.descriptions.labelElements[e].innerHTML !== a && (this.descriptions.labelElements[e].innerHTML = a) : this._describeElementHTML("label", e, a));
        }
      }, o.default.prototype._describeHTML = function (e, t) {
        var r = this.canvas.id;

        if ("fallback" === e) {
          if (this.dummyDOM.querySelector("#".concat(r + l))) this.dummyDOM.querySelector("#" + r + h).insertAdjacentHTML("beforebegin", '<p id="'.concat(r + u, '"></p>'));else {
            var i = '<div id="'.concat(r).concat(l, '" role="region" aria-label="Canvas Description"><p id="').concat(r).concat(u, '"></p></div>');
            this.dummyDOM.querySelector("#".concat(r, "accessibleOutput")) ? this.dummyDOM.querySelector("#".concat(r, "accessibleOutput")).insertAdjacentHTML("beforebegin", i) : this.dummyDOM.querySelector("#".concat(r)).innerHTML = i;
          }
          return this.descriptions.fallback = this.dummyDOM.querySelector("#".concat(r).concat(u)), void (this.descriptions.fallback.innerHTML = t);
        }

        if ("label" === e) {
          if (this.dummyDOM.querySelector("#".concat(r + c))) this.dummyDOM.querySelector("#".concat(r + d)) && this.dummyDOM.querySelector("#".concat(r + d)).insertAdjacentHTML("beforebegin", '<p id="'.concat(r).concat(f, '"></p>'));else {
            var n = '<div id="'.concat(r).concat(c, '" class="p5Label"><p id="').concat(r).concat(f, '"></p></div>');
            this.dummyDOM.querySelector("#".concat(r, "accessibleOutputLabel")) ? this.dummyDOM.querySelector("#".concat(r, "accessibleOutputLabel")).insertAdjacentHTML("beforebegin", n) : this.dummyDOM.querySelector("#" + r).insertAdjacentHTML("afterend", n);
          }
          return this.descriptions.label = this.dummyDOM.querySelector("#" + r + f), void (this.descriptions.label.innerHTML = t);
        }
      }, o.default.prototype._describeElementHTML = function (e, t, r) {
        var i = this.canvas.id;

        if ("fallback" === e) {
          if (this.dummyDOM.querySelector("#".concat(i + l))) this.dummyDOM.querySelector("#" + i + h) || this.dummyDOM.querySelector("#" + i + u).insertAdjacentHTML("afterend", '<table id="'.concat(i).concat(h, '"><caption>Canvas elements and their descriptions</caption></table>'));else {
            var n = '<div id="'.concat(i).concat(l, '" role="region" aria-label="Canvas Description"><table id="').concat(i).concat(h, '"><caption>Canvas elements and their descriptions</caption></table></div>');
            this.dummyDOM.querySelector("#".concat(i, "accessibleOutput")) ? this.dummyDOM.querySelector("#".concat(i, "accessibleOutput")).insertAdjacentHTML("beforebegin", n) : this.dummyDOM.querySelector("#" + i).innerHTML = n;
          }
          var a = document.createElement("tr");
          return a.id = i + "_fte_" + t, this.dummyDOM.querySelector("#" + i + h).appendChild(a), this.descriptions.fallbackElements[t] = this.dummyDOM.querySelector("#".concat(i).concat("_fte_").concat(t)), void (this.descriptions.fallbackElements[t].innerHTML = r);
        }

        if ("label" === e) {
          if (this.dummyDOM.querySelector("#".concat(i + c))) this.dummyDOM.querySelector("#".concat(i + d)) || this.dummyDOM.querySelector("#" + i + f).insertAdjacentHTML("afterend", '<table id="'.concat(i + d, '"></table>'));else {
            var o = '<div id="'.concat(i).concat(c, '" class="p5Label"><table id="').concat(i).concat(d, '"></table></div>');
            this.dummyDOM.querySelector("#".concat(i, "accessibleOutputLabel")) ? this.dummyDOM.querySelector("#".concat(i, "accessibleOutputLabel")).insertAdjacentHTML("beforebegin", o) : this.dummyDOM.querySelector("#" + i).insertAdjacentHTML("afterend", o);
          }
          var s = document.createElement("tr");
          s.id = i + "_lte_" + t, this.dummyDOM.querySelector("#" + i + d).appendChild(s), this.descriptions.labelElements[t] = this.dummyDOM.querySelector("#".concat(i).concat("_lte_").concat(t)), this.descriptions.labelElements[t].innerHTML = r;
        }
      };
      var n = o.default;
      r.default = n;
    }, {
      "../core/main": 36
    }],
    18: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };

      n.default.prototype._updateGridOutput = function (e) {
        if (this.dummyDOM.querySelector("#".concat(e, "_summary"))) {
          var t = this._accessibleOutputs[e],
              r = function (e, t) {
            var r = "",
                i = "",
                n = 0;

            for (var a in t) {
              var o = 0;

              for (var s in t[a]) {
                var l = '<li id="'.concat(e, "shape").concat(n, '">').concat(t[a][s].color, " ").concat(a, ",");
                "line" === a ? l += " location = ".concat(t[a][s].pos, ", length = ").concat(t[a][s].length, " pixels") : (l += " location = ".concat(t[a][s].pos), "point" !== a && (l += ", area = ".concat(t[a][s].area, " %")), l += "</li>"), r += l, o++, n++;
              }

              i = 1 < o ? "".concat(i, " ").concat(o, " ").concat(a, "s") : "".concat(i, " ").concat(o, " ").concat(a);
            }

            return {
              numShapes: [n, i],
              details: r
            };
          }(e, this.ingredients.shapes),
              i = function (e, t, r, i) {
            var n = "".concat(t, " canvas, ").concat(r, " by ").concat(i, " pixels, contains ").concat(e[0]);
            n = 1 === e[0] ? "".concat(n, " shape: ").concat(e[1]) : "".concat(n, " shapes: ").concat(e[1]);
            return n;
          }(r.numShapes, this.ingredients.colors.background, this.width, this.height),
              n = function (e, t) {
            var r = 0,
                i = "",
                n = Array.apply(null, Array(10)).map(function () {});

            for (var a in n) n[a] = Array.apply(null, Array(10)).map(function () {});

            for (var o in t) for (var s in t[o]) {
              var l = void 0;
              l = "line" !== o ? '<a href="#'.concat(e, "shape").concat(r, '">').concat(t[o][s].color, " ").concat(o, "</a>") : '<a href="#'.concat(e, "shape").concat(r, '">').concat(t[o][s].color, " ").concat(o, " midpoint</a>"), n[t[o][s].loc.locY][t[o][s].loc.locX] ? n[t[o][s].loc.locY][t[o][s].loc.locX] = n[t[o][s].loc.locY][t[o][s].loc.locX] + "  " + l : n[t[o][s].loc.locY][t[o][s].loc.locX] = l, r++;
            }

            for (var u in n) {
              var h = "<tr>";

              for (var c in n[u]) h += "<td>", void 0 !== n[u][c] && (h += n[u][c]), h += "</td>";

              i = i + h + "</tr>";
            }

            return i;
          }(e, this.ingredients.shapes);

          i !== t.summary.innerHTML && (t.summary.innerHTML = i), n !== t.map.innerHTML && (t.map.innerHTML = n), r.details !== t.shapeDetails.innerHTML && (t.shapeDetails.innerHTML = r.details), this._accessibleOutputs[e] = t;
        }
      };

      var a = n.default;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    19: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };

      function l(e, t, r) {
        return e[0] < .4 * t ? e[1] < .4 * r ? "top left" : e[1] > .6 * r ? "bottom left" : "mid left" : e[0] > .6 * t ? e[1] < .4 * r ? "top right" : e[1] > .6 * r ? "bottom right" : "mid right" : e[1] < .4 * r ? "top middle" : e[1] > .6 * r ? "bottom middle" : "middle";
      }

      function u(e, t, r) {
        var i = Math.floor(e[0] / t * 10),
            n = Math.floor(e[1] / r * 10);
        return 10 === i && --i, 10 === n && --n, {
          locX: i,
          locY: n
        };
      }

      n.default.prototype.textOutput = function (e) {
        n.default._validateParameters("textOutput", arguments), this._accessibleOutputs.text || (this._accessibleOutputs.text = !0, this._createOutput("textOutput", "Fallback"), e === this.LABEL && (this._accessibleOutputs.textLabel = !0, this._createOutput("textOutput", "Label")));
      }, n.default.prototype.gridOutput = function (e) {
        n.default._validateParameters("gridOutput", arguments), this._accessibleOutputs.grid || (this._accessibleOutputs.grid = !0, this._createOutput("gridOutput", "Fallback"), e === this.LABEL && (this._accessibleOutputs.gridLabel = !0, this._createOutput("gridOutput", "Label")));
      }, n.default.prototype._addAccsOutput = function () {
        return this._accessibleOutputs || (this._accessibleOutputs = {
          text: !1,
          grid: !1,
          textLabel: !1,
          gridLabel: !1
        }), this._accessibleOutputs.grid || this._accessibleOutputs.text;
      }, n.default.prototype._createOutput = function (e, t) {
        var r,
            i,
            n,
            a = this.canvas.id;
        this.ingredients || (this.ingredients = {
          shapes: {},
          colors: {
            background: "white",
            fill: "white",
            stroke: "black"
          },
          pShapes: ""
        }), this.dummyDOM || (this.dummyDOM = document.getElementById(a).parentNode);
        var o = "";
        "Fallback" === t ? (r = a + e, i = a + "accessibleOutput", this.dummyDOM.querySelector("#".concat(i)) || (this.dummyDOM.querySelector("#".concat(a, "_Description")) ? this.dummyDOM.querySelector("#".concat(a, "_Description")).insertAdjacentHTML("afterend", '<div id="'.concat(i, '" role="region" aria-label="Canvas Outputs"></div>')) : this.dummyDOM.querySelector("#".concat(a)).innerHTML = '<div id="'.concat(i, '" role="region" aria-label="Canvas Outputs"></div>'))) : "Label" === t && (r = a + e + (o = t), i = a + "accessibleOutput" + t, this.dummyDOM.querySelector("#".concat(i)) || (this.dummyDOM.querySelector("#".concat(a, "_Label")) ? this.dummyDOM.querySelector("#".concat(a, "_Label")).insertAdjacentHTML("afterend", '<div id="'.concat(i, '"></div>')) : this.dummyDOM.querySelector("#".concat(a)).insertAdjacentHTML("afterend", '<div id="'.concat(i, '"></div>')))), this._accessibleOutputs[r] = {}, "textOutput" === e ? (o = "#".concat(a, "gridOutput").concat(o), n = '<div id="'.concat(r, '">Text Output<div id="').concat(r, 'Summary" aria-label="text output summary"><p id="').concat(r, '_summary"></p><ul id="').concat(r, '_list"></ul></div><table id="').concat(r, '_shapeDetails" summary="text output shape details"></table></div>'), this.dummyDOM.querySelector(o) ? this.dummyDOM.querySelector(o).insertAdjacentHTML("beforebegin", n) : this.dummyDOM.querySelector("#".concat(i)).innerHTML = n, this._accessibleOutputs[r].list = this.dummyDOM.querySelector("#".concat(r, "_list"))) : "gridOutput" === e && (o = "#".concat(a, "textOutput").concat(o), n = '<div id="'.concat(r, '">Grid Output<p id="').concat(r, '_summary" aria-label="grid output summary"><table id="').concat(r, '_map" summary="grid output content"></table><ul id="').concat(r, '_shapeDetails" aria-label="grid output shape details"></ul></div>'), this.dummyDOM.querySelector(o) ? this.dummyDOM.querySelector(o).insertAdjacentHTML("afterend", n) : this.dummyDOM.querySelector("#".concat(i)).innerHTML = n, this._accessibleOutputs[r].map = this.dummyDOM.querySelector("#".concat(r, "_map"))), this._accessibleOutputs[r].shapeDetails = this.dummyDOM.querySelector("#".concat(r, "_shapeDetails")), this._accessibleOutputs[r].summary = this.dummyDOM.querySelector("#".concat(r, "_summary"));
      }, n.default.prototype._updateAccsOutput = function () {
        var e = this.canvas.id;
        JSON.stringify(this.ingredients.shapes) !== this.ingredients.pShapes && (this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes), this._accessibleOutputs.text && this._updateTextOutput(e + "textOutput"), this._accessibleOutputs.grid && this._updateGridOutput(e + "gridOutput"), this._accessibleOutputs.textLabel && this._updateTextOutput(e + "textOutputLabel"), this._accessibleOutputs.gridLabel && this._updateGridOutput(e + "gridOutputLabel"));
      }, n.default.prototype._accsBackground = function (e) {
        this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes), this.ingredients.shapes = {}, this.ingredients.colors.backgroundRGBA !== e && (this.ingredients.colors.backgroundRGBA = e, this.ingredients.colors.background = this._rgbColorName(e));
      }, n.default.prototype._accsCanvasColors = function (e, t) {
        "fill" === e ? this.ingredients.colors.fillRGBA !== t && (this.ingredients.colors.fillRGBA = t, this.ingredients.colors.fill = this._rgbColorName(t)) : "stroke" === e && this.ingredients.colors.strokeRGBA !== t && (this.ingredients.colors.strokeRGBA = t, this.ingredients.colors.stroke = this._rgbColorName(t));
      }, n.default.prototype._accsOutput = function (e, t) {
        "ellipse" === e && t[2] === t[3] ? e = "circle" : "rectangle" === e && t[2] === t[3] && (e = "square");

        var r = {},
            i = !0,
            n = function (e, t) {
          var r, i;
          i = "rectangle" === e || "ellipse" === e || "arc" === e || "circle" === e || "square" === e ? (r = Math.round(t[0] + t[2] / 2), Math.round(t[1] + t[3] / 2)) : "triangle" === e ? (r = (t[0] + t[2] + t[4]) / 3, (t[1] + t[3] + t[5]) / 3) : "quadrilateral" === e ? (r = (t[0] + t[2] + t[4] + t[6]) / 4, (t[1] + t[3] + t[5] + t[7]) / 4) : "line" === e ? (r = (t[0] + t[2]) / 2, (t[1] + t[3]) / 2) : (r = t[0], t[1]);
          return [r, i];
        }(e, t);

        if ("line" === e) {
          r.color = this.ingredients.colors.stroke, r.length = Math.round(this.dist(t[0], t[1], t[2], t[3]));
          var a = l([t[0], [1]], this.width, this.height),
              o = l([t[2], [3]], this.width, this.height);
          r.loc = u(n, this.width, this.height), r.pos = a === o ? "at ".concat(a) : "from ".concat(a, " to ").concat(o);
        } else "point" === e ? r.color = this.ingredients.colors.stroke : (r.color = this.ingredients.colors.fill, r.area = function (e, t, r, i) {
          var n = 0;

          if ("arc" === e) {
            var a = ((t[5] - t[4]) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);

            if (n = a * t[2] * t[3] / 8, "open" === t[6] || "chord" === t[6]) {
              var o = t[0],
                  s = t[1],
                  l = t[0] + t[2] / 2 * Math.cos(t[4]).toFixed(2),
                  u = t[1] + t[3] / 2 * Math.sin(t[4]).toFixed(2),
                  h = t[0] + t[2] / 2 * Math.cos(t[5]).toFixed(2),
                  c = t[1] + t[3] / 2 * Math.sin(t[5]).toFixed(2),
                  f = Math.abs(o * (u - c) + l * (c - s) + h * (s - u)) / 2;
              a > Math.PI ? n += f : n -= f;
            }
          } else "ellipse" === e || "circle" === e ? n = 3.14 * t[2] / 2 * t[3] / 2 : "line" === e ? n = 0 : "point" === e ? n = 0 : "quadrilateral" === e ? n = Math.abs((t[6] + t[0]) * (t[7] - t[1]) + (t[0] + t[2]) * (t[1] - t[3]) + (t[2] + t[4]) * (t[3] - t[5]) + (t[4] + t[6]) * (t[5] - t[7])) / 2 : "rectangle" === e || "square" === e ? n = t[2] * t[3] : "triangle" === e && (n = Math.abs(t[0] * (t[3] - t[5]) + t[2] * (t[5] - t[1]) + t[4] * (t[1] - t[3])) / 2);

          return Math.round(100 * n / (r * i));
        }(e, t, this.width, this.height)), r.pos = l(n, this.width, this.height), r.loc = u(n, this.width, this.height);

        if (this.ingredients.shapes[e]) {
          if (this.ingredients.shapes[e] !== [r]) {
            for (var s in this.ingredients.shapes[e]) JSON.stringify(this.ingredients.shapes[e][s]) === JSON.stringify(r) && (i = !1);

            !0 === i && this.ingredients.shapes[e].push(r);
          }
        } else this.ingredients.shapes[e] = [r];
      };
      var a = n.default;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    20: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };

      n.default.prototype._updateTextOutput = function (e) {
        if (this.dummyDOM.querySelector("#".concat(e, "_summary"))) {
          var t = this._accessibleOutputs[e],
              r = function (e, t) {
            var r = "",
                i = 0;

            for (var n in t) for (var a in t[n]) {
              var o = '<li><a href="#'.concat(e, "shape").concat(i, '">').concat(t[n][a].color, " ").concat(n, "</a>");
              "line" === n ? o += ", ".concat(t[n][a].pos, ", ").concat(t[n][a].length, " pixels long.</li>") : (o += ", at ".concat(t[n][a].pos), "point" !== n && (o += ", covering ".concat(t[n][a].area, "% of the canvas")), o += ".</li>"), r += o, i++;
            }

            return {
              numShapes: i,
              listShapes: r
            };
          }(e, this.ingredients.shapes),
              i = function (e, t, r, i) {
            var n = "Your output is a, ".concat(r, " by ").concat(i, " pixels, ").concat(t, " canvas containing the following");
            n = 1 === e ? "".concat(n, " shape:") : "".concat(n, " ").concat(e, " shapes:");
            return n;
          }(r.numShapes, this.ingredients.colors.background, this.width, this.height),
              n = function (e, t) {
            var r = "",
                i = 0;

            for (var n in t) for (var a in t[n]) {
              var o = '<tr id="'.concat(e, "shape").concat(i, '"><th>').concat(t[n][a].color, " ").concat(n, "</th>");
              "line" === n ? o += "<td>location = ".concat(t[n][a].pos, "</td><td>length = ").concat(t[n][a].length, " pixels</td></tr>") : (o += "<td>location = ".concat(t[n][a].pos, "</td>"), "point" !== n && (o += "<td> area = ".concat(t[n][a].area, "%</td>")), o += "</tr>"), r += o, i++;
            }

            return r;
          }(e, this.ingredients.shapes);

          i !== t.summary.innerHTML && (t.summary.innerHTML = i), r.listShapes !== t.list.innerHTML && (t.list.innerHTML = r.listShapes), n !== t.shapeDetails.innerHTML && (t.shapeDetails.innerHTML = n), this._accessibleOutputs[e] = t;
        }
      };

      var a = n.default;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    21: [function (e, t, r) {
      "use strict";

      var i,
          n = (i = e("./core/main")) && i.__esModule ? i : {
        default: i
      };
      e("./core/constants"), e("./core/environment"), e("./core/friendly_errors/stacktrace"), e("./core/friendly_errors/validate_params"), e("./core/friendly_errors/file_errors"), e("./core/friendly_errors/fes_core"), e("./core/helpers"), e("./core/legacy"), e("./core/preload"), e("./core/p5.Element"), e("./core/p5.Graphics"), e("./core/p5.Renderer"), e("./core/p5.Renderer2D"), e("./core/rendering"), e("./core/shim"), e("./core/structure"), e("./core/transform"), e("./core/shape/2d_primitives"), e("./core/shape/attributes"), e("./core/shape/curves"), e("./core/shape/vertex"), e("./accessibility/outputs"), e("./accessibility/textOutput"), e("./accessibility/gridOutput"), e("./accessibility/color_namer"), e("./color/color_conversion"), e("./color/creating_reading"), e("./color/p5.Color"), e("./color/setting"), e("./data/p5.TypedDict"), e("./data/local_storage.js"), e("./dom/dom"), e("./accessibility/describe"), e("./events/acceleration"), e("./events/keyboard"), e("./events/mouse"), e("./events/touch"), e("./image/filters"), e("./image/image"), e("./image/loading_displaying"), e("./image/p5.Image"), e("./image/pixels"), e("./io/files"), e("./io/p5.Table"), e("./io/p5.TableRow"), e("./io/p5.XML"), e("./math/calculation"), e("./math/math"), e("./math/noise"), e("./math/p5.Vector"), e("./math/random"), e("./math/trigonometry"), e("./typography/attributes"), e("./typography/loading_displaying"), e("./typography/p5.Font"), e("./utilities/array_functions"), e("./utilities/conversion"), e("./utilities/string_functions"), e("./utilities/time_date"), e("./webgl/3d_primitives"), e("./webgl/interaction"), e("./webgl/light"), e("./webgl/loading"), e("./webgl/material"), e("./webgl/p5.Camera"), e("./webgl/p5.Geometry"), e("./webgl/p5.Matrix"), e("./webgl/p5.RendererGL.Immediate"), e("./webgl/p5.RendererGL"), e("./webgl/p5.RendererGL.Retained"), e("./webgl/p5.Shader"), e("./webgl/p5.RenderBuffer"), e("./webgl/p5.Texture"), e("./webgl/text"), e("./core/init"), t.exports = n.default;
    }, {
      "./accessibility/color_namer": 16,
      "./accessibility/describe": 17,
      "./accessibility/gridOutput": 18,
      "./accessibility/outputs": 19,
      "./accessibility/textOutput": 20,
      "./color/color_conversion": 22,
      "./color/creating_reading": 23,
      "./color/p5.Color": 24,
      "./color/setting": 25,
      "./core/constants": 26,
      "./core/environment": 27,
      "./core/friendly_errors/fes_core": 28,
      "./core/friendly_errors/file_errors": 29,
      "./core/friendly_errors/stacktrace": 30,
      "./core/friendly_errors/validate_params": 31,
      "./core/helpers": 32,
      "./core/init": 33,
      "./core/legacy": 35,
      "./core/main": 36,
      "./core/p5.Element": 37,
      "./core/p5.Graphics": 38,
      "./core/p5.Renderer": 39,
      "./core/p5.Renderer2D": 40,
      "./core/preload": 41,
      "./core/rendering": 42,
      "./core/shape/2d_primitives": 43,
      "./core/shape/attributes": 44,
      "./core/shape/curves": 45,
      "./core/shape/vertex": 46,
      "./core/shim": 47,
      "./core/structure": 48,
      "./core/transform": 49,
      "./data/local_storage.js": 50,
      "./data/p5.TypedDict": 51,
      "./dom/dom": 52,
      "./events/acceleration": 53,
      "./events/keyboard": 54,
      "./events/mouse": 55,
      "./events/touch": 56,
      "./image/filters": 57,
      "./image/image": 58,
      "./image/loading_displaying": 59,
      "./image/p5.Image": 60,
      "./image/pixels": 61,
      "./io/files": 62,
      "./io/p5.Table": 63,
      "./io/p5.TableRow": 64,
      "./io/p5.XML": 65,
      "./math/calculation": 66,
      "./math/math": 67,
      "./math/noise": 68,
      "./math/p5.Vector": 69,
      "./math/random": 70,
      "./math/trigonometry": 71,
      "./typography/attributes": 72,
      "./typography/loading_displaying": 73,
      "./typography/p5.Font": 74,
      "./utilities/array_functions": 75,
      "./utilities/conversion": 76,
      "./utilities/string_functions": 77,
      "./utilities/time_date": 78,
      "./webgl/3d_primitives": 79,
      "./webgl/interaction": 80,
      "./webgl/light": 81,
      "./webgl/loading": 82,
      "./webgl/material": 83,
      "./webgl/p5.Camera": 84,
      "./webgl/p5.Geometry": 85,
      "./webgl/p5.Matrix": 86,
      "./webgl/p5.RenderBuffer": 87,
      "./webgl/p5.RendererGL": 90,
      "./webgl/p5.RendererGL.Immediate": 88,
      "./webgl/p5.RendererGL.Retained": 89,
      "./webgl/p5.Shader": 91,
      "./webgl/p5.Texture": 92,
      "./webgl/text": 93
    }],
    22: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      n.default.ColorConversion = {}, n.default.ColorConversion._hsbaToHSLA = function (e) {
        var t = e[0],
            r = e[1],
            i = e[2],
            n = (2 - r) * i / 2;
        return 0 != n && (1 == n ? r = 0 : n < .5 ? r /= 2 - r : r = r * i / (2 - 2 * n)), [t, r, n, e[3]];
      }, n.default.ColorConversion._hsbaToRGBA = function (e) {
        var t = 6 * e[0],
            r = e[1],
            i = e[2],
            n = [];
        if (0 === r) n = [i, i, i, e[3]];else {
          var a,
              o,
              s,
              l = Math.floor(t),
              u = i * (1 - r),
              h = i * (1 - r * (t - l)),
              c = i * (1 - r * (1 + l - t));
          s = 1 === l ? (a = h, o = i, u) : 2 === l ? (a = u, o = i, c) : 3 === l ? (a = u, o = h, i) : 4 === l ? (a = c, o = u, i) : 5 === l ? (a = i, o = u, h) : (a = i, o = c, u), n = [a, o, s, e[3]];
        }
        return n;
      }, n.default.ColorConversion._hslaToHSBA = function (e) {
        var t,
            r = e[0],
            i = e[1],
            n = e[2];
        return [r, i = 2 * ((t = n < .5 ? (1 + i) * n : n + i - n * i) - n) / t, t, e[3]];
      }, n.default.ColorConversion._hslaToRGBA = function (e) {
        var t = 6 * e[0],
            r = e[1],
            i = e[2],
            n = [];
        if (0 === r) n = [i, i, i, e[3]];else {
          var a,
              o = 2 * i - (a = i < .5 ? (1 + r) * i : i + r - i * r),
              s = function (e, t, r) {
            return e < 0 ? e += 6 : 6 <= e && (e -= 6), e < 1 ? t + (r - t) * e : e < 3 ? r : e < 4 ? t + (r - t) * (4 - e) : t;
          };

          n = [s(2 + t, o, a), s(t, o, a), s(t - 2, o, a), e[3]];
        }
        return n;
      }, n.default.ColorConversion._rgbaToHSBA = function (e) {
        var t,
            r,
            i = e[0],
            n = e[1],
            a = e[2],
            o = Math.max(i, n, a),
            s = o - Math.min(i, n, a);
        return 0 == s ? r = t = 0 : (r = s / o, i === o ? t = (n - a) / s : n === o ? t = 2 + (a - i) / s : a === o && (t = 4 + (i - n) / s), t < 0 ? t += 6 : 6 <= t && (t -= 6)), [t / 6, r, o, e[3]];
      }, n.default.ColorConversion._rgbaToHSLA = function (e) {
        var t,
            r,
            i = e[0],
            n = e[1],
            a = e[2],
            o = Math.max(i, n, a),
            s = Math.min(i, n, a),
            l = o + s,
            u = o - s;
        return 0 == u ? r = t = 0 : (r = l < 1 ? u / l : u / (2 - l), i === o ? t = (n - a) / u : n === o ? t = 2 + (a - i) / u : a === o && (t = 4 + (i - n) / u), t < 0 ? t += 6 : 6 <= t && (t -= 6)), [t / 6, r, l / 2, e[3]];
      };
      var a = n.default.ColorConversion;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    23: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var i,
          c = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      },
          f = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../core/constants"));

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      e("./p5.Color"), e("../core/friendly_errors/validate_params"), e("../core/friendly_errors/file_errors"), e("../core/friendly_errors/fes_core"), c.default.prototype.alpha = function (e) {
        return c.default._validateParameters("alpha", arguments), this.color(e)._getAlpha();
      }, c.default.prototype.blue = function (e) {
        return c.default._validateParameters("blue", arguments), this.color(e)._getBlue();
      }, c.default.prototype.brightness = function (e) {
        return c.default._validateParameters("brightness", arguments), this.color(e)._getBrightness();
      }, c.default.prototype.color = function () {
        if (c.default._validateParameters("color", arguments), arguments[0] instanceof c.default.Color) return arguments[0];
        var e = arguments[0] instanceof Array ? arguments[0] : arguments;
        return new c.default.Color(this, e);
      }, c.default.prototype.green = function (e) {
        return c.default._validateParameters("green", arguments), this.color(e)._getGreen();
      }, c.default.prototype.hue = function (e) {
        return c.default._validateParameters("hue", arguments), this.color(e)._getHue();
      }, c.default.prototype.lerpColor = function (e, t, r) {
        c.default._validateParameters("lerpColor", arguments);

        var i,
            n,
            a,
            o,
            s,
            l,
            u = this._colorMode,
            h = this._colorMaxes;
        if (u === f.RGB) s = e.levels.map(function (e) {
          return e / 255;
        }), l = t.levels.map(function (e) {
          return e / 255;
        });else if (u === f.HSB) e._getBrightness(), t._getBrightness(), s = e.hsba, l = t.hsba;else {
          if (u !== f.HSL) throw new Error("".concat(u, "cannot be used for interpolation."));
          e._getLightness(), t._getLightness(), s = e.hsla, l = t.hsla;
        }
        return r = Math.max(Math.min(r, 1), 0), void 0 === this.lerp && (this.lerp = function (e, t, r) {
          return r * (t - e) + e;
        }), i = this.lerp(s[0], l[0], r), n = this.lerp(s[1], l[1], r), a = this.lerp(s[2], l[2], r), o = this.lerp(s[3], l[3], r), i *= h[u][0], n *= h[u][1], a *= h[u][2], o *= h[u][3], this.color(i, n, a, o);
      }, c.default.prototype.lightness = function (e) {
        return c.default._validateParameters("lightness", arguments), this.color(e)._getLightness();
      }, c.default.prototype.red = function (e) {
        return c.default._validateParameters("red", arguments), this.color(e)._getRed();
      }, c.default.prototype.saturation = function (e) {
        return c.default._validateParameters("saturation", arguments), this.color(e)._getSaturation();
      };
      var n = c.default;
      r.default = n;
    }, {
      "../core/constants": 26,
      "../core/friendly_errors/fes_core": 28,
      "../core/friendly_errors/file_errors": 29,
      "../core/friendly_errors/validate_params": 31,
      "../core/main": 36,
      "./p5.Color": 24
    }],
    24: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var c = i(e("../core/main")),
          f = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../core/constants")),
          d = i(e("./color_conversion"));

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      function i(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      c.default.Color = function (e, t) {
        if (this._storeModeAndMaxes(e._colorMode, e._colorMaxes), this.mode !== f.RGB && this.mode !== f.HSL && this.mode !== f.HSB) throw new Error("".concat(this.mode, " is an invalid colorMode."));
        return this._array = c.default.Color._parseInputs.apply(this, t), this._calculateLevels(), this;
      }, c.default.Color.prototype.toString = function (e) {
        var t = this.levels,
            r = this._array,
            i = r[3];

        switch (e) {
          case "#rrggbb":
            return "#".concat(t[0] < 16 ? "0".concat(t[0].toString(16)) : t[0].toString(16), t[1] < 16 ? "0".concat(t[1].toString(16)) : t[1].toString(16), t[2] < 16 ? "0".concat(t[2].toString(16)) : t[2].toString(16));

          case "#rrggbbaa":
            return "#".concat(t[0] < 16 ? "0".concat(t[0].toString(16)) : t[0].toString(16), t[1] < 16 ? "0".concat(t[1].toString(16)) : t[1].toString(16), t[2] < 16 ? "0".concat(t[2].toString(16)) : t[2].toString(16), t[3] < 16 ? "0".concat(t[2].toString(16)) : t[3].toString(16));

          case "#rgb":
            return "#".concat(Math.round(15 * r[0]).toString(16), Math.round(15 * r[1]).toString(16), Math.round(15 * r[2]).toString(16));

          case "#rgba":
            return "#".concat(Math.round(15 * r[0]).toString(16), Math.round(15 * r[1]).toString(16), Math.round(15 * r[2]).toString(16), Math.round(15 * r[3]).toString(16));

          case "rgb":
            return "rgb(".concat(t[0], ", ", t[1], ", ", t[2], ")");

          case "rgb%":
            return "rgb(".concat((100 * r[0]).toPrecision(3), "%, ", (100 * r[1]).toPrecision(3), "%, ", (100 * r[2]).toPrecision(3), "%)");

          case "rgba%":
            return "rgba(".concat((100 * r[0]).toPrecision(3), "%, ", (100 * r[1]).toPrecision(3), "%, ", (100 * r[2]).toPrecision(3), "%, ", (100 * r[3]).toPrecision(3), "%)");

          case "hsb":
          case "hsv":
            return this.hsba || (this.hsba = d.default._rgbaToHSBA(this._array)), "hsb(".concat(this.hsba[0] * this.maxes[f.HSB][0], ", ", this.hsba[1] * this.maxes[f.HSB][1], ", ", this.hsba[2] * this.maxes[f.HSB][2], ")");

          case "hsb%":
          case "hsv%":
            return this.hsba || (this.hsba = d.default._rgbaToHSBA(this._array)), "hsb(".concat((100 * this.hsba[0]).toPrecision(3), "%, ", (100 * this.hsba[1]).toPrecision(3), "%, ", (100 * this.hsba[2]).toPrecision(3), "%)");

          case "hsba":
          case "hsva":
            return this.hsba || (this.hsba = d.default._rgbaToHSBA(this._array)), "hsba(".concat(this.hsba[0] * this.maxes[f.HSB][0], ", ", this.hsba[1] * this.maxes[f.HSB][1], ", ", this.hsba[2] * this.maxes[f.HSB][2], ", ", i, ")");

          case "hsba%":
          case "hsva%":
            return this.hsba || (this.hsba = d.default._rgbaToHSBA(this._array)), "hsba(".concat((100 * this.hsba[0]).toPrecision(3), "%, ", (100 * this.hsba[1]).toPrecision(3), "%, ", (100 * this.hsba[2]).toPrecision(3), "%, ", (100 * i).toPrecision(3), "%)");

          case "hsl":
            return this.hsla || (this.hsla = d.default._rgbaToHSLA(this._array)), "hsl(".concat(this.hsla[0] * this.maxes[f.HSL][0], ", ", this.hsla[1] * this.maxes[f.HSL][1], ", ", this.hsla[2] * this.maxes[f.HSL][2], ")");

          case "hsl%":
            return this.hsla || (this.hsla = d.default._rgbaToHSLA(this._array)), "hsl(".concat((100 * this.hsla[0]).toPrecision(3), "%, ", (100 * this.hsla[1]).toPrecision(3), "%, ", (100 * this.hsla[2]).toPrecision(3), "%)");

          case "hsla":
            return this.hsla || (this.hsla = d.default._rgbaToHSLA(this._array)), "hsla(".concat(this.hsla[0] * this.maxes[f.HSL][0], ", ", this.hsla[1] * this.maxes[f.HSL][1], ", ", this.hsla[2] * this.maxes[f.HSL][2], ", ", i, ")");

          case "hsla%":
            return this.hsla || (this.hsla = d.default._rgbaToHSLA(this._array)), "hsl(".concat((100 * this.hsla[0]).toPrecision(3), "%, ", (100 * this.hsla[1]).toPrecision(3), "%, ", (100 * this.hsla[2]).toPrecision(3), "%, ", (100 * i).toPrecision(3), "%)");

          case "rgba":
          default:
            return "rgba(".concat(t[0], ",", t[1], ",", t[2], ",", i, ")");
        }
      }, c.default.Color.prototype.setRed = function (e) {
        this._array[0] = e / this.maxes[f.RGB][0], this._calculateLevels();
      }, c.default.Color.prototype.setGreen = function (e) {
        this._array[1] = e / this.maxes[f.RGB][1], this._calculateLevels();
      }, c.default.Color.prototype.setBlue = function (e) {
        this._array[2] = e / this.maxes[f.RGB][2], this._calculateLevels();
      }, c.default.Color.prototype.setAlpha = function (e) {
        this._array[3] = e / this.maxes[this.mode][3], this._calculateLevels();
      }, c.default.Color.prototype._calculateLevels = function () {
        for (var e = this._array, t = this.levels = new Array(e.length), r = e.length - 1; 0 <= r; --r) t[r] = Math.round(255 * e[r]);
      }, c.default.Color.prototype._getAlpha = function () {
        return this._array[3] * this.maxes[this.mode][3];
      }, c.default.Color.prototype._storeModeAndMaxes = function (e, t) {
        this.mode = e, this.maxes = t;
      }, c.default.Color.prototype._getMode = function () {
        return this.mode;
      }, c.default.Color.prototype._getMaxes = function () {
        return this.maxes;
      }, c.default.Color.prototype._getBlue = function () {
        return this._array[2] * this.maxes[f.RGB][2];
      }, c.default.Color.prototype._getBrightness = function () {
        return this.hsba || (this.hsba = d.default._rgbaToHSBA(this._array)), this.hsba[2] * this.maxes[f.HSB][2];
      }, c.default.Color.prototype._getGreen = function () {
        return this._array[1] * this.maxes[f.RGB][1];
      }, c.default.Color.prototype._getHue = function () {
        return this.mode === f.HSB ? (this.hsba || (this.hsba = d.default._rgbaToHSBA(this._array)), this.hsba[0] * this.maxes[f.HSB][0]) : (this.hsla || (this.hsla = d.default._rgbaToHSLA(this._array)), this.hsla[0] * this.maxes[f.HSL][0]);
      }, c.default.Color.prototype._getLightness = function () {
        return this.hsla || (this.hsla = d.default._rgbaToHSLA(this._array)), this.hsla[2] * this.maxes[f.HSL][2];
      }, c.default.Color.prototype._getRed = function () {
        return this._array[0] * this.maxes[f.RGB][0];
      }, c.default.Color.prototype._getSaturation = function () {
        return this.mode === f.HSB ? (this.hsba || (this.hsba = d.default._rgbaToHSBA(this._array)), this.hsba[1] * this.maxes[f.HSB][1]) : (this.hsla || (this.hsla = d.default._rgbaToHSLA(this._array)), this.hsla[1] * this.maxes[f.HSL][1]);
      };
      var p = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavender: "#e6e6fa",
        lavenderblush: "#fff0f5",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
      },
          n = /\s*/,
          a = /(\d{1,3})/,
          l = /((?:\d+(?:\.\d+)?)|(?:\.\d+))/,
          u = new RegExp("".concat(l.source, "%")),
          m = {
        HEX3: /^#([a-f0-9])([a-f0-9])([a-f0-9])$/i,
        HEX4: /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])$/i,
        HEX6: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i,
        HEX8: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i,
        RGB: new RegExp(["^rgb\\(", a.source, ",", a.source, ",", a.source, "\\)$"].join(n.source), "i"),
        RGB_PERCENT: new RegExp(["^rgb\\(", u.source, ",", u.source, ",", u.source, "\\)$"].join(n.source), "i"),
        RGBA: new RegExp(["^rgba\\(", a.source, ",", a.source, ",", a.source, ",", l.source, "\\)$"].join(n.source), "i"),
        RGBA_PERCENT: new RegExp(["^rgba\\(", u.source, ",", u.source, ",", u.source, ",", l.source, "\\)$"].join(n.source), "i"),
        HSL: new RegExp(["^hsl\\(", a.source, ",", u.source, ",", u.source, "\\)$"].join(n.source), "i"),
        HSLA: new RegExp(["^hsla\\(", a.source, ",", u.source, ",", u.source, ",", l.source, "\\)$"].join(n.source), "i"),
        HSB: new RegExp(["^hsb\\(", a.source, ",", u.source, ",", u.source, "\\)$"].join(n.source), "i"),
        HSBA: new RegExp(["^hsba\\(", a.source, ",", u.source, ",", u.source, ",", l.source, "\\)$"].join(n.source), "i")
      };

      c.default.Color._parseInputs = function (e, t, r, i) {
        var n,
            a = arguments.length,
            o = this.mode,
            s = this.maxes[o],
            l = [];

        if (3 <= a) {
          for (l[0] = e / s[0], l[1] = t / s[1], l[2] = r / s[2], l[3] = "number" == typeof i ? i / s[3] : 1, n = l.length - 1; 0 <= n; --n) {
            var u = l[n];
            u < 0 ? l[n] = 0 : 1 < u && (l[n] = 1);
          }

          return o === f.HSL ? d.default._hslaToRGBA(l) : o === f.HSB ? d.default._hsbaToRGBA(l) : l;
        }

        if (1 === a && "string" == typeof e) {
          var h = e.trim().toLowerCase();
          if (p[h]) return c.default.Color._parseInputs.call(this, p[h]);
          if (m.HEX3.test(h)) return (l = m.HEX3.exec(h).slice(1).map(function (e) {
            return parseInt(e + e, 16) / 255;
          }))[3] = 1, l;
          if (m.HEX6.test(h)) return (l = m.HEX6.exec(h).slice(1).map(function (e) {
            return parseInt(e, 16) / 255;
          }))[3] = 1, l;
          if (m.HEX4.test(h)) return l = m.HEX4.exec(h).slice(1).map(function (e) {
            return parseInt(e + e, 16) / 255;
          });
          if (m.HEX8.test(h)) return l = m.HEX8.exec(h).slice(1).map(function (e) {
            return parseInt(e, 16) / 255;
          });
          if (m.RGB.test(h)) return (l = m.RGB.exec(h).slice(1).map(function (e) {
            return e / 255;
          }))[3] = 1, l;
          if (m.RGB_PERCENT.test(h)) return (l = m.RGB_PERCENT.exec(h).slice(1).map(function (e) {
            return parseFloat(e) / 100;
          }))[3] = 1, l;
          if (m.RGBA.test(h)) return l = m.RGBA.exec(h).slice(1).map(function (e, t) {
            return 3 === t ? parseFloat(e) : e / 255;
          });
          if (m.RGBA_PERCENT.test(h)) return l = m.RGBA_PERCENT.exec(h).slice(1).map(function (e, t) {
            return 3 === t ? parseFloat(e) : parseFloat(e) / 100;
          });
          if (m.HSL.test(h) ? (l = m.HSL.exec(h).slice(1).map(function (e, t) {
            return 0 === t ? parseInt(e, 10) / 360 : parseInt(e, 10) / 100;
          }))[3] = 1 : m.HSLA.test(h) && (l = m.HSLA.exec(h).slice(1).map(function (e, t) {
            return 0 === t ? parseInt(e, 10) / 360 : 3 === t ? parseFloat(e) : parseInt(e, 10) / 100;
          })), (l = l.map(function (e) {
            return Math.max(Math.min(e, 1), 0);
          })).length) return d.default._hslaToRGBA(l);

          if (m.HSB.test(h) ? (l = m.HSB.exec(h).slice(1).map(function (e, t) {
            return 0 === t ? parseInt(e, 10) / 360 : parseInt(e, 10) / 100;
          }))[3] = 1 : m.HSBA.test(h) && (l = m.HSBA.exec(h).slice(1).map(function (e, t) {
            return 0 === t ? parseInt(e, 10) / 360 : 3 === t ? parseFloat(e) : parseInt(e, 10) / 100;
          })), l.length) {
            for (n = l.length - 1; 0 <= n; --n) l[n] = Math.max(Math.min(l[n], 1), 0);

            return d.default._hsbaToRGBA(l);
          }

          l = [1, 1, 1, 1];
        } else {
          if (1 !== a && 2 !== a || "number" != typeof e) throw new Error("".concat(arguments, "is not a valid color representation."));
          l[0] = e / s[2], l[1] = e / s[2], l[2] = e / s[2], l[3] = "number" == typeof t ? t / s[3] : 1, l = l.map(function (e) {
            return Math.max(Math.min(e, 1), 0);
          });
        }

        return l;
      };

      var h = c.default.Color;
      r.default = h;
    }, {
      "../core/constants": 26,
      "../core/main": 36,
      "./color_conversion": 22
    }],
    25: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var i,
          s = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      },
          l = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = u();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../core/constants"));

      function u() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return u = function () {
          return e;
        }, e;
      }

      e("./p5.Color"), s.default.prototype.background = function () {
        var e;
        return (e = this._renderer).background.apply(e, arguments), this;
      }, s.default.prototype.clear = function () {
        return this._renderer.clear(), this;
      }, s.default.prototype.colorMode = function (e, t, r, i, n) {
        if (s.default._validateParameters("colorMode", arguments), e === l.RGB || e === l.HSB || e === l.HSL) {
          this._colorMode = e;
          var a = this._colorMaxes[e];
          2 === arguments.length ? (a[0] = t, a[1] = t, a[2] = t, a[3] = t) : 4 === arguments.length ? (a[0] = t, a[1] = r, a[2] = i) : 5 === arguments.length && (a[0] = t, a[1] = r, a[2] = i, a[3] = n);
        }

        return this;
      }, s.default.prototype.fill = function () {
        var e;
        return this._renderer._setProperty("_fillSet", !0), this._renderer._setProperty("_doFill", !0), (e = this._renderer).fill.apply(e, arguments), this;
      }, s.default.prototype.noFill = function () {
        return this._renderer._setProperty("_doFill", !1), this;
      }, s.default.prototype.noStroke = function () {
        return this._renderer._setProperty("_doStroke", !1), this;
      }, s.default.prototype.stroke = function () {
        var e;
        return this._renderer._setProperty("_strokeSet", !0), this._renderer._setProperty("_doStroke", !0), (e = this._renderer).stroke.apply(e, arguments), this;
      }, s.default.prototype.erase = function () {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 255,
            t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 255;
        return this._renderer.erase(e, t), this;
      }, s.default.prototype.noErase = function () {
        return this._renderer.noErase(), this;
      };
      var n = s.default;
      r.default = n;
    }, {
      "../core/constants": 26,
      "../core/main": 36,
      "./p5.Color": 24
    }],
    26: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.FILL = r.STROKE = r.CURVE = r.BEZIER = r.QUADRATIC = r.LINEAR = r._CTX_MIDDLE = r._DEFAULT_LEADMULT = r._DEFAULT_TEXT_FILL = r.BOLDITALIC = r.BOLD = r.ITALIC = r.NORMAL = r.BLUR = r.ERODE = r.DILATE = r.POSTERIZE = r.INVERT = r.OPAQUE = r.GRAY = r.THRESHOLD = r.BURN = r.DODGE = r.SOFT_LIGHT = r.HARD_LIGHT = r.OVERLAY = r.REPLACE = r.SCREEN = r.MULTIPLY = r.EXCLUSION = r.SUBTRACT = r.DIFFERENCE = r.LIGHTEST = r.DARKEST = r.ADD = r.REMOVE = r.BLEND = r.UP_ARROW = r.TAB = r.SHIFT = r.RIGHT_ARROW = r.RETURN = r.OPTION = r.LEFT_ARROW = r.ESCAPE = r.ENTER = r.DOWN_ARROW = r.DELETE = r.CONTROL = r.BACKSPACE = r.ALT = r.AUTO = r.HSL = r.HSB = r.RGB = r.MITER = r.BEVEL = r.ROUND = r.SQUARE = r.PROJECT = r.PIE = r.CHORD = r.OPEN = r.CLOSE = r.TESS = r.QUAD_STRIP = r.QUADS = r.TRIANGLE_STRIP = r.TRIANGLE_FAN = r.TRIANGLES = r.LINE_LOOP = r.LINE_STRIP = r.LINES = r.POINTS = r.BASELINE = r.BOTTOM = r.TOP = r.CENTER = r.LEFT = r.RIGHT = r.RADIUS = r.CORNERS = r.CORNER = r.RAD_TO_DEG = r.DEG_TO_RAD = r.RADIANS = r.DEGREES = r.TWO_PI = r.TAU = r.QUARTER_PI = r.PI = r.HALF_PI = r.WAIT = r.TEXT = r.MOVE = r.HAND = r.CROSS = r.ARROW = r.WEBGL = r.P2D = void 0, r.FALLBACK = r.LABEL = r.AXES = r.GRID = r._DEFAULT_FILL = r._DEFAULT_STROKE = r.PORTRAIT = r.LANDSCAPE = r.MIRROR = r.CLAMP = r.REPEAT = r.NEAREST = r.IMAGE = r.IMMEDIATE = r.TEXTURE = void 0;
      var i = Math.PI;
      r.P2D = "p2d";
      r.WEBGL = "webgl";
      r.ARROW = "default";
      r.CROSS = "crosshair";
      r.HAND = "pointer";
      r.MOVE = "move";
      r.TEXT = "text";
      r.WAIT = "wait";
      var n = i / 2;
      r.HALF_PI = n;
      var a = i;
      r.PI = a;
      var o = i / 4;
      r.QUARTER_PI = o;
      var s = 2 * i;
      r.TAU = s;
      var l = 2 * i;
      r.TWO_PI = l;
      r.DEGREES = "degrees";
      r.RADIANS = "radians";
      var u = i / 180;
      r.DEG_TO_RAD = u;
      var h = 180 / i;
      r.RAD_TO_DEG = h;
      r.CORNER = "corner";
      r.CORNERS = "corners";
      r.RADIUS = "radius";
      r.RIGHT = "right";
      r.LEFT = "left";
      r.CENTER = "center";
      r.TOP = "top";
      r.BOTTOM = "bottom";
      r.BASELINE = "alphabetic";
      r.POINTS = 0;
      r.LINES = 1;
      r.LINE_STRIP = 3;
      r.LINE_LOOP = 2;
      r.TRIANGLES = 4;
      r.TRIANGLE_FAN = 6;
      r.TRIANGLE_STRIP = 5;
      r.QUADS = "quads";
      r.QUAD_STRIP = "quad_strip";
      r.TESS = "tess";
      r.CLOSE = "close";
      r.OPEN = "open";
      r.CHORD = "chord";
      r.PIE = "pie";
      r.PROJECT = "square";
      r.SQUARE = "butt";
      r.ROUND = "round";
      r.BEVEL = "bevel";
      r.MITER = "miter";
      r.RGB = "rgb";
      r.HSB = "hsb";
      r.HSL = "hsl";
      r.AUTO = "auto";
      r.ALT = 18;
      r.BACKSPACE = 8;
      r.CONTROL = 17;
      r.DELETE = 46;
      r.DOWN_ARROW = 40;
      r.ENTER = 13;
      r.ESCAPE = 27;
      r.LEFT_ARROW = 37;
      r.OPTION = 18;
      r.RETURN = 13;
      r.RIGHT_ARROW = 39;
      r.SHIFT = 16;
      r.TAB = 9;
      r.UP_ARROW = 38;
      r.BLEND = "source-over";
      r.REMOVE = "destination-out";
      r.ADD = "lighter";
      r.DARKEST = "darken";
      r.LIGHTEST = "lighten";
      r.DIFFERENCE = "difference";
      r.SUBTRACT = "subtract";
      r.EXCLUSION = "exclusion";
      r.MULTIPLY = "multiply";
      r.SCREEN = "screen";
      r.REPLACE = "copy";
      r.OVERLAY = "overlay";
      r.HARD_LIGHT = "hard-light";
      r.SOFT_LIGHT = "soft-light";
      r.DODGE = "color-dodge";
      r.BURN = "color-burn";
      r.THRESHOLD = "threshold";
      r.GRAY = "gray";
      r.OPAQUE = "opaque";
      r.INVERT = "invert";
      r.POSTERIZE = "posterize";
      r.DILATE = "dilate";
      r.ERODE = "erode";
      r.BLUR = "blur";
      r.NORMAL = "normal";
      r.ITALIC = "italic";
      r.BOLD = "bold";
      r.BOLDITALIC = "bold italic";
      r._DEFAULT_TEXT_FILL = "#000000";
      r._DEFAULT_LEADMULT = 1.25;
      r._CTX_MIDDLE = "middle";
      r.LINEAR = "linear";
      r.QUADRATIC = "quadratic";
      r.BEZIER = "bezier";
      r.CURVE = "curve";
      r.STROKE = "stroke";
      r.FILL = "fill";
      r.TEXTURE = "texture";
      r.IMMEDIATE = "immediate";
      r.IMAGE = "image";
      r.NEAREST = "nearest";
      r.REPEAT = "repeat";
      r.CLAMP = "clamp";
      r.MIRROR = "mirror";
      r.LANDSCAPE = "landscape";
      r.PORTRAIT = "portrait";
      r._DEFAULT_STROKE = "#000000";
      r._DEFAULT_FILL = "#FFFFFF";
      r.GRID = "grid";
      r.AXES = "axes";
      r.LABEL = "label";
      r.FALLBACK = "fallback";
    }, {}],
    27: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var i,
          n = (i = e("./main")) && i.__esModule ? i : {
        default: i
      },
          a = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("./constants"));

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      var l = [a.ARROW, a.CROSS, a.HAND, a.MOVE, a.TEXT, a.WAIT];
      n.default.prototype._frameRate = 0, n.default.prototype._lastFrameTime = window.performance.now(), n.default.prototype._targetFrameRate = 60;
      var u = window.print;

      function h() {
        return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth || 0;
      }

      function c() {
        return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight || 0;
      }

      n.default.prototype.print = function () {
        var e;
        arguments.length ? (e = console).log.apply(e, arguments) : u();
      }, n.default.prototype.frameCount = 0, n.default.prototype.deltaTime = 0, n.default.prototype.focused = document.hasFocus(), n.default.prototype.cursor = function (e, t, r) {
        var i = "auto",
            n = this._curElement.elt;
        if (l.includes(e)) i = e;else if ("string" == typeof e) {
          var a = "";
          t && r && "number" == typeof t && "number" == typeof r && (a = "".concat(t, " ").concat(r)), i = "http://" === e.substring(0, 7) || "https://" === e.substring(0, 8) ? "url(".concat(e, ") ").concat(a, ", auto") : /\.(cur|jpg|jpeg|gif|png|CUR|JPG|JPEG|GIF|PNG)$/.test(e) ? "url(".concat(e, ") ").concat(a, ", auto") : e;
        }
        n.style.cursor = i;
      }, n.default.prototype.frameRate = function (e) {
        return n.default._validateParameters("frameRate", arguments), "number" != typeof e || e < 0 ? this._frameRate : (this._setProperty("_targetFrameRate", e), 0 === e && this._setProperty("_frameRate", e), this);
      }, n.default.prototype.getFrameRate = function () {
        return this.frameRate();
      }, n.default.prototype.setFrameRate = function (e) {
        return this.frameRate(e);
      }, n.default.prototype.noCursor = function () {
        this._curElement.elt.style.cursor = "none";
      }, n.default.prototype.displayWidth = screen.width, n.default.prototype.displayHeight = screen.height, n.default.prototype.windowWidth = h(), n.default.prototype.windowHeight = c(), n.default.prototype._onresize = function (e) {
        this._setProperty("windowWidth", h()), this._setProperty("windowHeight", c());
        var t,
            r = this._isGlobal ? window : this;
        "function" == typeof r.windowResized && (void 0 === (t = r.windowResized(e)) || t || e.preventDefault());
      }, n.default.prototype.width = 0, n.default.prototype.height = 0, n.default.prototype.fullscreen = function (e) {
        if (n.default._validateParameters("fullscreen", arguments), void 0 === e) return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
        e ? function (e) {
          if (!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled)) throw new Error("Fullscreen not enabled in this browser.");
          e.requestFullscreen ? e.requestFullscreen() : e.mozRequestFullScreen ? e.mozRequestFullScreen() : e.webkitRequestFullscreen ? e.webkitRequestFullscreen() : e.msRequestFullscreen && e.msRequestFullscreen();
        }(document.documentElement) : document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen && document.msExitFullscreen();
      }, n.default.prototype.pixelDensity = function (e) {
        var t;
        return n.default._validateParameters("pixelDensity", arguments), "number" == typeof e ? (e !== this._pixelDensity && (this._pixelDensity = e), (t = this).resizeCanvas(this.width, this.height, !0)) : t = this._pixelDensity, t;
      }, n.default.prototype.displayDensity = function () {
        return window.devicePixelRatio;
      }, n.default.prototype.getURL = function () {
        return location.href;
      }, n.default.prototype.getURLPath = function () {
        return location.pathname.split("/").filter(function (e) {
          return "" !== e;
        });
      }, n.default.prototype.getURLParams = function () {
        for (var e, t = /[?&]([^&=]+)(?:[&=])([^&=]+)/gim, r = {}; null != (e = t.exec(location.search));) e.index === t.lastIndex && t.lastIndex++, r[e[1]] = e[2];

        return r;
      };
      var f = n.default;
      r.default = f;
    }, {
      "./constants": 26,
      "./main": 36
    }],
    28: [function (r, e, t) {
      "use strict";

      Object.defineProperty(t, "__esModule", {
        value: !0
      }), t.default = void 0;
      var i,
          n = (i = r("../main")) && i.__esModule ? i : {
        default: i
      };
      r("../internationalization");
      var a = null,
          o = null;
      n.default._friendlyError = n.default._checkForUserDefinedFunctions = n.default._fesErrorMonitor = function () {}, a = null;
      var s = "https://github.com/processing/p5.js/wiki/p5.js-overview#why-cant-i-assign-variables-using-p5-functions-and-variables-before-setup";

      o = function () {
        function e(r) {
          return Object.getOwnPropertyNames(r).filter(function (e) {
            return "_" !== e[0] && !(e in t) && (t[e] = !0);
          }).map(function (e) {
            var t;
            return t = "function" == typeof r[e] ? "function" : e === e.toUpperCase() ? "constant" : "variable", {
              name: e,
              type: t
            };
          });
        }

        var t = {};
        (a = [].concat(e(n.default.prototype), e(r("../constants")))).sort(function (e, t) {
          return t.name.length - e.name.length;
        });
      };

      function l(r, i) {
        i = i || console.log.bind(console), a || o(), a.some(function (e) {
          if (r.message && null !== r.message.match("\\W?".concat(e.name, "\\W"))) {
            var t = "function" === e.type ? "".concat(e.name, "()") : e.name;
            return i("Did you just try to use p5.js's ".concat(t, " ").concat(e.type, "? If so, you may want to move it into your sketch's setup() function.\n\nFor more details, see: ").concat(s)), !0;
          }
        });
      }

      n.default.prototype._helpForMisusedAtTopLevelCode = l, "complete" !== document.readyState && (window.addEventListener("error", l, !1), window.addEventListener("load", function () {
        window.removeEventListener("error", l, !1);
      }));
      var u = n.default;
      t.default = u;
    }, {
      "../constants": 26,
      "../internationalization": 34,
      "../main": 36,
      "./browser_errors": void 0
    }],
    29: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../main")) && i.__esModule ? i : {
        default: i
      };
      e("../internationalization");

      n.default._friendlyFileLoadError = function () {};

      var a = n.default;
      r.default = a;
    }, {
      "../internationalization": 34,
      "../main": 36
    }],
    30: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../main")) && i.__esModule ? i : {
        default: i
      };

      function a() {
        var t = /(^|@)\S+:\d+/,
            r = /^\s*at .*(\S+:\d+|\(native\))/m,
            i = /^(eval@)?(\[native code])?$/;
        return {
          parse: function (e) {
            return void 0 !== e.stacktrace || void 0 !== e["opera#sourceloc"] ? this.parseOpera(e) : e.stack && e.stack.match(r) ? this.parseV8OrIE(e) : e.stack ? this.parseFFOrSafari(e) : void 0;
          },
          extractLocation: function (e) {
            if (-1 === e.indexOf(":")) return [e];
            var t = /(.+?)(?::(\d+))?(?::(\d+))?$/.exec(e.replace(/[()]/g, ""));
            return [t[1], t[2] || void 0, t[3] || void 0];
          },
          parseV8OrIE: function (e) {
            return e.stack.split("\n").filter(function (e) {
              return !!e.match(r);
            }, this).map(function (e) {
              -1 < e.indexOf("(eval ") && (e = e.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(\),.*$)/g, ""));
              var t = e.replace(/^\s+/, "").replace(/\(eval code/g, "("),
                  r = t.match(/ (\((.+):(\d+):(\d+)\)$)/),
                  i = (t = r ? t.replace(r[0], "") : t).split(/\s+/).slice(1),
                  n = this.extractLocation(r ? r[1] : i.pop());
              return {
                functionName: i.join(" ") || void 0,
                fileName: -1 < ["eval", "<anonymous>"].indexOf(n[0]) ? void 0 : n[0],
                lineNumber: n[1],
                columnNumber: n[2],
                source: e
              };
            }, this);
          },
          parseFFOrSafari: function (e) {
            return e.stack.split("\n").filter(function (e) {
              return !e.match(i);
            }, this).map(function (e) {
              if (-1 < e.indexOf(" > eval") && (e = e.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1")), -1 === e.indexOf("@") && -1 === e.indexOf(":")) return {
                functionName: e
              };
              var t = /((.*".+"[^@]*)?[^@]*)(?:@)/,
                  r = e.match(t),
                  i = r && r[1] ? r[1] : void 0,
                  n = this.extractLocation(e.replace(t, ""));
              return {
                functionName: i,
                fileName: n[0],
                lineNumber: n[1],
                columnNumber: n[2],
                source: e
              };
            }, this);
          },
          parseOpera: function (e) {
            return !e.stacktrace || -1 < e.message.indexOf("\n") && e.message.split("\n").length > e.stacktrace.split("\n").length ? this.parseOpera9(e) : e.stack ? this.parseOpera11(e) : this.parseOpera10(e);
          },
          parseOpera9: function (e) {
            for (var t = /Line (\d+).*script (?:in )?(\S+)/i, r = e.message.split("\n"), i = [], n = 2, a = r.length; n < a; n += 2) {
              var o = t.exec(r[n]);
              o && i.push({
                fileName: o[2],
                lineNumber: o[1],
                source: r[n]
              });
            }

            return i;
          },
          parseOpera10: function (e) {
            for (var t = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i, r = e.stacktrace.split("\n"), i = [], n = 0, a = r.length; n < a; n += 2) {
              var o = t.exec(r[n]);
              o && i.push({
                functionName: o[3] || void 0,
                fileName: o[2],
                lineNumber: o[1],
                source: r[n]
              });
            }

            return i;
          },
          parseOpera11: function (e) {
            return e.stack.split("\n").filter(function (e) {
              return !!e.match(t) && !e.match(/^Error created at/);
            }, this).map(function (e) {
              var t,
                  r = e.split("@"),
                  i = this.extractLocation(r.pop()),
                  n = r.shift() || "",
                  a = n.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || void 0;
              return n.match(/\(([^)]*)\)/) && (t = n.replace(/^[^(]+\(([^)]*)\)$/, "$1")), {
                functionName: a,
                args: void 0 === t || "[arguments not available]" === t ? void 0 : t.split(","),
                fileName: i[0],
                lineNumber: i[1],
                columnNumber: i[2],
                source: e
              };
            }, this);
          }
        };
      }

      n.default._getErrorStackParser = function () {
        return new a();
      };

      var o = n.default;
      r.default = o;
    }, {
      "../main": 36
    }],
    31: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../main")) && i.__esModule ? i : {
        default: i
      };
      (function (e) {
        if (e && e.__esModule) return;
        if (null === e || "object" !== s(e) && "function" != typeof e) return;
        var t = o();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
      })(e("../constants")), e("../internationalization");

      function o() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return o = function () {
          return e;
        }, e;
      }

      function s(e) {
        return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      n.default._validateParameters = n.default._clearValidateParamsCache = function () {};

      var a = n.default;
      r.default = a;
    }, {
      "../../../docs/parameterData.json": void 0,
      "../constants": 26,
      "../internationalization": 34,
      "../main": 36
    }],
    32: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var a = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("./constants"));

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      var i = {
        modeAdjust: function (e, t, r, i, n) {
          return n === a.CORNER ? {
            x: e,
            y: t,
            w: r,
            h: i
          } : n === a.CORNERS ? {
            x: e,
            y: t,
            w: r - e,
            h: i - t
          } : n === a.RADIUS ? {
            x: e - r,
            y: t - i,
            w: 2 * r,
            h: 2 * i
          } : n === a.CENTER ? {
            x: e - .5 * r,
            y: t - .5 * i,
            w: r,
            h: i
          } : void 0;
        }
      };
      r.default = i;
    }, {
      "./constants": 26
    }],
    33: [function (e, t, r) {
      "use strict";

      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      e("./internationalization");
      var a = Promise.resolve();
      Promise.all([new Promise(function (e, t) {
        "complete" === document.readyState ? e() : window.addEventListener("load", e, !1);
      }), a]).then(function () {
        void 0 === window._setupDone ? window.mocha || (window.setup && "function" == typeof window.setup || window.draw && "function" == typeof window.draw) && !n.default.instance && new n.default() : console.warn("p5.js seems to have been imported multiple times. Please remove the duplicate import");
      });
    }, {
      "../core/main": 36,
      "./internationalization": 34
    }],
    34: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.initialize = r.translator = void 0;
      var a,
          o,
          i = s(e("i18next")),
          n = s(e("i18next-browser-languagedetector"));

      function s(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      function l(e, t) {
        for (var r = 0; r < t.length; r++) {
          var i = t[r];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
        }
      }

      var u = function () {
        function r(e, t) {
          !function (e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
          }(this, r), this.init(e, t);
        }

        var e, t, i;
        return e = r, (t = [{
          key: "fetchWithTimeout",
          value: function (e, t, r) {
            var i = 2 < arguments.length && void 0 !== r ? r : 2e3;
            return Promise.race([fetch(e, t), new Promise(function (e, t) {
              return setTimeout(function () {
                return t(new Error("timeout"));
              }, i);
            })]);
          }
        }, {
          key: "init",
          value: function (e, t) {
            var r = 1 < arguments.length && void 0 !== t ? t : {};
            this.services = e, this.options = r;
          }
        }, {
          key: "read",
          value: function (e, t, r) {
            var i = this.options.loadPath;
            if (e === this.options.fallback) r(null, a[e][t]);else if (o.includes(e)) {
              var n = this.services.interpolator.interpolate(i, {
                lng: e,
                ns: t
              });
              this.loadUrl(n, r);
            } else r("Not found", !1);
          }
        }, {
          key: "loadUrl",
          value: function (t, r) {
            this.fetchWithTimeout(t).then(function (e) {
              if (!e.ok) throw new Error("failed loading ".concat(t));
              return e.json();
            }, function () {
              throw new Error("failed loading ".concat(t));
            }).then(function (e) {
              return r(null, e);
            }).catch(r);
          }
        }]) && l(e.prototype, t), i && l(e, i), r;
      }();

      u.type = "backend";

      var h = function (e, t) {
        console.debug("p5.js translator called before translations were loaded"), i.default.t(e, t);
      };

      r.translator = h;

      r.initialize = function () {
        return i.default.use(n.default).use(u).init({
          fallbackLng: "en",
          nestingPrefix: "$tr(",
          nestingSuffix: ")",
          defaultNS: "translation",
          returnEmptyString: !1,
          interpolation: {
            escapeValue: !1
          },
          detection: {
            checkWhitelist: !1,
            order: ["querystring", "navigator", "htmlTag", "path", "subdomain"],
            caches: []
          },
          backend: {
            fallback: "en",
            loadPath: "https://cdn.jsdelivr.net/npm/p5/translations/{{lng}}/{{ns}}.json"
          },
          partialBundledLanguages: !0,
          resources: a
        }).then(function (e) {
          r.translator = h = e;
        }, function (e) {
          return console.debug("Translations failed to load (".concat(e, ")"));
        });
      };
    }, {
      "../../translations": void 0,
      "../../translations/dev": void 0,
      i18next: 3,
      "i18next-browser-languagedetector": 3
    }],
    35: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("./main")) && i.__esModule ? i : {
        default: i
      };
      n.default.prototype.pushStyle = function () {
        throw new Error("pushStyle() not used, see push()");
      }, n.default.prototype.popStyle = function () {
        throw new Error("popStyle() not used, see pop()");
      }, n.default.prototype.popMatrix = function () {
        throw new Error("popMatrix() not used, see pop()");
      }, n.default.prototype.pushMatrix = function () {
        throw new Error("pushMatrix() not used, see push()");
      };
      var a = n.default;
      r.default = a;
    }, {
      "./main": 36
    }],
    36: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0, e("./shim");

      var i = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("./constants"));

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      function n(e, t) {
        for (var r = 0; r < t.length; r++) {
          var i = t[r];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
        }
      }

      var a = function () {
        function _(e, t, r) {
          var f = this;
          !function (e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
          }(this, _), this._accessibleOutputs = {
            text: !1,
            grid: !1,
            textLabel: !1,
            gridLabel: !1
          }, this._setupDone = !1, this._pixelDensity = Math.ceil(window.devicePixelRatio) || 1, this._userNode = t, this._curElement = null, this._elements = [], this._glAttributes = null, this._requestAnimId = 0, this._preloadCount = 0, this._isGlobal = !1, this._loop = !0, this._initializeInstanceVariables(), this._defaultCanvasSize = {
            width: 100,
            height: 100
          }, this._events = {
            mousemove: null,
            mousedown: null,
            mouseup: null,
            dragend: null,
            dragover: null,
            click: null,
            dblclick: null,
            mouseover: null,
            mouseout: null,
            keydown: null,
            keyup: null,
            keypress: null,
            touchstart: null,
            touchmove: null,
            touchend: null,
            resize: null,
            blur: null
          }, this._millisStart = -1, this._lcg_random_state = null, this._gaussian_previous = !1, this._events.wheel = null, this._loadingScreenId = "p5_loading", this._registeredMethods = {};
          var i = Object.getOwnPropertyNames(_.prototype._registeredMethods),
              n = !0,
              a = !1,
              o = void 0;

          try {
            for (var s, l = i[Symbol.iterator](); !(n = (s = l.next()).done); n = !0) {
              var u = s.value;
              this._registeredMethods[u] = _.prototype._registeredMethods[u].slice();
            }
          } catch (e) {
            a = !0, o = e;
          } finally {
            try {
              n || null == l.return || l.return();
            } finally {
              if (a) throw o;
            }
          }

          window.DeviceOrientationEvent && (this._events.deviceorientation = null), window.DeviceMotionEvent && !window._isNodeWebkit && (this._events.devicemotion = null), this._start = function () {
            f._userNode && "string" == typeof f._userNode && (f._userNode = document.getElementById(f._userNode));
            var e = f._isGlobal ? window : f;

            if (e.preload) {
              var t = document.getElementById(f._loadingScreenId);
              if (!t) (t = document.createElement("div")).innerHTML = "Loading...", t.style.position = "absolute", t.id = f._loadingScreenId, (f._userNode || document.body).appendChild(t);
              var r = f._preloadMethods;

              for (var i in r) {
                r[i] = r[i] || _;
                var n = r[i];
                n !== _.prototype && n !== _ || (f._isGlobal && (window[i] = f._wrapPreload(f, i)), n = f), f._registeredPreloadMethods[i] = n[i], n[i] = f._wrapPreload(n, i);
              }

              e.preload(), f._runIfPreloadsAreDone();
            } else f._setup(), f._draw();
          }, this._runIfPreloadsAreDone = function () {
            var e = this._isGlobal ? window : this;

            if (0 === e._preloadCount) {
              var t = document.getElementById(e._loadingScreenId);
              t && t.parentNode.removeChild(t), this._setupDone || (this._lastFrameTime = window.performance.now(), e._setup(), e._draw());
            }
          }, this._decrementPreload = function () {
            var e = this._isGlobal ? window : this;
            "function" == typeof e.preload && (e._setProperty("_preloadCount", e._preloadCount - 1), e._runIfPreloadsAreDone());
          }, this._wrapPreload = function (i, n) {
            var a = this;
            return function () {
              a._incrementPreload();

              for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

              return a._registeredPreloadMethods[n].apply(i, t);
            };
          }, this._incrementPreload = function () {
            var e = this._isGlobal ? window : this;

            e._setProperty("_preloadCount", e._preloadCount + 1);
          }, this._setup = function () {
            f.createCanvas(f._defaultCanvasSize.width, f._defaultCanvasSize.height, "p2d");
            var e = f._isGlobal ? window : f;
            if ("function" == typeof e.preload) for (var t in f._preloadMethods) e[t] = f._preloadMethods[t][t], e[t] && f && (e[t] = e[t].bind(f));
            f._millisStart = window.performance.now(), "function" == typeof e.setup && e.setup();
            var r = document.getElementsByTagName("canvas"),
                i = !0,
                n = !1,
                a = void 0;

            try {
              for (var o, s = r[Symbol.iterator](); !(i = (o = s.next()).done); i = !0) {
                var l = o.value;
                "true" === l.dataset.hidden && (l.style.visibility = "", delete l.dataset.hidden);
              }
            } catch (e) {
              n = !0, a = e;
            } finally {
              try {
                i || null == s.return || s.return();
              } finally {
                if (n) throw a;
              }
            }

            f._lastFrameTime = window.performance.now(), f._setupDone = !0, (f._accessibleOutputs.grid || f._accessibleOutputs.text) && f._updateAccsOutput();
          }, this._draw = function () {
            var e = window.performance.now(),
                t = e - f._lastFrameTime,
                r = 1e3 / f._targetFrameRate;
            (!f._loop || r - 5 <= t) && (f.redraw(), f._frameRate = 1e3 / (e - f._lastFrameTime), f.deltaTime = e - f._lastFrameTime, f._setProperty("deltaTime", f.deltaTime), f._lastFrameTime = e, void 0 !== f._updateMouseCoords && (f._updateMouseCoords(), f._setProperty("movedX", 0), f._setProperty("movedY", 0))), f._loop && (f._requestAnimId = window.requestAnimationFrame(f._draw));
          }, this._setProperty = function (e, t) {
            f[e] = t, f._isGlobal && (window[e] = t);
          }, this.remove = function () {
            var e = document.getElementById(f._loadingScreenId);

            if (e && (e.parentNode.removeChild(e), f._incrementPreload()), f._curElement) {
              for (var t in f._loop = !1, f._requestAnimId && window.cancelAnimationFrame(f._requestAnimId), f._events) window.removeEventListener(t, f._events[t]);

              var r = !0,
                  i = !1,
                  n = void 0;

              try {
                for (var a, o = f._elements[Symbol.iterator](); !(r = (a = o.next()).done); r = !0) {
                  var s = a.value;

                  for (var l in s.elt && s.elt.parentNode && s.elt.parentNode.removeChild(s.elt), s._events) s.elt.removeEventListener(l, s._events[l]);
                }
              } catch (e) {
                i = !0, n = e;
              } finally {
                try {
                  r || null == o.return || o.return();
                } finally {
                  if (i) throw n;
                }
              }

              var u = f;

              f._registeredMethods.remove.forEach(function (e) {
                void 0 !== e && e.call(u);
              });
            }

            if (f._isGlobal) {
              for (var h in _.prototype) try {
                delete window[h];
              } catch (e) {
                window[h] = void 0;
              }

              for (var c in f) if (f.hasOwnProperty(c)) try {
                delete window[c];
              } catch (e) {
                window[c] = void 0;
              }

              _.instance = null;
            }
          }, this._registeredMethods.init.forEach(function (e) {
            void 0 !== e && e.call(this);
          }, this), this._setupPromisePreloads();

          var h = this._createFriendlyGlobalFunctionBinder();

          if (e) e(this), _._checkForUserDefinedFunctions(this);else {
            for (var c in this._isGlobal = !0, _.instance = this, _.prototype) if ("function" == typeof _.prototype[c]) {
              var d = c.substring(2);
              this._events.hasOwnProperty(d) || (Math.hasOwnProperty(c) && Math[c] === _.prototype[c] ? h(c, _.prototype[c]) : h(c, _.prototype[c].bind(this)));
            } else h(c, _.prototype[c]);

            for (var p in this) this.hasOwnProperty(p) && h(p, this[p]);
          }

          for (var m in this._events) {
            var v = this["_on".concat(m)];

            if (v) {
              var y = v.bind(this);
              window.addEventListener(m, y, {
                passive: !1
              }), this._events[m] = y;
            }
          }

          function g() {
            f._setProperty("focused", !0);
          }

          function b() {
            f._setProperty("focused", !1);
          }

          window.addEventListener("focus", g), window.addEventListener("blur", b), this.registerMethod("remove", function () {
            window.removeEventListener("focus", g), window.removeEventListener("blur", b);
          }), "complete" === document.readyState ? this._start() : window.addEventListener("load", this._start.bind(this), !1);
        }

        var e, t, r;
        return e = _, (t = [{
          key: "_initializeInstanceVariables",
          value: function () {
            this._styles = [], this._bezierDetail = 20, this._curveDetail = 20, this._colorMode = i.RGB, this._colorMaxes = {
              rgb: [255, 255, 255, 255],
              hsb: [360, 100, 100, 1],
              hsl: [360, 100, 100, 1]
            }, this._downKeys = {};
          }
        }, {
          key: "registerPreloadMethod",
          value: function (e, t) {
            _.prototype._preloadMethods.hasOwnProperty(e) || (_.prototype._preloadMethods[e] = t);
          }
        }, {
          key: "registerMethod",
          value: function (e, t) {
            var r = this || _.prototype;
            r._registeredMethods.hasOwnProperty(e) || (r._registeredMethods[e] = []), r._registeredMethods[e].push(t);
          }
        }, {
          key: "_createFriendlyGlobalFunctionBinder",
          value: function (e) {
            var t = 0 < arguments.length && void 0 !== e ? e : {},
                r = t.globalObject || window;
            t.log || console.log.bind(console);
            return function (e, t) {
              r[e] = t;
            };
          }
        }]) && n(e.prototype, t), r && n(e, r), _;
      }();

      for (var l in a.instance = null, a.disableFriendlyErrors = !1, i) a.prototype[l] = i[l];

      a.prototype._preloadMethods = {
        loadJSON: a.prototype,
        loadImage: a.prototype,
        loadStrings: a.prototype,
        loadXML: a.prototype,
        loadBytes: a.prototype,
        loadTable: a.prototype,
        loadFont: a.prototype,
        loadModel: a.prototype,
        loadShader: a.prototype
      }, a.prototype._registeredMethods = {
        init: [],
        pre: [],
        post: [],
        remove: []
      }, a.prototype._registeredPreloadMethods = {};
      var u = a;
      r.default = u;
    }, {
      "./constants": 26,
      "./shim": 47
    }],
    37: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("./main")) && i.__esModule ? i : {
        default: i
      };
      n.default.Element = function (e, t) {
        this.elt = e, this._pInst = this._pixelsState = t, this._events = {}, this.width = this.elt.offsetWidth, this.height = this.elt.offsetHeight;
      }, n.default.Element.prototype.parent = function (e) {
        return void 0 === e ? this.elt.parentNode : ("string" == typeof e ? ("#" === e[0] && (e = e.substring(1)), e = document.getElementById(e)) : e instanceof n.default.Element && (e = e.elt), e.appendChild(this.elt), this);
      }, n.default.Element.prototype.id = function (e) {
        return void 0 === e ? this.elt.id : (this.elt.id = e, this.width = this.elt.offsetWidth, this.height = this.elt.offsetHeight, this);
      }, n.default.Element.prototype.class = function (e) {
        return void 0 === e ? this.elt.className : (this.elt.className = e, this);
      }, n.default.Element.prototype.mousePressed = function (t) {
        return n.default.Element._adjustListener("mousedown", function (e) {
          return this._pInst._setProperty("mouseIsPressed", !0), this._pInst._setMouseButton(e), t.call(this);
        }, this), this;
      }, n.default.Element.prototype.doubleClicked = function (e) {
        return n.default.Element._adjustListener("dblclick", e, this), this;
      }, n.default.Element.prototype.mouseWheel = function (e) {
        return n.default.Element._adjustListener("wheel", e, this), this;
      }, n.default.Element.prototype.mouseReleased = function (e) {
        return n.default.Element._adjustListener("mouseup", e, this), this;
      }, n.default.Element.prototype.mouseClicked = function (e) {
        return n.default.Element._adjustListener("click", e, this), this;
      }, n.default.Element.prototype.mouseMoved = function (e) {
        return n.default.Element._adjustListener("mousemove", e, this), this;
      }, n.default.Element.prototype.mouseOver = function (e) {
        return n.default.Element._adjustListener("mouseover", e, this), this;
      }, n.default.Element.prototype.mouseOut = function (e) {
        return n.default.Element._adjustListener("mouseout", e, this), this;
      }, n.default.Element.prototype.touchStarted = function (e) {
        return n.default.Element._adjustListener("touchstart", e, this), this;
      }, n.default.Element.prototype.touchMoved = function (e) {
        return n.default.Element._adjustListener("touchmove", e, this), this;
      }, n.default.Element.prototype.touchEnded = function (e) {
        return n.default.Element._adjustListener("touchend", e, this), this;
      }, n.default.Element.prototype.dragOver = function (e) {
        return n.default.Element._adjustListener("dragover", e, this), this;
      }, n.default.Element.prototype.dragLeave = function (e) {
        return n.default.Element._adjustListener("dragleave", e, this), this;
      }, n.default.Element._adjustListener = function (e, t, r) {
        return !1 === t ? n.default.Element._detachListener(e, r) : n.default.Element._attachListener(e, t, r), this;
      }, n.default.Element._attachListener = function (e, t, r) {
        r._events[e] && n.default.Element._detachListener(e, r);
        var i = t.bind(r);
        r.elt.addEventListener(e, i, !1), r._events[e] = i;
      }, n.default.Element._detachListener = function (e, t) {
        var r = t._events[e];
        t.elt.removeEventListener(e, r, !1), t._events[e] = null;
      }, n.default.Element.prototype._setProperty = function (e, t) {
        this[e] = t;
      };
      var a = n.default.Element;
      r.default = a;
    }, {
      "./main": 36
    }],
    38: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var i,
          s = (i = e("./main")) && i.__esModule ? i : {
        default: i
      },
          l = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = u();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("./constants"));

      function u() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return u = function () {
          return e;
        }, e;
      }

      s.default.Graphics = function (e, t, r, i) {
        var n = r || l.P2D;
        this.canvas = document.createElement("canvas");
        var a = i._userNode || document.body;

        for (var o in a.appendChild(this.canvas), s.default.Element.call(this, this.canvas, i), s.default.prototype) this[o] || ("function" == typeof s.default.prototype[o] ? this[o] = s.default.prototype[o].bind(this) : this[o] = s.default.prototype[o]);

        return s.default.prototype._initializeInstanceVariables.apply(this), this.width = e, this.height = t, this._pixelDensity = i._pixelDensity, n === l.WEBGL ? this._renderer = new s.default.RendererGL(this.canvas, this, !1) : this._renderer = new s.default.Renderer2D(this.canvas, this, !1), i._elements.push(this), Object.defineProperty(this, "deltaTime", {
          get: function () {
            return this._pInst.deltaTime;
          }
        }), this._renderer.resize(e, t), this._renderer._applyDefaults(), this;
      }, s.default.Graphics.prototype = Object.create(s.default.Element.prototype), s.default.Graphics.prototype.reset = function () {
        this._renderer.resetMatrix(), this._renderer.isP3D && this._renderer._update();
      }, s.default.Graphics.prototype.remove = function () {
        this.elt.parentNode && this.elt.parentNode.removeChild(this.elt);

        var e = this._pInst._elements.indexOf(this);

        for (var t in -1 !== e && this._pInst._elements.splice(e, 1), this._events) this.elt.removeEventListener(t, this._events[t]);
      };
      var n = s.default.Graphics;
      r.default = n;
    }, {
      "./constants": 26,
      "./main": 36
    }],
    39: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var i,
          l = (i = e("./main")) && i.__esModule ? i : {
        default: i
      },
          T = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== s(e) && "function" != typeof e) return {
          default: e
        };
        var t = o();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../core/constants"));

      function o() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return o = function () {
          return e;
        }, e;
      }

      function s(e) {
        return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function u(e) {
        var t = 0,
            r = 0;
        if (e.offsetParent) for (; t += e.offsetLeft, r += e.offsetTop, e = e.offsetParent;);else t += e.offsetLeft, r += e.offsetTop;
        return [t, r];
      }

      l.default.Renderer = function (e, t, r) {
        l.default.Element.call(this, e, t), this.canvas = e, this._pixelsState = t, r ? (this._isMainCanvas = !0, this._pInst._setProperty("_curElement", this), this._pInst._setProperty("canvas", this.canvas), this._pInst._setProperty("width", this.width), this._pInst._setProperty("height", this.height)) : (this.canvas.style.display = "none", this._styles = []), this._textSize = 12, this._textLeading = 15, this._textFont = "sans-serif", this._textStyle = T.NORMAL, this._textAscent = null, this._textDescent = null, this._textAlign = T.LEFT, this._textBaseline = T.BASELINE, this._rectMode = T.CORNER, this._ellipseMode = T.CENTER, this._curveTightness = 0, this._imageMode = T.CORNER, this._tint = null, this._doStroke = !0, this._doFill = !0, this._strokeSet = !1, this._fillSet = !1;
      }, l.default.Renderer.prototype = Object.create(l.default.Element.prototype), l.default.Renderer.prototype.push = function () {
        return {
          properties: {
            _doStroke: this._doStroke,
            _strokeSet: this._strokeSet,
            _doFill: this._doFill,
            _fillSet: this._fillSet,
            _tint: this._tint,
            _imageMode: this._imageMode,
            _rectMode: this._rectMode,
            _ellipseMode: this._ellipseMode,
            _textFont: this._textFont,
            _textLeading: this._textLeading,
            _textSize: this._textSize,
            _textAlign: this._textAlign,
            _textBaseline: this._textBaseline,
            _textStyle: this._textStyle
          }
        };
      }, l.default.Renderer.prototype.pop = function (e) {
        e.properties && Object.assign(this, e.properties);
      }, l.default.Renderer.prototype.resize = function (e, t) {
        this.width = e, this.height = t, this.elt.width = e * this._pInst._pixelDensity, this.elt.height = t * this._pInst._pixelDensity, this.elt.style.width = "".concat(e, "px"), this.elt.style.height = "".concat(t, "px"), this._isMainCanvas && (this._pInst._setProperty("width", this.width), this._pInst._setProperty("height", this.height));
      }, l.default.Renderer.prototype.get = function (e, t, r, i) {
        var n = this._pixelsState,
            a = n._pixelDensity,
            o = this.canvas;
        if (void 0 === e && void 0 === t) e = t = 0, r = n.width, i = n.height;else if (e *= a, t *= a, void 0 === r && void 0 === i) return e < 0 || t < 0 || e >= o.width || t >= o.height ? [0, 0, 0, 0] : this._getPixel(e, t);
        var s = new l.default.Image(r, i);
        return s.canvas.getContext("2d").drawImage(o, e, t, r * a, i * a, 0, 0, r, i), s;
      }, l.default.Renderer.prototype.textLeading = function (e) {
        return "number" == typeof e ? (this._setProperty("_textLeading", e), this._pInst) : this._textLeading;
      }, l.default.Renderer.prototype.textSize = function (e) {
        return "number" == typeof e ? (this._setProperty("_textSize", e), this._setProperty("_textLeading", e * T._DEFAULT_LEADMULT), this._applyTextProperties()) : this._textSize;
      }, l.default.Renderer.prototype.textStyle = function (e) {
        return e ? (e !== T.NORMAL && e !== T.ITALIC && e !== T.BOLD && e !== T.BOLDITALIC || this._setProperty("_textStyle", e), this._applyTextProperties()) : this._textStyle;
      }, l.default.Renderer.prototype.textAscent = function () {
        return null === this._textAscent && this._updateTextMetrics(), this._textAscent;
      }, l.default.Renderer.prototype.textDescent = function () {
        return null === this._textDescent && this._updateTextMetrics(), this._textDescent;
      }, l.default.Renderer.prototype.textAlign = function (e, t) {
        return void 0 !== e ? (this._setProperty("_textAlign", e), void 0 !== t && this._setProperty("_textBaseline", t), this._applyTextProperties()) : {
          horizontal: this._textAlign,
          vertical: this._textBaseline
        };
      }, l.default.Renderer.prototype.text = function (e, t, r, i, n) {
        var a,
            o,
            s,
            l,
            u,
            h,
            c,
            f,
            d,
            p = this._pInst,
            m = Number.MAX_VALUE;

        if ((this._doFill || this._doStroke) && void 0 !== e) {
          if ("string" != typeof e && (e = e.toString()), a = (e = e.replace(/(\t)/g, "  ")).split("\n"), void 0 !== i) {
            for (s = f = 0; s < a.length; s++) {
              for (u = "", c = a[s].split(" "), o = 0; o < c.length; o++) if (h = "".concat(u + c[o], " "), i < this.textWidth(h)) {
                for (var v = c[o], y = 0; y < v.length; y++) h = "".concat(u + v[y]), i < this.textWidth(h) && 0 < u.length ? (u = "".concat(v[y]), f += p.textLeading()) : u = h;

                u = "".concat(u, " ");
              } else u = h;

              s < a.length - 1 && (f += p.textLeading());
            }

            switch (this._rectMode === T.CENTER && (t -= i / 2, r -= n / 2), this._textAlign) {
              case T.CENTER:
                t += i / 2;
                break;

              case T.RIGHT:
                t += i;
            }

            var g = !1;

            if (void 0 !== n) {
              switch (this._textBaseline) {
                case T.BOTTOM:
                  d = r + (n - f), r = Math.max(d, r);
                  break;

                case T.CENTER:
                  d = r + (n - f) / 2, r = Math.max(d, r);
                  break;

                case T.BASELINE:
                  g = !0, this._textBaseline = T.TOP;
              }

              m = r + n - p.textAscent();
            }

            for (s = 0; s < a.length; s++) {
              for (u = "", c = a[s].split(" "), o = 0; o < c.length; o++) if (h = "".concat(u + c[o], " "), i < this.textWidth(h)) {
                for (var b = c[o], _ = 0; _ < b.length; _++) if (h = "".concat(u + b[_]), i < this.textWidth(h) && 0 < u.length) {
                  var x = u.slice(-1),
                      w = "\n" !== x && " " !== x;
                  u = "".concat(u).concat(w ? "-" : ""), this._renderText(p, u, t, r, m), r += p.textLeading(), u = "".concat(b[_]);
                } else u = h;

                u = "".concat(u, " ");
              } else u = h;

              this._renderText(p, u, t, r, m), r += p.textLeading(), g && (this._textBaseline = T.BASELINE);
            }
          } else {
            var S = 0,
                M = p.textAlign().vertical;

            for (M === T.CENTER ? S = (a.length - 1) * p.textLeading() / 2 : M === T.BOTTOM && (S = (a.length - 1) * p.textLeading()), l = 0; l < a.length; l++) this._renderText(p, a[l], t, r - S, m), r += p.textLeading();
          }

          return p;
        }
      }, l.default.Renderer.prototype._applyDefaults = function () {
        return this;
      }, l.default.Renderer.prototype._isOpenType = function () {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : this._textFont;
        return "object" === s(e) && e.font && e.font.supported;
      }, l.default.Renderer.prototype._updateTextMetrics = function () {
        if (this._isOpenType()) return this._setProperty("_textAscent", this._textFont._textAscent()), this._setProperty("_textDescent", this._textFont._textDescent()), this;
        var e = document.createElement("span");
        e.style.fontFamily = this._textFont, e.style.fontSize = "".concat(this._textSize, "px"), e.innerHTML = "ABCjgq|";
        var t = document.createElement("div");
        t.style.display = "inline-block", t.style.width = "1px", t.style.height = "0px";
        var r = document.createElement("div");
        r.appendChild(e), r.appendChild(t), r.style.height = "0px", r.style.overflow = "hidden", document.body.appendChild(r), t.style.verticalAlign = "baseline";
        var i = u(t),
            n = u(e),
            a = i[1] - n[1];
        t.style.verticalAlign = "bottom", i = u(t), n = u(e);
        var o = i[1] - n[1] - a;
        return document.body.removeChild(r), this._setProperty("_textAscent", a), this._setProperty("_textDescent", o), this;
      };
      var n = l.default.Renderer;
      r.default = n;
    }, {
      "../core/constants": 26,
      "./main": 36
    }],
    40: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var c = i(e("./main")),
          p = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("./constants")),
          f = i(e("../image/filters"));

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      function i(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      e("./p5.Renderer");
      var v = "rgba(0,0,0,0)";
      c.default.Renderer2D = function (e, t, r) {
        return c.default.Renderer.call(this, e, t, r), this.drawingContext = this.canvas.getContext("2d"), this._pInst._setProperty("drawingContext", this.drawingContext), this;
      }, c.default.Renderer2D.prototype = Object.create(c.default.Renderer.prototype), c.default.Renderer2D.prototype._applyDefaults = function () {
        this._cachedFillStyle = this._cachedStrokeStyle = void 0, this._cachedBlendMode = p.BLEND, this._setFill(p._DEFAULT_FILL), this._setStroke(p._DEFAULT_STROKE), this.drawingContext.lineCap = p.ROUND, this.drawingContext.font = "normal 12px sans-serif";
      }, c.default.Renderer2D.prototype.resize = function (e, t) {
        c.default.Renderer.prototype.resize.call(this, e, t), this.drawingContext.scale(this._pInst._pixelDensity, this._pInst._pixelDensity);
      }, c.default.Renderer2D.prototype.background = function () {
        if (this.drawingContext.save(), this.resetMatrix(), (arguments.length <= 0 ? void 0 : arguments[0]) instanceof c.default.Image) this._pInst.image(arguments.length <= 0 ? void 0 : arguments[0], 0, 0, this.width, this.height);else {
          var e,
              t = this._getFill(),
              r = (e = this._pInst).color.apply(e, arguments);

          this._pInst._addAccsOutput() && this._pInst._accsBackground(r.levels);
          var i = r.toString();
          this._setFill(i), this._isErasing && this.blendMode(this._cachedBlendMode), this.drawingContext.fillRect(0, 0, this.width, this.height), this._setFill(t), this._isErasing && this._pInst.erase();
        }
        this.drawingContext.restore();
      }, c.default.Renderer2D.prototype.clear = function () {
        this.drawingContext.save(), this.resetMatrix(), this.drawingContext.clearRect(0, 0, this.width, this.height), this.drawingContext.restore();
      }, c.default.Renderer2D.prototype.fill = function () {
        var e,
            t = (e = this._pInst).color.apply(e, arguments);

        this._setFill(t.toString()), this._pInst._addAccsOutput() && this._pInst._accsCanvasColors("fill", t.levels);
      }, c.default.Renderer2D.prototype.stroke = function () {
        var e,
            t = (e = this._pInst).color.apply(e, arguments);

        this._setStroke(t.toString()), this._pInst._addAccsOutput() && this._pInst._accsCanvasColors("stroke", t.levels);
      }, c.default.Renderer2D.prototype.erase = function (e, t) {
        if (!this._isErasing) {
          this._cachedFillStyle = this.drawingContext.fillStyle;

          var r = this._pInst.color(255, e).toString();

          this.drawingContext.fillStyle = r, this._cachedStrokeStyle = this.drawingContext.strokeStyle;

          var i = this._pInst.color(255, t).toString();

          this.drawingContext.strokeStyle = i;
          var n = this._cachedBlendMode;
          this.blendMode(p.REMOVE), this._cachedBlendMode = n, this._isErasing = !0;
        }
      }, c.default.Renderer2D.prototype.noErase = function () {
        this._isErasing && (this.drawingContext.fillStyle = this._cachedFillStyle, this.drawingContext.strokeStyle = this._cachedStrokeStyle, this.blendMode(this._cachedBlendMode), this._isErasing = !1);
      }, c.default.Renderer2D.prototype.image = function (e, t, r, i, n, a, o, s, l) {
        var u;
        e.gifProperties && e._animateGif(this._pInst);

        try {
          this._tint && (c.default.MediaElement && e instanceof c.default.MediaElement && e.loadPixels(), e.canvas && (u = this._getTintedImageCanvas(e))), u = u || e.canvas || e.elt;
          var h = 1;
          e.width && 0 < e.width && (h = u.width / e.width), this._isErasing && this.blendMode(this._cachedBlendMode), this.drawingContext.drawImage(u, h * t, h * r, h * i, h * n, a, o, s, l), this._isErasing && this._pInst.erase();
        } catch (e) {
          if ("NS_ERROR_NOT_AVAILABLE" !== e.name) throw e;
        }
      }, c.default.Renderer2D.prototype._getTintedImageCanvas = function (e) {
        if (!e.canvas) return e;

        var t = f.default._toPixels(e.canvas),
            r = document.createElement("canvas");

        r.width = e.canvas.width, r.height = e.canvas.height;

        for (var i = r.getContext("2d"), n = i.createImageData(e.canvas.width, e.canvas.height), a = n.data, o = 0; o < t.length; o += 4) {
          var s = t[o],
              l = t[o + 1],
              u = t[o + 2],
              h = t[o + 3];
          a[o] = s * this._tint[0] / 255, a[o + 1] = l * this._tint[1] / 255, a[o + 2] = u * this._tint[2] / 255, a[o + 3] = h * this._tint[3] / 255;
        }

        return i.putImageData(n, 0, 0), r;
      }, c.default.Renderer2D.prototype.blendMode = function (e) {
        if (e === p.SUBTRACT) console.warn("blendMode(SUBTRACT) only works in WEBGL mode.");else {
          if (e !== p.BLEND && e !== p.REMOVE && e !== p.DARKEST && e !== p.LIGHTEST && e !== p.DIFFERENCE && e !== p.MULTIPLY && e !== p.EXCLUSION && e !== p.SCREEN && e !== p.REPLACE && e !== p.OVERLAY && e !== p.HARD_LIGHT && e !== p.SOFT_LIGHT && e !== p.DODGE && e !== p.BURN && e !== p.ADD) throw new Error("Mode ".concat(e, " not recognized."));
          this._cachedBlendMode = e, this.drawingContext.globalCompositeOperation = e;
        }
      }, c.default.Renderer2D.prototype.blend = function () {
        for (var e = this.drawingContext.globalCompositeOperation, t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];

        var n = r[r.length - 1],
            a = Array.prototype.slice.call(r, 0, r.length - 1);
        this.drawingContext.globalCompositeOperation = n, c.default.prototype.copy.apply(this, a), this.drawingContext.globalCompositeOperation = e;
      }, c.default.Renderer2D.prototype._getPixel = function (e, t) {
        var r;
        return [(r = this.drawingContext.getImageData(e, t, 1, 1).data)[0], r[1], r[2], r[3]];
      }, c.default.Renderer2D.prototype.loadPixels = function () {
        var e = this._pixelsState,
            t = e._pixelDensity,
            r = this.width * t,
            i = this.height * t,
            n = this.drawingContext.getImageData(0, 0, r, i);
        e._setProperty("imageData", n), e._setProperty("pixels", n.data);
      }, c.default.Renderer2D.prototype.set = function (e, t, r) {
        e = Math.floor(e), t = Math.floor(t);
        var i = this._pixelsState;
        if (r instanceof c.default.Image) this.drawingContext.save(), this.drawingContext.setTransform(1, 0, 0, 1, 0, 0), this.drawingContext.scale(i._pixelDensity, i._pixelDensity), this.drawingContext.clearRect(e, t, r.width, r.height), this.drawingContext.drawImage(r.canvas, e, t), this.drawingContext.restore();else {
          var n = 0,
              a = 0,
              o = 0,
              s = 0,
              l = 4 * (t * i._pixelDensity * (this.width * i._pixelDensity) + e * i._pixelDensity);
          if (i.imageData || i.loadPixels.call(i), "number" == typeof r) l < i.pixels.length && (o = a = n = r, s = 255);else if (r instanceof Array) {
            if (r.length < 4) throw new Error("pixel array must be of the form [R, G, B, A]");
            l < i.pixels.length && (n = r[0], a = r[1], o = r[2], s = r[3]);
          } else r instanceof c.default.Color && l < i.pixels.length && (n = r.levels[0], a = r.levels[1], o = r.levels[2], s = r.levels[3]);

          for (var u = 0; u < i._pixelDensity; u++) for (var h = 0; h < i._pixelDensity; h++) l = 4 * ((t * i._pixelDensity + h) * this.width * i._pixelDensity + (e * i._pixelDensity + u)), i.pixels[l] = n, i.pixels[l + 1] = a, i.pixels[l + 2] = o, i.pixels[l + 3] = s;
        }
      }, c.default.Renderer2D.prototype.updatePixels = function (e, t, r, i) {
        var n = this._pixelsState,
            a = n._pixelDensity;
        void 0 === e && void 0 === t && void 0 === r && void 0 === i && (t = e = 0, r = this.width, i = this.height), e *= a, t *= a, r *= a, i *= a, this.gifProperties && (this.gifProperties.frames[this.gifProperties.displayIndex].image = n.imageData), this.drawingContext.putImageData(n.imageData, e, t, 0, 0, r, i);
      }, c.default.Renderer2D.prototype._acuteArcToBezier = function (e, t) {
        var r = t / 2,
            i = Math.cos(r),
            n = Math.sin(r),
            a = 1 / Math.tan(r),
            o = e + r,
            s = Math.cos(o),
            l = Math.sin(o),
            u = (4 - i) / 3,
            h = n + (i - u) * a;
        return {
          ax: Math.cos(e).toFixed(7),
          ay: Math.sin(e).toFixed(7),
          bx: (u * s + h * l).toFixed(7),
          by: (u * l - h * s).toFixed(7),
          cx: (u * s - h * l).toFixed(7),
          cy: (u * l + h * s).toFixed(7),
          dx: Math.cos(e + t).toFixed(7),
          dy: Math.sin(e + t).toFixed(7)
        };
      }, c.default.Renderer2D.prototype.arc = function (r, i, e, t, n, a, o) {
        var s = this.drawingContext,
            l = e / 2,
            u = t / 2,
            h = 0,
            c = [];

        for (r += l, i += u; 1e-5 <= a - n;) h = Math.min(a - n, p.HALF_PI), c.push(this._acuteArcToBezier(n, h)), n += h;

        return this._doFill && (s.beginPath(), c.forEach(function (e, t) {
          0 === t && s.moveTo(r + e.ax * l, i + e.ay * u), s.bezierCurveTo(r + e.bx * l, i + e.by * u, r + e.cx * l, i + e.cy * u, r + e.dx * l, i + e.dy * u);
        }), o !== p.PIE && null != o || s.lineTo(r, i), s.closePath(), s.fill()), this._doStroke && (s.beginPath(), c.forEach(function (e, t) {
          0 === t && s.moveTo(r + e.ax * l, i + e.ay * u), s.bezierCurveTo(r + e.bx * l, i + e.by * u, r + e.cx * l, i + e.cy * u, r + e.dx * l, i + e.dy * u);
        }), o === p.PIE ? (s.lineTo(r, i), s.closePath()) : o === p.CHORD && s.closePath(), s.stroke()), this;
      }, c.default.Renderer2D.prototype.ellipse = function (e) {
        var t = this.drawingContext,
            r = this._doFill,
            i = this._doStroke,
            n = parseFloat(e[0]),
            a = parseFloat(e[1]),
            o = parseFloat(e[2]),
            s = parseFloat(e[3]);

        if (r && !i) {
          if (this._getFill() === v) return this;
        } else if (!r && i && this._getStroke() === v) return this;

        var l = o / 2 * .5522847498,
            u = s / 2 * .5522847498,
            h = n + o,
            c = a + s,
            f = n + o / 2,
            d = a + s / 2;
        t.beginPath(), t.moveTo(n, d), t.bezierCurveTo(n, d - u, f - l, a, f, a), t.bezierCurveTo(f + l, a, h, d - u, h, d), t.bezierCurveTo(h, d + u, f + l, c, f, c), t.bezierCurveTo(f - l, c, n, d + u, n, d), r && t.fill(), i && t.stroke();
      }, c.default.Renderer2D.prototype.line = function (e, t, r, i) {
        var n = this.drawingContext;
        return this._doStroke && (this._getStroke() === v || (n.beginPath(), n.moveTo(e, t), n.lineTo(r, i), n.stroke())), this;
      }, c.default.Renderer2D.prototype.point = function (e, t) {
        var r = this.drawingContext;
        if (!this._doStroke) return this;
        if (this._getStroke() === v) return this;

        var i = this._getStroke(),
            n = this._getFill();

        e = Math.round(e), t = Math.round(t), this._setFill(i), 1 < r.lineWidth ? (r.beginPath(), r.arc(e, t, r.lineWidth / 2, 0, p.TWO_PI, !1), r.fill()) : r.fillRect(e, t, 1, 1), this._setFill(n);
      }, c.default.Renderer2D.prototype.quad = function (e, t, r, i, n, a, o, s) {
        var l = this.drawingContext,
            u = this._doFill,
            h = this._doStroke;

        if (u && !h) {
          if (this._getFill() === v) return this;
        } else if (!u && h && this._getStroke() === v) return this;

        return l.beginPath(), l.moveTo(e, t), l.lineTo(r, i), l.lineTo(n, a), l.lineTo(o, s), l.closePath(), u && l.fill(), h && l.stroke(), this;
      }, c.default.Renderer2D.prototype.rect = function (e) {
        var t = e[0],
            r = e[1],
            i = e[2],
            n = e[3],
            a = e[4],
            o = e[5],
            s = e[6],
            l = e[7],
            u = this.drawingContext,
            h = this._doFill,
            c = this._doStroke;

        if (h && !c) {
          if (this._getFill() === v) return this;
        } else if (!h && c && this._getStroke() === v) return this;

        if (u.beginPath(), void 0 === a) u.rect(t, r, i, n);else {
          void 0 === o && (o = a), void 0 === s && (s = o), void 0 === l && (l = s);
          var f = Math.abs(i),
              d = Math.abs(n),
              p = f / 2,
              m = d / 2;
          f < 2 * a && (a = p), d < 2 * a && (a = m), f < 2 * o && (o = p), d < 2 * o && (o = m), f < 2 * s && (s = p), d < 2 * s && (s = m), f < 2 * l && (l = p), d < 2 * l && (l = m), u.beginPath(), u.moveTo(t + a, r), u.arcTo(t + i, r, t + i, r + n, o), u.arcTo(t + i, r + n, t, r + n, s), u.arcTo(t, r + n, t, r, l), u.arcTo(t, r, t + i, r, a), u.closePath();
        }
        return this._doFill && u.fill(), this._doStroke && u.stroke(), this;
      }, c.default.Renderer2D.prototype.triangle = function (e) {
        var t = this.drawingContext,
            r = this._doFill,
            i = this._doStroke,
            n = e[0],
            a = e[1],
            o = e[2],
            s = e[3],
            l = e[4],
            u = e[5];

        if (r && !i) {
          if (this._getFill() === v) return this;
        } else if (!r && i && this._getStroke() === v) return this;

        t.beginPath(), t.moveTo(n, a), t.lineTo(o, s), t.lineTo(l, u), t.closePath(), r && t.fill(), i && t.stroke();
      }, c.default.Renderer2D.prototype.endShape = function (e, t, r, i, n, a, o) {
        if (0 === t.length) return this;
        if (!this._doStroke && !this._doFill) return this;
        var s,
            l,
            u,
            h = e === p.CLOSE;
        h && !a && t.push(t[0]);
        var c = t.length;
        if (!r || o !== p.POLYGON && null !== o) {
          if (!i || o !== p.POLYGON && null !== o) {
            if (!n || o !== p.POLYGON && null !== o) {
              if (o === p.POINTS) for (l = 0; l < c; l++) s = t[l], this._doStroke && this._pInst.stroke(s[6]), this._pInst.point(s[0], s[1]);else if (o === p.LINES) for (l = 0; l + 1 < c; l += 2) s = t[l], this._doStroke && this._pInst.stroke(t[l + 1][6]), this._pInst.line(s[0], s[1], t[l + 1][0], t[l + 1][1]);else if (o === p.TRIANGLES) for (l = 0; l + 2 < c; l += 3) s = t[l], this.drawingContext.beginPath(), this.drawingContext.moveTo(s[0], s[1]), this.drawingContext.lineTo(t[l + 1][0], t[l + 1][1]), this.drawingContext.lineTo(t[l + 2][0], t[l + 2][1]), this.drawingContext.closePath(), this._doFill && (this._pInst.fill(t[l + 2][5]), this.drawingContext.fill()), this._doStroke && (this._pInst.stroke(t[l + 2][6]), this.drawingContext.stroke());else if (o === p.TRIANGLE_STRIP) for (l = 0; l + 1 < c; l++) s = t[l], this.drawingContext.beginPath(), this.drawingContext.moveTo(t[l + 1][0], t[l + 1][1]), this.drawingContext.lineTo(s[0], s[1]), this._doStroke && this._pInst.stroke(t[l + 1][6]), this._doFill && this._pInst.fill(t[l + 1][5]), l + 2 < c && (this.drawingContext.lineTo(t[l + 2][0], t[l + 2][1]), this._doStroke && this._pInst.stroke(t[l + 2][6]), this._doFill && this._pInst.fill(t[l + 2][5])), this._doFillStrokeClose(h);else if (o === p.TRIANGLE_FAN) {
                if (2 < c) {
                  for (this.drawingContext.beginPath(), l = 2; l < c; l++) s = t[l], this.drawingContext.moveTo(t[0][0], t[0][1]), this.drawingContext.lineTo(t[l - 1][0], t[l - 1][1]), this.drawingContext.lineTo(s[0], s[1]), this.drawingContext.lineTo(t[0][0], t[0][1]), l < c - 1 && (this._doFill && s[5] !== t[l + 1][5] || this._doStroke && s[6] !== t[l + 1][6]) && (this._doFill && (this._pInst.fill(s[5]), this.drawingContext.fill(), this._pInst.fill(t[l + 1][5])), this._doStroke && (this._pInst.stroke(s[6]), this.drawingContext.stroke(), this._pInst.stroke(t[l + 1][6])), this.drawingContext.closePath(), this.drawingContext.beginPath());

                  this._doFillStrokeClose(h);
                }
              } else if (o === p.QUADS) for (l = 0; l + 3 < c; l += 4) {
                for (s = t[l], this.drawingContext.beginPath(), this.drawingContext.moveTo(s[0], s[1]), u = 1; u < 4; u++) this.drawingContext.lineTo(t[l + u][0], t[l + u][1]);

                this.drawingContext.lineTo(s[0], s[1]), this._doFill && this._pInst.fill(t[l + 3][5]), this._doStroke && this._pInst.stroke(t[l + 3][6]), this._doFillStrokeClose(h);
              } else if (o === p.QUAD_STRIP) {
                if (3 < c) for (l = 0; l + 1 < c; l += 2) s = t[l], this.drawingContext.beginPath(), l + 3 < c ? (this.drawingContext.moveTo(t[l + 2][0], t[l + 2][1]), this.drawingContext.lineTo(s[0], s[1]), this.drawingContext.lineTo(t[l + 1][0], t[l + 1][1]), this.drawingContext.lineTo(t[l + 3][0], t[l + 3][1]), this._doFill && this._pInst.fill(t[l + 3][5]), this._doStroke && this._pInst.stroke(t[l + 3][6])) : (this.drawingContext.moveTo(s[0], s[1]), this.drawingContext.lineTo(t[l + 1][0], t[l + 1][1])), this._doFillStrokeClose(h);
              } else {
                for (this.drawingContext.beginPath(), this.drawingContext.moveTo(t[0][0], t[0][1]), l = 1; l < c; l++) (s = t[l]).isVert && (s.moveTo ? this.drawingContext.moveTo(s[0], s[1]) : this.drawingContext.lineTo(s[0], s[1]));

                this._doFillStrokeClose(h);
              }
            } else {
              for (this.drawingContext.beginPath(), l = 0; l < c; l++) t[l].isVert ? t[l].moveTo ? this.drawingContext.moveTo(t[l][0], t[l][1]) : this.drawingContext.lineTo(t[l][0], t[l][1]) : this.drawingContext.quadraticCurveTo(t[l][0], t[l][1], t[l][2], t[l][3]);

              this._doFillStrokeClose(h);
            }
          } else {
            for (this.drawingContext.beginPath(), l = 0; l < c; l++) t[l].isVert ? t[l].moveTo ? this.drawingContext.moveTo(t[l][0], t[l][1]) : this.drawingContext.lineTo(t[l][0], t[l][1]) : this.drawingContext.bezierCurveTo(t[l][0], t[l][1], t[l][2], t[l][3], t[l][4], t[l][5]);

            this._doFillStrokeClose(h);
          }
        } else if (3 < c) {
          var f = [],
              d = 1 - this._curveTightness;

          for (this.drawingContext.beginPath(), this.drawingContext.moveTo(t[1][0], t[1][1]), l = 1; l + 2 < c; l++) s = t[l], f[0] = [s[0], s[1]], f[1] = [s[0] + (d * t[l + 1][0] - d * t[l - 1][0]) / 6, s[1] + (d * t[l + 1][1] - d * t[l - 1][1]) / 6], f[2] = [t[l + 1][0] + (d * t[l][0] - d * t[l + 2][0]) / 6, t[l + 1][1] + (d * t[l][1] - d * t[l + 2][1]) / 6], f[3] = [t[l + 1][0], t[l + 1][1]], this.drawingContext.bezierCurveTo(f[1][0], f[1][1], f[2][0], f[2][1], f[3][0], f[3][1]);

          h && this.drawingContext.lineTo(t[l + 1][0], t[l + 1][1]), this._doFillStrokeClose(h);
        }
        return a = n = i = r = !1, h && t.pop(), this;
      }, c.default.Renderer2D.prototype.strokeCap = function (e) {
        return e !== p.ROUND && e !== p.SQUARE && e !== p.PROJECT || (this.drawingContext.lineCap = e), this;
      }, c.default.Renderer2D.prototype.strokeJoin = function (e) {
        return e !== p.ROUND && e !== p.BEVEL && e !== p.MITER || (this.drawingContext.lineJoin = e), this;
      }, c.default.Renderer2D.prototype.strokeWeight = function (e) {
        return this.drawingContext.lineWidth = void 0 === e || 0 === e ? 1e-4 : e, this;
      }, c.default.Renderer2D.prototype._getFill = function () {
        return this._cachedFillStyle || (this._cachedFillStyle = this.drawingContext.fillStyle), this._cachedFillStyle;
      }, c.default.Renderer2D.prototype._setFill = function (e) {
        e !== this._cachedFillStyle && (this.drawingContext.fillStyle = e, this._cachedFillStyle = e);
      }, c.default.Renderer2D.prototype._getStroke = function () {
        return this._cachedStrokeStyle || (this._cachedStrokeStyle = this.drawingContext.strokeStyle), this._cachedStrokeStyle;
      }, c.default.Renderer2D.prototype._setStroke = function (e) {
        e !== this._cachedStrokeStyle && (this.drawingContext.strokeStyle = e, this._cachedStrokeStyle = e);
      }, c.default.Renderer2D.prototype.bezier = function (e, t, r, i, n, a, o, s) {
        return this._pInst.beginShape(), this._pInst.vertex(e, t), this._pInst.bezierVertex(r, i, n, a, o, s), this._pInst.endShape(), this;
      }, c.default.Renderer2D.prototype.curve = function (e, t, r, i, n, a, o, s) {
        return this._pInst.beginShape(), this._pInst.curveVertex(e, t), this._pInst.curveVertex(r, i), this._pInst.curveVertex(n, a), this._pInst.curveVertex(o, s), this._pInst.endShape(), this;
      }, c.default.Renderer2D.prototype._doFillStrokeClose = function (e) {
        e && this.drawingContext.closePath(), this._doFill && this.drawingContext.fill(), this._doStroke && this.drawingContext.stroke();
      }, c.default.Renderer2D.prototype.applyMatrix = function (e, t, r, i, n, a) {
        this.drawingContext.transform(e, t, r, i, n, a);
      }, c.default.Renderer2D.prototype.resetMatrix = function () {
        return this.drawingContext.setTransform(1, 0, 0, 1, 0, 0), this.drawingContext.scale(this._pInst._pixelDensity, this._pInst._pixelDensity), this;
      }, c.default.Renderer2D.prototype.rotate = function (e) {
        this.drawingContext.rotate(e);
      }, c.default.Renderer2D.prototype.scale = function (e, t) {
        return this.drawingContext.scale(e, t), this;
      }, c.default.Renderer2D.prototype.translate = function (e, t) {
        return e instanceof c.default.Vector && (t = e.y, e = e.x), this.drawingContext.translate(e, t), this;
      }, c.default.Renderer2D.prototype.text = function (e, t, r, i, n) {
        var a;
        void 0 !== i && this.drawingContext.textBaseline === p.BASELINE && (a = !0, this.drawingContext.textBaseline = p.TOP);
        var o = c.default.Renderer.prototype.text.apply(this, arguments);
        return a && (this.drawingContext.textBaseline = p.BASELINE), o;
      }, c.default.Renderer2D.prototype._renderText = function (e, t, r, i, n) {
        if (!(n <= i)) return e.push(), this._isOpenType() ? this._textFont._renderPath(t, r, i, {
          renderer: this
        }) : (this._doStroke && this._strokeSet && this.drawingContext.strokeText(t, r, i), this._doFill && (this._fillSet || this._setFill(p._DEFAULT_TEXT_FILL), this.drawingContext.fillText(t, r, i))), e.pop(), e;
      }, c.default.Renderer2D.prototype.textWidth = function (e) {
        return this._isOpenType() ? this._textFont._textWidth(e, this._textSize) : this.drawingContext.measureText(e).width;
      }, c.default.Renderer2D.prototype._applyTextProperties = function () {
        var e,
            t = this._pInst;
        return this._setProperty("_textAscent", null), this._setProperty("_textDescent", null), e = this._textFont, this._isOpenType() && (e = this._textFont.font.familyName, this._setProperty("_textStyle", this._textFont.font.styleName)), this.drawingContext.font = "".concat(this._textStyle || "normal", " ").concat(this._textSize || 12, "px ").concat(e || "sans-serif"), this.drawingContext.textAlign = this._textAlign, this._textBaseline === p.CENTER ? this.drawingContext.textBaseline = p._CTX_MIDDLE : this.drawingContext.textBaseline = this._textBaseline, t;
      }, c.default.Renderer2D.prototype.push = function () {
        return this.drawingContext.save(), c.default.Renderer.prototype.push.apply(this);
      }, c.default.Renderer2D.prototype.pop = function (e) {
        this.drawingContext.restore(), this._cachedFillStyle = this.drawingContext.fillStyle, this._cachedStrokeStyle = this.drawingContext.strokeStyle, c.default.Renderer.prototype.pop.call(this, e);
      };
      var n = c.default.Renderer2D;
      r.default = n;
    }, {
      "../image/filters": 57,
      "./constants": 26,
      "./main": 36,
      "./p5.Renderer": 39
    }],
    41: [function (e, t, r) {
      "use strict";

      var i,
          f = (i = e("./main")) && i.__esModule ? i : {
        default: i
      };
      f.default.prototype._promisePreloads = [];
      var d = !(f.default.prototype.registerPromisePreload = function (e) {
        f.default.prototype._promisePreloads.push(e);
      });
      f.default.prototype._setupPromisePreloads = function () {
        var e = !0,
            t = !1,
            r = void 0;

        try {
          for (var i, n = this._promisePreloads[Symbol.iterator](); !(e = (i = n.next()).done); e = !0) {
            var a = i.value,
                o = this,
                s = a.method,
                l = a.addCallbacks,
                u = a.legacyPreloadSetup,
                h = a.target || this,
                c = h[s].bind(h);

            if (h === f.default.prototype) {
              if (d) continue;
              o = null, c = h[s];
            }

            if (h[s] = this._wrapPromisePreload(o, c, l), u) h[u.method] = this._legacyPreloadGenerator(o, u, h[s]);
          }
        } catch (e) {
          t = !0, r = e;
        } finally {
          try {
            e || null == n.return || n.return();
          } finally {
            if (t) throw r;
          }
        }

        d = !0;
      }, f.default.prototype._wrapPromisePreload = function (e, l, u) {
        var t = function () {
          var e = this;

          this._incrementPreload();

          for (var t = null, r = null, i = arguments.length, n = new Array(i), a = 0; a < i; a++) n[a] = arguments[a];

          if (u) for (var o = n.length - 1; 0 <= o && !r && "function" == typeof n[o]; o--) r = t, t = n.pop();
          var s = Promise.resolve(l.apply(this, n));
          return t && s.then(t), r && s.catch(r), s.then(function () {
            return e._decrementPreload();
          }), s;
        };

        return e && (t = t.bind(e)), t;
      };

      function a() {
        return {};
      }

      f.default.prototype._legacyPreloadGenerator = function (e, t, i) {
        var n = t.createBaseObject || a,
            r = function () {
          var t = this;

          this._incrementPreload();

          var r = n.apply(this, arguments);
          return i.apply(this, arguments).then(function (e) {
            Object.assign(r, e), t._decrementPreload();
          }), r;
        };

        return e && (r = r.bind(e)), r;
      };
    }, {
      "./main": 36
    }],
    42: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var i,
          l = (i = e("./main")) && i.__esModule ? i : {
        default: i
      },
          u = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== s(e) && "function" != typeof e) return {
          default: e
        };
        var t = o();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("./constants"));

      function o() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return o = function () {
          return e;
        }, e;
      }

      function s(e) {
        return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      e("./p5.Graphics"), e("./p5.Renderer2D"), e("../webgl/p5.RendererGL");
      var h = "defaultCanvas0";
      l.default.prototype.createCanvas = function (e, t, r) {
        l.default._validateParameters("createCanvas", arguments);

        var i,
            n = r || u.P2D;

        if (n === u.WEBGL) {
          if (i = document.getElementById(h)) {
            i.parentNode.removeChild(i);
            var a = this._renderer;
            this._elements = this._elements.filter(function (e) {
              return e !== a;
            });
          }

          (i = document.createElement("canvas")).id = h, i.classList.add("p5Canvas");
        } else if (this._defaultGraphicsCreated) i = this.canvas;else {
          i = document.createElement("canvas");

          for (var o = 0; document.getElementById("defaultCanvas".concat(o));) o++;

          h = "defaultCanvas".concat(o), i.id = h, i.classList.add("p5Canvas");
        }

        if (this._setupDone || (i.dataset.hidden = !0, i.style.visibility = "hidden"), this._userNode) this._userNode.appendChild(i);else {
          if (0 === document.getElementsByTagName("main").length) {
            var s = document.createElement("main");
            document.body.appendChild(s);
          }

          document.getElementsByTagName("main")[0].appendChild(i);
        }
        return n === u.WEBGL ? (this._setProperty("_renderer", new l.default.RendererGL(i, this, !0)), this._elements.push(this._renderer)) : this._defaultGraphicsCreated || (this._setProperty("_renderer", new l.default.Renderer2D(i, this, !0)), this._defaultGraphicsCreated = !0, this._elements.push(this._renderer)), this._renderer.resize(e, t), this._renderer._applyDefaults(), this._renderer;
      }, l.default.prototype.resizeCanvas = function (e, t, r) {
        if (l.default._validateParameters("resizeCanvas", arguments), this._renderer) {
          var i = {};

          for (var n in this.drawingContext) {
            var a = this.drawingContext[n];
            "object" !== s(a) && "function" != typeof a && (i[n] = a);
          }

          for (var o in this._renderer.resize(e, t), this.width = e, this.height = t, i) try {
            this.drawingContext[o] = i[o];
          } catch (e) {}

          r || this.redraw();
        }

        this._addAccsOutput() && this._updateAccsOutput();
      }, l.default.prototype.noCanvas = function () {
        this.canvas && this.canvas.parentNode.removeChild(this.canvas);
      }, l.default.prototype.createGraphics = function (e, t, r) {
        return l.default._validateParameters("createGraphics", arguments), new l.default.Graphics(e, t, r, this);
      }, l.default.prototype.blendMode = function (e) {
        l.default._validateParameters("blendMode", arguments), e === u.NORMAL && (console.warn("NORMAL has been deprecated for use in blendMode. defaulting to BLEND instead."), e = u.BLEND), this._renderer.blendMode(e);
      };
      var n = l.default;
      r.default = n;
    }, {
      "../webgl/p5.RendererGL": 90,
      "./constants": 26,
      "./main": 36,
      "./p5.Graphics": 38,
      "./p5.Renderer2D": 40
    }],
    43: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var h = i(e("../main")),
          s = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = l();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../constants")),
          c = i(e("../helpers"));

      function l() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return l = function () {
          return e;
        }, e;
      }

      function i(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      e("../friendly_errors/fes_core"), e("../friendly_errors/file_errors"), e("../friendly_errors/validate_params"), h.default.prototype._normalizeArcAngles = function (e, t, r, i, n) {
        var a;
        return e -= s.TWO_PI * Math.floor(e / s.TWO_PI), t -= s.TWO_PI * Math.floor(t / s.TWO_PI), a = Math.min(Math.abs(e - t), s.TWO_PI - Math.abs(e - t)), n && (e = e <= s.HALF_PI ? Math.atan(r / i * Math.tan(e)) : e > s.HALF_PI && e <= 3 * s.HALF_PI ? Math.atan(r / i * Math.tan(e)) + s.PI : Math.atan(r / i * Math.tan(e)) + s.TWO_PI, t = t <= s.HALF_PI ? Math.atan(r / i * Math.tan(t)) : t > s.HALF_PI && t <= 3 * s.HALF_PI ? Math.atan(r / i * Math.tan(t)) + s.PI : Math.atan(r / i * Math.tan(t)) + s.TWO_PI), t < e && (t += s.TWO_PI), {
          start: e,
          stop: t,
          correspondToSamePoint: a < 1e-5
        };
      }, h.default.prototype.arc = function (e, t, r, i, n, a, o, s) {
        if (h.default._validateParameters("arc", arguments), !this._renderer._doStroke && !this._renderer._doFill) return this;
        if (n === a) return this;
        n = this._toRadians(n), a = this._toRadians(a), r = Math.abs(r), i = Math.abs(i);

        var l = c.default.modeAdjust(e, t, r, i, this._renderer._ellipseMode),
            u = this._normalizeArcAngles(n, a, l.w, l.h, !0);

        return u.correspondToSamePoint ? this._renderer.ellipse([l.x, l.y, l.w, l.h, s]) : (this._renderer.arc(l.x, l.y, l.w, l.h, u.start, u.stop, o, s), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput("arc", [l.x, l.y, l.w, l.h, u.start, u.stop, o])), this;
      }, h.default.prototype.ellipse = function (e, t, r, i, n) {
        return h.default._validateParameters("ellipse", arguments), this._renderEllipse.apply(this, arguments);
      }, h.default.prototype.circle = function () {
        h.default._validateParameters("circle", arguments);

        var e = Array.prototype.slice.call(arguments, 0, 2);
        return e.push(arguments[2]), e.push(arguments[2]), this._renderEllipse.apply(this, e);
      }, h.default.prototype._renderEllipse = function (e, t, r, i, n) {
        if (!this._renderer._doStroke && !this._renderer._doFill) return this;
        r < 0 && (r = Math.abs(r)), void 0 === i ? i = r : i < 0 && (i = Math.abs(i));
        var a = c.default.modeAdjust(e, t, r, i, this._renderer._ellipseMode);
        return this._renderer.ellipse([a.x, a.y, a.w, a.h, n]), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput("ellipse", [a.x, a.y, a.w, a.h]), this;
      }, h.default.prototype.line = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        var i;
        h.default._validateParameters("line", t), this._renderer._doStroke && (i = this._renderer).line.apply(i, t);
        return (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput("line", t), this;
      }, h.default.prototype.point = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        var i;
        h.default._validateParameters("point", t), this._renderer._doStroke && (1 === t.length && t[0] instanceof h.default.Vector ? this._renderer.point.call(this._renderer, t[0].x, t[0].y, t[0].z) : ((i = this._renderer).point.apply(i, t), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput("point", t)));
        return this;
      }, h.default.prototype.quad = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        var i;
        h.default._validateParameters("quad", t), (this._renderer._doStroke || this._renderer._doFill) && (this._renderer.isP3D && 12 !== t.length ? this._renderer.quad.call(this._renderer, t[0], t[1], 0, t[2], t[3], 0, t[4], t[5], 0, t[6], t[7], 0) : ((i = this._renderer).quad.apply(i, t), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput("quadrilateral", t)));
        return this;
      }, h.default.prototype.rect = function () {
        return h.default._validateParameters("rect", arguments), this._renderRect.apply(this, arguments);
      }, h.default.prototype.square = function (e, t, r, i, n, a, o) {
        return h.default._validateParameters("square", arguments), this._renderRect.call(this, e, t, r, r, i, n, a, o);
      }, h.default.prototype._renderRect = function () {
        if (this._renderer._doStroke || this._renderer._doFill) {
          3 === arguments.length && (arguments[3] = arguments[2]);

          for (var e = c.default.modeAdjust(arguments[0], arguments[1], arguments[2], arguments[3], this._renderer._rectMode), t = [e.x, e.y, e.w, e.h], r = 4; r < arguments.length; r++) t[r] = arguments[r];

          this._renderer.rect(t), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput("rectangle", [e.x, e.y, e.w, e.h]);
        }

        return this;
      }, h.default.prototype.triangle = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        return h.default._validateParameters("triangle", t), (this._renderer._doStroke || this._renderer._doFill) && this._renderer.triangle(t), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput("triangle", t), this;
      };
      var n = h.default;
      r.default = n;
    }, {
      "../constants": 26,
      "../friendly_errors/fes_core": 28,
      "../friendly_errors/file_errors": 29,
      "../friendly_errors/validate_params": 31,
      "../helpers": 32,
      "../main": 36
    }],
    44: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var i,
          n = (i = e("../main")) && i.__esModule ? i : {
        default: i
      },
          a = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../constants"));

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      n.default.prototype.ellipseMode = function (e) {
        return n.default._validateParameters("ellipseMode", arguments), e !== a.CORNER && e !== a.CORNERS && e !== a.RADIUS && e !== a.CENTER || (this._renderer._ellipseMode = e), this;
      }, n.default.prototype.noSmooth = function () {
        return this.setAttributes("antialias", !1), this._renderer.isP3D || "imageSmoothingEnabled" in this.drawingContext && (this.drawingContext.imageSmoothingEnabled = !1), this;
      }, n.default.prototype.rectMode = function (e) {
        return n.default._validateParameters("rectMode", arguments), e !== a.CORNER && e !== a.CORNERS && e !== a.RADIUS && e !== a.CENTER || (this._renderer._rectMode = e), this;
      }, n.default.prototype.smooth = function () {
        return this.setAttributes("antialias", !0), this._renderer.isP3D || "imageSmoothingEnabled" in this.drawingContext && (this.drawingContext.imageSmoothingEnabled = !0), this;
      }, n.default.prototype.strokeCap = function (e) {
        return n.default._validateParameters("strokeCap", arguments), e !== a.ROUND && e !== a.SQUARE && e !== a.PROJECT || this._renderer.strokeCap(e), this;
      }, n.default.prototype.strokeJoin = function (e) {
        return n.default._validateParameters("strokeJoin", arguments), e !== a.ROUND && e !== a.BEVEL && e !== a.MITER || this._renderer.strokeJoin(e), this;
      }, n.default.prototype.strokeWeight = function (e) {
        return n.default._validateParameters("strokeWeight", arguments), this._renderer.strokeWeight(e), this;
      };
      var l = n.default;
      r.default = l;
    }, {
      "../constants": 26,
      "../main": 36
    }],
    45: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          s = (i = e("../main")) && i.__esModule ? i : {
        default: i
      };
      e("../friendly_errors/fes_core"), e("../friendly_errors/file_errors"), e("../friendly_errors/validate_params"), s.default.prototype.bezier = function () {
        for (var e, t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];

        return s.default._validateParameters("bezier", r), (this._renderer._doStroke || this._renderer._doFill) && (e = this._renderer).bezier.apply(e, r), this;
      }, s.default.prototype.bezierDetail = function (e) {
        return s.default._validateParameters("bezierDetail", arguments), this._bezierDetail = e, this;
      }, s.default.prototype.bezierPoint = function (e, t, r, i, n) {
        s.default._validateParameters("bezierPoint", arguments);

        var a = 1 - n;
        return Math.pow(a, 3) * e + 3 * Math.pow(a, 2) * n * t + 3 * a * Math.pow(n, 2) * r + Math.pow(n, 3) * i;
      }, s.default.prototype.bezierTangent = function (e, t, r, i, n) {
        s.default._validateParameters("bezierTangent", arguments);

        var a = 1 - n;
        return 3 * i * Math.pow(n, 2) - 3 * r * Math.pow(n, 2) + 6 * r * a * n - 6 * t * a * n + 3 * t * Math.pow(a, 2) - 3 * e * Math.pow(a, 2);
      }, s.default.prototype.curve = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        var i;
        s.default._validateParameters("curve", t), this._renderer._doStroke && (i = this._renderer).curve.apply(i, t);
        return this;
      }, s.default.prototype.curveDetail = function (e) {
        return s.default._validateParameters("curveDetail", arguments), this._curveDetail = e < 3 ? 3 : e, this;
      }, s.default.prototype.curveTightness = function (e) {
        return s.default._validateParameters("curveTightness", arguments), this._renderer._curveTightness = e, this;
      }, s.default.prototype.curvePoint = function (e, t, r, i, n) {
        s.default._validateParameters("curvePoint", arguments);

        var a = n * n * n,
            o = n * n;
        return e * (-.5 * a + o - .5 * n) + t * (1.5 * a - 2.5 * o + 1) + r * (-1.5 * a + 2 * o + .5 * n) + i * (.5 * a - .5 * o);
      }, s.default.prototype.curveTangent = function (e, t, r, i, n) {
        s.default._validateParameters("curveTangent", arguments);

        var a = n * n;
        return e * (-3 * a / 2 + 2 * n - .5) + t * (9 * a / 2 - 5 * n) + r * (-9 * a / 2 + 4 * n + .5) + i * (3 * a / 2 - n);
      };
      var n = s.default;
      r.default = n;
    }, {
      "../friendly_errors/fes_core": 28,
      "../friendly_errors/file_errors": 29,
      "../friendly_errors/validate_params": 31,
      "../main": 36
    }],
    46: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var i,
          s = (i = e("../main")) && i.__esModule ? i : {
        default: i
      },
          l = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = u();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../constants"));

      function u() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return u = function () {
          return e;
        }, e;
      }

      var n = null,
          h = [],
          c = [],
          f = !1,
          a = !1,
          d = !1,
          p = !1,
          m = !0;
      s.default.prototype.beginContour = function () {
        return c = [], p = !0, this;
      }, s.default.prototype.beginShape = function (e) {
        var t;
        (s.default._validateParameters("beginShape", arguments), this._renderer.isP3D) ? (t = this._renderer).beginShape.apply(t, arguments) : (n = e === l.POINTS || e === l.LINES || e === l.TRIANGLES || e === l.TRIANGLE_FAN || e === l.TRIANGLE_STRIP || e === l.QUADS || e === l.QUAD_STRIP ? e : null, h = [], c = []);
        return this;
      }, s.default.prototype.bezierVertex = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        var i;
        if (s.default._validateParameters("bezierVertex", t), this._renderer.isP3D) (i = this._renderer).bezierVertex.apply(i, t);else if (0 === h.length) s.default._friendlyError("vertex() must be used once before calling bezierVertex()", "bezierVertex");else {
          f = !0;

          for (var n = [], a = 0; a < t.length; a++) n[a] = t[a];

          n.isVert = !1, p ? c.push(n) : h.push(n);
        }
        return this;
      }, s.default.prototype.curveVertex = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        var i;
        (s.default._validateParameters("curveVertex", t), this._renderer.isP3D) ? (i = this._renderer).curveVertex.apply(i, t) : (a = !0, this.vertex(t[0], t[1]));
        return this;
      }, s.default.prototype.endContour = function () {
        var e = c[0].slice();
        e.isVert = c[0].isVert, e.moveTo = !1, c.push(e), m && (h.push(h[0]), m = !1);

        for (var t = 0; t < c.length; t++) h.push(c[t]);

        return this;
      }, s.default.prototype.endShape = function (e) {
        if (s.default._validateParameters("endShape", arguments), this._renderer.isP3D) this._renderer.endShape(e, a, f, d, p, n);else {
          if (0 === h.length) return this;
          if (!this._renderer._doStroke && !this._renderer._doFill) return this;
          var t = e === l.CLOSE;
          t && !p && h.push(h[0]), this._renderer.endShape(e, h, a, f, d, p, n), m = !(p = d = f = a = !1), t && h.pop();
        }
        return this;
      }, s.default.prototype.quadraticVertex = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        if (s.default._validateParameters("quadraticVertex", t), this._renderer.isP3D) {
          var i;

          (i = this._renderer).quadraticVertex.apply(i, t);
        } else {
          if (this._contourInited) {
            var n = {};
            return n.x = t[0], n.y = t[1], n.x3 = t[2], n.y3 = t[3], n.type = l.QUADRATIC, this._contourVertices.push(n), this;
          }

          if (0 < h.length) {
            d = !0;

            for (var a = [], o = 0; o < t.length; o++) a[o] = t[o];

            a.isVert = !1, p ? c.push(a) : h.push(a);
          } else s.default._friendlyError("vertex() must be used once before calling quadraticVertex()", "quadraticVertex");
        }

        return this;
      }, s.default.prototype.vertex = function (e, t, r, i, n) {
        if (this._renderer.isP3D) {
          var a;

          (a = this._renderer).vertex.apply(a, arguments);
        } else {
          var o = [];
          o.isVert = !0, o[0] = e, o[1] = t, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = this._renderer._getFill(), o[6] = this._renderer._getStroke(), r && (o.moveTo = r), p ? (0 === c.length && (o.moveTo = !0), c.push(o)) : h.push(o);
        }

        return this;
      };
      var v = s.default;
      r.default = v;
    }, {
      "../constants": 26,
      "../main": 36
    }],
    47: [function (e, t, r) {
      "use strict";

      function i(e) {
        return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (e, t) {
        window.setTimeout(e, 1e3 / 60);
      }, "undefined" == typeof Uint8ClampedArray || Uint8ClampedArray.prototype.slice || Object.defineProperty(Uint8ClampedArray.prototype, "slice", {
        value: Array.prototype.slice,
        writable: !0,
        configurable: !0,
        enumerable: !1
      }), function () {
        if (!Object.assign) {
          var s = Object.keys,
              e = Object.defineProperty,
              l = "function" == typeof Symbol && "symbol" === i(Symbol()),
              r = Object.prototype.propertyIsEnumerable,
              u = function (t) {
            return function (e) {
              return r.call(t, e);
            };
          };

          e(Object, "assign", {
            value: function (e, t) {
              if (null == e) throw new TypeError("target must be an object");
              var r,
                  i,
                  n,
                  a,
                  o = Object(e);

              for (r = 1; r < arguments.length; ++r) for (i = Object(arguments[r]), a = s(i), l && Object.getOwnPropertySymbols && a.push.apply(a, Object.getOwnPropertySymbols(i).filter(u(i))), n = 0; n < a.length; ++n) o[a[n]] = i[a[n]];

              return o;
            },
            configurable: !0,
            enumerable: !1,
            writable: !0
          });
        }
      }();
    }, {}],
    48: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("./main")) && i.__esModule ? i : {
        default: i
      };
      n.default.prototype.noLoop = function () {
        this._loop = !1;
      }, n.default.prototype.loop = function () {
        this._loop || (this._loop = !0, this._setupDone && this._draw());
      }, n.default.prototype.isLooping = function () {
        return this._loop;
      }, n.default.prototype.push = function () {
        this._styles.push({
          props: {
            _colorMode: this._colorMode
          },
          renderer: this._renderer.push()
        });
      }, n.default.prototype.pop = function () {
        var e = this._styles.pop();

        e ? (this._renderer.pop(e.renderer), Object.assign(this, e.props)) : console.warn("pop() was called without matching push()");
      }, n.default.prototype.redraw = function (e) {
        if (!this._inUserDraw && this._setupDone) {
          var t = parseInt(e);
          (isNaN(t) || t < 1) && (t = 1);
          var r = this._isGlobal ? window : this;

          if ("function" == typeof r.draw) {
            void 0 === r.setup && r.scale(r._pixelDensity, r._pixelDensity);

            for (var i = function (e) {
              e.call(r);
            }, n = 0; n < t; n++) {
              r.resetMatrix(), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._updateAccsOutput(), r._renderer.isP3D && r._renderer._update(), r._setProperty("frameCount", r.frameCount + 1), r._registeredMethods.pre.forEach(i), this._inUserDraw = !0;

              try {
                r.draw();
              } finally {
                this._inUserDraw = !1;
              }

              r._registeredMethods.post.forEach(i);
            }
          }
        }
      };
      var a = n.default;
      r.default = a;
    }, {
      "./main": 36
    }],
    49: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          a = (i = e("./main")) && i.__esModule ? i : {
        default: i
      };
      a.default.prototype.applyMatrix = function (e, t, r, i, n, a) {
        var o;
        return (o = this._renderer).applyMatrix.apply(o, arguments), this;
      }, a.default.prototype.resetMatrix = function () {
        return this._renderer.resetMatrix(), this;
      }, a.default.prototype.rotate = function (e, t) {
        return a.default._validateParameters("rotate", arguments), this._renderer.rotate(this._toRadians(e), t), this;
      }, a.default.prototype.rotateX = function (e) {
        return this._assert3d("rotateX"), a.default._validateParameters("rotateX", arguments), this._renderer.rotateX(this._toRadians(e)), this;
      }, a.default.prototype.rotateY = function (e) {
        return this._assert3d("rotateY"), a.default._validateParameters("rotateY", arguments), this._renderer.rotateY(this._toRadians(e)), this;
      }, a.default.prototype.rotateZ = function (e) {
        return this._assert3d("rotateZ"), a.default._validateParameters("rotateZ", arguments), this._renderer.rotateZ(this._toRadians(e)), this;
      }, a.default.prototype.scale = function (e, t, r) {
        if (a.default._validateParameters("scale", arguments), e instanceof a.default.Vector) {
          var i = e;
          e = i.x, t = i.y, r = i.z;
        } else if (e instanceof Array) {
          var n = e;
          e = n[0], t = n[1], r = n[2] || 1;
        }

        return isNaN(t) ? t = r = e : isNaN(r) && (r = 1), this._renderer.scale.call(this._renderer, e, t, r), this;
      }, a.default.prototype.shearX = function (e) {
        a.default._validateParameters("shearX", arguments);

        var t = this._toRadians(e);

        return this._renderer.applyMatrix(1, 0, Math.tan(t), 1, 0, 0), this;
      }, a.default.prototype.shearY = function (e) {
        a.default._validateParameters("shearY", arguments);

        var t = this._toRadians(e);

        return this._renderer.applyMatrix(1, Math.tan(t), 0, 1, 0, 0), this;
      }, a.default.prototype.translate = function (e, t, r) {
        return a.default._validateParameters("translate", arguments), this._renderer.isP3D ? this._renderer.translate(e, t, r) : this._renderer.translate(e, t), this;
      };
      var n = a.default;
      r.default = n;
    }, {
      "./main": 36
    }],
    50: [function (e, t, r) {
      "use strict";

      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };

      function a(e) {
        return function (e) {
          if (Array.isArray(e)) {
            for (var t = 0, r = new Array(e.length); t < e.length; t++) r[t] = e[t];

            return r;
          }
        }(e) || function (e) {
          if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e);
        }(e) || function () {
          throw new TypeError("Invalid attempt to spread non-iterable instance");
        }();
      }

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      n.default.prototype.storeItem = function (e, t) {
        "string" != typeof e && console.log("The argument that you passed to storeItem() - ".concat(e, " is not a string.")), e.endsWith("p5TypeID") && console.log("The argument that you passed to storeItem() - ".concat(e, " must not end with 'p5TypeID'.")), void 0 === t && console.log("You cannot store undefined variables using storeItem().");
        var r = o(t);

        switch (r) {
          case "number":
          case "boolean":
            t = t.toString();
            break;

          case "object":
            if (t instanceof n.default.Color) r = "p5.Color";else if (t instanceof n.default.Vector) {
              r = "p5.Vector", t = [t.x, t.y, t.z];
            }
            t = JSON.stringify(t);
        }

        localStorage.setItem(e, t);
        var i = "".concat(e, "p5TypeID");
        localStorage.setItem(i, r);
      }, n.default.prototype.getItem = function (e) {
        var t = localStorage.getItem(e),
            r = localStorage.getItem("".concat(e, "p5TypeID"));
        if (void 0 === r) console.log("Unable to determine type of item stored under ".concat(e, "in local storage. Did you save the item with something other than setItem()?"));else if (null !== t) switch (r) {
          case "number":
            t = parseFloat(t);
            break;

          case "boolean":
            t = "true" === t;
            break;

          case "object":
            t = JSON.parse(t);
            break;

          case "p5.Color":
            t = JSON.parse(t), t = this.color.apply(this, a(t.levels));
            break;

          case "p5.Vector":
            t = JSON.parse(t), t = this.createVector.apply(this, a(t));
        }
        return t;
      }, n.default.prototype.clearStorage = function () {
        localStorage.clear();
      }, n.default.prototype.removeItem = function (e) {
        "string" != typeof e && console.log("The argument that you passed to removeItem() - ".concat(e, " is not a string.")), localStorage.removeItem(e), localStorage.removeItem("".concat(e, "p5TypeID"));
      };
    }, {
      "../core/main": 36
    }],
    51: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      n.default.prototype.createStringDict = function (e, t) {
        return n.default._validateParameters("createStringDict", arguments), new n.default.StringDict(e, t);
      }, n.default.prototype.createNumberDict = function (e, t) {
        return n.default._validateParameters("createNumberDict", arguments), new n.default.NumberDict(e, t);
      }, n.default.TypedDict = function (e, t) {
        return e instanceof Object ? this.data = e : (this.data = {}, this.data[e] = t), this;
      }, n.default.TypedDict.prototype.size = function () {
        return Object.keys(this.data).length;
      }, n.default.TypedDict.prototype.hasKey = function (e) {
        return this.data.hasOwnProperty(e);
      }, n.default.TypedDict.prototype.get = function (e) {
        if (this.data.hasOwnProperty(e)) return this.data[e];
        console.log("".concat(e, " does not exist in this Dictionary"));
      }, n.default.TypedDict.prototype.set = function (e, t) {
        this._validate(t) ? this.data[e] = t : console.log("Those values dont work for this dictionary type.");
      }, n.default.TypedDict.prototype._addObj = function (e) {
        for (var t in e) this.set(t, e[t]);
      }, n.default.TypedDict.prototype.create = function (e, t) {
        e instanceof Object && void 0 === t ? this._addObj(e) : void 0 !== e ? this.set(e, t) : console.log("In order to create a new Dictionary entry you must pass an object or a key, value pair");
      }, n.default.TypedDict.prototype.clear = function () {
        this.data = {};
      }, n.default.TypedDict.prototype.remove = function (e) {
        if (!this.data.hasOwnProperty(e)) throw new Error("".concat(e, " does not exist in this Dictionary"));
        delete this.data[e];
      }, n.default.TypedDict.prototype.print = function () {
        for (var e in this.data) console.log("key:".concat(e, " value:").concat(this.data[e]));
      }, n.default.TypedDict.prototype.saveTable = function (e) {
        var t = "";

        for (var r in this.data) t += "".concat(r, ",").concat(this.data[r], "\n");

        var i = new Blob([t], {
          type: "text/csv"
        });
        n.default.prototype.downloadFile(i, e || "mycsv", "csv");
      }, n.default.TypedDict.prototype.saveJSON = function (e, t) {
        n.default.prototype.saveJSON(this.data, e, t);
      }, n.default.TypedDict.prototype._validate = function (e) {
        return !0;
      }, n.default.StringDict = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        n.default.TypedDict.apply(this, t);
      }, n.default.StringDict.prototype = Object.create(n.default.TypedDict.prototype), n.default.StringDict.prototype._validate = function (e) {
        return "string" == typeof e;
      }, n.default.NumberDict = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        n.default.TypedDict.apply(this, t);
      }, n.default.NumberDict.prototype = Object.create(n.default.TypedDict.prototype), n.default.NumberDict.prototype._validate = function (e) {
        return "number" == typeof e;
      }, n.default.NumberDict.prototype.add = function (e, t) {
        this.data.hasOwnProperty(e) ? this.data[e] += t : console.log("The key - ".concat(e, " does not exist in this dictionary."));
      }, n.default.NumberDict.prototype.sub = function (e, t) {
        this.add(e, -t);
      }, n.default.NumberDict.prototype.mult = function (e, t) {
        this.data.hasOwnProperty(e) ? this.data[e] *= t : console.log("The key - ".concat(e, " does not exist in this dictionary."));
      }, n.default.NumberDict.prototype.div = function (e, t) {
        this.data.hasOwnProperty(e) ? this.data[e] /= t : console.log("The key - ".concat(e, " does not exist in this dictionary."));
      }, n.default.NumberDict.prototype._valueTest = function (e) {
        if (0 === Object.keys(this.data).length) throw new Error("Unable to search for a minimum or maximum value on an empty NumberDict");
        if (1 === Object.keys(this.data).length) return this.data[Object.keys(this.data)[0]];
        var t = this.data[Object.keys(this.data)[0]];

        for (var r in this.data) this.data[r] * e < t * e && (t = this.data[r]);

        return t;
      }, n.default.NumberDict.prototype.minValue = function () {
        return this._valueTest(1);
      }, n.default.NumberDict.prototype.maxValue = function () {
        return this._valueTest(-1);
      }, n.default.NumberDict.prototype._keyTest = function (e) {
        if (0 === Object.keys(this.data).length) throw new Error("Unable to use minValue on an empty NumberDict");
        if (1 === Object.keys(this.data).length) return Object.keys(this.data)[0];

        for (var t = Object.keys(this.data)[0], r = 1; r < Object.keys(this.data).length; r++) Object.keys(this.data)[r] * e < t * e && (t = Object.keys(this.data)[r]);

        return t;
      }, n.default.NumberDict.prototype.minKey = function () {
        return this._keyTest(1);
      }, n.default.NumberDict.prototype.maxKey = function () {
        return this._keyTest(-1);
      };
      var a = n.default.TypedDict;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    52: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          f = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };

      function d(e) {
        return (d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function m(e, t, r) {
        (t._userNode ? t._userNode : document.body).appendChild(e);
        var i = r ? new f.default.MediaElement(e, t) : new f.default.Element(e, t);
        return t._elements.push(i), i;
      }

      function n(e, t, r, i) {
        var n = document.createElement(t);
        "string" == typeof (r = r || "") && (r = [r]);
        var a = !0,
            o = !1,
            s = void 0;

        try {
          for (var l, u = r[Symbol.iterator](); !(a = (l = u.next()).done); a = !0) {
            var h = l.value,
                c = document.createElement("source");
            c.setAttribute("src", h), n.appendChild(c);
          }
        } catch (e) {
          o = !0, s = e;
        } finally {
          try {
            a || null == u.return || u.return();
          } finally {
            if (o) throw s;
          }
        }

        if ("function" == typeof i) {
          n.addEventListener("canplaythrough", function e() {
            i(), n.removeEventListener("canplaythrough", e);
          });
        }

        var f = m(n, e, !0);
        return f.loadedmetadata = !1, n.addEventListener("loadedmetadata", function () {
          f.width = n.videoWidth, f.height = n.videoHeight, 0 === f.elt.width && (f.elt.width = n.videoWidth), 0 === f.elt.height && (f.elt.height = n.videoHeight), f.presetPlaybackRate && (f.elt.playbackRate = f.presetPlaybackRate, delete f.presetPlaybackRate), f.loadedmetadata = !0;
        }), f;
      }

      f.default.prototype.select = function (e, t) {
        f.default._validateParameters("select", arguments);

        var r = this._getContainer(t).querySelector(e);

        return r ? this._wrapElement(r) : null;
      }, f.default.prototype.selectAll = function (e, t) {
        f.default._validateParameters("selectAll", arguments);

        var r = [],
            i = this._getContainer(t).querySelectorAll(e);

        if (i) for (var n = 0; n < i.length; n++) {
          var a = this._wrapElement(i[n]);

          r.push(a);
        }
        return r;
      }, f.default.prototype._getContainer = function (e) {
        var t = document;
        return "string" == typeof e ? t = document.querySelector(e) || document : e instanceof f.default.Element ? t = e.elt : e instanceof HTMLElement && (t = e), t;
      }, f.default.prototype._wrapElement = function (e) {
        var t = Array.prototype.slice.call(e.children);
        if ("INPUT" !== e.tagName || "checkbox" !== e.type) return "VIDEO" === e.tagName || "AUDIO" === e.tagName ? new f.default.MediaElement(e, this) : "SELECT" === e.tagName ? this.createSelect(new f.default.Element(e, this)) : 0 < t.length && t.every(function (e) {
          return "INPUT" === e.tagName || "LABEL" === e.tagName;
        }) ? this.createRadio(new f.default.Element(e, this)) : new f.default.Element(e, this);
        var r = new f.default.Element(e, this);
        return r.checked = function () {
          return 0 === arguments.length ? this.elt.checked : (this.elt.checked = !!arguments[0], this);
        }, r;
      }, f.default.prototype.removeElements = function (e) {
        f.default._validateParameters("removeElements", arguments);

        this._elements.filter(function (e) {
          return !(e.elt instanceof HTMLCanvasElement);
        }).map(function (e) {
          return e.remove();
        });
      }, f.default.Element.prototype.changed = function (e) {
        return f.default.Element._adjustListener("change", e, this), this;
      }, f.default.Element.prototype.input = function (e) {
        return f.default.Element._adjustListener("input", e, this), this;
      }, f.default.prototype.createDiv = function () {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "",
            t = document.createElement("div");
        return t.innerHTML = e, m(t, this);
      }, f.default.prototype.createP = function () {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "",
            t = document.createElement("p");
        return t.innerHTML = e, m(t, this);
      }, f.default.prototype.createSpan = function () {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "",
            t = document.createElement("span");
        return t.innerHTML = e, m(t, this);
      }, f.default.prototype.createImg = function () {
        f.default._validateParameters("createImg", arguments);

        var t,
            r = document.createElement("img"),
            i = arguments;
        return 1 < i.length && "string" == typeof i[1] && (r.alt = i[1]), 2 < i.length && "string" == typeof i[2] && (r.crossOrigin = i[2]), r.src = i[0], t = m(r, this), r.addEventListener("load", function () {
          t.width = r.offsetWidth || r.width, t.height = r.offsetHeight || r.height;
          var e = i[i.length - 1];
          "function" == typeof e && e(t);
        }), t;
      }, f.default.prototype.createA = function (e, t, r) {
        f.default._validateParameters("createA", arguments);

        var i = document.createElement("a");
        return i.href = e, i.innerHTML = t, r && (i.target = r), m(i, this);
      }, f.default.prototype.createSlider = function (e, t, r, i) {
        f.default._validateParameters("createSlider", arguments);

        var n = document.createElement("input");
        return n.type = "range", n.min = e, n.max = t, 0 === i ? n.step = 1e-18 : i && (n.step = i), "number" == typeof r && (n.value = r), m(n, this);
      }, f.default.prototype.createButton = function (e, t) {
        f.default._validateParameters("createButton", arguments);

        var r = document.createElement("button");
        return r.innerHTML = e, t && (r.value = t), m(r, this);
      }, f.default.prototype.createCheckbox = function () {
        f.default._validateParameters("createCheckbox", arguments);

        var e = document.createElement("div"),
            t = document.createElement("input");
        t.type = "checkbox", e.appendChild(t);
        var r = m(e, this);

        if (r.checked = function () {
          var e = r.elt.getElementsByTagName("input")[0];

          if (e) {
            if (0 === arguments.length) return e.checked;
            e.checked = !!arguments[0];
          }

          return r;
        }, this.value = function (e) {
          return r.value = e, this;
        }, arguments[0]) {
          var i = Math.random().toString(36).slice(2),
              n = document.createElement("label");
          t.setAttribute("id", i), n.htmlFor = i, r.value(arguments[0]), n.appendChild(document.createTextNode(arguments[0])), e.appendChild(n);
        }

        return arguments[1] && (t.checked = !0), r;
      }, f.default.prototype.createSelect = function () {
        var e;

        f.default._validateParameters("createSelect", arguments);

        var t = arguments[0];
        if (t instanceof f.default.Element && t.elt instanceof HTMLSelectElement) e = t, this.elt = t.elt;else if (t instanceof HTMLSelectElement) e = m(t, this), this.elt = t;else {
          var r = document.createElement("select");
          t && "boolean" == typeof t && r.setAttribute("multiple", "true"), e = m(r, this), this.elt = r;
        }
        return e.option = function (e, t) {
          var r;

          if (void 0 !== e) {
            for (var i = 0; i < this.elt.length; i += 1) if (this.elt[i].innerHTML === e) {
              r = i;
              break;
            }

            if (void 0 !== r) !1 === t ? this.elt.remove(r) : this.elt[r].value = t;else {
              var n = document.createElement("option");
              n.innerHTML = e, n.value = void 0 === t ? e : t, this.elt.appendChild(n), this._pInst._elements.push(n);
            }
          }
        }, e.selected = function (e) {
          if (void 0 !== e) {
            for (var t = 0; t < this.elt.length; t += 1) this.elt[t].value.toString() === e.toString() && (this.elt.selectedIndex = t);

            return this;
          }

          if (this.elt.getAttribute("multiple")) {
            var r = [],
                i = !0,
                n = !1,
                a = void 0;

            try {
              for (var o, s = this.elt.selectedOptions[Symbol.iterator](); !(i = (o = s.next()).done); i = !0) {
                var l = o.value;
                r.push(l.value);
              }
            } catch (e) {
              n = !0, a = e;
            } finally {
              try {
                i || null == s.return || s.return();
              } finally {
                if (n) throw a;
              }
            }

            return r;
          }

          return this.elt.value;
        }, e.disable = function (e) {
          if ("string" == typeof e) for (var t = 0; t < this.elt.length; t++) this.elt[t].value.toString() === e && (this.elt[t].disabled = !0, this.elt[t].selected = !1);else this.elt.disabled = !0;
          return this;
        }, e;
      }, f.default.prototype.createRadio = function () {
        var e,
            t,
            r = arguments[0];
        r instanceof HTMLDivElement || r instanceof HTMLSpanElement ? (e = r, "string" == typeof arguments[1] && (t = arguments[1])) : ("string" == typeof r && (t = r), e = document.createElement("div"));
        var p = m(this.elt = e, this);
        p._name = t || "radioOption";

        function i(e) {
          return e instanceof HTMLInputElement && "radio" === e.type;
        }

        function h(e) {
          return e.nextElementSibling instanceof HTMLLabelElement;
        }

        return p._getOptionsArray = function () {
          return Array.from(this.elt.children).filter(i);
        }, p.option = function (e, t) {
          var r,
              i,
              n = !0,
              a = !1,
              o = void 0;

          try {
            for (var s, l = p._getOptionsArray()[Symbol.iterator](); !(n = (s = l.next()).done); n = !0) {
              var u = s.value;

              if (u.value === e) {
                r = u;
                break;
              }
            }
          } catch (e) {
            a = !0, o = e;
          } finally {
            try {
              n || null == l.return || l.return();
            } finally {
              if (a) throw o;
            }
          }

          return void 0 === r && ((r = document.createElement("input")).setAttribute("type", "radio"), r.setAttribute("value", e), this.elt.appendChild(r)), h(r) ? i = r.nextElementSibling : (i = document.createElement("label"), r.insertAdjacentElement("afterend", i)), i.innerHTML = void 0 === t ? e : t, r.setAttribute("name", p._name), r;
        }, p.remove = function (e) {
          var t = !0,
              r = !1,
              i = void 0;

          try {
            for (var n, a = p._getOptionsArray()[Symbol.iterator](); !(t = (n = a.next()).done); t = !0) {
              var o = n.value;
              if (o.value === e) return h(o) && o.nextElementSibling.remove(), void o.remove();
            }
          } catch (e) {
            r = !0, i = e;
          } finally {
            try {
              t || null == a.return || a.return();
            } finally {
              if (r) throw i;
            }
          }
        }, p.value = function () {
          var e = "",
              t = !0,
              r = !1,
              i = void 0;

          try {
            for (var n, a = p._getOptionsArray()[Symbol.iterator](); !(t = (n = a.next()).done); t = !0) {
              var o = n.value;

              if (o.checked) {
                e = o.value;
                break;
              }
            }
          } catch (e) {
            r = !0, i = e;
          } finally {
            try {
              t || null == a.return || a.return();
            } finally {
              if (r) throw i;
            }
          }

          return e;
        }, p.selected = function (e) {
          var t = null;

          if (void 0 === e) {
            var r = !0,
                i = !1,
                n = void 0;

            try {
              for (var a, o = p._getOptionsArray()[Symbol.iterator](); !(r = (a = o.next()).done); r = !0) {
                var s = a.value;

                if (s.checked) {
                  t = s;
                  break;
                }
              }
            } catch (e) {
              i = !0, n = e;
            } finally {
              try {
                r || null == o.return || o.return();
              } finally {
                if (i) throw n;
              }
            }
          } else {
            var l = !0,
                u = !1,
                h = void 0;

            try {
              for (var c, f = p._getOptionsArray()[Symbol.iterator](); !(l = (c = f.next()).done); l = !0) {
                var d = c.value;
                d.value === e && (d.setAttribute("checked", !0), t = d);
              }
            } catch (e) {
              u = !0, h = e;
            } finally {
              try {
                l || null == f.return || f.return();
              } finally {
                if (u) throw h;
              }
            }
          }

          return t;
        }, p.disable = function () {
          var e = !(0 < arguments.length && void 0 !== arguments[0]) || arguments[0],
              t = !0,
              r = !1,
              i = void 0;

          try {
            for (var n, a = p._getOptionsArray()[Symbol.iterator](); !(t = (n = a.next()).done); t = !0) {
              n.value.setAttribute("disabled", e);
            }
          } catch (e) {
            r = !0, i = e;
          } finally {
            try {
              t || null == a.return || a.return();
            } finally {
              if (r) throw i;
            }
          }
        }, p;
      }, f.default.prototype.createColorPicker = function (e) {
        f.default._validateParameters("createColorPicker", arguments);

        var t,
            r = document.createElement("input");
        return r.type = "color", e ? e instanceof f.default.Color ? r.value = e.toString("#rrggbb") : (f.default.prototype._colorMode = "rgb", f.default.prototype._colorMaxes = {
          rgb: [255, 255, 255, 255],
          hsb: [360, 100, 100, 1],
          hsl: [360, 100, 100, 1]
        }, r.value = f.default.prototype.color(e).toString("#rrggbb")) : r.value = "#000000", (t = m(r, this)).color = function () {
          return e && (e.mode && (f.default.prototype._colorMode = e.mode), e.maxes && (f.default.prototype._colorMaxes = e.maxes)), f.default.prototype.color(this.elt.value);
        }, t;
      }, f.default.prototype.createInput = function () {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "",
            t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "text";

        f.default._validateParameters("createInput", arguments);

        var r = document.createElement("input");
        return r.setAttribute("value", e), r.setAttribute("type", t), m(r, this);
      }, f.default.prototype.createFileInput = function (s) {
        var e = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];

        f.default._validateParameters("createFileInput", arguments);

        if (window.File && window.FileReader && window.FileList && window.Blob) {
          var t = document.createElement("input");
          return t.setAttribute("type", "file"), e && t.setAttribute("multiple", !0), t.addEventListener("change", function (e) {
            var t = !0,
                r = !1,
                i = void 0;

            try {
              for (var n, a = e.target.files[Symbol.iterator](); !(t = (n = a.next()).done); t = !0) {
                var o = n.value;

                f.default.File._load(o, s);
              }
            } catch (e) {
              r = !0, i = e;
            } finally {
              try {
                t || null == a.return || a.return();
              } finally {
                if (r) throw i;
              }
            }
          }, !1), m(t, this);
        }

        console.log("The File APIs are not fully supported in this browser. Cannot create element.");
      }, f.default.prototype.createVideo = function (e, t) {
        return f.default._validateParameters("createVideo", arguments), n(this, "video", e, t);
      }, f.default.prototype.createAudio = function (e, t) {
        return f.default._validateParameters("createAudio", arguments), n(this, "audio", e, t);
      }, f.default.prototype.VIDEO = "video", f.default.prototype.AUDIO = "audio", void 0 === navigator.mediaDevices && (navigator.mediaDevices = {}), void 0 === navigator.mediaDevices.getUserMedia && (navigator.mediaDevices.getUserMedia = function (r) {
        var i = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
        return i ? new Promise(function (e, t) {
          i.call(navigator, r, e, t);
        }) : Promise.reject(new Error("getUserMedia is not implemented in this browser"));
      }), f.default.prototype.createCapture = function () {
        if (f.default._validateParameters("createCapture", arguments), !navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new DOMException("getUserMedia not supported in this browser");
        var e,
            t,
            r = !0,
            i = !0,
            n = !0,
            a = !1,
            o = void 0;

        try {
          for (var s, l = arguments[Symbol.iterator](); !(n = (s = l.next()).done); n = !0) {
            var u = s.value;
            u === f.default.prototype.VIDEO ? i = !1 : u === f.default.prototype.AUDIO ? r = !1 : "object" === d(u) ? e = u : "function" == typeof u && (t = u);
          }
        } catch (e) {
          a = !0, o = e;
        } finally {
          try {
            n || null == l.return || l.return();
          } finally {
            if (a) throw o;
          }
        }

        e = e || {
          video: r,
          audio: i
        };
        var h = document.createElement("video");
        h.setAttribute("playsinline", ""), navigator.mediaDevices.getUserMedia(e).then(function (t) {
          try {
            "srcObject" in h ? h.srcObject = t : h.src = window.URL.createObjectURL(t);
          } catch (e) {
            h.src = t;
          }
        }, console.log);
        var c = m(h, this, !0);
        return c.loadedmetadata = !1, h.addEventListener("loadedmetadata", function () {
          h.play(), h.width ? (c.width = h.width, c.height = h.height) : (c.width = c.elt.width = h.videoWidth, c.height = c.elt.height = h.videoHeight), c.loadedmetadata = !0, t && t(h.srcObject);
        }), c;
      }, f.default.prototype.createElement = function (e, t) {
        f.default._validateParameters("createElement", arguments);

        var r = document.createElement(e);
        return void 0 !== t && (r.innerHTML = t), m(r, this);
      }, f.default.Element.prototype.addClass = function (e) {
        return this.elt.className ? this.hasClass(e) || (this.elt.className = this.elt.className + " " + e) : this.elt.className = e, this;
      }, f.default.Element.prototype.removeClass = function (e) {
        return this.elt.classList.remove(e), this;
      }, f.default.Element.prototype.hasClass = function (e) {
        return this.elt.classList.contains(e);
      }, f.default.Element.prototype.toggleClass = function (e) {
        return this.elt.classList.contains(e) ? this.elt.classList.remove(e) : this.elt.classList.add(e), this;
      }, f.default.Element.prototype.child = function (e) {
        return void 0 === e ? this.elt.childNodes : ("string" == typeof e ? ("#" === e[0] && (e = e.substring(1)), e = document.getElementById(e)) : e instanceof f.default.Element && (e = e.elt), e instanceof HTMLElement && this.elt.appendChild(e), this);
      }, f.default.Element.prototype.center = function (e) {
        var t = this.elt.style.display,
            r = "none" === this.elt.style.display,
            i = "none" === this.parent().style.display,
            n = {
          x: this.elt.offsetLeft,
          y: this.elt.offsetTop
        };
        r && this.show(), i && this.parent().show(), this.elt.style.display = "block", this.position(0, 0);
        var a = Math.abs(this.parent().offsetWidth - this.elt.offsetWidth),
            o = Math.abs(this.parent().offsetHeight - this.elt.offsetHeight);
        return "both" === e || void 0 === e ? this.position(a / 2 + this.parent().offsetLeft, o / 2 + this.parent().offsetTop) : "horizontal" === e ? this.position(a / 2 + this.parent().offsetLeft, n.y) : "vertical" === e && this.position(n.x, o / 2 + this.parent().offsetTop), this.style("display", t), r && this.hide(), i && this.parent().hide(), this;
      }, f.default.Element.prototype.html = function () {
        return 0 === arguments.length ? this.elt.innerHTML : (arguments[1] ? this.elt.insertAdjacentHTML("beforeend", arguments[0]) : this.elt.innerHTML = arguments[0], this);
      }, f.default.Element.prototype.position = function () {
        if (0 === arguments.length) return {
          x: this.elt.offsetLeft,
          y: this.elt.offsetTop
        };
        var e = "absolute";
        return "static" !== arguments[2] && "fixed" !== arguments[2] && "relative" !== arguments[2] && "sticky" !== arguments[2] && "initial" !== arguments[2] && "inherit" !== arguments[2] || (e = arguments[2]), this.elt.style.position = e, this.elt.style.left = arguments[0] + "px", this.elt.style.top = arguments[1] + "px", this.x = arguments[0], this.y = arguments[1], this;
      }, f.default.Element.prototype._translate = function () {
        this.elt.style.position = "absolute";
        var e = "";
        return this.elt.style.transform && (e = (e = this.elt.style.transform.replace(/translate3d\(.*\)/g, "")).replace(/translate[X-Z]?\(.*\)/g, "")), 2 === arguments.length ? this.elt.style.transform = "translate(" + arguments[0] + "px, " + arguments[1] + "px)" : 2 < arguments.length && (this.elt.style.transform = "translate3d(" + arguments[0] + "px," + arguments[1] + "px," + arguments[2] + "px)", this.elt.parentElement.style.perspective = 3 === arguments.length ? "1000px" : arguments[3] + "px"), this.elt.style.transform += e, this;
      }, f.default.Element.prototype._rotate = function () {
        var e = "";
        return this.elt.style.transform && (e = (e = this.elt.style.transform.replace(/rotate3d\(.*\)/g, "")).replace(/rotate[X-Z]?\(.*\)/g, "")), 1 === arguments.length ? this.elt.style.transform = "rotate(" + arguments[0] + "deg)" : 2 === arguments.length ? this.elt.style.transform = "rotate(" + arguments[0] + "deg, " + arguments[1] + "deg)" : 3 === arguments.length && (this.elt.style.transform = "rotateX(" + arguments[0] + "deg)", this.elt.style.transform += "rotateY(" + arguments[1] + "deg)", this.elt.style.transform += "rotateZ(" + arguments[2] + "deg)"), this.elt.style.transform += e, this;
      }, f.default.Element.prototype.style = function (e, t) {
        if (t instanceof f.default.Color && (t = "rgba(" + t.levels[0] + "," + t.levels[1] + "," + t.levels[2] + "," + t.levels[3] / 255 + ")"), void 0 === t) {
          if (-1 === e.indexOf(":")) return window.getComputedStyle(this.elt).getPropertyValue(e);

          for (var r = e.split(";"), i = 0; i < r.length; i++) {
            var n = r[i].split(":");
            n[0] && n[1] && (this.elt.style[n[0].trim()] = n[1].trim());
          }
        } else if (this.elt.style[e] = t, "width" === e || "height" === e || "left" === e || "top" === e) {
          var a = window.getComputedStyle(this.elt).getPropertyValue(e).replace(/\D+/g, "");
          this[e] = parseInt(a, 10);
        }

        return this;
      }, f.default.Element.prototype.attribute = function (e, t) {
        if (null == this.elt.firstChild || "checkbox" !== this.elt.firstChild.type && "radio" !== this.elt.firstChild.type) return void 0 === t ? this.elt.getAttribute(e) : (this.elt.setAttribute(e, t), this);
        if (void 0 === t) return this.elt.firstChild.getAttribute(e);

        for (var r = 0; r < this.elt.childNodes.length; r++) this.elt.childNodes[r].setAttribute(e, t);
      }, f.default.Element.prototype.removeAttribute = function (e) {
        if (null != this.elt.firstChild && ("checkbox" === this.elt.firstChild.type || "radio" === this.elt.firstChild.type)) for (var t = 0; t < this.elt.childNodes.length; t++) this.elt.childNodes[t].removeAttribute(e);
        return this.elt.removeAttribute(e), this;
      }, f.default.Element.prototype.value = function () {
        return 0 < arguments.length ? (this.elt.value = arguments[0], this) : "range" === this.elt.type ? parseFloat(this.elt.value) : this.elt.value;
      }, f.default.Element.prototype.show = function () {
        return this.elt.style.display = "block", this;
      }, f.default.Element.prototype.hide = function () {
        return this.elt.style.display = "none", this;
      }, f.default.Element.prototype.size = function (e, t) {
        if (0 === arguments.length) return {
          width: this.elt.offsetWidth,
          height: this.elt.offsetHeight
        };
        var r = e,
            i = t,
            n = f.default.prototype.AUTO;

        if (r !== n || i !== n) {
          if (r === n ? r = t * this.width / this.height : i === n && (i = e * this.height / this.width), this.elt instanceof HTMLCanvasElement) {
            var a,
                o = {},
                s = this.elt.getContext("2d");

            for (a in s) o[a] = s[a];

            for (a in this.elt.setAttribute("width", r * this._pInst._pixelDensity), this.elt.setAttribute("height", i * this._pInst._pixelDensity), this.elt.style.width = r + "px", this.elt.style.height = i + "px", this._pInst.scale(this._pInst._pixelDensity, this._pInst._pixelDensity), o) this.elt.getContext("2d")[a] = o[a];
          } else this.elt.style.width = r + "px", this.elt.style.height = i + "px", this.elt.width = r, this.elt.height = i;

          this.width = this.elt.offsetWidth, this.height = this.elt.offsetHeight, this._pInst && this._pInst._curElement && this._pInst._curElement.elt === this.elt && (this._pInst._setProperty("width", this.elt.offsetWidth), this._pInst._setProperty("height", this.elt.offsetHeight));
        }

        return this;
      }, f.default.Element.prototype.remove = function () {
        if (this instanceof f.default.MediaElement) {
          this.stop();
          var e = this.elt.srcObject;
          if (null !== e) e.getTracks().forEach(function (e) {
            e.stop();
          });
        }

        var t = this._pInst._elements.indexOf(this);

        for (var r in -1 !== t && this._pInst._elements.splice(t, 1), this._events) this.elt.removeEventListener(r, this._events[r]);

        this.elt && this.elt.parentNode && this.elt.parentNode.removeChild(this.elt);
      }, f.default.Element.prototype.drop = function (n, a) {
        if (window.File && window.FileReader && window.FileList && window.Blob) {
          if (!this._dragDisabled) {
            this._dragDisabled = !0;

            var e = function (e) {
              e.preventDefault();
            };

            this.elt.addEventListener("dragover", e), this.elt.addEventListener("dragleave", e);
          }

          f.default.Element._attachListener("drop", function (e) {
            e.preventDefault(), "function" == typeof a && a.call(this, e);

            for (var t = e.dataTransfer.files, r = 0; r < t.length; r++) {
              var i = t[r];

              f.default.File._load(i, n);
            }
          }, this);
        } else console.log("The File APIs are not fully supported in this browser.");

        return this;
      }, f.default.MediaElement = function (i, e) {
        f.default.Element.call(this, i, e);
        var n = this;
        this.elt.crossOrigin = "anonymous", this._prevTime = 0, this._cueIDCounter = 0, this._cues = [], (this._pixelsState = this)._pixelDensity = 1, this._modified = !1, Object.defineProperty(n, "src", {
          get: function () {
            var e = n.elt.children[0].src,
                t = n.elt.src === window.location.href ? "" : n.elt.src;
            return e === window.location.href ? t : e;
          },
          set: function (e) {
            for (var t = 0; t < n.elt.children.length; t++) n.elt.removeChild(n.elt.children[t]);

            var r = document.createElement("source");
            r.src = e, i.appendChild(r), n.elt.src = e, n.modified = !0;
          }
        }), n._onended = function () {}, n.elt.onended = function () {
          n._onended(n);
        };
      }, f.default.MediaElement.prototype = Object.create(f.default.Element.prototype), f.default.MediaElement.prototype.play = function () {
        var e,
            t = this;
        return this.elt.currentTime === this.elt.duration && (this.elt.currentTime = 0), (e = (1 < this.elt.readyState || this.elt.load(), this.elt.play())) && e.catch && e.catch(function (e) {
          "NotAllowedError" === e.name ? f.default._friendlyAutoplayError(t.src) : console.error("Media play method encountered an unexpected error", e);
        }), this;
      }, f.default.MediaElement.prototype.stop = function () {
        return this.elt.pause(), this.elt.currentTime = 0, this;
      }, f.default.MediaElement.prototype.pause = function () {
        return this.elt.pause(), this;
      }, f.default.MediaElement.prototype.loop = function () {
        return this.elt.setAttribute("loop", !0), this.play(), this;
      }, f.default.MediaElement.prototype.noLoop = function () {
        return this.elt.removeAttribute("loop"), this;
      }, f.default.MediaElement.prototype._setupAutoplayFailDetection = function () {
        var e = this,
            t = setTimeout(function () {
          return f.default._friendlyAutoplayError(e.src);
        }, 500);
        this.elt.addEventListener("play", function () {
          return clearTimeout(t);
        }, {
          passive: !0,
          once: !0
        });
      }, f.default.MediaElement.prototype.autoplay = function (e) {
        var t = this,
            r = this.elt.getAttribute("autoplay");

        if (this.elt.setAttribute("autoplay", e), e && !r) {
          var i = function () {
            return t._setupAutoplayFailDetection();
          };

          4 === this.elt.readyState ? i() : this.elt.addEventListener("canplay", i, {
            passive: !0,
            once: !0
          });
        }

        return this;
      }, f.default.MediaElement.prototype.volume = function (e) {
        if (void 0 === e) return this.elt.volume;
        this.elt.volume = e;
      }, f.default.MediaElement.prototype.speed = function (e) {
        if (void 0 === e) return this.presetPlaybackRate || this.elt.playbackRate;
        this.loadedmetadata ? this.elt.playbackRate = e : this.presetPlaybackRate = e;
      }, f.default.MediaElement.prototype.time = function (e) {
        return void 0 === e ? this.elt.currentTime : (this.elt.currentTime = e, this);
      }, f.default.MediaElement.prototype.duration = function () {
        return this.elt.duration;
      }, f.default.MediaElement.prototype.pixels = [], f.default.MediaElement.prototype._ensureCanvas = function () {
        this.canvas || (this.canvas = document.createElement("canvas"), this.drawingContext = this.canvas.getContext("2d"), this.setModified(!0)), this.loadedmetadata && (this.canvas.width !== this.elt.width && (this.canvas.width = this.elt.width, this.canvas.height = this.elt.height, this.width = this.canvas.width, this.height = this.canvas.height), this.drawingContext.drawImage(this.elt, 0, 0, this.canvas.width, this.canvas.height), this.setModified(!0));
      }, f.default.MediaElement.prototype.loadPixels = function () {
        return this._ensureCanvas(), f.default.Renderer2D.prototype.loadPixels.apply(this, arguments);
      }, f.default.MediaElement.prototype.updatePixels = function (e, t, r, i) {
        return this.loadedmetadata && (this._ensureCanvas(), f.default.Renderer2D.prototype.updatePixels.call(this, e, t, r, i)), this.setModified(!0), this;
      }, f.default.MediaElement.prototype.get = function () {
        return this._ensureCanvas(), f.default.Renderer2D.prototype.get.apply(this, arguments);
      }, f.default.MediaElement.prototype._getPixel = function () {
        return this.loadPixels(), f.default.Renderer2D.prototype._getPixel.apply(this, arguments);
      }, f.default.MediaElement.prototype.set = function (e, t, r) {
        this.loadedmetadata && (this._ensureCanvas(), f.default.Renderer2D.prototype.set.call(this, e, t, r), this.setModified(!0));
      }, f.default.MediaElement.prototype.copy = function () {
        this._ensureCanvas(), f.default.prototype.copy.apply(this, arguments);
      }, f.default.MediaElement.prototype.mask = function () {
        this.loadPixels(), this.setModified(!0), f.default.Image.prototype.mask.apply(this, arguments);
      }, f.default.MediaElement.prototype.isModified = function () {
        return this._modified;
      }, f.default.MediaElement.prototype.setModified = function (e) {
        this._modified = e;
      }, f.default.MediaElement.prototype.onended = function (e) {
        return this._onended = e, this;
      }, f.default.MediaElement.prototype.connect = function (e) {
        var t, r;
        if ("function" == typeof f.default.prototype.getAudioContext) t = f.default.prototype.getAudioContext(), r = f.default.soundOut.input;else try {
          r = (t = e.context).destination;
        } catch (e) {
          throw "connect() is meant to be used with Web Audio API or p5.sound.js";
        }
        this.audioSourceNode || (this.audioSourceNode = t.createMediaElementSource(this.elt), this.audioSourceNode.connect(r)), e ? e.input ? this.audioSourceNode.connect(e.input) : this.audioSourceNode.connect(e) : this.audioSourceNode.connect(r);
      }, f.default.MediaElement.prototype.disconnect = function () {
        if (!this.audioSourceNode) throw "nothing to disconnect";
        this.audioSourceNode.disconnect();
      }, f.default.MediaElement.prototype.showControls = function () {
        this.elt.style["text-align"] = "inherit", this.elt.controls = !0;
      }, f.default.MediaElement.prototype.hideControls = function () {
        this.elt.controls = !1;
      };

      function a(e, t, r, i) {
        this.callback = e, this.time = t, this.id = r, this.val = i;
      }

      f.default.MediaElement.prototype.addCue = function (e, t, r) {
        var i = this._cueIDCounter++,
            n = new a(t, e, i, r);
        return this._cues.push(n), this.elt.ontimeupdate || (this.elt.ontimeupdate = this._onTimeUpdate.bind(this)), i;
      }, f.default.MediaElement.prototype.removeCue = function (e) {
        for (var t = 0; t < this._cues.length; t++) this._cues[t].id === e && (console.log(e), this._cues.splice(t, 1));

        0 === this._cues.length && (this.elt.ontimeupdate = null);
      }, f.default.MediaElement.prototype.clearCues = function () {
        this._cues = [], this.elt.ontimeupdate = null;
      }, f.default.MediaElement.prototype._onTimeUpdate = function () {
        for (var e = this.time(), t = 0; t < this._cues.length; t++) {
          var r = this._cues[t].time,
              i = this._cues[t].val;
          this._prevTime < r && r <= e && this._cues[t].callback(i);
        }

        this._prevTime = e;
      }, f.default.File = function (e, t) {
        this.file = e, this._pInst = t;
        var r = e.type.split("/");
        this.type = r[0], this.subtype = r[1], this.name = e.name, this.size = e.size, this.data = void 0;
      }, f.default.File._createLoader = function (i, n) {
        var e = new FileReader();
        return e.onload = function (e) {
          var t = new f.default.File(i);
          if ("application/json" === t.file.type) t.data = JSON.parse(e.target.result);else if ("text/xml" === t.file.type) {
            var r = new DOMParser().parseFromString(e.target.result, "text/xml");
            t.data = new f.default.XML(r.documentElement);
          } else t.data = e.target.result;
          n(t);
        }, e;
      }, f.default.File._load = function (e, t) {
        if (/^text\//.test(e.type) || "application/json" === e.type) f.default.File._createLoader(e, t).readAsText(e);else if (/^(video|audio)\//.test(e.type)) {
          var r = new f.default.File(e);
          r.data = URL.createObjectURL(e), t(r);
        } else f.default.File._createLoader(e, t).readAsDataURL(e);
      };
      var o = f.default;
      r.default = o;
    }, {
      "../core/main": 36
    }],
    53: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      },
          a = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../core/constants"));

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      n.default.prototype.deviceOrientation = 1 < window.innerWidth / window.innerHeight ? "landscape" : "portrait", n.default.prototype.accelerationX = 0, n.default.prototype.accelerationY = 0, n.default.prototype.accelerationZ = 0, n.default.prototype.pAccelerationX = 0, n.default.prototype.pAccelerationY = 0, n.default.prototype.pAccelerationZ = 0, n.default.prototype._updatePAccelerations = function () {
        this._setProperty("pAccelerationX", this.accelerationX), this._setProperty("pAccelerationY", this.accelerationY), this._setProperty("pAccelerationZ", this.accelerationZ);
      }, n.default.prototype.rotationX = 0, n.default.prototype.rotationY = 0, n.default.prototype.rotationZ = 0, n.default.prototype.pRotationX = 0, n.default.prototype.pRotationY = 0;
      var u = n.default.prototype.pRotationZ = 0,
          h = 0,
          c = 0,
          f = "clockwise",
          d = "clockwise",
          p = "clockwise";
      n.default.prototype.pRotateDirectionX = void 0, n.default.prototype.pRotateDirectionY = void 0, n.default.prototype.pRotateDirectionZ = void 0, n.default.prototype._updatePRotations = function () {
        this._setProperty("pRotationX", this.rotationX), this._setProperty("pRotationY", this.rotationY), this._setProperty("pRotationZ", this.rotationZ);
      }, n.default.prototype.turnAxis = void 0;
      var m = .5,
          v = 30;
      n.default.prototype.setMoveThreshold = function (e) {
        n.default._validateParameters("setMoveThreshold", arguments), m = e;
      }, n.default.prototype.setShakeThreshold = function (e) {
        n.default._validateParameters("setShakeThreshold", arguments), v = e;
      }, n.default.prototype._ondeviceorientation = function (e) {
        this._updatePRotations(), this._angleMode === a.radians && (e.beta = e.beta * (_PI / 180), e.gamma = e.gamma * (_PI / 180), e.alpha = e.alpha * (_PI / 180)), this._setProperty("rotationX", e.beta), this._setProperty("rotationY", e.gamma), this._setProperty("rotationZ", e.alpha), this._handleMotion();
      }, n.default.prototype._ondevicemotion = function (e) {
        this._updatePAccelerations(), this._setProperty("accelerationX", 2 * e.acceleration.x), this._setProperty("accelerationY", 2 * e.acceleration.y), this._setProperty("accelerationZ", 2 * e.acceleration.z), this._handleMotion();
      }, n.default.prototype._handleMotion = function () {
        90 === window.orientation || -90 === window.orientation ? this._setProperty("deviceOrientation", "landscape") : 0 === window.orientation ? this._setProperty("deviceOrientation", "portrait") : void 0 === window.orientation && this._setProperty("deviceOrientation", "undefined");
        var e,
            t,
            r = this._isGlobal ? window : this;

        if ("function" == typeof r.deviceMoved && (Math.abs(this.accelerationX - this.pAccelerationX) > m || Math.abs(this.accelerationY - this.pAccelerationY) > m || Math.abs(this.accelerationZ - this.pAccelerationZ) > m) && r.deviceMoved(), "function" == typeof r.deviceTurned) {
          var i = this.rotationX + 180,
              n = this.pRotationX + 180,
              a = u + 180;
          0 < i - n && i - n < 270 || i - n < -270 ? f = "clockwise" : (i - n < 0 || 270 < i - n) && (f = "counter-clockwise"), f !== this.pRotateDirectionX && (a = i), 90 < Math.abs(i - a) && Math.abs(i - a) < 270 && (a = i, this._setProperty("turnAxis", "X"), r.deviceTurned()), this.pRotateDirectionX = f, u = a - 180;
          var o = this.rotationY + 180,
              s = this.pRotationY + 180,
              l = h + 180;
          0 < o - s && o - s < 270 || o - s < -270 ? d = "clockwise" : (o - s < 0 || 270 < o - this.pRotationY) && (d = "counter-clockwise"), d !== this.pRotateDirectionY && (l = o), 90 < Math.abs(o - l) && Math.abs(o - l) < 270 && (l = o, this._setProperty("turnAxis", "Y"), r.deviceTurned()), this.pRotateDirectionY = d, h = l - 180, 0 < this.rotationZ - this.pRotationZ && this.rotationZ - this.pRotationZ < 270 || this.rotationZ - this.pRotationZ < -270 ? p = "clockwise" : (this.rotationZ - this.pRotationZ < 0 || 270 < this.rotationZ - this.pRotationZ) && (p = "counter-clockwise"), p !== this.pRotateDirectionZ && (c = this.rotationZ), 90 < Math.abs(this.rotationZ - c) && Math.abs(this.rotationZ - c) < 270 && (c = this.rotationZ, this._setProperty("turnAxis", "Z"), r.deviceTurned()), this.pRotateDirectionZ = p, this._setProperty("turnAxis", void 0);
        }

        "function" == typeof r.deviceShaken && (null !== this.pAccelerationX && (e = Math.abs(this.accelerationX - this.pAccelerationX), t = Math.abs(this.accelerationY - this.pAccelerationY)), v < e + t && r.deviceShaken());
      };
      var l = n.default;
      r.default = l;
    }, {
      "../core/constants": 26,
      "../core/main": 36
    }],
    54: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      n.default.prototype.isKeyPressed = !1, n.default.prototype.keyIsPressed = !1, n.default.prototype.key = "", n.default.prototype.keyCode = 0, n.default.prototype._onkeydown = function (e) {
        if (!this._downKeys[e.which]) {
          this._setProperty("isKeyPressed", !0), this._setProperty("keyIsPressed", !0), this._setProperty("keyCode", e.which), this._downKeys[e.which] = !0, this._setProperty("key", e.key || String.fromCharCode(e.which) || e.which);
          var t = this._isGlobal ? window : this;
          if ("function" == typeof t.keyPressed && !e.charCode) !1 === t.keyPressed(e) && e.preventDefault();
        }
      }, n.default.prototype._onkeyup = function (e) {
        this._downKeys[e.which] = !1, this._areDownKeys() || (this._setProperty("isKeyPressed", !1), this._setProperty("keyIsPressed", !1)), this._setProperty("_lastKeyCodeTyped", null), this._setProperty("key", e.key || String.fromCharCode(e.which) || e.which), this._setProperty("keyCode", e.which);
        var t = this._isGlobal ? window : this;
        "function" == typeof t.keyReleased && !1 === t.keyReleased(e) && e.preventDefault();
      }, n.default.prototype._onkeypress = function (e) {
        if (e.which !== this._lastKeyCodeTyped) {
          this._setProperty("_lastKeyCodeTyped", e.which), this._setProperty("key", e.key || String.fromCharCode(e.which) || e.which);
          var t = this._isGlobal ? window : this;
          if ("function" == typeof t.keyTyped) !1 === t.keyTyped(e) && e.preventDefault();
        }
      }, n.default.prototype._onblur = function (e) {
        this._downKeys = {};
      }, n.default.prototype.keyIsDown = function (e) {
        return n.default._validateParameters("keyIsDown", arguments), this._downKeys[e] || !1;
      }, n.default.prototype._areDownKeys = function () {
        for (var e in this._downKeys) if (this._downKeys.hasOwnProperty(e) && !0 === this._downKeys[e]) return !0;

        return !1;
      };
      var a = n.default;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    55: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      },
          a = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../core/constants"));

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      n.default.prototype.movedX = 0, n.default.prototype.movedY = 0, n.default.prototype._hasMouseInteracted = !1, n.default.prototype.mouseX = 0, n.default.prototype.mouseY = 0, n.default.prototype.pmouseX = 0, n.default.prototype.pmouseY = 0, n.default.prototype.winMouseX = 0, n.default.prototype.winMouseY = 0, n.default.prototype.pwinMouseX = 0, n.default.prototype.pwinMouseY = 0, n.default.prototype.mouseButton = 0, n.default.prototype.mouseIsPressed = !1, n.default.prototype._updateNextMouseCoords = function (e) {
        if (null !== this._curElement && (!e.touches || 0 < e.touches.length)) {
          var t = function (e, t, r, i) {
            i && !i.clientX && (i.touches ? i = i.touches[0] : i.changedTouches && (i = i.changedTouches[0]));
            var n = e.getBoundingClientRect(),
                a = e.scrollWidth / t || 1,
                o = e.scrollHeight / r || 1;
            return {
              x: (i.clientX - n.left) / a,
              y: (i.clientY - n.top) / o,
              winX: i.clientX,
              winY: i.clientY,
              id: i.identifier
            };
          }(this._curElement.elt, this.width, this.height, e);

          this._setProperty("movedX", e.movementX), this._setProperty("movedY", e.movementY), this._setProperty("mouseX", t.x), this._setProperty("mouseY", t.y), this._setProperty("winMouseX", t.winX), this._setProperty("winMouseY", t.winY);
        }

        this._hasMouseInteracted || (this._updateMouseCoords(), this._setProperty("_hasMouseInteracted", !0));
      }, n.default.prototype._updateMouseCoords = function () {
        this._setProperty("pmouseX", this.mouseX), this._setProperty("pmouseY", this.mouseY), this._setProperty("pwinMouseX", this.winMouseX), this._setProperty("pwinMouseY", this.winMouseY), this._setProperty("_pmouseWheelDeltaY", this._mouseWheelDeltaY);
      }, n.default.prototype._setMouseButton = function (e) {
        1 === e.button ? this._setProperty("mouseButton", a.CENTER) : 2 === e.button ? this._setProperty("mouseButton", a.RIGHT) : this._setProperty("mouseButton", a.LEFT);
      }, n.default.prototype._onmousemove = function (e) {
        var t = this._isGlobal ? window : this;
        this._updateNextMouseCoords(e), this.mouseIsPressed ? "function" == typeof t.mouseDragged ? !1 === t.mouseDragged(e) && e.preventDefault() : "function" == typeof t.touchMoved && !1 === t.touchMoved(e) && e.preventDefault() : "function" == typeof t.mouseMoved && !1 === t.mouseMoved(e) && e.preventDefault();
      }, n.default.prototype._onmousedown = function (e) {
        var t = this._isGlobal ? window : this;
        this._setProperty("mouseIsPressed", !0), this._setMouseButton(e), this._updateNextMouseCoords(e), "function" == typeof t.mousePressed ? !1 === t.mousePressed(e) && e.preventDefault() : navigator.userAgent.toLowerCase().includes("safari") && "function" == typeof t.touchStarted && !1 === t.touchStarted(e) && e.preventDefault();
      }, n.default.prototype._onmouseup = function (e) {
        var t = this._isGlobal ? window : this;
        this._setProperty("mouseIsPressed", !1), "function" == typeof t.mouseReleased ? !1 === t.mouseReleased(e) && e.preventDefault() : "function" == typeof t.touchEnded && !1 === t.touchEnded(e) && e.preventDefault();
      }, n.default.prototype._ondragend = n.default.prototype._onmouseup, n.default.prototype._ondragover = n.default.prototype._onmousemove, n.default.prototype._onclick = function (e) {
        var t = this._isGlobal ? window : this;
        "function" == typeof t.mouseClicked && !1 === t.mouseClicked(e) && e.preventDefault();
      }, n.default.prototype._ondblclick = function (e) {
        var t = this._isGlobal ? window : this;
        "function" == typeof t.doubleClicked && !1 === t.doubleClicked(e) && e.preventDefault();
      }, n.default.prototype._mouseWheelDeltaY = 0, n.default.prototype._pmouseWheelDeltaY = 0, n.default.prototype._onwheel = function (e) {
        var t = this._isGlobal ? window : this;
        this._setProperty("_mouseWheelDeltaY", e.deltaY), "function" == typeof t.mouseWheel && (e.delta = e.deltaY, !1 === t.mouseWheel(e) && e.preventDefault());
      }, n.default.prototype.requestPointerLock = function () {
        var e = this._curElement.elt;
        return e.requestPointerLock = e.requestPointerLock || e.mozRequestPointerLock, e.requestPointerLock ? (e.requestPointerLock(), !0) : (console.log("requestPointerLock is not implemented in this browser"), !1);
      }, n.default.prototype.exitPointerLock = function () {
        document.exitPointerLock();
      };
      var l = n.default;
      r.default = l;
    }, {
      "../core/constants": 26,
      "../core/main": 36
    }],
    56: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };

      function a(e, t, r, i, n) {
        var a = 4 < arguments.length && void 0 !== n ? n : 0,
            o = e.getBoundingClientRect(),
            s = e.scrollWidth / t || 1,
            l = e.scrollHeight / r || 1,
            u = i.touches[a] || i.changedTouches[a];
        return {
          x: (u.clientX - o.left) / s,
          y: (u.clientY - o.top) / l,
          winX: u.clientX,
          winY: u.clientY,
          id: u.identifier
        };
      }

      n.default.prototype.touches = [], n.default.prototype._updateTouchCoords = function (e) {
        if (null !== this._curElement) {
          for (var t = [], r = 0; r < e.touches.length; r++) t[r] = a(this._curElement.elt, this.width, this.height, e, r);

          this._setProperty("touches", t);
        }
      }, n.default.prototype._ontouchstart = function (e) {
        var t = this._isGlobal ? window : this;
        this._setProperty("mouseIsPressed", !0), this._updateTouchCoords(e), this._updateNextMouseCoords(e), this._updateMouseCoords(), "function" == typeof t.touchStarted ? !1 === t.touchStarted(e) && e.preventDefault() : navigator.userAgent.toLowerCase().includes("safari") && "function" == typeof t.mousePressed && !1 === t.mousePressed(e) && e.preventDefault();
      }, n.default.prototype._ontouchmove = function (e) {
        var t = this._isGlobal ? window : this;
        this._updateTouchCoords(e), this._updateNextMouseCoords(e), "function" == typeof t.touchMoved ? !1 === t.touchMoved(e) && e.preventDefault() : "function" == typeof t.mouseDragged && !1 === t.mouseDragged(e) && e.preventDefault();
      }, n.default.prototype._ontouchend = function (e) {
        this._setProperty("mouseIsPressed", !1), this._updateTouchCoords(e), this._updateNextMouseCoords(e);
        var t = this._isGlobal ? window : this;
        "function" == typeof t.touchEnded ? !1 === t.touchEnded(e) && e.preventDefault() : "function" == typeof t.mouseReleased && !1 === t.mouseReleased(e) && e.preventDefault();
      };
      var o = n.default;
      r.default = o;
    }, {
      "../core/main": 36
    }],
    57: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var L,
          O,
          P,
          R,
          D = {};

      function i(e, t) {
        for (var r, i, n, a, o, s, l, u, h, c, f = D._toPixels(e), d = e.width, p = e.height, m = d * p, v = new Int32Array(m), y = 0; y < m; y++) v[y] = D._getARGB(f, y);

        var g,
            b,
            _,
            x,
            w = new Int32Array(m),
            S = new Int32Array(m),
            M = new Int32Array(m),
            T = new Int32Array(m),
            E = 0;

        for (!function (e) {
          var t = 3.5 * e | 0;

          if (L !== (t = t < 1 ? 1 : t < 248 ? t : 248)) {
            O = 1 + (L = t) << 1, P = new Int32Array(O), R = new Array(O);

            for (var r = 0; r < O; r++) R[r] = new Int32Array(256);

            for (var i, n, a, o, s = 1, l = t - 1; s < t; s++) {
              P[t + s] = P[l] = n = l * l, a = R[t + s], o = R[l--];

              for (var u = 0; u < 256; u++) a[u] = o[u] = n * u;
            }

            i = P[t] = t * t, a = R[t];

            for (var h = 0; h < 256; h++) a[h] = i * h;
          }
        }(t), b = 0; b < p; b++) {
          for (g = 0; g < d; g++) {
            if (a = n = i = o = r = 0, (s = g - L) < 0) c = -s, s = 0;else {
              if (d <= s) break;
              c = 0;
            }

            for (_ = c; _ < O && !(d <= s); _++) {
              var C = v[s + E];
              o += (x = R[_])[(-16777216 & C) >>> 24], i += x[(16711680 & C) >> 16], n += x[(65280 & C) >> 8], a += x[255 & C], r += P[_], s++;
            }

            w[l = E + g] = o / r, S[l] = i / r, M[l] = n / r, T[l] = a / r;
          }

          E += d;
        }

        for (h = (u = -L) * d, b = E = 0; b < p; b++) {
          for (g = 0; g < d; g++) {
            if (a = n = i = o = r = 0, u < 0) c = l = -u, s = g;else {
              if (p <= u) break;
              c = 0, l = u, s = g + h;
            }

            for (_ = c; _ < O && !(p <= l); _++) o += (x = R[_])[w[s]], i += x[S[s]], n += x[M[s]], a += x[T[s]], r += P[_], l++, s += d;

            v[g + E] = o / r << 24 | i / r << 16 | n / r << 8 | a / r;
          }

          E += d, h += d, u++;
        }

        D._setPixels(f, v);
      }

      D._toPixels = function (e) {
        return e instanceof ImageData ? e.data : e.getContext("2d").getImageData(0, 0, e.width, e.height).data;
      }, D._getARGB = function (e, t) {
        var r = 4 * t;
        return e[3 + r] << 24 & 4278190080 | e[r] << 16 & 16711680 | e[1 + r] << 8 & 65280 | 255 & e[2 + r];
      }, D._setPixels = function (e, t) {
        for (var r = 0, i = 0, n = e.length; i < n; i++) e[(r = 4 * i) + 0] = (16711680 & t[i]) >>> 16, e[r + 1] = (65280 & t[i]) >>> 8, e[r + 2] = 255 & t[i], e[r + 3] = (4278190080 & t[i]) >>> 24;
      }, D._toImageData = function (e) {
        return e instanceof ImageData ? e : e.getContext("2d").getImageData(0, 0, e.width, e.height);
      }, D._createImageData = function (e, t) {
        return D._tmpCanvas = document.createElement("canvas"), D._tmpCtx = D._tmpCanvas.getContext("2d"), this._tmpCtx.createImageData(e, t);
      }, D.apply = function (e, t, r) {
        var i = e.getContext("2d"),
            n = i.getImageData(0, 0, e.width, e.height),
            a = t(n, r);
        a instanceof ImageData ? i.putImageData(a, 0, 0, 0, 0, e.width, e.height) : i.putImageData(n, 0, 0, 0, 0, e.width, e.height);
      }, D.threshold = function (e, t) {
        var r = D._toPixels(e);

        void 0 === t && (t = .5);

        for (var i = Math.floor(255 * t), n = 0; n < r.length; n += 4) {
          var a = void 0;
          a = i <= .2126 * r[n] + .7152 * r[n + 1] + .0722 * r[n + 2] ? 255 : 0, r[n] = r[n + 1] = r[n + 2] = a;
        }
      }, D.gray = function (e) {
        for (var t = D._toPixels(e), r = 0; r < t.length; r += 4) {
          var i = .2126 * t[r] + .7152 * t[r + 1] + .0722 * t[r + 2];
          t[r] = t[r + 1] = t[r + 2] = i;
        }
      }, D.opaque = function (e) {
        for (var t = D._toPixels(e), r = 0; r < t.length; r += 4) t[r + 3] = 255;

        return t;
      }, D.invert = function (e) {
        for (var t = D._toPixels(e), r = 0; r < t.length; r += 4) t[r] = 255 - t[r], t[r + 1] = 255 - t[r + 1], t[r + 2] = 255 - t[r + 2];
      }, D.posterize = function (e, t) {
        var r = D._toPixels(e);

        if (t < 2 || 255 < t) throw new Error("Level must be greater than 2 and less than 255 for posterize");

        for (var i = t - 1, n = 0; n < r.length; n += 4) {
          var a = r[n],
              o = r[n + 1],
              s = r[n + 2];
          r[n] = 255 * (a * t >> 8) / i, r[n + 1] = 255 * (o * t >> 8) / i, r[n + 2] = 255 * (s * t >> 8) / i;
        }
      }, D.dilate = function (e) {
        for (var t, r, i, n, a, o, s, l, u, h, c, f, d, p, m, v, y, g = D._toPixels(e), b = 0, _ = g.length ? g.length / 4 : 0, x = new Int32Array(_); b < _;) for (r = (t = b) + e.width; b < r;) i = n = D._getARGB(g, b), (s = b - 1) < t && (s = b), r <= (o = b + 1) && (o = b), (l = b - e.width) < 0 && (l = 0), _ <= (u = b + e.width) && (u = b), f = D._getARGB(g, l), c = D._getARGB(g, s), d = D._getARGB(g, u), (a = 77 * (i >> 16 & 255) + 151 * (i >> 8 & 255) + 28 * (255 & i)) < (m = 77 * (c >> 16 & 255) + 151 * (c >> 8 & 255) + 28 * (255 & c)) && (n = c, a = m), a < (p = 77 * ((h = D._getARGB(g, o)) >> 16 & 255) + 151 * (h >> 8 & 255) + 28 * (255 & h)) && (n = h, a = p), a < (v = 77 * (f >> 16 & 255) + 151 * (f >> 8 & 255) + 28 * (255 & f)) && (n = f, a = v), a < (y = 77 * (d >> 16 & 255) + 151 * (d >> 8 & 255) + 28 * (255 & d)) && (n = d, a = y), x[b++] = n;

        D._setPixels(g, x);
      }, D.erode = function (e) {
        for (var t, r, i, n, a, o, s, l, u, h, c, f, d, p, m, v, y, g = D._toPixels(e), b = 0, _ = g.length ? g.length / 4 : 0, x = new Int32Array(_); b < _;) for (r = (t = b) + e.width; b < r;) i = n = D._getARGB(g, b), (s = b - 1) < t && (s = b), r <= (o = b + 1) && (o = b), (l = b - e.width) < 0 && (l = 0), _ <= (u = b + e.width) && (u = b), f = D._getARGB(g, l), c = D._getARGB(g, s), d = D._getARGB(g, u), (m = 77 * (c >> 16 & 255) + 151 * (c >> 8 & 255) + 28 * (255 & c)) < (a = 77 * (i >> 16 & 255) + 151 * (i >> 8 & 255) + 28 * (255 & i)) && (n = c, a = m), (p = 77 * ((h = D._getARGB(g, o)) >> 16 & 255) + 151 * (h >> 8 & 255) + 28 * (255 & h)) < a && (n = h, a = p), (v = 77 * (f >> 16 & 255) + 151 * (f >> 8 & 255) + 28 * (255 & f)) < a && (n = f, a = v), (y = 77 * (d >> 16 & 255) + 151 * (d >> 8 & 255) + 28 * (255 & d)) < a && (n = d, a = y), x[b++] = n;

        D._setPixels(g, x);
      }, D.blur = function (e, t) {
        i(e, t);
      };
      var n = D;
      r.default = n;
    }, {}],
    58: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var D = i(e("../core/main")),
          k = i(e("omggif"));

      function i(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      function A(e) {
        return function (e) {
          if (Array.isArray(e)) {
            for (var t = 0, r = new Array(e.length); t < e.length; t++) r[t] = e[t];

            return r;
          }
        }(e) || function (e) {
          if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e);
        }(e) || function () {
          throw new TypeError("Invalid attempt to spread non-iterable instance");
        }();
      }

      D.default.prototype.createImage = function (e, t) {
        return D.default._validateParameters("createImage", arguments), new D.default.Image(e, t);
      }, D.default.prototype.saveCanvas = function () {
        D.default._validateParameters("saveCanvas", arguments);

        var e,
            t,
            r,
            i,
            n = [].slice.call(arguments);

        switch (arguments[0] instanceof HTMLCanvasElement ? (e = arguments[0], n.shift()) : arguments[0] instanceof D.default.Element ? (e = arguments[0].elt, n.shift()) : e = this._curElement && this._curElement.elt, 1 <= n.length && (t = n[0]), 2 <= n.length && (r = n[1]), r = r || D.default.prototype._checkFileExtension(t, r)[1] || "png") {
          default:
            i = "image/png";
            break;

          case "jpeg":
          case "jpg":
            i = "image/jpeg";
        }

        e.toBlob(function (e) {
          D.default.prototype.downloadFile(e, t, r);
        }, i);
      }, D.default.prototype.saveGif = function (p, e) {
        var m = p.gifProperties,
            t = m.loopLimit;
        1 === t ? t = null : null === t && (t = 0);

        for (var r = new Uint8Array(p.width * p.height * m.numFrames), v = [], i = {}, n = 0; n < m.numFrames; n++) {
          for (var a = new Set(), o = m.frames[n].image.data, s = o.length, l = new Uint32Array(p.width * p.height), u = 0, h = 0; u < s; u += 4, h++) {
            var c = o[u + 0] << 16 | o[u + 1] << 8 | o[u + 2] << 0;
            a.add(c), l[h] = c;
          }

          var f = A(a).sort().toString();
          void 0 === i[f] ? i[f] = {
            freq: 1,
            frames: [n]
          } : (i[f].freq += 1, i[f].frames.push(n)), v.push(l);
        }

        var y = [],
            d = Object.keys(i).sort(function (e, t) {
          return i[t].freq - i[e].freq;
        }),
            g = d[0].split(",").map(function (e) {
          return parseInt(e);
        });
        y = y.concat(i[g].frames);

        for (var b = new Set(g), _ = 1; _ < d.length; _++) {
          var x = d[_].split(",").map(function (e) {
            return parseInt(e);
          }).filter(function (e) {
            return !b.has(e);
          });

          if (g.length + x.length <= 256) {
            for (var w = 0; w < x.length; w++) g.push(x[w]), b.add(x[w]);

            y = y.concat(i[d[_]].frames);
          }
        }

        y = new Set(y);

        for (var S = {}, M = 0; M < g.length; M++) S[g[M]] || (S[g[M]] = M);

        for (var T = 1; T < g.length;) T <<= 1;

        g.length = T;

        for (var E = {
          loop: t,
          palette: new Uint32Array(g)
        }, C = new k.default.GifWriter(r, p.width, p.height, E), L = {}, O = function (e) {
          for (var t = !y.has(e), r = t ? [] : g, i = new Uint8Array(p.width * p.height), n = {}, a = new Set(), o = 0; o < v[e].length; o++) {
            var s = v[e][o];
            t ? (void 0 === n[s] && (n[s] = r.length, r.push(s)), i[o] = n[s]) : i[o] = S[s], 0 < e && v[e - 1][o] !== s && a.add(s);
          }

          var l = {},
              u = r.filter(function (e) {
            return !a.has(e);
          });

          if (0 < u.length) {
            var h = u[0],
                c = t ? n[h] : S[h];

            if (0 < e) {
              for (var f = 0; f < v[e].length; f++) v[e - 1][f] === v[e][f] && (i[f] = c);

              l.transparent = c, L.frameOpts.disposal = 1;
            }
          }

          if (l.delay = m.frames[e].delay / 10, t) {
            for (var d = 1; d < r.length;) d <<= 1;

            r.length = d, l.palette = new Uint32Array(r);
          }

          0 < e && C.addFrame(0, 0, p.width, p.height, L.pixelPaletteIndex, L.frameOpts), L = {
            pixelPaletteIndex: i,
            frameOpts: l
          };
        }, P = 0; P < m.numFrames; P++) O(P);

        L.frameOpts.disposal = 1, C.addFrame(0, 0, p.width, p.height, L.pixelPaletteIndex, L.frameOpts);
        var R = new Blob([r.slice(0, C.end())], {
          type: "image/gif"
        });
        D.default.prototype.downloadFile(R, e, "gif");
      }, D.default.prototype.saveFrames = function (e, t, r, i, o) {
        D.default._validateParameters("saveFrames", arguments);

        var n = r || 3;
        n = D.default.prototype.constrain(n, 0, 15), n *= 1e3;
        var a = i || 15;
        a = D.default.prototype.constrain(a, 0, 22);
        var s = 0,
            l = D.default.prototype._makeFrame,
            u = this._curElement.elt,
            h = [],
            c = setInterval(function () {
          h.push(l(e + s, t, u)), s++;
        }, 1e3 / a);
        setTimeout(function () {
          if (clearInterval(c), o) o(h);else {
            var e = !0,
                t = !1,
                r = void 0;

            try {
              for (var i, n = h[Symbol.iterator](); !(e = (i = n.next()).done); e = !0) {
                var a = i.value;
                D.default.prototype.downloadFile(a.imageData, a.filename, a.ext);
              }
            } catch (e) {
              t = !0, r = e;
            } finally {
              try {
                e || null == n.return || n.return();
              } finally {
                if (t) throw r;
              }
            }
          }
          h = [];
        }, n + .01);
      }, D.default.prototype._makeFrame = function (e, t, r) {
        var i, n;
        if (i = this ? this._curElement.elt : r, t) switch (t.toLowerCase()) {
          case "png":
            n = "image/png";
            break;

          case "jpeg":
          case "jpg":
            n = "image/jpeg";
            break;

          default:
            n = "image/png";
        } else t = "png", n = "image/png";
        var a = i.toDataURL(n);
        a = a.replace(n, "image/octet-stream");
        var o = {};
        return o.imageData = a, o.filename = e, o.ext = t, o;
      };
      var n = D.default;
      r.default = n;
    }, {
      "../core/main": 36,
      omggif: 11
    }],
    59: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var x = n(e("../core/main")),
          c = n(e("./filters")),
          w = n(e("../core/helpers")),
          i = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../core/constants")),
          p = n(e("omggif"));

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      function n(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      function S(e, t) {
        return 0 < e && e < t ? e : t;
      }

      e("../core/friendly_errors/validate_params"), e("../core/friendly_errors/file_errors"), e("../core/friendly_errors/fes_core"), x.default.prototype.loadImage = function (i, n, a) {
        x.default._validateParameters("loadImage", arguments);

        var o = new x.default.Image(1, 1, this),
            s = this,
            e = new Request(i, {
          method: "GET",
          mode: "cors"
        });
        return fetch(i, e).then(function (e) {
          var t = e.headers.get("content-type");
          if (null === t && console.warn("The image you loaded does not have a Content-Type header. If you are using the online editor consider reuploading the asset."), t && t.includes("image/gif")) e.arrayBuffer().then(function (e) {
            e && function (e, r, t, i, n) {
              var a = new p.default.GifReader(e);
              r.width = r.canvas.width = a.width, r.height = r.canvas.height = a.height;
              var o = [],
                  s = a.numFrames(),
                  l = new Uint8ClampedArray(r.width * r.height * 4);

              if (1 < s) {
                for (var u = function (e, t) {
                  try {
                    t.decodeAndBlitFrameRGBA(e, l);
                  } catch (e) {
                    x.default._friendlyFileLoadError(8, r.src), "function" == typeof i ? i(e) : console.error(e);
                  }
                }, h = 0; h < s; h++) {
                  var c = a.frameInfo(h);
                  1 === a.frameInfo(h).disposal && 0 < h ? r.drawingContext.putImageData(o[h - 1].image, 0, 0) : (r.drawingContext.clearRect(0, 0, r.width, r.height), l = new Uint8ClampedArray(r.width * r.height * 4)), u(h, a);
                  var f = new ImageData(l, r.width, r.height);
                  r.drawingContext.putImageData(f, 0, 0), o.push({
                    image: r.drawingContext.getImageData(0, 0, r.width, r.height),
                    delay: 10 * c.delay
                  });
                }

                var d = a.loopCount();
                null === d ? d = 1 : 0 === d && (d = null), r.drawingContext.putImageData(o[0].image, 0, 0), r.gifProperties = {
                  displayIndex: 0,
                  loopLimit: d,
                  loopCount: 0,
                  frames: o,
                  numFrames: s,
                  playing: !0,
                  timeDisplayed: 0,
                  lastChangeTime: 0
                };
              }

              "function" == typeof t && t(r);
              n();
            }(new Uint8Array(e), o, n, a, function (e) {
              s._decrementPreload();
            }.bind(s));
          }, function (e) {
            "function" == typeof a ? a(e) : console.error(e);
          });else {
            var r = new Image();
            r.onload = function () {
              o.width = o.canvas.width = r.width, o.height = o.canvas.height = r.height, o.drawingContext.drawImage(r, 0, 0), o.modified = !0, "function" == typeof n && n(o), s._decrementPreload();
            }, r.onerror = function (e) {
              x.default._friendlyFileLoadError(0, r.src), "function" == typeof a ? a(e) : console.error(e);
            }, 0 !== i.indexOf("data:image/") && (r.crossOrigin = "Anonymous"), r.src = i;
          }
          o.modified = !0;
        }), o;
      }, x.default.prototype.image = function (e, t, r, i, n, a, o, s, l) {
        x.default._validateParameters("image", arguments);

        var u = e.width,
            h = e.height;
        e.elt && e.elt.videoWidth && !e.canvas && (u = e.elt.videoWidth, h = e.elt.videoHeight);
        var c = t,
            f = r,
            d = i || u,
            p = n || h,
            m = a || 0,
            v = o || 0,
            y = s || u,
            g = l || h;
        y = S(y, u), g = S(g, h);
        var b = 1;
        e.elt && !e.canvas && e.elt.style.width && (b = e.elt.videoWidth && !i ? e.elt.videoWidth : e.elt.width, b /= parseInt(e.elt.style.width, 10)), m *= b, v *= b, g *= b, y *= b;

        var _ = w.default.modeAdjust(c, f, d, p, this._renderer._imageMode);

        this._renderer.image(e, m, v, y, g, _.x, _.y, _.w, _.h);
      }, x.default.prototype.tint = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        x.default._validateParameters("tint", t);

        var i = this.color.apply(this, t);
        this._renderer._tint = i.levels;
      }, x.default.prototype.noTint = function () {
        this._renderer._tint = null;
      }, x.default.prototype._getTintedImageCanvas = function (e) {
        if (!e.canvas) return e;

        var t = c.default._toPixels(e.canvas),
            r = document.createElement("canvas");

        r.width = e.canvas.width, r.height = e.canvas.height;

        for (var i = r.getContext("2d"), n = i.createImageData(e.canvas.width, e.canvas.height), a = n.data, o = 0; o < t.length; o += 4) {
          var s = t[o],
              l = t[o + 1],
              u = t[o + 2],
              h = t[o + 3];
          a[o] = s * this._renderer._tint[0] / 255, a[o + 1] = l * this._renderer._tint[1] / 255, a[o + 2] = u * this._renderer._tint[2] / 255, a[o + 3] = h * this._renderer._tint[3] / 255;
        }

        return i.putImageData(n, 0, 0), r;
      }, x.default.prototype.imageMode = function (e) {
        x.default._validateParameters("imageMode", arguments), e !== i.CORNER && e !== i.CORNERS && e !== i.CENTER || (this._renderer._imageMode = e);
      };
      var a = x.default;
      r.default = a;
    }, {
      "../core/constants": 26,
      "../core/friendly_errors/fes_core": 28,
      "../core/friendly_errors/file_errors": 29,
      "../core/friendly_errors/validate_params": 31,
      "../core/helpers": 32,
      "../core/main": 36,
      "./filters": 57,
      omggif: 11
    }],
    60: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var n = a(e("../core/main")),
          i = a(e("./filters"));

      function a(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      n.default.Image = function (e, t) {
        this.width = e, this.height = t, this.canvas = document.createElement("canvas"), this.canvas.width = this.width, this.canvas.height = this.height, this.drawingContext = this.canvas.getContext("2d"), (this._pixelsState = this)._pixelDensity = 1, this.gifProperties = null, this._modified = !1, this.pixels = [];
      }, n.default.Image.prototype._animateGif = function (e) {
        var t = this.gifProperties,
            r = e._lastFrameTime + e.deltaTime;

        if (0 === t.lastChangeTime && (t.lastChangeTime = r), t.playing) {
          t.timeDisplayed = r - t.lastChangeTime;
          var i = t.frames[t.displayIndex].delay;

          if (t.timeDisplayed >= i) {
            var n = Math.floor(t.timeDisplayed / i);
            if (t.timeDisplayed = 0, t.lastChangeTime = r, t.displayIndex += n, t.loopCount = Math.floor(t.displayIndex / t.numFrames), null !== t.loopLimit && t.loopCount >= t.loopLimit) t.playing = !1;else {
              var a = t.displayIndex % t.numFrames;
              this.drawingContext.putImageData(t.frames[a].image, 0, 0), t.displayIndex = a, this.setModified(!0);
            }
          }
        }
      }, n.default.Image.prototype._setProperty = function (e, t) {
        this[e] = t, this.setModified(!0);
      }, n.default.Image.prototype.loadPixels = function () {
        n.default.Renderer2D.prototype.loadPixels.call(this), this.setModified(!0);
      }, n.default.Image.prototype.updatePixels = function (e, t, r, i) {
        n.default.Renderer2D.prototype.updatePixels.call(this, e, t, r, i), this.setModified(!0);
      }, n.default.Image.prototype.get = function (e, t, r, i) {
        return n.default._validateParameters("p5.Image.get", arguments), n.default.Renderer2D.prototype.get.apply(this, arguments);
      }, n.default.Image.prototype._getPixel = n.default.Renderer2D.prototype._getPixel, n.default.Image.prototype.set = function (e, t, r) {
        n.default.Renderer2D.prototype.set.call(this, e, t, r), this.setModified(!0);
      }, n.default.Image.prototype.resize = function (e, t) {
        0 === e && 0 === t ? (e = this.canvas.width, t = this.canvas.height) : 0 === e ? e = this.canvas.width * t / this.canvas.height : 0 === t && (t = this.canvas.height * e / this.canvas.width), e = Math.floor(e), t = Math.floor(t);
        var r = document.createElement("canvas");
        if (r.width = e, r.height = t, this.gifProperties) for (var i = this.gifProperties, n = function (e, t) {
          for (var r = 0, i = 0; i < t.height; i++) for (var n = 0; n < t.width; n++) {
            var a = Math.floor(n * e.width / t.width),
                o = 4 * (Math.floor(i * e.height / t.height) * e.width + a);
            t.data[r++] = e.data[o++], t.data[r++] = e.data[o++], t.data[r++] = e.data[o++], t.data[r++] = e.data[o++];
          }
        }, a = 0; a < i.numFrames; a++) {
          var o = this.drawingContext.createImageData(e, t);
          n(i.frames[a].image, o), i.frames[a].image = o;
        }
        r.getContext("2d").drawImage(this.canvas, 0, 0, this.canvas.width, this.canvas.height, 0, 0, r.width, r.height), this.canvas.width = this.width = e, this.canvas.height = this.height = t, this.drawingContext.drawImage(r, 0, 0, e, t, 0, 0, e, t), 0 < this.pixels.length && this.loadPixels(), this.setModified(!0);
      }, n.default.Image.prototype.copy = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        n.default.prototype.copy.apply(this, t);
      }, n.default.Image.prototype.mask = function (e) {
        void 0 === e && (e = this);
        var t = this.drawingContext.globalCompositeOperation,
            r = 1;
        e instanceof n.default.Renderer && (r = e._pInst._pixelDensity);
        var i = [e, 0, 0, r * e.width, r * e.height, 0, 0, this.width, this.height];
        this.drawingContext.globalCompositeOperation = "destination-in", n.default.Image.prototype.copy.apply(this, i), this.drawingContext.globalCompositeOperation = t, this.setModified(!0);
      }, n.default.Image.prototype.filter = function (e, t) {
        i.default.apply(this.canvas, i.default[e], t), this.setModified(!0);
      }, n.default.Image.prototype.blend = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        n.default._validateParameters("p5.Image.blend", arguments), n.default.prototype.blend.apply(this, t), this.setModified(!0);
      }, n.default.Image.prototype.setModified = function (e) {
        this._modified = e;
      }, n.default.Image.prototype.isModified = function () {
        return this._modified;
      }, n.default.Image.prototype.save = function (e, t) {
        this.gifProperties ? n.default.prototype.saveGif(this, e) : n.default.prototype.saveCanvas(this.canvas, e, t);
      }, n.default.Image.prototype.reset = function () {
        if (this.gifProperties) {
          var e = this.gifProperties;
          e.playing = !0, e.timeSinceStart = 0, e.timeDisplayed = 0, e.lastChangeTime = 0, e.loopCount = 0, e.displayIndex = 0, this.drawingContext.putImageData(e.frames[0].image, 0, 0);
        }
      }, n.default.Image.prototype.getCurrentFrame = function () {
        if (this.gifProperties) {
          var e = this.gifProperties;
          return e.displayIndex % e.numFrames;
        }
      }, n.default.Image.prototype.setFrame = function (e) {
        if (this.gifProperties) {
          var t = this.gifProperties;
          e < t.numFrames && 0 <= e ? (t.timeDisplayed = 0, t.lastChangeTime = 0, t.displayIndex = e, this.drawingContext.putImageData(t.frames[e].image, 0, 0)) : console.log("Cannot set GIF to a frame number that is higher than total number of frames or below zero.");
        }
      }, n.default.Image.prototype.numFrames = function () {
        if (this.gifProperties) return this.gifProperties.numFrames;
      }, n.default.Image.prototype.play = function () {
        this.gifProperties && (this.gifProperties.playing = !0);
      }, n.default.Image.prototype.pause = function () {
        this.gifProperties && (this.gifProperties.playing = !1);
      }, n.default.Image.prototype.delay = function (e, t) {
        if (this.gifProperties) {
          var r = this.gifProperties;
          if (t < r.numFrames && 0 <= t) r.frames[t].delay = e;else {
            var i = !0,
                n = !1,
                a = void 0;

            try {
              for (var o, s = r.frames[Symbol.iterator](); !(i = (o = s.next()).done); i = !0) {
                o.value.delay = e;
              }
            } catch (e) {
              n = !0, a = e;
            } finally {
              try {
                i || null == s.return || s.return();
              } finally {
                if (n) throw a;
              }
            }
          }
        }
      };
      var o = n.default.Image;
      r.default = o;
    }, {
      "../core/main": 36,
      "./filters": 57
    }],
    61: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var d = n(e("../core/main")),
          i = n(e("./filters"));

      function n(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      e("../color/p5.Color"), d.default.prototype.pixels = [], d.default.prototype.blend = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        var i;
        (d.default._validateParameters("blend", t), this._renderer) ? (i = this._renderer).blend.apply(i, t) : d.default.Renderer2D.prototype.blend.apply(this, t);
      }, d.default.prototype.copy = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        var i, n, a, o, s, l, u, h, c;
        if (d.default._validateParameters("copy", t), 9 === t.length) i = t[0], n = t[1], a = t[2], o = t[3], s = t[4], l = t[5], u = t[6], h = t[7], c = t[8];else {
          if (8 !== t.length) throw new Error("Signature not supported");
          i = this, n = t[0], a = t[1], o = t[2], s = t[3], l = t[4], u = t[5], h = t[6], c = t[7];
        }

        d.default.prototype._copyHelper(this, i, n, a, o, s, l, u, h, c);
      }, d.default.prototype._copyHelper = function (e, t, r, i, n, a, o, s, l, u) {
        t.loadPixels();
        var h = t.canvas.width / t.width,
            c = 0,
            f = 0;
        t._renderer && t._renderer.isP3D && (c = t.width / 2, f = t.height / 2), e._renderer && e._renderer.isP3D ? d.default.RendererGL.prototype.image.call(e._renderer, t, r + c, i + f, n, a, o, s, l, u) : e.drawingContext.drawImage(t.canvas, h * (r + c), h * (i + f), h * n, h * a, o, s, l, u);
      }, d.default.prototype.filter = function (e, t) {
        d.default._validateParameters("filter", arguments), void 0 !== this.canvas ? i.default.apply(this.canvas, i.default[e], t) : i.default.apply(this.elt, i.default[e], t);
      }, d.default.prototype.get = function (e, t, r, i) {
        var n;
        return d.default._validateParameters("get", arguments), (n = this._renderer).get.apply(n, arguments);
      }, d.default.prototype.loadPixels = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        d.default._validateParameters("loadPixels", t), this._renderer.loadPixels();
      }, d.default.prototype.set = function (e, t, r) {
        this._renderer.set(e, t, r);
      }, d.default.prototype.updatePixels = function (e, t, r, i) {
        d.default._validateParameters("updatePixels", arguments), 0 !== this.pixels.length && this._renderer.updatePixels(e, t, r, i);
      };
      var a = d.default;
      r.default = a;
    }, {
      "../color/p5.Color": 24,
      "../core/main": 36,
      "./filters": 57
    }],
    62: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var y = i(e("../core/main"));
      e("whatwg-fetch"), e("es6-promise/auto");
      var v = i(e("fetch-jsonp")),
          s = i(e("file-saver"));

      function i(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      function g(e) {
        return (g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function b(e, t) {
        var r = {};
        if (void 0 === (t = t || [])) for (var i = 0; i < e.length; i++) t[i.toString()] = i;

        for (var n = 0; n < t.length; n++) {
          var a = t[n],
              o = e[n];
          r[a] = o;
        }

        return r;
      }

      function m(e) {
        return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
      }

      function l(e, t) {
        t && !0 !== t && "true" !== t || (t = "");
        var r = "";
        return (e = e || "untitled") && e.includes(".") && (r = e.split(".").pop()), t && r !== t && (r = t, e = "".concat(e, ".").concat(r)), [e, r];
      }

      e("../core/friendly_errors/validate_params"), e("../core/friendly_errors/file_errors"), e("../core/friendly_errors/fes_core"), y.default.prototype.loadJSON = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        y.default._validateParameters("loadJSON", t);

        for (var i, n, a, o = t[0], s = {}, l = "json", u = 1; u < t.length; u++) {
          var h = t[u];
          "string" == typeof h ? "jsonp" !== h && "json" !== h || (l = h) : "function" == typeof h ? i ? n = h : i = h : "object" === g(h) && (h.hasOwnProperty("jsonpCallback") || h.hasOwnProperty("jsonpCallbackFunction")) && (l = "jsonp", a = h);
        }

        var c = this;
        return this.httpDo(o, "GET", a, l, function (e) {
          for (var t in e) s[t] = e[t];

          void 0 !== i && i(e), c._decrementPreload();
        }, function (e) {
          if (y.default._friendlyFileLoadError(5, o), !n) throw e;
          n(e);
        }), s;
      }, y.default.prototype.loadStrings = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        y.default._validateParameters("loadStrings", t);

        for (var n, i, a = [], o = 1; o < t.length; o++) {
          var s = t[o];
          "function" == typeof s && (void 0 === n ? n = s : void 0 === i && (i = s));
        }

        var l = this;
        return y.default.prototype.httpDo.call(this, t[0], "GET", "text", function (e) {
          for (var t = e.replace(/\r\n/g, "\r").replace(/\n/g, "\r").split(/\r/), r = 0, i = t.length; r < i; r += 32768) Array.prototype.push.apply(a, t.slice(r, Math.min(r + 32768, i)));

          void 0 !== n && n(a), l._decrementPreload();
        }, function (e) {
          if (y.default._friendlyFileLoadError(3, e), !i) throw e;
          i(e);
        }), a;
      }, y.default.prototype.loadTable = function (t) {
        var f,
            r,
            d,
            e = [],
            p = !1,
            i = t.substring(t.lastIndexOf(".") + 1, t.length);
        "csv" === i ? d = "," : "ssv" === i ? d = ";" : "tsv" === i && (d = "\t");

        for (var n = 1; n < arguments.length; n++) "function" == typeof arguments[n] ? void 0 === f ? f = arguments[n] : void 0 === r && (r = arguments[n]) : "string" == typeof arguments[n] && (e.push(arguments[n]), "header" === arguments[n] && (p = !0), "csv" === arguments[n] ? d = "," : "ssv" === arguments[n] ? d = ";" : "tsv" === arguments[n] && (d = "\t"));

        var m = new y.default.Table(),
            v = this;
        return this.httpDo(t, "GET", "table", function (e) {
          for (var t, r, i = {}, n = [], a = 0, o = null, s = function () {
            i.currentState = 0, i.token = "";
          }, l = function () {
            o.push(i.token), s();
          }, u = function () {
            i.currentState = 4, n.push(o), o = null;
          };;) {
            if (null == (t = e[a++])) {
              if (i.escaped) throw new Error("Unclosed quote in file.");

              if (o) {
                l(), u();
                break;
              }
            }

            if (null === o && (i.escaped = !1, o = [], s()), 0 === i.currentState) {
              if ('"' === t) {
                i.escaped = !0, i.currentState = 1;
                continue;
              }

              i.currentState = 1;
            }

            if (1 === i.currentState && i.escaped) {
              if ('"' === t) '"' === e[a] ? (i.token += '"', a++) : (i.escaped = !1, i.currentState = 2);else {
                if ("\r" === t) continue;
                i.token += t;
              }
            } else "\r" === t ? ("\n" === e[a] && a++, l(), u()) : "\n" === t ? (l(), u()) : t === d ? l() : 1 === i.currentState && (i.token += t);
          }

          if (p) m.columns = n.shift();else for (var h = 0; h < n[0].length; h++) m.columns[h] = "null";

          for (var c = 0; c < n.length; c++) (1 !== n[c].length || "undefined" !== n[c][0] && "" !== n[c][0]) && ((r = new y.default.TableRow()).arr = n[c], r.obj = b(n[c], m.columns), m.addRow(r));

          "function" == typeof f && f(m), v._decrementPreload();
        }, function (e) {
          y.default._friendlyFileLoadError(2, t), r ? r(e) : console.error(e);
        }), m;
      }, y.default.prototype.loadXML = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        for (var i, n, a = new y.default.XML(), o = 1; o < t.length; o++) {
          var s = t[o];
          "function" == typeof s && (void 0 === i ? i = s : void 0 === n && (n = s));
        }

        var l = this;
        return this.httpDo(t[0], "GET", "xml", function (e) {
          for (var t in e) a[t] = e[t];

          void 0 !== i && i(a), l._decrementPreload();
        }, function (e) {
          if (y.default._friendlyFileLoadError(1, e), !n) throw e;
          n(e);
        }), a;
      }, y.default.prototype.loadBytes = function (t, r, i) {
        var n = {},
            a = this;
        return this.httpDo(t, "GET", "arrayBuffer", function (e) {
          n.bytes = new Uint8Array(e), "function" == typeof r && r(n), a._decrementPreload();
        }, function (e) {
          if (y.default._friendlyFileLoadError(6, t), !i) throw e;
          i(e);
        }), n;
      }, y.default.prototype.httpGet = function () {
        y.default._validateParameters("httpGet", arguments);

        var e = Array.prototype.slice.call(arguments);
        return e.splice(1, 0, "GET"), y.default.prototype.httpDo.apply(this, e);
      }, y.default.prototype.httpPost = function () {
        y.default._validateParameters("httpPost", arguments);

        var e = Array.prototype.slice.call(arguments);
        return e.splice(1, 0, "POST"), y.default.prototype.httpDo.apply(this, e);
      }, y.default.prototype.httpDo = function () {
        for (var i, e, t, r, n, a = {}, o = 0, s = "text/plain", l = arguments.length - 1; 0 < l && "function" == typeof (l < 0 || arguments.length <= l ? void 0 : arguments[l]); l--) o++;

        var u = arguments.length <= 0 ? void 0 : arguments[0];
        if (2 == arguments.length - o && "string" == typeof u && "object" === g(arguments.length <= 1 ? void 0 : arguments[1])) r = new Request(u, arguments.length <= 1 ? void 0 : arguments[1]), e = arguments.length <= 2 ? void 0 : arguments[2], t = arguments.length <= 3 ? void 0 : arguments[3];else {
          for (var h, c = "GET", f = 1; f < arguments.length; f++) {
            var d = f < 0 || arguments.length <= f ? void 0 : arguments[f];
            if ("string" == typeof d) "GET" === d || "POST" === d || "PUT" === d || "DELETE" === d ? c = d : "json" === d || "jsonp" === d || "binary" === d || "arrayBuffer" === d || "xml" === d || "text" === d || "table" === d ? i = d : h = d;else if ("number" == typeof d) h = d.toString();else if ("object" === g(d)) {
              if (d.hasOwnProperty("jsonpCallback") || d.hasOwnProperty("jsonpCallbackFunction")) for (var p in d) a[p] = d[p];else s = d instanceof y.default.XML ? (h = d.serialize(), "application/xml") : (h = JSON.stringify(d), "application/json");
            } else "function" == typeof d && (e ? t = d : e = d);
          }

          var m = "GET" === c ? new Headers() : new Headers({
            "Content-Type": s
          });
          r = new Request(u, {
            method: c,
            mode: "cors",
            body: h,
            headers: m
          });
        }
        return (n = (n = "jsonp" === (i = i || (u.includes("json") ? "json" : u.includes("xml") ? "xml" : "text")) ? (0, v.default)(u, a) : fetch(r)).then(function (e) {
          if (!e.ok) {
            var t = new Error(e.body);
            throw t.status = e.status, t.ok = !1, t;
          }

          var r = 0;

          switch ("jsonp" !== i && (r = e.headers.get("content-length")), r && 64e6 < r && y.default._friendlyFileLoadError(7, u), i) {
            case "json":
            case "jsonp":
              return e.json();

            case "binary":
              return e.blob();

            case "arrayBuffer":
              return e.arrayBuffer();

            case "xml":
              return e.text().then(function (e) {
                var t = new DOMParser().parseFromString(e, "text/xml");
                return new y.default.XML(t.documentElement);
              });

            default:
              return e.text();
          }
        })).then(e || function () {}), n.catch(t || console.error), n;
      }, window.URL = window.URL || window.webkitURL, y.default.prototype._pWriters = [], y.default.prototype.createWriter = function (e, t) {
        var r;

        for (var i in y.default.prototype._pWriters) if (y.default.prototype._pWriters[i].name === e) return r = new y.default.PrintWriter(e + this.millis(), t), y.default.prototype._pWriters.push(r), r;

        return r = new y.default.PrintWriter(e, t), y.default.prototype._pWriters.push(r), r;
      }, y.default.PrintWriter = function (r, i) {
        var n = this;
        this.name = r, this.content = "", this.write = function (e) {
          this.content += e;
        }, this.print = function (e) {
          this.content += "".concat(e, "\n");
        }, this.clear = function () {
          this.content = "";
        }, this.close = function () {
          var e = [];

          for (var t in e.push(this.content), y.default.prototype.writeFile(e, r, i), y.default.prototype._pWriters) y.default.prototype._pWriters[t].name === this.name && y.default.prototype._pWriters.splice(t, 1);

          n.clear(), n = {};
        };
      }, y.default.prototype.save = function (e, t, r) {
        var i = arguments,
            n = this._curElement ? this._curElement.elt : this.elt;
        if (0 !== i.length) {
          if (i[0] instanceof y.default.Renderer || i[0] instanceof y.default.Graphics) y.default.prototype.saveCanvas(i[0].elt, i[1], i[2]);else if (1 === i.length && "string" == typeof i[0]) y.default.prototype.saveCanvas(n, i[0]);else switch (l(i[1], i[2])[1]) {
            case "json":
              return void y.default.prototype.saveJSON(i[0], i[1], i[2]);

            case "txt":
              return void y.default.prototype.saveStrings(i[0], i[1], i[2]);

            default:
              i[0] instanceof Array ? y.default.prototype.saveStrings(i[0], i[1], i[2]) : i[0] instanceof y.default.Table ? y.default.prototype.saveTable(i[0], i[1], i[2]) : i[0] instanceof y.default.Image ? y.default.prototype.saveCanvas(i[0].canvas, i[1]) : i[0] instanceof y.default.SoundFile && y.default.prototype.saveSound(i[0], i[1], i[2], i[3]);
          }
        } else y.default.prototype.saveCanvas(n);
      }, y.default.prototype.saveJSON = function (e, t, r) {
        var i;
        y.default._validateParameters("saveJSON", arguments), i = r ? JSON.stringify(e) : JSON.stringify(e, void 0, 2), this.saveStrings(i.split("\n"), t, "json");
      }, y.default.prototype.saveJSONObject = y.default.prototype.saveJSON, y.default.prototype.saveJSONArray = y.default.prototype.saveJSON, y.default.prototype.saveStrings = function (e, t, r, i) {
        y.default._validateParameters("saveStrings", arguments);

        for (var n = r || "txt", a = this.createWriter(t, n), o = 0; o < e.length; o++) i ? a.write(e[o] + "\r\n") : a.write(e[o] + "\n");

        a.close(), a.clear();
      }, y.default.prototype.saveTable = function (e, t, r) {
        var i;
        y.default._validateParameters("saveTable", arguments), i = void 0 === r ? t.substring(t.lastIndexOf(".") + 1, t.length) : r;
        var n = this.createWriter(t, i),
            a = e.columns,
            o = ",";

        if ("tsv" === i && (o = "\t"), "html" !== i) {
          if ("0" !== a[0]) {
            for (var s = 0; s < a.length; s++) s < a.length - 1 ? n.write(a[s] + o) : n.write(a[s]);

            n.write("\n");
          }

          for (var l = 0; l < e.rows.length; l++) {
            var u = void 0;

            for (u = 0; u < e.rows[l].arr.length; u++) u < e.rows[l].arr.length - 1 ? "csv" === i && e.rows[l].arr[u].includes(",") ? n.write('"' + e.rows[l].arr[u] + '"' + o) : n.write(e.rows[l].arr[u] + o) : "csv" === i && e.rows[l].arr[u].includes(",") ? n.write('"' + e.rows[l].arr[u] + '"') : n.write(e.rows[l].arr[u]);

            n.write("\n");
          }
        } else {
          n.print("<html>"), n.print("<head>");

          if (n.print('  <meta http-equiv="content-type" content="text/html;charset=utf-8" />'), n.print("</head>"), n.print("<body>"), n.print("  <table>"), "0" !== a[0]) {
            n.print("    <tr>");

            for (var h = 0; h < a.length; h++) {
              var c = m(a[h]);
              n.print("      <td>".concat(c)), n.print("      </td>");
            }

            n.print("    </tr>");
          }

          for (var f = 0; f < e.rows.length; f++) {
            n.print("    <tr>");

            for (var d = 0; d < e.columns.length; d++) {
              var p = m(e.rows[f].getString(d));
              n.print("      <td>".concat(p)), n.print("      </td>");
            }

            n.print("    </tr>");
          }

          n.print("  </table>"), n.print("</body>"), n.print("</html>");
        }

        n.close(), n.clear();
      }, y.default.prototype.writeFile = function (e, t, r) {
        var i = "application/octet-stream";
        y.default.prototype._isSafari() && (i = "text/plain");
        var n = new Blob(e, {
          type: i
        });
        y.default.prototype.downloadFile(n, t, r);
      }, y.default.prototype.downloadFile = function (e, t, r) {
        var i = l(t, r),
            n = i[0];
        if (e instanceof Blob) s.default.saveAs(e, n);else {
          var a = document.createElement("a");

          if (a.href = e, a.download = n, a.onclick = function (e) {
            var t;
            t = e, document.body.removeChild(t.target), e.stopPropagation();
          }, a.style.display = "none", document.body.appendChild(a), y.default.prototype._isSafari()) {
            var o = "Hello, Safari user! To download this file...\n";
            o += "1. Go to File --\x3e Save As.\n", o += '2. Choose "Page Source" as the Format.\n', o += '3. Name it with this extension: ."'.concat(i[1], '"'), alert(o);
          }

          a.click();
        }
      }, y.default.prototype._checkFileExtension = l, y.default.prototype._isSafari = function () {
        return 0 < Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor");
      };
      var n = y.default;
      r.default = n;
    }, {
      "../core/friendly_errors/fes_core": 28,
      "../core/friendly_errors/file_errors": 29,
      "../core/friendly_errors/validate_params": 31,
      "../core/main": 36,
      "es6-promise/auto": 5,
      "fetch-jsonp": 7,
      "file-saver": 8,
      "whatwg-fetch": 15
    }],
    63: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      n.default.Table = function (e) {
        this.columns = [], this.rows = [];
      }, n.default.Table.prototype.addRow = function (e) {
        var t = e || new n.default.TableRow();
        if (void 0 === t.arr || void 0 === t.obj) throw new Error("invalid TableRow: ".concat(t));
        return (t.table = this).rows.push(t), t;
      }, n.default.Table.prototype.removeRow = function (e) {
        this.rows[e].table = null;
        var t = this.rows.splice(e + 1, this.rows.length);
        this.rows.pop(), this.rows = this.rows.concat(t);
      }, n.default.Table.prototype.getRow = function (e) {
        return this.rows[e];
      }, n.default.Table.prototype.getRows = function () {
        return this.rows;
      }, n.default.Table.prototype.findRow = function (e, t) {
        if ("string" == typeof t) {
          for (var r = 0; r < this.rows.length; r++) if (this.rows[r].obj[t] === e) return this.rows[r];
        } else for (var i = 0; i < this.rows.length; i++) if (this.rows[i].arr[t] === e) return this.rows[i];

        return null;
      }, n.default.Table.prototype.findRows = function (e, t) {
        var r = [];
        if ("string" == typeof t) for (var i = 0; i < this.rows.length; i++) this.rows[i].obj[t] === e && r.push(this.rows[i]);else for (var n = 0; n < this.rows.length; n++) this.rows[n].arr[t] === e && r.push(this.rows[n]);
        return r;
      }, n.default.Table.prototype.matchRow = function (e, t) {
        if ("number" == typeof t) {
          for (var r = 0; r < this.rows.length; r++) if (this.rows[r].arr[t].match(e)) return this.rows[r];
        } else for (var i = 0; i < this.rows.length; i++) if (this.rows[i].obj[t].match(e)) return this.rows[i];

        return null;
      }, n.default.Table.prototype.matchRows = function (e, t) {
        var r = [];
        if ("number" == typeof t) for (var i = 0; i < this.rows.length; i++) this.rows[i].arr[t].match(e) && r.push(this.rows[i]);else for (var n = 0; n < this.rows.length; n++) this.rows[n].obj[t].match(e) && r.push(this.rows[n]);
        return r;
      }, n.default.Table.prototype.getColumn = function (e) {
        var t = [];
        if ("string" == typeof e) for (var r = 0; r < this.rows.length; r++) t.push(this.rows[r].obj[e]);else for (var i = 0; i < this.rows.length; i++) t.push(this.rows[i].arr[e]);
        return t;
      }, n.default.Table.prototype.clearRows = function () {
        delete this.rows, this.rows = [];
      }, n.default.Table.prototype.addColumn = function (e) {
        var t = e || null;
        this.columns.push(t);
      }, n.default.Table.prototype.getColumnCount = function () {
        return this.columns.length;
      }, n.default.Table.prototype.getRowCount = function () {
        return this.rows.length;
      }, n.default.Table.prototype.removeTokens = function (e, t) {
        for (var r = [], i = 0; i < e.length; i++) r.push(e.charAt(i).replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"));

        var n = new RegExp(r.join("|"), "g");
        if (void 0 === t) for (var a = 0; a < this.columns.length; a++) for (var o = 0; o < this.rows.length; o++) {
          var s = this.rows[o].arr[a];
          s = s.replace(n, ""), this.rows[o].arr[a] = s, this.rows[o].obj[this.columns[a]] = s;
        } else if ("string" == typeof t) for (var l = 0; l < this.rows.length; l++) {
          var u = this.rows[l].obj[t];
          u = u.replace(n, ""), this.rows[l].obj[t] = u;
          var h = this.columns.indexOf(t);
          this.rows[l].arr[h] = u;
        } else for (var c = 0; c < this.rows.length; c++) {
          var f = this.rows[c].arr[t];
          f = f.replace(n, ""), this.rows[c].arr[t] = f, this.rows[c].obj[this.columns[t]] = f;
        }
      }, n.default.Table.prototype.trim = function (e) {
        var t = new RegExp(" ", "g");
        if (void 0 === e) for (var r = 0; r < this.columns.length; r++) for (var i = 0; i < this.rows.length; i++) {
          var n = this.rows[i].arr[r];
          n = n.replace(t, ""), this.rows[i].arr[r] = n, this.rows[i].obj[this.columns[r]] = n;
        } else if ("string" == typeof e) for (var a = 0; a < this.rows.length; a++) {
          var o = this.rows[a].obj[e];
          o = o.replace(t, ""), this.rows[a].obj[e] = o;
          var s = this.columns.indexOf(e);
          this.rows[a].arr[s] = o;
        } else for (var l = 0; l < this.rows.length; l++) {
          var u = this.rows[l].arr[e];
          u = u.replace(t, ""), this.rows[l].arr[e] = u, this.rows[l].obj[this.columns[e]] = u;
        }
      }, n.default.Table.prototype.removeColumn = function (e) {
        var t, r;
        "string" == typeof e ? (t = e, r = this.columns.indexOf(e)) : (r = e, t = this.columns[e]);
        var i = this.columns.splice(r + 1, this.columns.length);
        this.columns.pop(), this.columns = this.columns.concat(i);

        for (var n = 0; n < this.rows.length; n++) {
          var a = this.rows[n].arr,
              o = a.splice(r + 1, a.length);
          a.pop(), this.rows[n].arr = a.concat(o), delete this.rows[n].obj[t];
        }
      }, n.default.Table.prototype.set = function (e, t, r) {
        this.rows[e].set(t, r);
      }, n.default.Table.prototype.setNum = function (e, t, r) {
        this.rows[e].setNum(t, r);
      }, n.default.Table.prototype.setString = function (e, t, r) {
        this.rows[e].setString(t, r);
      }, n.default.Table.prototype.get = function (e, t) {
        return this.rows[e].get(t);
      }, n.default.Table.prototype.getNum = function (e, t) {
        return this.rows[e].getNum(t);
      }, n.default.Table.prototype.getString = function (e, t) {
        return this.rows[e].getString(t);
      }, n.default.Table.prototype.getObject = function (e) {
        for (var t, r = {}, i = 0; i < this.rows.length; i++) if (t = this.rows[i].obj, "string" == typeof e) {
          if (!(0 <= this.columns.indexOf(e))) throw new Error('This table has no column named "'.concat(e, '"'));
          r[t[e]] = t;
        } else r[i] = this.rows[i].obj;

        return r;
      }, n.default.Table.prototype.getArray = function () {
        for (var e = [], t = 0; t < this.rows.length; t++) e.push(this.rows[t].arr);

        return e;
      };
      var a = n.default;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    64: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      n.default.TableRow = function (e, t) {
        var r = [],
            i = {};
        e && (t = t || ",", r = e.split(t));

        for (var n = 0; n < r.length; n++) {
          var a = n,
              o = r[n];
          i[a] = o;
        }

        this.arr = r, this.obj = i, this.table = null;
      }, n.default.TableRow.prototype.set = function (e, t) {
        if ("string" == typeof e) {
          var r = this.table.columns.indexOf(e);
          if (!(0 <= r)) throw new Error('This table has no column named "'.concat(e, '"'));
          this.obj[e] = t, this.arr[r] = t;
        } else {
          if (!(e < this.table.columns.length)) throw new Error("Column #".concat(e, " is out of the range of this table"));
          this.arr[e] = t;
          var i = this.table.columns[e];
          this.obj[i] = t;
        }
      }, n.default.TableRow.prototype.setNum = function (e, t) {
        var r = parseFloat(t);
        this.set(e, r);
      }, n.default.TableRow.prototype.setString = function (e, t) {
        var r = t.toString();
        this.set(e, r);
      }, n.default.TableRow.prototype.get = function (e) {
        return "string" == typeof e ? this.obj[e] : this.arr[e];
      }, n.default.TableRow.prototype.getNum = function (e) {
        var t;
        if ("NaN" === (t = "string" == typeof e ? parseFloat(this.obj[e]) : parseFloat(this.arr[e])).toString()) throw "Error: ".concat(this.obj[e], " is NaN (Not a Number)");
        return t;
      }, n.default.TableRow.prototype.getString = function (e) {
        return "string" == typeof e ? this.obj[e].toString() : this.arr[e].toString();
      };
      var a = n.default;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    65: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          s = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };

      function n(e) {
        for (var t = [], r = 0; r < e.length; r++) t.push(new s.default.XML(e[r]));

        return t;
      }

      s.default.XML = function (e) {
        if (e) this.DOM = e;else {
          var t = document.implementation.createDocument(null, "doc");
          this.DOM = t.createElement("root");
        }
      }, s.default.XML.prototype.getParent = function () {
        return new s.default.XML(this.DOM.parentElement);
      }, s.default.XML.prototype.getName = function () {
        return this.DOM.tagName;
      }, s.default.XML.prototype.setName = function (e) {
        var t = this.DOM.innerHTML,
            r = this.DOM.attributes,
            i = document.implementation.createDocument(null, "default").createElement(e);
        i.innerHTML = t;

        for (var n = 0; n < r.length; n++) i.setAttribute(r[n].nodeName, r.nodeValue);

        this.DOM = i;
      }, s.default.XML.prototype.hasChildren = function () {
        return 0 < this.DOM.children.length;
      }, s.default.XML.prototype.listChildren = function () {
        for (var e = [], t = 0; t < this.DOM.childNodes.length; t++) e.push(this.DOM.childNodes[t].nodeName);

        return e;
      }, s.default.XML.prototype.getChildren = function (e) {
        return n(e ? this.DOM.getElementsByTagName(e) : this.DOM.children);
      }, s.default.XML.prototype.getChild = function (e) {
        if ("string" != typeof e) return new s.default.XML(this.DOM.children[e]);
        var t = !0,
            r = !1,
            i = void 0;

        try {
          for (var n, a = this.DOM.children[Symbol.iterator](); !(t = (n = a.next()).done); t = !0) {
            var o = n.value;
            if (o.tagName === e) return new s.default.XML(o);
          }
        } catch (e) {
          r = !0, i = e;
        } finally {
          try {
            t || null == a.return || a.return();
          } finally {
            if (r) throw i;
          }
        }
      }, s.default.XML.prototype.addChild = function (e) {
        e instanceof s.default.XML && this.DOM.appendChild(e.DOM);
      }, s.default.XML.prototype.removeChild = function (e) {
        var t = -1;

        if ("string" == typeof e) {
          for (var r = 0; r < this.DOM.children.length; r++) if (this.DOM.children[r].tagName === e) {
            t = r;
            break;
          }
        } else t = e;

        -1 !== t && this.DOM.removeChild(this.DOM.children[t]);
      }, s.default.XML.prototype.getAttributeCount = function () {
        return this.DOM.attributes.length;
      }, s.default.XML.prototype.listAttributes = function () {
        var e = [],
            t = !0,
            r = !1,
            i = void 0;

        try {
          for (var n, a = this.DOM.attributes[Symbol.iterator](); !(t = (n = a.next()).done); t = !0) {
            var o = n.value;
            e.push(o.nodeName);
          }
        } catch (e) {
          r = !0, i = e;
        } finally {
          try {
            t || null == a.return || a.return();
          } finally {
            if (r) throw i;
          }
        }

        return e;
      }, s.default.XML.prototype.hasAttribute = function (e) {
        var t = {},
            r = !0,
            i = !1,
            n = void 0;

        try {
          for (var a, o = this.DOM.attributes[Symbol.iterator](); !(r = (a = o.next()).done); r = !0) {
            var s = a.value;
            t[s.nodeName] = s.nodeValue;
          }
        } catch (e) {
          i = !0, n = e;
        } finally {
          try {
            r || null == o.return || o.return();
          } finally {
            if (i) throw n;
          }
        }

        return !!t[e];
      }, s.default.XML.prototype.getNum = function (e, t) {
        var r = {},
            i = !0,
            n = !1,
            a = void 0;

        try {
          for (var o, s = this.DOM.attributes[Symbol.iterator](); !(i = (o = s.next()).done); i = !0) {
            var l = o.value;
            r[l.nodeName] = l.nodeValue;
          }
        } catch (e) {
          n = !0, a = e;
        } finally {
          try {
            i || null == s.return || s.return();
          } finally {
            if (n) throw a;
          }
        }

        return Number(r[e]) || t || 0;
      }, s.default.XML.prototype.getString = function (e, t) {
        var r = {},
            i = !0,
            n = !1,
            a = void 0;

        try {
          for (var o, s = this.DOM.attributes[Symbol.iterator](); !(i = (o = s.next()).done); i = !0) {
            var l = o.value;
            r[l.nodeName] = l.nodeValue;
          }
        } catch (e) {
          n = !0, a = e;
        } finally {
          try {
            i || null == s.return || s.return();
          } finally {
            if (n) throw a;
          }
        }

        return r[e] ? String(r[e]) : t || null;
      }, s.default.XML.prototype.setAttribute = function (e, t) {
        this.DOM.setAttribute(e, t);
      }, s.default.XML.prototype.getContent = function (e) {
        return this.DOM.textContent.replace(/\s\s+/g, ",") || e || null;
      }, s.default.XML.prototype.setContent = function (e) {
        this.DOM.children.length || (this.DOM.textContent = e);
      }, s.default.XML.prototype.serialize = function () {
        return new XMLSerializer().serializeToString(this.DOM);
      };
      var a = s.default;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    66: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          s = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };

      function n() {
        if ("function" == typeof Math.hypot) return Math.hypot.apply(null, arguments);

        for (var e = arguments.length, t = [], r = 0, i = 0; i < e; i++) {
          var n = arguments[i];
          if ((n = +n) === 1 / 0 || n === -1 / 0) return 1 / 0;
          r < (n = Math.abs(n)) && (r = n), t[i] = n;
        }

        0 === r && (r = 1);

        for (var a = 0, o = 0, s = 0; s < e; s++) {
          var l = t[s] / r,
              u = l * l - o,
              h = a + u;
          o = h - a - u, a = h;
        }

        return Math.sqrt(a) * r;
      }

      s.default.prototype.abs = Math.abs, s.default.prototype.ceil = Math.ceil, s.default.prototype.constrain = function (e, t, r) {
        return s.default._validateParameters("constrain", arguments), Math.max(Math.min(e, r), t);
      }, s.default.prototype.dist = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        return s.default._validateParameters("dist", t), 4 === t.length ? n(t[2] - t[0], t[3] - t[1]) : 6 === t.length ? n(t[3] - t[0], t[4] - t[1], t[5] - t[2]) : void 0;
      }, s.default.prototype.exp = Math.exp, s.default.prototype.floor = Math.floor, s.default.prototype.lerp = function (e, t, r) {
        return s.default._validateParameters("lerp", arguments), r * (t - e) + e;
      }, s.default.prototype.log = Math.log, s.default.prototype.mag = function (e, t) {
        return s.default._validateParameters("mag", arguments), n(e, t);
      }, s.default.prototype.map = function (e, t, r, i, n, a) {
        s.default._validateParameters("map", arguments);

        var o = (e - t) / (r - t) * (n - i) + i;
        return a ? i < n ? this.constrain(o, i, n) : this.constrain(o, n, i) : o;
      }, s.default.prototype.max = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        return t[0] instanceof Array ? Math.max.apply(null, t[0]) : Math.max.apply(null, t);
      }, s.default.prototype.min = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        return t[0] instanceof Array ? Math.min.apply(null, t[0]) : Math.min.apply(null, t);
      }, s.default.prototype.norm = function (e, t, r) {
        return s.default._validateParameters("norm", arguments), this.map(e, t, r, 0, 1);
      }, s.default.prototype.pow = Math.pow, s.default.prototype.round = function (e, t) {
        return t ? Number(Math.round(e + "e" + t) + "e-" + t) : Math.round(e);
      }, s.default.prototype.sq = function (e) {
        return e * e;
      }, s.default.prototype.sqrt = Math.sqrt, s.default.prototype.fract = function (e) {
        s.default._validateParameters("fract", arguments);

        var t = 0,
            r = Number(e);
        if (isNaN(r) || Math.abs(r) === 1 / 0) return r;
        if (r < 0 && (r = -r, t = 1), !String(r).includes(".") || String(r).includes("e")) return r < 1 ? Math.abs(t - r) : 0;
        var i = String(r);
        return i = Number("0" + i.slice(i.indexOf("."))), Math.abs(t - i);
      };
      var a = s.default;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    67: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };

      n.default.prototype.createVector = function (e, t, r) {
        return this instanceof n.default ? new n.default.Vector(this, arguments) : new n.default.Vector(e, t, r);
      };

      var a = n.default;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    68: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };

      function b(e) {
        return .5 * (1 - Math.cos(e * Math.PI));
      }

      var _,
          x = 4095,
          w = 4,
          S = .5;

      n.default.prototype.noise = function (e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
            r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;

        if (null == _) {
          _ = new Array(4096);

          for (var i = 0; i < 4096; i++) _[i] = Math.random();
        }

        e < 0 && (e = -e), t < 0 && (t = -t), r < 0 && (r = -r);

        for (var n, a, o, s, l, u = Math.floor(e), h = Math.floor(t), c = Math.floor(r), f = e - u, d = t - h, p = r - c, m = 0, v = .5, y = 0; y < w; y++) {
          var g = u + (h << 4) + (c << 8);
          n = b(f), a = b(d), o = _[g & x], o += n * (_[g + 1 & x] - o), s = _[g + 16 & x], o += a * ((s += n * (_[g + 16 + 1 & x] - s)) - o), s = _[(g += 256) & x], s += n * (_[g + 1 & x] - s), l = _[g + 16 & x], s += a * ((l += n * (_[g + 16 + 1 & x] - l)) - s), m += (o += b(p) * (s - o)) * v, v *= S, u <<= 1, h <<= 1, c <<= 1, 1 <= (f *= 2) && (u++, f--), 1 <= (d *= 2) && (h++, d--), 1 <= (p *= 2) && (c++, p--);
        }

        return m;
      }, n.default.prototype.noiseDetail = function (e, t) {
        0 < e && (w = e), 0 < t && (S = t);
      }, n.default.prototype.noiseSeed = function (e) {
        var t,
            r,
            i,
            n = (i = 4294967296, {
          setSeed: function (e) {
            r = t = (null == e ? Math.random() * i : e) >>> 0;
          },
          getSeed: function () {
            return t;
          },
          rand: function () {
            return (r = (1664525 * r + 1013904223) % i) / i;
          }
        });
        n.setSeed(e), _ = new Array(4096);

        for (var a = 0; a < 4096; a++) _[a] = n.rand();
      };
      var a = n.default;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    69: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var i,
          l = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      },
          a = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../core/constants"));

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      l.default.Vector = function (e, t, r) {
        var i, n, a;
        a = e instanceof l.default ? (this.p5 = e, i = t[0] || 0, n = t[1] || 0, t[2] || 0) : (i = e || 0, n = t || 0, r || 0), this.x = i, this.y = n, this.z = a;
      }, l.default.Vector.prototype.toString = function () {
        return "p5.Vector Object : [".concat(this.x, ", ").concat(this.y, ", ").concat(this.z, "]");
      }, l.default.Vector.prototype.set = function (e, t, r) {
        return e instanceof l.default.Vector ? (this.x = e.x || 0, this.y = e.y || 0, this.z = e.z || 0) : e instanceof Array ? (this.x = e[0] || 0, this.y = e[1] || 0, this.z = e[2] || 0) : (this.x = e || 0, this.y = t || 0, this.z = r || 0), this;
      }, l.default.Vector.prototype.copy = function () {
        return this.p5 ? new l.default.Vector(this.p5, [this.x, this.y, this.z]) : new l.default.Vector(this.x, this.y, this.z);
      }, l.default.Vector.prototype.add = function (e, t, r) {
        return e instanceof l.default.Vector ? (this.x += e.x || 0, this.y += e.y || 0, this.z += e.z || 0) : e instanceof Array ? (this.x += e[0] || 0, this.y += e[1] || 0, this.z += e[2] || 0) : (this.x += e || 0, this.y += t || 0, this.z += r || 0), this;
      };

      function u(e, t) {
        return 0 !== e && (this.x = this.x % e), 0 !== t && (this.y = this.y % t), this;
      }

      function h(e, t, r) {
        return 0 !== e && (this.x = this.x % e), 0 !== t && (this.y = this.y % t), 0 !== r && (this.z = this.z % r), this;
      }

      l.default.Vector.prototype.rem = function (e, t, r) {
        if (e instanceof l.default.Vector) {
          if (Number.isFinite(e.x) && Number.isFinite(e.y) && Number.isFinite(e.z)) {
            var i = parseFloat(e.x),
                n = parseFloat(e.y),
                a = parseFloat(e.z);
            h.call(this, i, n, a);
          }
        } else if (e instanceof Array) e.every(function (e) {
          return Number.isFinite(e);
        }) && (2 === e.length && u.call(this, e[0], e[1]), 3 === e.length && h.call(this, e[0], e[1], e[2]));else if (1 === arguments.length) {
          if (Number.isFinite(e) && 0 !== e) return this.x = this.x % e, this.y = this.y % e, this.z = this.z % e, this;
        } else if (2 === arguments.length) {
          var o = Array.prototype.slice.call(arguments);
          o.every(function (e) {
            return Number.isFinite(e);
          }) && 2 === o.length && u.call(this, o[0], o[1]);
        } else if (3 === arguments.length) {
          var s = Array.prototype.slice.call(arguments);
          s.every(function (e) {
            return Number.isFinite(e);
          }) && 3 === s.length && h.call(this, s[0], s[1], s[2]);
        }
      }, l.default.Vector.prototype.sub = function (e, t, r) {
        return e instanceof l.default.Vector ? (this.x -= e.x || 0, this.y -= e.y || 0, this.z -= e.z || 0) : e instanceof Array ? (this.x -= e[0] || 0, this.y -= e[1] || 0, this.z -= e[2] || 0) : (this.x -= e || 0, this.y -= t || 0, this.z -= r || 0), this;
      }, l.default.Vector.prototype.mult = function (e, t, r) {
        if (e instanceof l.default.Vector) return Number.isFinite(e.x) && Number.isFinite(e.y) && Number.isFinite(e.z) && "number" == typeof e.x && "number" == typeof e.y && "number" == typeof e.z ? (this.x *= e.x, this.y *= e.y, this.z *= e.z) : console.warn("p5.Vector.prototype.mult:", "x contains components that are either undefined or not finite numbers"), this;
        if (e instanceof Array) return e.every(function (e) {
          return Number.isFinite(e);
        }) && e.every(function (e) {
          return "number" == typeof e;
        }) ? 1 === e.length ? (this.x *= e[0], this.y *= e[0], this.z *= e[0]) : 2 === e.length ? (this.x *= e[0], this.y *= e[1]) : 3 === e.length && (this.x *= e[0], this.y *= e[1], this.z *= e[2]) : console.warn("p5.Vector.prototype.mult:", "x contains elements that are either undefined or not finite numbers"), this;
        var i = Array.prototype.slice.call(arguments);
        return i.every(function (e) {
          return Number.isFinite(e);
        }) && i.every(function (e) {
          return "number" == typeof e;
        }) ? (1 === arguments.length && (this.x *= e, this.y *= e, this.z *= e), 2 === arguments.length && (this.x *= e, this.y *= t), 3 === arguments.length && (this.x *= e, this.y *= t, this.z *= r)) : console.warn("p5.Vector.prototype.mult:", "x, y, or z arguments are either undefined or not a finite number"), this;
      }, l.default.Vector.prototype.div = function (e, t, r) {
        if (e instanceof l.default.Vector) {
          if (Number.isFinite(e.x) && Number.isFinite(e.y) && Number.isFinite(e.z) && "number" == typeof e.x && "number" == typeof e.y && "number" == typeof e.z) {
            if (0 === e.x || 0 === e.y || 0 === e.z) return console.warn("p5.Vector.prototype.div:", "divide by 0"), this;
            this.x /= e.x, this.y /= e.y, this.z /= e.z;
          } else console.warn("p5.Vector.prototype.div:", "x contains components that are either undefined or not finite numbers");

          return this;
        }

        if (e instanceof Array) {
          if (e.every(function (e) {
            return Number.isFinite(e);
          }) && e.every(function (e) {
            return "number" == typeof e;
          })) {
            if (e.some(function (e) {
              return 0 === e;
            })) return console.warn("p5.Vector.prototype.div:", "divide by 0"), this;
            1 === e.length ? (this.x /= e[0], this.y /= e[0], this.z /= e[0]) : 2 === e.length ? (this.x /= e[0], this.y /= e[1]) : 3 === e.length && (this.x /= e[0], this.y /= e[1], this.z /= e[2]);
          } else console.warn("p5.Vector.prototype.div:", "x contains components that are either undefined or not finite numbers");

          return this;
        }

        var i = Array.prototype.slice.call(arguments);

        if (i.every(function (e) {
          return Number.isFinite(e);
        }) && i.every(function (e) {
          return "number" == typeof e;
        })) {
          if (i.some(function (e) {
            return 0 === e;
          })) return console.warn("p5.Vector.prototype.div:", "divide by 0"), this;
          1 === arguments.length && (this.x /= e, this.y /= e, this.z /= e), 2 === arguments.length && (this.x /= e, this.y /= t), 3 === arguments.length && (this.x /= e, this.y /= t, this.z /= r);
        } else console.warn("p5.Vector.prototype.div:", "x, y, or z arguments are either undefined or not a finite number");

        return this;
      }, l.default.Vector.prototype.mag = function () {
        return Math.sqrt(this.magSq());
      }, l.default.Vector.prototype.magSq = function () {
        var e = this.x,
            t = this.y,
            r = this.z;
        return e * e + t * t + r * r;
      }, l.default.Vector.prototype.dot = function (e, t, r) {
        return e instanceof l.default.Vector ? this.dot(e.x, e.y, e.z) : this.x * (e || 0) + this.y * (t || 0) + this.z * (r || 0);
      }, l.default.Vector.prototype.cross = function (e) {
        var t = this.y * e.z - this.z * e.y,
            r = this.z * e.x - this.x * e.z,
            i = this.x * e.y - this.y * e.x;
        return this.p5 ? new l.default.Vector(this.p5, [t, r, i]) : new l.default.Vector(t, r, i);
      }, l.default.Vector.prototype.dist = function (e) {
        return e.copy().sub(this).mag();
      }, l.default.Vector.prototype.normalize = function () {
        var e = this.mag();
        return 0 !== e && this.mult(1 / e), this;
      }, l.default.Vector.prototype.limit = function (e) {
        var t = this.magSq();
        return e * e < t && this.div(Math.sqrt(t)).mult(e), this;
      }, l.default.Vector.prototype.setMag = function (e) {
        return this.normalize().mult(e);
      }, l.default.Vector.prototype.heading = function () {
        var e = Math.atan2(this.y, this.x);
        return this.p5 ? this.p5._fromRadians(e) : e;
      }, l.default.Vector.prototype.setHeading = function (e) {
        var t = this.mag();
        return this.x = t * Math.cos(e), this.y = t * Math.sin(e), this;
      }, l.default.Vector.prototype.rotate = function (e) {
        var t = this.heading() + e;
        this.p5 && (t = this.p5._toRadians(t));
        var r = this.mag();
        return this.x = Math.cos(t) * r, this.y = Math.sin(t) * r, this;
      }, l.default.Vector.prototype.angleBetween = function (e) {
        var t,
            r = this.dot(e) / (this.mag() * e.mag());
        return t = Math.acos(Math.min(1, Math.max(-1, r))), t *= Math.sign(this.cross(e).z || 1), this.p5 && (t = this.p5._fromRadians(t)), t;
      }, l.default.Vector.prototype.lerp = function (e, t, r, i) {
        return e instanceof l.default.Vector ? this.lerp(e.x, e.y, e.z, t) : (this.x += (e - this.x) * i || 0, this.y += (t - this.y) * i || 0, this.z += (r - this.z) * i || 0, this);
      }, l.default.Vector.prototype.reflect = function (e) {
        return e.normalize(), this.sub(e.mult(2 * this.dot(e)));
      }, l.default.Vector.prototype.array = function () {
        return [this.x || 0, this.y || 0, this.z || 0];
      }, l.default.Vector.prototype.equals = function (e, t, r) {
        var i, n, a;
        return a = e instanceof l.default.Vector ? (i = e.x || 0, n = e.y || 0, e.z || 0) : e instanceof Array ? (i = e[0] || 0, n = e[1] || 0, e[2] || 0) : (i = e || 0, n = t || 0, r || 0), this.x === i && this.y === n && this.z === a;
      }, l.default.Vector.fromAngle = function (e, t) {
        return void 0 === t && (t = 1), new l.default.Vector(t * Math.cos(e), t * Math.sin(e), 0);
      }, l.default.Vector.fromAngles = function (e, t, r) {
        void 0 === r && (r = 1);
        var i = Math.cos(t),
            n = Math.sin(t),
            a = Math.cos(e),
            o = Math.sin(e);
        return new l.default.Vector(r * o * n, -r * a, r * o * i);
      }, l.default.Vector.random2D = function () {
        return this.fromAngle(Math.random() * a.TWO_PI);
      }, l.default.Vector.random3D = function () {
        var e = Math.random() * a.TWO_PI,
            t = 2 * Math.random() - 1,
            r = Math.sqrt(1 - t * t),
            i = r * Math.cos(e),
            n = r * Math.sin(e);
        return new l.default.Vector(i, n, t);
      }, l.default.Vector.add = function (e, t, r) {
        return r ? r.set(e) : (r = e.copy(), 3 === arguments.length && l.default._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.add")), r.add(t), r;
      }, l.default.Vector.rem = function (e, t) {
        if (e instanceof l.default.Vector && t instanceof l.default.Vector) {
          var r = e.copy();
          return r.rem(t), r;
        }
      }, l.default.Vector.sub = function (e, t, r) {
        return r ? r.set(e) : (r = e.copy(), 3 === arguments.length && l.default._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.sub")), r.sub(t), r;
      }, l.default.Vector.mult = function (e, t, r) {
        return r ? r.set(e) : (r = e.copy(), 3 === arguments.length && l.default._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.mult")), r.mult(t), r;
      }, l.default.Vector.div = function (e, t, r) {
        return r ? r.set(e) : (r = e.copy(), 3 === arguments.length && l.default._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.div")), r.div(t), r;
      }, l.default.Vector.dot = function (e, t) {
        return e.dot(t);
      }, l.default.Vector.cross = function (e, t) {
        return e.cross(t);
      }, l.default.Vector.dist = function (e, t) {
        return e.dist(t);
      }, l.default.Vector.lerp = function (e, t, r, i) {
        return i ? i.set(e) : (i = e.copy(), 4 === arguments.length && l.default._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.lerp")), i.lerp(t, r), i;
      }, l.default.Vector.mag = function (e) {
        var t = e.x,
            r = e.y,
            i = e.z,
            n = t * t + r * r + i * i;
        return Math.sqrt(n);
      };
      var n = l.default.Vector;
      r.default = n;
    }, {
      "../core/constants": 26,
      "../core/main": 36
    }],
    70: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      var a = "_lcg_random_state",
          o = 4294967296,
          s = 0;
      n.default.prototype._lcg = function (e) {
        return this[e] = (1664525 * this[e] + 1013904223) % o, this[e] / o;
      }, n.default.prototype._lcgSetSeed = function (e, t) {
        this[e] = (null == t ? Math.random() * o : t) >>> 0;
      }, n.default.prototype.randomSeed = function (e) {
        this._lcgSetSeed(a, e), this._gaussian_previous = !1;
      }, n.default.prototype.random = function (e, t) {
        var r;
        if (n.default._validateParameters("random", arguments), r = null != this[a] ? this._lcg(a) : Math.random(), void 0 === e) return r;
        if (void 0 === t) return e instanceof Array ? e[Math.floor(r * e.length)] : r * e;

        if (t < e) {
          var i = e;
          e = t, t = i;
        }

        return r * (t - e) + e;
      }, n.default.prototype.randomGaussian = function (e) {
        var t,
            r,
            i,
            n,
            a = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1;
        if (this._gaussian_previous) t = s, this._gaussian_previous = !1;else {
          for (; 1 <= (n = (r = this.random(2) - 1) * r + (i = this.random(2) - 1) * i););

          t = r * (n = Math.sqrt(-2 * Math.log(n) / n)), s = i * n, this._gaussian_previous = !0;
        }
        return t * a + (e || 0);
      };
      var l = n.default;
      r.default = l;
    }, {
      "../core/main": 36
    }],
    71: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      },
          a = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../core/constants"));

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      n.default.prototype._angleMode = a.RADIANS, n.default.prototype.acos = function (e) {
        return this._fromRadians(Math.acos(e));
      }, n.default.prototype.asin = function (e) {
        return this._fromRadians(Math.asin(e));
      }, n.default.prototype.atan = function (e) {
        return this._fromRadians(Math.atan(e));
      }, n.default.prototype.atan2 = function (e, t) {
        return this._fromRadians(Math.atan2(e, t));
      }, n.default.prototype.cos = function (e) {
        return Math.cos(this._toRadians(e));
      }, n.default.prototype.sin = function (e) {
        return Math.sin(this._toRadians(e));
      }, n.default.prototype.tan = function (e) {
        return Math.tan(this._toRadians(e));
      }, n.default.prototype.degrees = function (e) {
        return e * a.RAD_TO_DEG;
      }, n.default.prototype.radians = function (e) {
        return e * a.DEG_TO_RAD;
      }, n.default.prototype.angleMode = function (e) {
        e !== a.DEGREES && e !== a.RADIANS || (this._angleMode = e);
      }, n.default.prototype._toRadians = function (e) {
        return this._angleMode === a.DEGREES ? e * a.DEG_TO_RAD : e;
      }, n.default.prototype._toDegrees = function (e) {
        return this._angleMode === a.RADIANS ? e * a.RAD_TO_DEG : e;
      }, n.default.prototype._fromRadians = function (e) {
        return this._angleMode === a.DEGREES ? e * a.RAD_TO_DEG : e;
      };
      var l = n.default;
      r.default = l;
    }, {
      "../core/constants": 26,
      "../core/main": 36
    }],
    72: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      n.default.prototype.textAlign = function (e, t) {
        var r;
        return n.default._validateParameters("textAlign", arguments), (r = this._renderer).textAlign.apply(r, arguments);
      }, n.default.prototype.textLeading = function (e) {
        var t;
        return n.default._validateParameters("textLeading", arguments), (t = this._renderer).textLeading.apply(t, arguments);
      }, n.default.prototype.textSize = function (e) {
        var t;
        return n.default._validateParameters("textSize", arguments), (t = this._renderer).textSize.apply(t, arguments);
      }, n.default.prototype.textStyle = function (e) {
        var t;
        return n.default._validateParameters("textStyle", arguments), (t = this._renderer).textStyle.apply(t, arguments);
      }, n.default.prototype.textWidth = function () {
        for (var e, t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];

        return r[0] += "", n.default._validateParameters("textWidth", r), 0 === r[0].length ? 0 : (e = this._renderer).textWidth.apply(e, r);
      }, n.default.prototype.textAscent = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        return n.default._validateParameters("textAscent", t), this._renderer.textAscent();
      }, n.default.prototype.textDescent = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        return n.default._validateParameters("textDescent", t), this._renderer.textDescent();
      }, n.default.prototype._updateTextMetrics = function () {
        return this._renderer._updateTextMetrics();
      };
      var a = n.default;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    73: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          f = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      },
          n = l(e("../core/constants")),
          a = l(e("opentype.js"));

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      function l(e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        return r.default = e, t && t.set(e, r), r;
      }

      e("../core/friendly_errors/validate_params"), e("../core/friendly_errors/file_errors"), e("../core/friendly_errors/fes_core"), f.default.prototype.loadFont = function (s, l, u) {
        f.default._validateParameters("loadFont", arguments);

        var h = new f.default.Font(this),
            c = this;
        return a.load(s, function (e, t) {
          if (e) return f.default._friendlyFileLoadError(4, s), void 0 !== u ? u(e) : void console.error(e, s);
          h.font = t, void 0 !== l && l(h), c._decrementPreload();
          var r,
              i,
              n = s.split("\\").pop().split("/").pop(),
              a = n.lastIndexOf("."),
              o = a < 1 ? null : n.substr(a + 1);
          ["ttf", "otf", "woff", "woff2"].includes(o) && (r = n.substr(0, a), (i = document.createElement("style")).appendChild(document.createTextNode("\n@font-face {\nfont-family: ".concat(r, ";\nsrc: url(").concat(s, ");\n}\n"))), document.head.appendChild(i));
        }), h;
      }, f.default.prototype.text = function (e, t, r, i, n) {
        var a;
        return f.default._validateParameters("text", arguments), this._renderer._doFill || this._renderer._doStroke ? (a = this._renderer).text.apply(a, arguments) : this;
      }, f.default.prototype.textFont = function (e, t) {
        if (f.default._validateParameters("textFont", arguments), arguments.length) {
          if (!e) throw new Error("null font passed to textFont");
          return this._renderer._setProperty("_textFont", e), t && (this._renderer._setProperty("_textSize", t), this._renderer._setProperty("_textLeading", t * n._DEFAULT_LEADMULT)), this._renderer._applyTextProperties();
        }

        return this._renderer._textFont;
      };
      var u = f.default;
      r.default = u;
    }, {
      "../core/constants": 26,
      "../core/friendly_errors/fes_core": 28,
      "../core/friendly_errors/file_errors": 29,
      "../core/friendly_errors/validate_params": 31,
      "../core/main": 36,
      "opentype.js": 12
    }],
    74: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      },
          x = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== d(e) && "function" != typeof e) return {
          default: e
        };
        var t = o();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../core/constants"));

      function o() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return o = function () {
          return e;
        }, e;
      }

      function d(e) {
        return (d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function p(e, t) {
        for (var r = function (e, t) {
          if ("object" !== d(e)) e = t;else for (var r in t) void 0 === e[r] && (e[r] = t[r]);
          return e;
        }(t, {
          sampleFactor: .1,
          simplifyThreshold: 0
        }), i = l(e, 0, 1), n = i / (i * r.sampleFactor), a = [], o = 0; o < i; o += n) a.push(l(e, o));

        return r.simplifyThreshold && function (e) {
          for (var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, r = 0, i = e.length - 1; 3 < e.length && 0 <= i; --i) f(s(e, i - 1), s(e, i), s(e, i + 1), t) && (e.splice(i % e.length, 1), r++);
        }(a, r.simplifyThreshold), a;
      }

      function m(e) {
        for (var t, r = [], i = 0; i < e.length; i++) "M" === e[i].type && (t && r.push(t), t = []), t.push(a(e[i]));

        return r.push(t), r;
      }

      function a(e) {
        var t = [e.type];
        return "M" === e.type || "L" === e.type ? t.push(e.x, e.y) : "C" === e.type ? t.push(e.x1, e.y1, e.x2, e.y2, e.x, e.y) : "Q" === e.type && t.push(e.x1, e.y1, e.x, e.y), t;
      }

      function s(e, t) {
        var r = e.length;
        return e[t < 0 ? t % r + r : t % r];
      }

      function f(e, t, r, i) {
        if (!i) return 0 == (n = e, o = r, ((a = t)[0] - n[0]) * (o[1] - n[1]) - (o[0] - n[0]) * (a[1] - n[1]));
        var n, a, o;
        void 0 === f.tmpPoint1 && (f.tmpPoint1 = [], f.tmpPoint2 = []);
        var s = f.tmpPoint1,
            l = f.tmpPoint2;
        s.x = t.x - e.x, s.y = t.y - e.y, l.x = r.x - t.x, l.y = r.y - t.y;
        var u = s.x * l.x + s.y * l.y,
            h = Math.sqrt(s.x * s.x + s.y * s.y),
            c = Math.sqrt(l.x * l.x + l.y * l.y);
        return Math.acos(u / (h * c)) < i;
      }

      function c(e, t, r, i, n, a, o, s, l) {
        var u = 1 - l,
            h = Math.pow(u, 3),
            c = Math.pow(u, 2),
            f = l * l,
            d = f * l,
            p = h * e + 3 * c * l * r + 3 * u * l * l * n + d * o,
            m = h * t + 3 * c * l * i + 3 * u * l * l * a + d * s,
            v = e + 2 * l * (r - e) + f * (n - 2 * r + e),
            y = t + 2 * l * (i - t) + f * (a - 2 * i + t),
            g = r + 2 * l * (n - r) + f * (o - 2 * n + r),
            b = i + 2 * l * (a - i) + f * (s - 2 * a + i),
            _ = u * e + l * r,
            x = u * t + l * i,
            w = u * n + l * o,
            S = u * a + l * s,
            M = 90 - 180 * Math.atan2(v - g, y - b) / Math.PI;

        return (g < v || y < b) && (M += 180), {
          x: p,
          y: m,
          m: {
            x: v,
            y: y
          },
          n: {
            x: g,
            y: b
          },
          start: {
            x: _,
            y: x
          },
          end: {
            x: w,
            y: S
          },
          alpha: M
        };
      }

      function v(e, t, r, i, n, a, o, s, l) {
        return null == l ? y(e, t, r, i, n, a, o, s) : c(e, t, r, i, n, a, o, s, function (e, t, r, i, n, a, o, s, l) {
          if (l < 0 || y(e, t, r, i, n, a, o, s) < l) return;
          var u,
              h = .5,
              c = 1 - h;
          u = y(e, t, r, i, n, a, o, s, c);

          for (; .01 < Math.abs(u - l);) u = y(e, t, r, i, n, a, o, s, c += (u < l ? 1 : -1) * (h /= 2));

          return c;
        }(e, t, r, i, n, a, o, s, l));
      }

      function l(e, t, r) {
        for (var i, n, a, o, s, l = 0, u = 0, h = (e = function (e, t) {
          function r(e, t, r) {
            var i, n;
            if (!e) return ["C", t.x, t.y, t.x, t.y, t.x, t.y];

            switch ((e[0] in {
              T: 1,
              Q: 1
            }) || (t.qx = t.qy = null), e[0]) {
              case "M":
                t.X = e[1], t.Y = e[2];
                break;

              case "A":
                e = ["C"].concat(function e(t, r, i, n, a, o, s, l, u, h) {
                  var c = Math.PI;
                  var f = 120 * c / 180;
                  var d;
                  var p;
                  var m;
                  var v;
                  var y = c / 180 * (+a || 0);
                  var g = [];
                  var b;

                  var _ = function (e, t, r) {
                    var i = e * Math.cos(r) - t * Math.sin(r),
                        n = e * Math.sin(r) + t * Math.cos(r);
                    return {
                      x: i,
                      y: n
                    };
                  };

                  if (h) d = h[0], p = h[1], m = h[2], v = h[3];else {
                    b = _(t, r, -y), t = b.x, r = b.y, b = _(l, u, -y), l = b.x, u = b.y;
                    var x = (t - l) / 2,
                        w = (r - u) / 2,
                        S = x * x / (i * i) + w * w / (n * n);
                    1 < S && (S = Math.sqrt(S), i *= S, n *= S);
                    var M = i * i,
                        T = n * n,
                        E = (o === s ? -1 : 1) * Math.sqrt(Math.abs((M * T - M * w * w - T * x * x) / (M * w * w + T * x * x)));
                    m = E * i * w / n + (t + l) / 2, v = E * -n * x / i + (r + u) / 2, d = Math.asin(((r - v) / n).toFixed(9)), p = Math.asin(((u - v) / n).toFixed(9)), (d = t < m ? c - d : d) < 0 && (d = 2 * c + d), (p = l < m ? c - p : p) < 0 && (p = 2 * c + p), s && p < d && (d -= 2 * c), !s && d < p && (p -= 2 * c);
                  }
                  var C = p - d;

                  if (Math.abs(C) > f) {
                    var L = p,
                        O = l,
                        P = u;
                    p = d + f * (s && d < p ? 1 : -1), l = m + i * Math.cos(p), u = v + n * Math.sin(p), g = e(l, u, i, n, a, 0, s, O, P, [p, L, m, v]);
                  }

                  C = p - d;
                  var R = Math.cos(d),
                      D = Math.sin(d),
                      k = Math.cos(p),
                      A = Math.sin(p),
                      I = Math.tan(C / 4),
                      U = 4 / 3 * i * I,
                      N = 4 / 3 * n * I,
                      F = [t, r],
                      B = [t + U * D, r - N * R],
                      G = [l + U * A, u - N * k],
                      j = [l, u];
                  B[0] = 2 * F[0] - B[0];
                  B[1] = 2 * F[1] - B[1];
                  {
                    if (h) return [B, G, j].concat(g);
                    g = [B, G, j].concat(g).join().split(",");

                    for (var V = [], z = 0, H = g.length; z < H; z++) V[z] = z % 2 ? _(g[z - 1], g[z], y).y : _(g[z], g[z + 1], y).x;

                    return V;
                  }
                }.apply(0, [t.x, t.y].concat(e.slice(1))));
                break;

              case "S":
                n = "C" === r || "S" === r ? (i = 2 * t.x - t.bx, 2 * t.y - t.by) : (i = t.x, t.y), e = ["C", i, n].concat(e.slice(1));
                break;

              case "T":
                "Q" === r || "T" === r ? (t.qx = 2 * t.x - t.qx, t.qy = 2 * t.y - t.qy) : (t.qx = t.x, t.qy = t.y), e = ["C"].concat(S(t.x, t.y, t.qx, t.qy, e[1], e[2]));
                break;

              case "Q":
                t.qx = e[1], t.qy = e[2], e = ["C"].concat(S(t.x, t.y, e[1], e[2], e[3], e[4]));
                break;

              case "L":
                e = ["C"].concat(w(t.x, t.y, e[1], e[2]));
                break;

              case "H":
                e = ["C"].concat(w(t.x, t.y, e[1], t.y));
                break;

              case "V":
                e = ["C"].concat(w(t.x, t.y, t.x, e[1]));
                break;

              case "Z":
                e = ["C"].concat(w(t.x, t.y, t.X, t.Y));
            }

            return e;
          }

          function i(e, t) {
            if (7 < e[t].length) {
              e[t].shift();

              for (var r = e[t]; r.length;) h[t] = "A", s && (c[t] = "A"), e.splice(t++, 0, ["C"].concat(r.splice(0, 6)));

              e.splice(t, 1), a = Math.max(o.length, s && s.length || 0);
            }
          }

          function n(e, t, r, i, n) {
            e && t && "M" === e[n][0] && "M" !== t[n][0] && (t.splice(n, 0, ["M", i.x, i.y]), r.bx = 0, r.by = 0, r.x = e[n][1], r.y = e[n][2], a = Math.max(o.length, s && s.length || 0));
          }

          var a,
              o = b(e),
              s = t && b(t),
              l = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
          },
              u = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
          },
              h = [],
              c = [],
              f = "",
              d = "";
          a = Math.max(o.length, s && s.length || 0);

          for (var p = 0; p < a; p++) {
            o[p] && (f = o[p][0]), "C" !== f && (h[p] = f, p && (d = h[p - 1])), o[p] = r(o[p], l, d), "A" !== h[p] && "C" === f && (h[p] = "C"), i(o, p), s && (s[p] && (f = s[p][0]), "C" !== f && (c[p] = f, p && (d = c[p - 1])), s[p] = r(s[p], u, d), "A" !== c[p] && "C" === f && (c[p] = "C"), i(s, p)), n(o, s, l, u, p), n(s, o, u, l, p);
            var m = o[p],
                v = s && s[p],
                y = m.length,
                g = s && v.length;
            l.x = m[y - 2], l.y = m[y - 1], l.bx = parseFloat(m[y - 4]) || l.x, l.by = parseFloat(m[y - 3]) || l.y, u.bx = s && (parseFloat(v[g - 4]) || u.x), u.by = s && (parseFloat(v[g - 3]) || u.y), u.x = s && v[g - 2], u.y = s && v[g - 1];
          }

          return s ? [o, s] : o;
        }(e)).length; u < h; u++) {
          if ("M" === (a = e[u])[0]) i = +a[1], n = +a[2];else {
            if (t < l + (o = v(i, n, a[1], a[2], a[3], a[4], a[5], a[6])) && !r) return {
              x: (s = v(i, n, a[1], a[2], a[3], a[4], a[5], a[6], t - l)).x,
              y: s.y,
              alpha: s.alpha
            };
            l += o, i = +a[5], n = +a[6];
          }
          a.shift() + a;
        }

        return (s = r ? l : c(i, n, a[0], a[1], a[2], a[3], a[4], a[5], 1)).alpha && (s = {
          x: s.x,
          y: s.y,
          alpha: s.alpha
        }), s;
      }

      function b(e) {
        var t,
            r = [],
            i = 0,
            n = 0,
            a = 0,
            o = 0,
            s = 0;
        if (!e) return r;
        "M" === e[0][0] && (a = i = +e[0][1], o = n = +e[0][2], s++, r[0] = ["M", i, n]);

        for (var l, u, h = 3 === e.length && "M" === e[0][0] && "R" === e[1][0].toUpperCase() && "Z" === e[2][0].toUpperCase(), c = s, f = e.length; c < f; c++) {
          if (r.push(l = []), (u = e[c])[0] !== String.prototype.toUpperCase.call(u[0])) switch (l[0] = String.prototype.toUpperCase.call(u[0]), l[0]) {
            case "A":
              l[1] = u[1], l[2] = u[2], l[3] = u[3], l[4] = u[4], l[5] = u[5], l[6] = +(u[6] + i), l[7] = +(u[7] + n);
              break;

            case "V":
              l[1] = +u[1] + n;
              break;

            case "H":
              l[1] = +u[1] + i;
              break;

            case "R":
              for (var d = 2, p = (t = [i, n].concat(u.slice(1))).length; d < p; d++) t[d] = +t[d] + i, t[++d] = +t[d] + n;

              r.pop(), r = r.concat(_(t, h));
              break;

            case "M":
              a = +u[1] + i, o = +u[2] + n;
              break;

            default:
              for (var m = 1, v = u.length; m < v; m++) l[m] = +u[m] + (m % 2 ? i : n);

          } else if ("R" === u[0]) t = [i, n].concat(u.slice(1)), r.pop(), r = r.concat(_(t, h)), l = ["R"].concat(u.slice(-2));else for (var y = 0, g = u.length; y < g; y++) l[y] = u[y];

          switch (l[0]) {
            case "Z":
              i = a, n = o;
              break;

            case "H":
              i = l[1];
              break;

            case "V":
              n = l[1];
              break;

            case "M":
              a = l[l.length - 2], o = l[l.length - 1];
              break;

            default:
              i = l[l.length - 2], n = l[l.length - 1];
          }
        }

        return r;
      }

      function _(e, t) {
        for (var r = [], i = 0, n = e.length; i < n - 2 * !t; i += 2) {
          var a = [{
            x: +e[i - 2],
            y: +e[i - 1]
          }, {
            x: +e[i],
            y: +e[i + 1]
          }, {
            x: +e[i + 2],
            y: +e[i + 3]
          }, {
            x: +e[i + 4],
            y: +e[i + 5]
          }];
          t ? i ? n - 4 === i ? a[3] = {
            x: +e[0],
            y: +e[1]
          } : n - 2 === i && (a[2] = {
            x: +e[0],
            y: +e[1]
          }, a[3] = {
            x: +e[2],
            y: +e[3]
          }) : a[0] = {
            x: +e[n - 2],
            y: +e[n - 1]
          } : n - 4 === i ? a[3] = a[2] : i || (a[0] = {
            x: +e[i],
            y: +e[i + 1]
          }), r.push(["C", (-a[0].x + 6 * a[1].x + a[2].x) / 6, (-a[0].y + 6 * a[1].y + a[2].y) / 6, (a[1].x + 6 * a[2].x - a[3].x) / 6, (a[1].y + 6 * a[2].y - a[3].y) / 6, a[2].x, a[2].y]);
        }

        return r;
      }

      function w(e, t, r, i) {
        return [e, t, r, i, r, i];
      }

      function S(e, t, r, i, n, a) {
        return [1 / 3 * e + 2 / 3 * r, 1 / 3 * t + 2 / 3 * i, 1 / 3 * n + 2 / 3 * r, 1 / 3 * a + 2 / 3 * i, n, a];
      }

      function y(e, t, r, i, n, a, o, s, l) {
        null == l && (l = 1);

        for (var u = (l = 1 < l ? 1 : l < 0 ? 0 : l) / 2, h = [-.1252, .1252, -.3678, .3678, -.5873, .5873, -.7699, .7699, -.9041, .9041, -.9816, .9816], c = 0, f = [.2491, .2491, .2335, .2335, .2032, .2032, .1601, .1601, .1069, .1069, .0472, .0472], d = 0; d < 12; d++) {
          var p = u * h[d] + u,
              m = g(p, e, r, n, o),
              v = g(p, t, i, a, s),
              y = m * m + v * v;
          c += f[d] * Math.sqrt(y);
        }

        return u * c;
      }

      function g(e, t, r, i, n) {
        return e * (e * (-3 * t + 9 * r - 9 * i + 3 * n) + 6 * t - 12 * r + 6 * i) - 3 * t + 3 * r;
      }

      n.default.Font = function (e) {
        this.parent = e, this.cache = {}, this.font = void 0;
      }, n.default.Font.prototype.textBounds = function (e) {
        var t,
            r = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
            i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0,
            n = 3 < arguments.length ? arguments[3] : void 0,
            a = 4 < arguments.length ? arguments[4] : void 0,
            o = a && a.renderer && a.renderer._pInst || this.parent,
            s = o._renderer.drawingContext;
        s.textAlign || x.LEFT, s.textBaseline || x.BASELINE;

        if (n = n || o._renderer._textSize, !t) {
          var l,
              u,
              h = [],
              c = [],
              f = [];
          f[0] = [];

          var d = [],
              p = this._scale(n),
              m = o._renderer.textLeading(),
              v = 0;

          this.font.forEachGlyph(e, r, i, n, a, function (e, t, r, i) {
            var n = e.getMetrics();
            0 === e.index || 10 === e.index ? f[v += 1] = [] : (f[v].push(t + n.xMin * p), f[v].push(t + n.xMax * p), d.push(r + v * m + -n.yMin * p), d.push(r + v * m + -n.yMax * p));
          }), 0 < f[v].length && (h[v] = Math.min.apply(null, f[v]), c[v] = Math.max.apply(null, f[v]));

          for (var y = 0, g = 0; g <= v; g++) {
            h[g] = Math.min.apply(null, f[g]), c[g] = Math.max.apply(null, f[g]);
            var b = c[g] - h[g];
            y < b && (y = b);
          }

          var _ = Math.min.apply(null, h);

          t = {
            x: _,
            y: l = Math.min.apply(null, d),
            h: Math.max.apply(null, d) - l,
            w: y,
            advance: _ - r
          }, u = this._handleAlignment(o._renderer, e, t.x, t.y, t.w + t.advance), t.x = u.x, t.y = u.y;
        }

        return t;
      }, n.default.Font.prototype.textToPoints = function (e, t, r, i, n) {
        var a,
            o = 0,
            s = [],
            l = this._getGlyphs(e);

        i = i || this.parent._renderer._textSize;

        for (var u = 0; u < l.length; u++) {
          if (!(l[a = u].name && "space" === l[a].name || e.length === l.length && " " === e[a] || l[a].index && 3 === l[a].index)) for (var h = m(l[u].getPath(t, r, i).commands), c = 0; c < h.length; c++) for (var f = p(h[c], n), d = 0; d < f.length; d++) f[d].x += o, s.push(f[d]);
          o += l[u].advanceWidth * this._scale(i);
        }

        return s;
      }, n.default.Font.prototype._getGlyphs = function (e) {
        return this.font.stringToGlyphs(e);
      }, n.default.Font.prototype._getPath = function (e, t, r, i) {
        var n = (i && i.renderer && i.renderer._pInst || this.parent)._renderer,
            a = this._handleAlignment(n, e, t, r);

        return this.font.getPath(e, a.x, a.y, n._textSize, i);
      }, n.default.Font.prototype._getPathData = function (e, t, r, i) {
        var n = 3;
        return "string" == typeof e && 2 < arguments.length ? e = this._getPath(e, t, r, i) : "object" === d(t) && (i = t), i && "number" == typeof i.decimals && (n = i.decimals), e.toPathData(n);
      }, n.default.Font.prototype._getSVG = function (e, t, r, i) {
        var n = 3;
        return "string" == typeof e && 2 < arguments.length ? e = this._getPath(e, t, r, i) : "object" === d(t) && (i = t), i && ("number" == typeof i.decimals && (n = i.decimals), "number" == typeof i.strokeWidth && (e.strokeWidth = i.strokeWidth), void 0 !== i.fill && (e.fill = i.fill), void 0 !== i.stroke && (e.stroke = i.stroke)), e.toSVG(n);
      }, n.default.Font.prototype._renderPath = function (e, t, r, i) {
        var n,
            a = i && i.renderer || this.parent._renderer,
            o = a.drawingContext;
        n = "object" === d(e) && e.commands ? e.commands : this._getPath(e, t, r, i).commands, o.beginPath();
        var s = !0,
            l = !1,
            u = void 0;

        try {
          for (var h, c = n[Symbol.iterator](); !(s = (h = c.next()).done); s = !0) {
            var f = h.value;
            "M" === f.type ? o.moveTo(f.x, f.y) : "L" === f.type ? o.lineTo(f.x, f.y) : "C" === f.type ? o.bezierCurveTo(f.x1, f.y1, f.x2, f.y2, f.x, f.y) : "Q" === f.type ? o.quadraticCurveTo(f.x1, f.y1, f.x, f.y) : "Z" === f.type && o.closePath();
          }
        } catch (e) {
          l = !0, u = e;
        } finally {
          try {
            s || null == c.return || c.return();
          } finally {
            if (l) throw u;
          }
        }

        return a._doStroke && a._strokeSet && o.stroke(), a._doFill && (a._fillSet || a._setFill(x._DEFAULT_TEXT_FILL), o.fill()), this;
      }, n.default.Font.prototype._textWidth = function (e, t) {
        return this.font.getAdvanceWidth(e, t);
      }, n.default.Font.prototype._textAscent = function (e) {
        return this.font.ascender * this._scale(e);
      }, n.default.Font.prototype._textDescent = function (e) {
        return -this.font.descender * this._scale(e);
      }, n.default.Font.prototype._scale = function (e) {
        return 1 / this.font.unitsPerEm * (e || this.parent._renderer._textSize);
      }, n.default.Font.prototype._handleAlignment = function (e, t, r, i, n) {
        var a = e._textSize;

        switch (void 0 === n && (n = this._textWidth(t, a)), e._textAlign) {
          case x.CENTER:
            r -= n / 2;
            break;

          case x.RIGHT:
            r -= n;
        }

        switch (e._textBaseline) {
          case x.TOP:
            i += this._textAscent(a);
            break;

          case x.CENTER:
            i += this._textAscent(a) / 2;
            break;

          case x.BOTTOM:
            i -= this._textDescent(a);
        }

        return {
          x: r,
          y: i
        };
      };
      var u = n.default;
      r.default = u;
    }, {
      "../core/constants": 26,
      "../core/main": 36
    }],
    75: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      n.default.prototype.append = function (e, t) {
        return e.push(t), e;
      }, n.default.prototype.arrayCopy = function (e, t, r, i, n) {
        var a, o;
        e = void 0 !== n ? (o = Math.min(n, e.length), a = i, e.slice(t, o + t)) : (o = void 0 !== r ? (o = r, Math.min(o, e.length)) : e.length, a = 0, r = t, e.slice(0, o)), Array.prototype.splice.apply(r, [a, o].concat(e));
      }, n.default.prototype.concat = function (e, t) {
        return e.concat(t);
      }, n.default.prototype.reverse = function (e) {
        return e.reverse();
      }, n.default.prototype.shorten = function (e) {
        return e.pop(), e;
      }, n.default.prototype.shuffle = function (e, t) {
        for (var r, i, n = ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(e), a = (e = t || n ? e : e.slice()).length; 1 < a;) r = this.random(0, 1) * a | 0, i = e[--a], e[a] = e[r], e[r] = i;

        return e;
      }, n.default.prototype.sort = function (e, t) {
        var r = t ? e.slice(0, Math.min(t, e.length)) : e,
            i = t ? e.slice(Math.min(t, e.length)) : [];
        return (r = "string" == typeof r[0] ? r.sort() : r.sort(function (e, t) {
          return e - t;
        })).concat(i);
      }, n.default.prototype.splice = function (e, t, r) {
        return Array.prototype.splice.apply(e, [r, 0].concat(t)), e;
      }, n.default.prototype.subset = function (e, t, r) {
        return void 0 !== r ? e.slice(t, t + r) : e.slice(t, e.length);
      };
      var a = n.default;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    76: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      n.default.prototype.float = function (e) {
        return e instanceof Array ? e.map(parseFloat) : parseFloat(e);
      }, n.default.prototype.int = function (e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 10;
        return e === 1 / 0 || "Infinity" === e ? 1 / 0 : e === -1 / 0 || "-Infinity" === e ? -1 / 0 : "string" == typeof e ? parseInt(e, t) : "number" == typeof e ? 0 | e : "boolean" == typeof e ? e ? 1 : 0 : e instanceof Array ? e.map(function (e) {
          return n.default.prototype.int(e, t);
        }) : void 0;
      }, n.default.prototype.str = function (e) {
        return e instanceof Array ? e.map(n.default.prototype.str) : String(e);
      }, n.default.prototype.boolean = function (e) {
        return "number" == typeof e ? 0 !== e : "string" == typeof e ? "true" === e.toLowerCase() : "boolean" == typeof e ? e : e instanceof Array ? e.map(n.default.prototype.boolean) : void 0;
      }, n.default.prototype.byte = function (e) {
        var t = n.default.prototype.int(e, 10);
        return "number" == typeof t ? (t + 128) % 256 - 128 : t instanceof Array ? t.map(n.default.prototype.byte) : void 0;
      }, n.default.prototype.char = function (e) {
        return "number" != typeof e || isNaN(e) ? e instanceof Array ? e.map(n.default.prototype.char) : "string" == typeof e ? n.default.prototype.char(parseInt(e, 10)) : void 0 : String.fromCharCode(e);
      }, n.default.prototype.unchar = function (e) {
        return "string" == typeof e && 1 === e.length ? e.charCodeAt(0) : e instanceof Array ? e.map(n.default.prototype.unchar) : void 0;
      }, n.default.prototype.hex = function (e, t) {
        if (t = null == t ? t = 8 : t, e instanceof Array) return e.map(function (e) {
          return n.default.prototype.hex(e, t);
        });
        if (e === 1 / 0 || e === -1 / 0) return (e === 1 / 0 ? "F" : "0").repeat(t);

        if ("number" == typeof e) {
          e < 0 && (e = 4294967295 + e + 1);

          for (var r = Number(e).toString(16).toUpperCase(); r.length < t;) r = "0".concat(r);

          return r.length >= t && (r = r.substring(r.length - t, r.length)), r;
        }
      }, n.default.prototype.unhex = function (e) {
        return e instanceof Array ? e.map(n.default.prototype.unhex) : parseInt("0x".concat(e), 16);
      };
      var a = n.default;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    77: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          o = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };

      function n(e, t, r) {
        var i = e < 0,
            n = i ? e.toString().substring(1) : e.toString(),
            a = n.indexOf("."),
            o = -1 !== a ? n.substring(0, a) : n,
            s = -1 !== a ? n.substring(a + 1) : "",
            l = i ? "-" : "";

        if (void 0 !== r) {
          var u = "";
          (-1 !== a || 0 < r - s.length) && (u = "."), s.length > r && (s = s.substring(0, r));

          for (var h = 0; h < t - o.length; h++) l += "0";

          l += o, l += u, l += s;

          for (var c = 0; c < r - s.length; c++) l += "0";

          return l;
        }

        for (var f = 0; f < Math.max(t - o.length, 0); f++) l += "0";

        return l += n;
      }

      function a(e, t) {
        var r = (e = e.toString()).indexOf("."),
            i = -1 !== r ? e.substring(r) : "",
            n = -1 !== r ? e.substring(0, r) : e;
        if (n = n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ","), 0 === t) i = "";else if (void 0 !== t) if (t > i.length) for (var a = t - (i += -1 === r ? "." : "").length + 1, o = 0; o < a; o++) i += "0";else i = i.substring(0, t + 1);
        return n + i;
      }

      function s(e) {
        return 0 < parseFloat(e) ? "+".concat(e.toString()) : e.toString();
      }

      function l(e) {
        return 0 <= parseFloat(e) ? " ".concat(e.toString()) : e.toString();
      }

      e("../core/friendly_errors/validate_params"), e("../core/friendly_errors/file_errors"), e("../core/friendly_errors/fes_core"), o.default.prototype.join = function (e, t) {
        return o.default._validateParameters("join", arguments), e.join(t);
      }, o.default.prototype.match = function (e, t) {
        return o.default._validateParameters("match", arguments), e.match(t);
      }, o.default.prototype.matchAll = function (e, t) {
        o.default._validateParameters("matchAll", arguments);

        for (var r = new RegExp(t, "g"), i = r.exec(e), n = []; null !== i;) n.push(i), i = r.exec(e);

        return n;
      }, o.default.prototype.nf = function (e, t, r) {
        return o.default._validateParameters("nf", arguments), e instanceof Array ? e.map(function (e) {
          return n(e, t, r);
        }) : "[object Arguments]" === Object.prototype.toString.call(e) ? 3 === e.length ? this.nf(e[0], e[1], e[2]) : 2 === e.length ? this.nf(e[0], e[1]) : this.nf(e[0]) : n(e, t, r);
      }, o.default.prototype.nfc = function (e, t) {
        return o.default._validateParameters("nfc", arguments), e instanceof Array ? e.map(function (e) {
          return a(e, t);
        }) : a(e, t);
      }, o.default.prototype.nfp = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        o.default._validateParameters("nfp", t);

        var i = o.default.prototype.nf.apply(this, t);
        return i instanceof Array ? i.map(s) : s(i);
      }, o.default.prototype.nfs = function () {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        o.default._validateParameters("nfs", t);

        var i = o.default.prototype.nf.apply(this, t);
        return i instanceof Array ? i.map(l) : l(i);
      }, o.default.prototype.split = function (e, t) {
        return o.default._validateParameters("split", arguments), e.split(t);
      }, o.default.prototype.splitTokens = function (e, t) {
        var r;

        if (o.default._validateParameters("splitTokens", arguments), void 0 !== t) {
          var i = t,
              n = /\]/g.exec(i),
              a = /\[/g.exec(i);
          r = a && n ? (i = i.slice(0, n.index) + i.slice(n.index + 1), a = /\[/g.exec(i), i = i.slice(0, a.index) + i.slice(a.index + 1), new RegExp("[\\[".concat(i, "\\]]"), "g")) : n ? (i = i.slice(0, n.index) + i.slice(n.index + 1), new RegExp("[".concat(i, "\\]]"), "g")) : a ? (i = i.slice(0, a.index) + i.slice(a.index + 1), new RegExp("[".concat(i, "\\[]"), "g")) : new RegExp("[".concat(i, "]"), "g");
        } else r = /\s/g;

        return e.split(r).filter(function (e) {
          return e;
        });
      }, o.default.prototype.trim = function (e) {
        return o.default._validateParameters("trim", arguments), e instanceof Array ? e.map(this.trim) : e.trim();
      };
      var u = o.default;
      r.default = u;
    }, {
      "../core/friendly_errors/fes_core": 28,
      "../core/friendly_errors/file_errors": 29,
      "../core/friendly_errors/validate_params": 31,
      "../core/main": 36
    }],
    78: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      n.default.prototype.day = function () {
        return new Date().getDate();
      }, n.default.prototype.hour = function () {
        return new Date().getHours();
      }, n.default.prototype.minute = function () {
        return new Date().getMinutes();
      }, n.default.prototype.millis = function () {
        return -1 === this._millisStart ? 0 : window.performance.now() - this._millisStart;
      }, n.default.prototype.month = function () {
        return new Date().getMonth() + 1;
      }, n.default.prototype.second = function () {
        return new Date().getSeconds();
      }, n.default.prototype.year = function () {
        return new Date().getFullYear();
      };
      var a = n.default;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    79: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          E = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      e("./p5.Geometry");

      var d = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../core/constants"));

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      E.default.prototype.plane = function (e, t, r, i) {
        this._assert3d("plane"), E.default._validateParameters("plane", arguments), void 0 === e && (e = 50), void 0 === t && (t = e), void 0 === r && (r = 1), void 0 === i && (i = 1);
        var n = "plane|".concat(r, "|").concat(i);

        if (!this._renderer.geometryInHash(n)) {
          var a = new E.default.Geometry(r, i, function () {
            for (var e, t, r, i = 0; i <= this.detailY; i++) {
              t = i / this.detailY;

              for (var n = 0; n <= this.detailX; n++) e = n / this.detailX, r = new E.default.Vector(e - .5, t - .5, 0), this.vertices.push(r), this.uvs.push(e, t);
            }
          });
          a.computeFaces().computeNormals(), r <= 1 && i <= 1 ? a._makeTriangleEdges()._edgesToVertices() : this._renderer._doStroke && console.log("Cannot draw stroke on plane objects with more than 1 detailX or 1 detailY"), this._renderer.createBuffers(n, a);
        }

        return this._renderer.drawBuffersScaled(n, e, t, 1), this;
      }, E.default.prototype.box = function (e, t, r, i, n) {
        this._assert3d("box"), E.default._validateParameters("box", arguments), void 0 === e && (e = 50), void 0 === t && (t = e), void 0 === r && (r = t);
        var a = this._renderer.attributes && this._renderer.attributes.perPixelLighting;
        void 0 === i && (i = a ? 1 : 4), void 0 === n && (n = a ? 1 : 4);
        var o = "box|".concat(i, "|").concat(n);

        if (!this._renderer.geometryInHash(o)) {
          var s = new E.default.Geometry(i, n, function () {
            var e = [[0, 4, 2, 6], [1, 3, 5, 7], [0, 1, 4, 5], [2, 6, 3, 7], [0, 2, 1, 3], [4, 5, 6, 7]];
            this.strokeIndices = [[0, 1], [1, 3], [3, 2], [6, 7], [8, 9], [9, 11], [14, 15], [16, 17], [17, 19], [18, 19], [20, 21], [22, 23]];

            for (var t = 0; t < e.length; t++) {
              for (var r = e[t], i = 4 * t, n = 0; n < 4; n++) {
                var a = r[n],
                    o = new E.default.Vector((2 * (1 & a) - 1) / 2, ((2 & a) - 1) / 2, ((4 & a) / 2 - 1) / 2);
                this.vertices.push(o), this.uvs.push(1 & n, (2 & n) / 2);
              }

              this.faces.push([i, 1 + i, 2 + i]), this.faces.push([2 + i, 1 + i, 3 + i]);
            }
          });
          s.computeNormals(), i <= 4 && n <= 4 ? s._makeTriangleEdges()._edgesToVertices() : this._renderer._doStroke && console.log("Cannot draw stroke on box objects with more than 4 detailX or 4 detailY"), this._renderer.createBuffers(o, s);
        }

        return this._renderer.drawBuffersScaled(o, e, t, r), this;
      }, E.default.prototype.sphere = function (e, t, r) {
        return this._assert3d("sphere"), E.default._validateParameters("sphere", arguments), void 0 === e && (e = 50), void 0 === t && (t = 24), void 0 === r && (r = 16), this.ellipsoid(e, e, e, t, r), this;
      };

      function l(e, t, r, i, n, a, o) {
        e = e <= 0 ? 1 : e, t = t < 0 ? 0 : t, r = r <= 0 ? e : r, i = i < 3 ? 3 : i;
        var s,
            l,
            u,
            h = (a = void 0 === a || a) ? -2 : 0,
            c = (n = n < 1 ? 1 : n) + ((o = void 0 === o ? 0 !== t : o) ? 2 : 0),
            f = Math.atan2(e - t, r),
            d = Math.sin(f),
            p = Math.cos(f);

        for (s = h; s <= c; ++s) {
          var m = s / n,
              v = r * m,
              y = void 0;

          for (y = s < 0 ? (m = v = 0, e) : n < s ? (v = r, m = 1, t) : e + (t - e) * m, -2 !== s && s !== n + 2 || (y = 0), v -= r / 2, l = 0; l < i; ++l) {
            var g = l / (i - 1),
                b = 2 * Math.PI * g,
                _ = Math.sin(b),
                x = Math.cos(b);

            this.vertices.push(new E.default.Vector(_ * y, v, x * y));
            var w = void 0;
            w = s < 0 ? new E.default.Vector(0, -1, 0) : n < s && t ? new E.default.Vector(0, 1, 0) : new E.default.Vector(_ * p, d, x * p), this.vertexNormals.push(w), this.uvs.push(g, m);
          }
        }

        var S = 0;

        if (a) {
          for (u = 0; u < i; ++u) {
            var M = (u + 1) % i;
            this.faces.push([S + u, S + i + M, S + i + u]);
          }

          S += 2 * i;
        }

        for (s = 0; s < n; ++s) {
          for (l = 0; l < i; ++l) {
            var T = (l + 1) % i;
            this.faces.push([S + l, S + T, S + i + T]), this.faces.push([S + l, S + i + T, S + i + l]);
          }

          S += i;
        }

        if (o) for (S += i, l = 0; l < i; ++l) this.faces.push([S + l, S + (l + 1) % i, S + i]);
      }

      E.default.prototype.cylinder = function (e, t, r, i, n, a) {
        this._assert3d("cylinder"), E.default._validateParameters("cylinder", arguments), void 0 === e && (e = 50), void 0 === t && (t = e), void 0 === r && (r = 24), void 0 === i && (i = 1), void 0 === a && (a = !0), void 0 === n && (n = !0);
        var o = "cylinder|".concat(r, "|").concat(i, "|").concat(n, "|").concat(a);

        if (!this._renderer.geometryInHash(o)) {
          var s = new E.default.Geometry(r, i);
          l.call(s, 1, 1, 1, r, i, n, a), r <= 24 && i <= 16 ? s._makeTriangleEdges()._edgesToVertices() : this._renderer._doStroke && console.log("Cannot draw stroke on cylinder objects with more than 24 detailX or 16 detailY"), this._renderer.createBuffers(o, s);
        }

        return this._renderer.drawBuffersScaled(o, e, t, e), this;
      }, E.default.prototype.cone = function (e, t, r, i, n) {
        this._assert3d("cone"), E.default._validateParameters("cone", arguments), void 0 === e && (e = 50), void 0 === t && (t = e), void 0 === r && (r = 24), void 0 === i && (i = 1), void 0 === n && (n = !0);
        var a = "cone|".concat(r, "|").concat(i, "|").concat(n);

        if (!this._renderer.geometryInHash(a)) {
          var o = new E.default.Geometry(r, i);
          l.call(o, 1, 0, 1, r, i, n, !1), r <= 24 && i <= 16 ? o._makeTriangleEdges()._edgesToVertices() : this._renderer._doStroke && console.log("Cannot draw stroke on cone objects with more than 24 detailX or 16 detailY"), this._renderer.createBuffers(a, o);
        }

        return this._renderer.drawBuffersScaled(a, e, t, e), this;
      }, E.default.prototype.ellipsoid = function (e, t, r, i, n) {
        this._assert3d("ellipsoid"), E.default._validateParameters("ellipsoid", arguments), void 0 === e && (e = 50), void 0 === t && (t = e), void 0 === r && (r = e), void 0 === i && (i = 24), void 0 === n && (n = 16);
        var a = "ellipsoid|".concat(i, "|").concat(n);

        if (!this._renderer.geometryInHash(a)) {
          var o = new E.default.Geometry(i, n, function () {
            for (var e = 0; e <= this.detailY; e++) for (var t = e / this.detailY, r = Math.PI * t - Math.PI / 2, i = Math.cos(r), n = Math.sin(r), a = 0; a <= this.detailX; a++) {
              var o = a / this.detailX,
                  s = 2 * Math.PI * o,
                  l = Math.cos(s),
                  u = Math.sin(s),
                  h = new E.default.Vector(i * u, n, i * l);
              this.vertices.push(h), this.vertexNormals.push(h), this.uvs.push(o, t);
            }
          });
          o.computeFaces(), i <= 24 && n <= 24 ? o._makeTriangleEdges()._edgesToVertices() : this._renderer._doStroke && console.log("Cannot draw stroke on ellipsoids with more than 24 detailX or 24 detailY"), this._renderer.createBuffers(a, o);
        }

        return this._renderer.drawBuffersScaled(a, e, t, r), this;
      }, E.default.prototype.torus = function (e, t, r, i) {
        if (this._assert3d("torus"), E.default._validateParameters("torus", arguments), void 0 === e) e = 50;else if (!e) return;
        if (void 0 === t) t = 10;else if (!t) return;
        void 0 === r && (r = 24), void 0 === i && (i = 16);
        var d = (t / e).toPrecision(4),
            n = "torus|".concat(d, "|").concat(r, "|").concat(i);

        if (!this._renderer.geometryInHash(n)) {
          var a = new E.default.Geometry(r, i, function () {
            for (var e = 0; e <= this.detailY; e++) for (var t = e / this.detailY, r = 2 * Math.PI * t, i = Math.cos(r), n = Math.sin(r), a = 1 + d * i, o = 0; o <= this.detailX; o++) {
              var s = o / this.detailX,
                  l = 2 * Math.PI * s,
                  u = Math.cos(l),
                  h = Math.sin(l),
                  c = new E.default.Vector(a * u, a * h, d * n),
                  f = new E.default.Vector(i * u, i * h, n);
              this.vertices.push(c), this.vertexNormals.push(f), this.uvs.push(s, t);
            }
          });
          a.computeFaces(), r <= 24 && i <= 16 ? a._makeTriangleEdges()._edgesToVertices() : this._renderer._doStroke && console.log("Cannot draw strokes on torus object with more than 24 detailX or 16 detailY"), this._renderer.createBuffers(n, a);
        }

        return this._renderer.drawBuffersScaled(n, e, e, e), this;
      }, E.default.RendererGL.prototype.point = function (e, t, r) {
        void 0 === r && (r = 0);
        var i = [];
        return i.push(new E.default.Vector(e, t, r)), this._drawPoints(i, this.immediateMode.buffers.point), this;
      }, E.default.RendererGL.prototype.triangle = function (e) {
        var t = e[0],
            r = e[1],
            i = e[2],
            n = e[3],
            a = e[4],
            o = e[5];

        if (!this.geometryInHash("tri")) {
          var s = new E.default.Geometry(1, 1, function () {
            var e = [];
            e.push(new E.default.Vector(0, 0, 0)), e.push(new E.default.Vector(0, 1, 0)), e.push(new E.default.Vector(1, 0, 0)), this.strokeIndices = [[0, 1], [1, 2], [2, 0]], this.vertices = e, this.faces = [[0, 1, 2]], this.uvs = [0, 0, 0, 1, 1, 1];
          });
          s._makeTriangleEdges()._edgesToVertices(), s.computeNormals(), this.createBuffers("tri", s);
        }

        var l = this.uMVMatrix.copy();

        try {
          var u = new E.default.Matrix([i - t, n - r, 0, 0, a - t, o - r, 0, 0, 0, 0, 1, 0, t, r, 0, 1]).mult(this.uMVMatrix);
          this.uMVMatrix = u, this.drawBuffers("tri");
        } finally {
          this.uMVMatrix = l;
        }

        return this;
      }, E.default.RendererGL.prototype.ellipse = function (e) {
        this.arc(e[0], e[1], e[2], e[3], 0, d.TWO_PI, d.OPEN, e[4]);
      }, E.default.RendererGL.prototype.arc = function (e) {
        var t,
            r = e,
            i = arguments[1],
            n = arguments[2],
            a = arguments[3],
            o = arguments[4],
            s = arguments[5],
            l = arguments[6],
            u = arguments[7] || 25;

        if (t = Math.abs(s - o) >= d.TWO_PI ? "".concat("ellipse", "|").concat(u, "|") : "".concat("arc", "|").concat(o, "|").concat(s, "|").concat(l, "|").concat(u, "|"), !this.geometryInHash(t)) {
          var h = new E.default.Geometry(u, 1, function () {
            if (this.strokeIndices = [], o.toFixed(10) !== s.toFixed(10)) {
              l !== d.PIE && void 0 !== l || (this.vertices.push(new E.default.Vector(.5, .5, 0)), this.uvs.push([.5, .5]));

              for (var e = 0; e <= u; e++) {
                var t = (s - o) * (e / u) + o,
                    r = .5 + Math.cos(t) / 2,
                    i = .5 + Math.sin(t) / 2;
                this.vertices.push(new E.default.Vector(r, i, 0)), this.uvs.push([r, i]), e < u - 1 && (this.faces.push([0, e + 1, e + 2]), this.strokeIndices.push([e + 1, e + 2]));
              }

              switch (l) {
                case d.PIE:
                  this.faces.push([0, this.vertices.length - 2, this.vertices.length - 1]), this.strokeIndices.push([0, 1]), this.strokeIndices.push([this.vertices.length - 2, this.vertices.length - 1]), this.strokeIndices.push([0, this.vertices.length - 1]);
                  break;

                case d.CHORD:
                  this.strokeIndices.push([0, 1]), this.strokeIndices.push([0, this.vertices.length - 1]);
                  break;

                case d.OPEN:
                  this.strokeIndices.push([0, 1]);
                  break;

                default:
                  this.faces.push([0, this.vertices.length - 2, this.vertices.length - 1]), this.strokeIndices.push([this.vertices.length - 2, this.vertices.length - 1]);
              }
            }
          });
          h.computeNormals(), u <= 50 ? h._makeTriangleEdges()._edgesToVertices(h) : this._renderer._doStroke && console.log("Cannot stroke ${shape} with more than 50 detail"), this.createBuffers(t, h);
        }

        var c = this.uMVMatrix.copy();

        try {
          this.uMVMatrix.translate([r, i, 0]), this.uMVMatrix.scale(n, a, 1), this.drawBuffers(t);
        } finally {
          this.uMVMatrix = c;
        }

        return this;
      }, E.default.RendererGL.prototype.rect = function (e) {
        var t = this._pInst._glAttributes.perPixelLighting,
            r = e[0],
            i = e[1],
            n = e[2],
            a = e[3],
            o = e[4] || (t ? 1 : 24),
            s = e[5] || (t ? 1 : 16),
            l = "rect|".concat(o, "|").concat(s);

        if (!this.geometryInHash(l)) {
          var u = new E.default.Geometry(o, s, function () {
            for (var e = 0; e <= this.detailY; e++) for (var t = e / this.detailY, r = 0; r <= this.detailX; r++) {
              var i = r / this.detailX,
                  n = new E.default.Vector(i, t, 0);
              this.vertices.push(n), this.uvs.push(i, t);
            }

            0 < o && 0 < s && (this.strokeIndices = [[0, o], [o, (o + 1) * (s + 1) - 1], [(o + 1) * (s + 1) - 1, (o + 1) * s], [(o + 1) * s, 0]]);
          });
          u.computeFaces().computeNormals()._makeTriangleEdges()._edgesToVertices(), this.createBuffers(l, u);
        }

        var h = this.uMVMatrix.copy();

        try {
          this.uMVMatrix.translate([r, i, 0]), this.uMVMatrix.scale(n, a, 1), this.drawBuffers(l);
        } finally {
          this.uMVMatrix = h;
        }

        return this;
      }, E.default.RendererGL.prototype.quad = function (e, t, r, i, n, a, o, s, l, u, h, c) {
        var f = "quad|".concat(e, "|").concat(t, "|").concat(r, "|").concat(i, "|").concat(n, "|").concat(a, "|").concat(o, "|").concat(s, "|").concat(l, "|").concat(u, "|").concat(h, "|").concat(c);

        if (!this.geometryInHash(f)) {
          var d = new E.default.Geometry(2, 2, function () {
            this.vertices.push(new E.default.Vector(e, t, r)), this.vertices.push(new E.default.Vector(i, n, a)), this.vertices.push(new E.default.Vector(o, s, l)), this.vertices.push(new E.default.Vector(u, h, c)), this.uvs.push(0, 0, 1, 0, 1, 1, 0, 1), this.strokeIndices = [[0, 1], [1, 2], [2, 3], [3, 0]];
          });
          d.computeNormals()._makeTriangleEdges()._edgesToVertices(), d.faces = [[0, 1, 2], [2, 3, 0]], this.createBuffers(f, d);
        }

        return this.drawBuffers(f), this;
      }, E.default.RendererGL.prototype.bezier = function (e, t, r, i, n, a, o, s, l, u, h, c) {
        8 === arguments.length && (h = s, u = o, s = a, o = n, n = i, i = r, r = a = l = c = 0);
        var f = this._pInst._bezierDetail || 20;
        this.beginShape();

        for (var d = 0; d <= f; d++) {
          var p = Math.pow(1 - d / f, 3),
              m = d / f * 3 * Math.pow(1 - d / f, 2),
              v = 3 * Math.pow(d / f, 2) * (1 - d / f),
              y = Math.pow(d / f, 3);
          this.vertex(e * p + i * m + o * v + u * y, t * p + n * m + s * v + h * y, r * p + a * m + l * v + c * y);
        }

        return this.endShape(), this;
      }, E.default.RendererGL.prototype.curve = function (e, t, r, i, n, a, o, s, l, u, h, c) {
        8 === arguments.length && (u = o, h = s, o = n, s = i, n = i = r, r = a = l = c = 0);
        var f = this._pInst._curveDetail;
        this.beginShape();

        for (var d = 0; d <= f; d++) {
          var p = .5 * Math.pow(d / f, 3),
              m = .5 * Math.pow(d / f, 2),
              v = d / f * .5,
              y = p * (3 * i - e - 3 * o + u) + m * (2 * e - 5 * i + 4 * o - u) + v * (-e + o) + 2 * i * .5,
              g = p * (3 * n - t - 3 * s + h) + m * (2 * t - 5 * n + 4 * s - h) + v * (-t + s) + 2 * n * .5,
              b = p * (3 * a - r - 3 * l + c) + m * (2 * r - 5 * a + 4 * l - c) + v * (-r + l) + 2 * a * .5;
          this.vertex(y, g, b);
        }

        return this.endShape(), this;
      }, E.default.RendererGL.prototype.line = function () {
        return 6 === arguments.length ? (this.beginShape(d.LINES), this.vertex(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 2 ? void 0 : arguments[2]), this.vertex(arguments.length <= 3 ? void 0 : arguments[3], arguments.length <= 4 ? void 0 : arguments[4], arguments.length <= 5 ? void 0 : arguments[5]), this.endShape()) : 4 === arguments.length && (this.beginShape(d.LINES), this.vertex(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], 0), this.vertex(arguments.length <= 2 ? void 0 : arguments[2], arguments.length <= 3 ? void 0 : arguments[3], 0), this.endShape()), this;
      }, E.default.RendererGL.prototype.bezierVertex = function () {
        if (0 === this.immediateMode._bezierVertex.length) throw Error("vertex() must be used once before calling bezierVertex()");
        var e,
            t,
            r,
            i,
            n,
            a = [],
            o = [],
            s = [],
            l = arguments.length;

        if ((e = 0) === this._lookUpTableBezier.length || this._lutBezierDetail !== this._pInst._curveDetail) {
          this._lookUpTableBezier = [], this._lutBezierDetail = this._pInst._curveDetail;

          for (var u = 1 / this._lutBezierDetail, h = 0, c = 1, f = 0; h < 1;) {
            if (e = parseFloat(h.toFixed(6)), this._lookUpTableBezier[f] = this._bezierCoefficients(e), c.toFixed(6) === u.toFixed(6)) {
              e = parseFloat(c.toFixed(6)) + parseFloat(h.toFixed(6)), ++f, this._lookUpTableBezier[f] = this._bezierCoefficients(e);
              break;
            }

            h += u, c -= u, ++f;
          }
        }

        var d = this._lookUpTableBezier.length;

        if (6 === l) {
          for (this.isBezier = !0, a = [this.immediateMode._bezierVertex[0], arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 2 ? void 0 : arguments[2], arguments.length <= 4 ? void 0 : arguments[4]], o = [this.immediateMode._bezierVertex[1], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 3 ? void 0 : arguments[3], arguments.length <= 5 ? void 0 : arguments[5]], n = 0; n < d; n++) t = a[0] * this._lookUpTableBezier[n][0] + a[1] * this._lookUpTableBezier[n][1] + a[2] * this._lookUpTableBezier[n][2] + a[3] * this._lookUpTableBezier[n][3], r = o[0] * this._lookUpTableBezier[n][0] + o[1] * this._lookUpTableBezier[n][1] + o[2] * this._lookUpTableBezier[n][2] + o[3] * this._lookUpTableBezier[n][3], this.vertex(t, r);

          this.immediateMode._bezierVertex[0] = arguments.length <= 4 ? void 0 : arguments[4], this.immediateMode._bezierVertex[1] = arguments.length <= 5 ? void 0 : arguments[5];
        } else if (9 === l) {
          for (this.isBezier = !0, a = [this.immediateMode._bezierVertex[0], arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 3 ? void 0 : arguments[3], arguments.length <= 6 ? void 0 : arguments[6]], o = [this.immediateMode._bezierVertex[1], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 4 ? void 0 : arguments[4], arguments.length <= 7 ? void 0 : arguments[7]], s = [this.immediateMode._bezierVertex[2], arguments.length <= 2 ? void 0 : arguments[2], arguments.length <= 5 ? void 0 : arguments[5], arguments.length <= 8 ? void 0 : arguments[8]], n = 0; n < d; n++) t = a[0] * this._lookUpTableBezier[n][0] + a[1] * this._lookUpTableBezier[n][1] + a[2] * this._lookUpTableBezier[n][2] + a[3] * this._lookUpTableBezier[n][3], r = o[0] * this._lookUpTableBezier[n][0] + o[1] * this._lookUpTableBezier[n][1] + o[2] * this._lookUpTableBezier[n][2] + o[3] * this._lookUpTableBezier[n][3], i = s[0] * this._lookUpTableBezier[n][0] + s[1] * this._lookUpTableBezier[n][1] + s[2] * this._lookUpTableBezier[n][2] + s[3] * this._lookUpTableBezier[n][3], this.vertex(t, r, i);

          this.immediateMode._bezierVertex[0] = arguments.length <= 6 ? void 0 : arguments[6], this.immediateMode._bezierVertex[1] = arguments.length <= 7 ? void 0 : arguments[7], this.immediateMode._bezierVertex[2] = arguments.length <= 8 ? void 0 : arguments[8];
        }
      }, E.default.RendererGL.prototype.quadraticVertex = function () {
        if (0 === this.immediateMode._quadraticVertex.length) throw Error("vertex() must be used once before calling quadraticVertex()");
        var e,
            t,
            r,
            i,
            n,
            a = [],
            o = [],
            s = [],
            l = arguments.length;

        if ((e = 0) === this._lookUpTableQuadratic.length || this._lutQuadraticDetail !== this._pInst._curveDetail) {
          this._lookUpTableQuadratic = [], this._lutQuadraticDetail = this._pInst._curveDetail;

          for (var u = 1 / this._lutQuadraticDetail, h = 0, c = 1, f = 0; h < 1;) {
            if (e = parseFloat(h.toFixed(6)), this._lookUpTableQuadratic[f] = this._quadraticCoefficients(e), c.toFixed(6) === u.toFixed(6)) {
              e = parseFloat(c.toFixed(6)) + parseFloat(h.toFixed(6)), ++f, this._lookUpTableQuadratic[f] = this._quadraticCoefficients(e);
              break;
            }

            h += u, c -= u, ++f;
          }
        }

        var d = this._lookUpTableQuadratic.length;

        if (4 === l) {
          for (this.isQuadratic = !0, a = [this.immediateMode._quadraticVertex[0], arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 2 ? void 0 : arguments[2]], o = [this.immediateMode._quadraticVertex[1], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 3 ? void 0 : arguments[3]], n = 0; n < d; n++) t = a[0] * this._lookUpTableQuadratic[n][0] + a[1] * this._lookUpTableQuadratic[n][1] + a[2] * this._lookUpTableQuadratic[n][2], r = o[0] * this._lookUpTableQuadratic[n][0] + o[1] * this._lookUpTableQuadratic[n][1] + o[2] * this._lookUpTableQuadratic[n][2], this.vertex(t, r);

          this.immediateMode._quadraticVertex[0] = arguments.length <= 2 ? void 0 : arguments[2], this.immediateMode._quadraticVertex[1] = arguments.length <= 3 ? void 0 : arguments[3];
        } else if (6 === l) {
          for (this.isQuadratic = !0, a = [this.immediateMode._quadraticVertex[0], arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 3 ? void 0 : arguments[3]], o = [this.immediateMode._quadraticVertex[1], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 4 ? void 0 : arguments[4]], s = [this.immediateMode._quadraticVertex[2], arguments.length <= 2 ? void 0 : arguments[2], arguments.length <= 5 ? void 0 : arguments[5]], n = 0; n < d; n++) t = a[0] * this._lookUpTableQuadratic[n][0] + a[1] * this._lookUpTableQuadratic[n][1] + a[2] * this._lookUpTableQuadratic[n][2], r = o[0] * this._lookUpTableQuadratic[n][0] + o[1] * this._lookUpTableQuadratic[n][1] + o[2] * this._lookUpTableQuadratic[n][2], i = s[0] * this._lookUpTableQuadratic[n][0] + s[1] * this._lookUpTableQuadratic[n][1] + s[2] * this._lookUpTableQuadratic[n][2], this.vertex(t, r, i);

          this.immediateMode._quadraticVertex[0] = arguments.length <= 3 ? void 0 : arguments[3], this.immediateMode._quadraticVertex[1] = arguments.length <= 4 ? void 0 : arguments[4], this.immediateMode._quadraticVertex[2] = arguments.length <= 5 ? void 0 : arguments[5];
        }
      }, E.default.RendererGL.prototype.curveVertex = function () {
        var e,
            t,
            r,
            i,
            n,
            a = [],
            o = [],
            s = [],
            l = arguments.length;

        if ((e = 0) === this._lookUpTableBezier.length || this._lutBezierDetail !== this._pInst._curveDetail) {
          this._lookUpTableBezier = [], this._lutBezierDetail = this._pInst._curveDetail;

          for (var u = 1 / this._lutBezierDetail, h = 0, c = 1, f = 0; h < 1;) {
            if (e = parseFloat(h.toFixed(6)), this._lookUpTableBezier[f] = this._bezierCoefficients(e), c.toFixed(6) === u.toFixed(6)) {
              e = parseFloat(c.toFixed(6)) + parseFloat(h.toFixed(6)), ++f, this._lookUpTableBezier[f] = this._bezierCoefficients(e);
              break;
            }

            h += u, c -= u, ++f;
          }
        }

        var d = this._lookUpTableBezier.length;

        if (2 === l) {
          if (this.immediateMode._curveVertex.push(arguments.length <= 0 ? void 0 : arguments[0]), this.immediateMode._curveVertex.push(arguments.length <= 1 ? void 0 : arguments[1]), 8 === this.immediateMode._curveVertex.length) {
            for (this.isCurve = !0, a = this._bezierToCatmull([this.immediateMode._curveVertex[0], this.immediateMode._curveVertex[2], this.immediateMode._curveVertex[4], this.immediateMode._curveVertex[6]]), o = this._bezierToCatmull([this.immediateMode._curveVertex[1], this.immediateMode._curveVertex[3], this.immediateMode._curveVertex[5], this.immediateMode._curveVertex[7]]), n = 0; n < d; n++) t = a[0] * this._lookUpTableBezier[n][0] + a[1] * this._lookUpTableBezier[n][1] + a[2] * this._lookUpTableBezier[n][2] + a[3] * this._lookUpTableBezier[n][3], r = o[0] * this._lookUpTableBezier[n][0] + o[1] * this._lookUpTableBezier[n][1] + o[2] * this._lookUpTableBezier[n][2] + o[3] * this._lookUpTableBezier[n][3], this.vertex(t, r);

            for (n = 0; n < l; n++) this.immediateMode._curveVertex.shift();
          }
        } else if (3 === l && (this.immediateMode._curveVertex.push(arguments.length <= 0 ? void 0 : arguments[0]), this.immediateMode._curveVertex.push(arguments.length <= 1 ? void 0 : arguments[1]), this.immediateMode._curveVertex.push(arguments.length <= 2 ? void 0 : arguments[2]), 12 === this.immediateMode._curveVertex.length)) {
          for (this.isCurve = !0, a = this._bezierToCatmull([this.immediateMode._curveVertex[0], this.immediateMode._curveVertex[3], this.immediateMode._curveVertex[6], this.immediateMode._curveVertex[9]]), o = this._bezierToCatmull([this.immediateMode._curveVertex[1], this.immediateMode._curveVertex[4], this.immediateMode._curveVertex[7], this.immediateMode._curveVertex[10]]), s = this._bezierToCatmull([this.immediateMode._curveVertex[2], this.immediateMode._curveVertex[5], this.immediateMode._curveVertex[8], this.immediateMode._curveVertex[11]]), n = 0; n < d; n++) t = a[0] * this._lookUpTableBezier[n][0] + a[1] * this._lookUpTableBezier[n][1] + a[2] * this._lookUpTableBezier[n][2] + a[3] * this._lookUpTableBezier[n][3], r = o[0] * this._lookUpTableBezier[n][0] + o[1] * this._lookUpTableBezier[n][1] + o[2] * this._lookUpTableBezier[n][2] + o[3] * this._lookUpTableBezier[n][3], i = s[0] * this._lookUpTableBezier[n][0] + s[1] * this._lookUpTableBezier[n][1] + s[2] * this._lookUpTableBezier[n][2] + s[3] * this._lookUpTableBezier[n][3], this.vertex(t, r, i);

          for (n = 0; n < l; n++) this.immediateMode._curveVertex.shift();
        }
      }, E.default.RendererGL.prototype.image = function (e, t, r, i, n, a, o, s, l) {
        this._isErasing && this.blendMode(this._cachedBlendMode), this._pInst.push(), this._pInst.noLights(), this._pInst.texture(e), this._pInst.textureMode(d.NORMAL);
        var u = 0;
        t <= e.width && (u = t / e.width);
        var h = 1;
        t + i <= e.width && (h = (t + i) / e.width);
        var c = 0;
        r <= e.height && (c = r / e.height);
        var f = 1;
        r + n <= e.height && (f = (r + n) / e.height), this.beginShape(), this.vertex(a, o, 0, u, c), this.vertex(a + s, o, 0, h, c), this.vertex(a + s, o + l, 0, h, f), this.vertex(a, o + l, 0, u, f), this.endShape(d.CLOSE), this._pInst.pop(), this._isErasing && this.blendMode(d.REMOVE);
      };
      var n = E.default;
      r.default = n;
    }, {
      "../core/constants": 26,
      "../core/main": 36,
      "./p5.Geometry": 85
    }],
    80: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var i,
          f = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      },
          n = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../core/constants"));

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      f.default.prototype.orbitControl = function (e, t, r) {
        if (this._assert3d("orbitControl"), f.default._validateParameters("orbitControl", arguments), this.mouseX < this.width && 0 < this.mouseX && this.mouseY < this.height && 0 < this.mouseY) {
          var i = this._renderer._curCamera;
          void 0 === e && (e = 1), void 0 === t && (t = e), void 0 === r && (r = .5), !0 !== this.contextMenuDisabled && (this.canvas.oncontextmenu = function () {
            return !1;
          }, this._setProperty("contextMenuDisabled", !0)), !0 !== this.wheelDefaultDisabled && (this.canvas.onwheel = function () {
            return !1;
          }, this._setProperty("wheelDefaultDisabled", !0));
          var n = this.height < this.width ? this.height : this.width;
          if (this._mouseWheelDeltaY !== this._pmouseWheelDeltaY && (0 < this._mouseWheelDeltaY ? this._renderer._curCamera._orbit(0, 0, r * n) : this._renderer._curCamera._orbit(0, 0, -r * n)), this.mouseIsPressed) if (this.mouseButton === this.LEFT) {
            var a = -e * (this.mouseX - this.pmouseX) / n,
                o = t * (this.mouseY - this.pmouseY) / n;

            this._renderer._curCamera._orbit(a, o, 0);
          } else if (this.mouseButton === this.RIGHT) {
            var s = i._getLocalAxes(),
                l = Math.sqrt(s.x[0] * s.x[0] + s.x[2] * s.x[2]);

            0 !== l && (s.x[0] /= l, s.x[2] /= l);
            var u = Math.sqrt(s.y[0] * s.y[0] + s.y[2] * s.y[2]);
            0 !== u && (s.y[0] /= u, s.y[2] /= u);
            var h = -1 * e * (this.mouseX - this.pmouseX),
                c = -1 * t * (this.mouseY - this.pmouseY);
            i.setPosition(i.eyeX + h * s.x[0] + c * s.z[0], i.eyeY, i.eyeZ + h * s.x[2] + c * s.z[2]);
          }
          return this;
        }
      }, f.default.prototype.debugMode = function () {
        this._assert3d("debugMode");

        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        f.default._validateParameters("debugMode", t);

        for (var i = this._registeredMethods.post.length - 1; 0 <= i; i--) this._registeredMethods.post[i].toString() !== this._grid().toString() && this._registeredMethods.post[i].toString() !== this._axesIcon().toString() || this._registeredMethods.post.splice(i, 1);

        t[0] === n.GRID ? this.registerMethod("post", this._grid.call(this, t[1], t[2], t[3], t[4], t[5])) : t[0] === n.AXES ? this.registerMethod("post", this._axesIcon.call(this, t[1], t[2], t[3], t[4])) : (this.registerMethod("post", this._grid.call(this, t[0], t[1], t[2], t[3], t[4])), this.registerMethod("post", this._axesIcon.call(this, t[5], t[6], t[7], t[8])));
      }, f.default.prototype.noDebugMode = function () {
        this._assert3d("noDebugMode");

        for (var e = this._registeredMethods.post.length - 1; 0 <= e; e--) this._registeredMethods.post[e].toString() !== this._grid().toString() && this._registeredMethods.post[e].toString() !== this._axesIcon().toString() || this._registeredMethods.post.splice(e, 1);
      }, f.default.prototype._grid = function (e, r, i, n, a) {
        void 0 === e && (e = this.width / 2), void 0 === r && (r = Math.round(e / 30) < 4 ? 4 : Math.round(e / 30)), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === a && (a = 0);
        var o = e / r,
            s = e / 2;
        return function () {
          this.push(), this.stroke(255 * this._renderer.curStrokeColor[0], 255 * this._renderer.curStrokeColor[1], 255 * this._renderer.curStrokeColor[2]), this._renderer.uMVMatrix.set(this._renderer._curCamera.cameraMatrix.mat4[0], this._renderer._curCamera.cameraMatrix.mat4[1], this._renderer._curCamera.cameraMatrix.mat4[2], this._renderer._curCamera.cameraMatrix.mat4[3], this._renderer._curCamera.cameraMatrix.mat4[4], this._renderer._curCamera.cameraMatrix.mat4[5], this._renderer._curCamera.cameraMatrix.mat4[6], this._renderer._curCamera.cameraMatrix.mat4[7], this._renderer._curCamera.cameraMatrix.mat4[8], this._renderer._curCamera.cameraMatrix.mat4[9], this._renderer._curCamera.cameraMatrix.mat4[10], this._renderer._curCamera.cameraMatrix.mat4[11], this._renderer._curCamera.cameraMatrix.mat4[12], this._renderer._curCamera.cameraMatrix.mat4[13], this._renderer._curCamera.cameraMatrix.mat4[14], this._renderer._curCamera.cameraMatrix.mat4[15]);

          for (var e = 0; e <= r; e++) this.beginShape(this.LINES), this.vertex(-s + i, n, e * o - s + a), this.vertex(+s + i, n, e * o - s + a), this.endShape();

          for (var t = 0; t <= r; t++) this.beginShape(this.LINES), this.vertex(t * o - s + i, n, -s + a), this.vertex(t * o - s + i, n, +s + a), this.endShape();

          this.pop();
        };
      }, f.default.prototype._axesIcon = function (e, t, r, i) {
        return void 0 === e && (e = 40 < this.width / 20 ? this.width / 20 : 40), void 0 === t && (t = -this.width / 4), void 0 === r && (r = t), void 0 === i && (i = t), function () {
          this.push(), this._renderer.uMVMatrix.set(this._renderer._curCamera.cameraMatrix.mat4[0], this._renderer._curCamera.cameraMatrix.mat4[1], this._renderer._curCamera.cameraMatrix.mat4[2], this._renderer._curCamera.cameraMatrix.mat4[3], this._renderer._curCamera.cameraMatrix.mat4[4], this._renderer._curCamera.cameraMatrix.mat4[5], this._renderer._curCamera.cameraMatrix.mat4[6], this._renderer._curCamera.cameraMatrix.mat4[7], this._renderer._curCamera.cameraMatrix.mat4[8], this._renderer._curCamera.cameraMatrix.mat4[9], this._renderer._curCamera.cameraMatrix.mat4[10], this._renderer._curCamera.cameraMatrix.mat4[11], this._renderer._curCamera.cameraMatrix.mat4[12], this._renderer._curCamera.cameraMatrix.mat4[13], this._renderer._curCamera.cameraMatrix.mat4[14], this._renderer._curCamera.cameraMatrix.mat4[15]), this.strokeWeight(2), this.stroke(255, 0, 0), this.beginShape(this.LINES), this.vertex(t, r, i), this.vertex(t + e, r, i), this.endShape(), this.stroke(0, 255, 0), this.beginShape(this.LINES), this.vertex(t, r, i), this.vertex(t, r + e, i), this.endShape(), this.stroke(0, 0, 255), this.beginShape(this.LINES), this.vertex(t, r, i), this.vertex(t, r, i + e), this.endShape(), this.pop();
        };
      };
      var a = f.default;
      r.default = a;
    }, {
      "../core/constants": 26,
      "../core/main": 36
    }],
    81: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          m = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      m.default.prototype.ambientLight = function (e, t, r, i) {
        this._assert3d("ambientLight"), m.default._validateParameters("ambientLight", arguments);
        var n = this.color.apply(this, arguments);
        return this._renderer.ambientLightColors.push(n._array[0], n._array[1], n._array[2]), this._renderer._enableLighting = !0, this;
      }, m.default.prototype.specularColor = function (e, t, r) {
        this._assert3d("specularColor"), m.default._validateParameters("specularColor", arguments);
        var i = this.color.apply(this, arguments);
        return this._renderer.specularColors = [i._array[0], i._array[1], i._array[2]], this;
      }, m.default.prototype.directionalLight = function (e, t, r, i, n, a) {
        var o, s, l, u;
        this._assert3d("directionalLight"), m.default._validateParameters("directionalLight", arguments), o = e instanceof m.default.Color ? e : this.color(e, t, r);
        var h = arguments[arguments.length - 1];
        u = "number" == typeof h ? (s = arguments[arguments.length - 3], l = arguments[arguments.length - 2], arguments[arguments.length - 1]) : (s = h.x, l = h.y, h.z);
        var c = Math.sqrt(s * s + l * l + u * u);
        return this._renderer.directionalLightDirections.push(s / c, l / c, u / c), this._renderer.directionalLightDiffuseColors.push(o._array[0], o._array[1], o._array[2]), Array.prototype.push.apply(this._renderer.directionalLightSpecularColors, this._renderer.specularColors), this._renderer._enableLighting = !0, this;
      }, m.default.prototype.pointLight = function (e, t, r, i, n, a) {
        var o, s, l, u;
        this._assert3d("pointLight"), m.default._validateParameters("pointLight", arguments), o = e instanceof m.default.Color ? e : this.color(e, t, r);
        var h = arguments[arguments.length - 1];
        return u = "number" == typeof h ? (s = arguments[arguments.length - 3], l = arguments[arguments.length - 2], arguments[arguments.length - 1]) : (s = h.x, l = h.y, h.z), this._renderer.pointLightPositions.push(s, l, u), this._renderer.pointLightDiffuseColors.push(o._array[0], o._array[1], o._array[2]), Array.prototype.push.apply(this._renderer.pointLightSpecularColors, this._renderer.specularColors), this._renderer._enableLighting = !0, this;
      }, m.default.prototype.lights = function () {
        return this._assert3d("lights"), this.ambientLight(128, 128, 128), this.directionalLight(128, 128, 128, 0, 0, -1), this;
      }, m.default.prototype.lightFalloff = function (e, t, r) {
        return this._assert3d("lightFalloff"), m.default._validateParameters("lightFalloff", arguments), e < 0 && (e = 0, console.warn("Value of constant argument in lightFalloff() should be never be negative. Set to 0.")), t < 0 && (t = 0, console.warn("Value of linear argument in lightFalloff() should be never be negative. Set to 0.")), r < 0 && (r = 0, console.warn("Value of quadratic argument in lightFalloff() should be never be negative. Set to 0.")), 0 === e && 0 === t && 0 === r && (e = 1, console.warn("Either one of the three arguments in lightFalloff() should be greater than zero. Set constant argument to 1.")), this._renderer.constantAttenuation = e, this._renderer.linearAttenuation = t, this._renderer.quadraticAttenuation = r, this;
      }, m.default.prototype.spotLight = function (e, t, r, i, n, a, o, s, l, u, h) {
        var c, f, d;
        this._assert3d("spotLight"), m.default._validateParameters("spotLight", arguments);
        var p = arguments.length;

        switch (p) {
          case 11:
          case 10:
            c = this.color(e, t, r), f = new m.default.Vector(i, n, a), d = new m.default.Vector(o, s, l);
            break;

          case 9:
            e instanceof m.default.Color ? (c = e, f = new m.default.Vector(t, r, i), d = new m.default.Vector(n, a, o), u = s, h = l) : i instanceof m.default.Vector ? (c = this.color(e, t, r), f = i, d = new m.default.Vector(n, a, o), u = s, h = l) : o instanceof m.default.Vector ? (c = this.color(e, t, r), f = new m.default.Vector(i, n, a), d = o, u = s, h = l) : (c = this.color(e, t, r), f = new m.default.Vector(i, n, a), d = new m.default.Vector(o, s, l));
            break;

          case 8:
            u = (d = e instanceof m.default.Color ? (c = e, f = new m.default.Vector(t, r, i), new m.default.Vector(n, a, o)) : i instanceof m.default.Vector ? (c = this.color(e, t, r), f = i, new m.default.Vector(n, a, o)) : (c = this.color(e, t, r), f = new m.default.Vector(i, n, a), o), s);
            break;

          case 7:
            e instanceof m.default.Color && t instanceof m.default.Vector ? (c = e, f = t, d = new m.default.Vector(r, i, n), u = a, h = o) : e instanceof m.default.Color && n instanceof m.default.Vector ? (c = e, f = new m.default.Vector(t, r, i), d = n, u = a, h = o) : i instanceof m.default.Vector && n instanceof m.default.Vector ? (c = this.color(e, t, r), f = i, d = n, u = a, h = o) : d = e instanceof m.default.Color ? (c = e, f = new m.default.Vector(t, r, i), new m.default.Vector(n, a, o)) : i instanceof m.default.Vector ? (c = this.color(e, t, r), f = i, new m.default.Vector(n, a, o)) : (c = this.color(e, t, r), f = new m.default.Vector(i, n, a), o);
            break;

          case 6:
            i instanceof m.default.Vector && n instanceof m.default.Vector ? (c = this.color(e, t, r), f = i, d = n, u = a) : e instanceof m.default.Color && n instanceof m.default.Vector ? (c = e, f = new m.default.Vector(t, r, i), d = n, u = a) : e instanceof m.default.Color && t instanceof m.default.Vector && (c = e, f = t, d = new m.default.Vector(r, i, n), u = a);
            break;

          case 5:
            e instanceof m.default.Color && t instanceof m.default.Vector && r instanceof m.default.Vector ? (c = e, f = t, d = r, u = i, h = n) : i instanceof m.default.Vector && n instanceof m.default.Vector ? (c = this.color(e, t, r), f = i, d = n) : e instanceof m.default.Color && n instanceof m.default.Vector ? (c = e, f = new m.default.Vector(t, r, i), d = n) : e instanceof m.default.Color && t instanceof m.default.Vector && (c = e, f = t, d = new m.default.Vector(r, i, n));
            break;

          case 4:
            c = e, f = t, d = r, u = i;
            break;

          case 3:
            c = e, f = t, d = r;
            break;

          default:
            return console.warn("Sorry, input for spotlight() is not in prescribed format. Too ".concat(p < 3 ? "few" : "many", " arguments were provided")), this;
        }

        return this._renderer.spotLightDiffuseColors.push(c._array[0], c._array[1], c._array[2]), Array.prototype.push.apply(this._renderer.spotLightSpecularColors, this._renderer.specularColors), this._renderer.spotLightPositions.push(f.x, f.y, f.z), d.normalize(), this._renderer.spotLightDirections.push(d.x, d.y, d.z), void 0 === u && (u = Math.PI / 3), void 0 !== h && h < 1 ? (h = 1, console.warn("Value of concentration needs to be greater than 1. Setting it to 1")) : void 0 === h && (h = 100), u = this._renderer._pInst._toRadians(u), this._renderer.spotLightAngle.push(Math.cos(u)), this._renderer.spotLightConc.push(h), this._renderer._enableLighting = !0, this;
      }, m.default.prototype.noLights = function () {
        return this._assert3d("noLights"), m.default._validateParameters("noLights", arguments), this._renderer._enableLighting = !1, this._renderer.ambientLightColors.length = 0, this._renderer.specularColors = [1, 1, 1], this._renderer.directionalLightDirections.length = 0, this._renderer.directionalLightDiffuseColors.length = 0, this._renderer.directionalLightSpecularColors.length = 0, this._renderer.pointLightPositions.length = 0, this._renderer.pointLightDiffuseColors.length = 0, this._renderer.pointLightSpecularColors.length = 0, this._renderer.spotLightPositions.length = 0, this._renderer.spotLightDirections.length = 0, this._renderer.spotLightDiffuseColors.length = 0, this._renderer.spotLightSpecularColors.length = 0, this._renderer.spotLightAngle.length = 0, this._renderer.spotLightConc.length = 0, this._renderer.constantAttenuation = 1, this._renderer.linearAttenuation = 0, this._renderer.quadraticAttenuation = 0, this._renderer._useShininess = 1, this;
      };
      var n = m.default;
      r.default = n;
    }, {
      "../core/main": 36
    }],
    82: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          S = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };

      function s(e, t, r) {
        for (var i = 0, n = e.length; i < n; i++) if (e[i] !== t.getUint8(r + i, !1)) return !1;

        return !0;
      }

      e("./p5.Geometry"), S.default.prototype.loadModel = function (e) {
        var t, r, i;

        S.default._validateParameters("loadModel", arguments);

        var n = e.slice(-4);
        "boolean" == typeof arguments[1] ? (t = arguments[1], r = arguments[2], i = arguments[3], void 0 !== arguments[4] && (n = arguments[4])) : (t = !1, r = arguments[1], i = arguments[2], void 0 !== arguments[3] && (n = arguments[3]));
        var a = new S.default.Geometry();
        a.gid = "".concat(e, "|").concat(t);
        var o = this;
        return n.match(/\.stl$/i) ? this.httpDo(e, "GET", "arrayBuffer", function (e) {
          !function (e, t) {
            if (function (e) {
              for (var t = new DataView(e), r = [115, 111, 108, 105, 100], i = 0; i < 5; i++) if (s(r, t, i)) return !1;

              return !0;
            }(t)) !function (e, t) {
              for (var r, i, n, a, o, s, l, u = new DataView(t), h = u.getUint32(80, !0), c = !1, f = 0; f < 70; f++) 1129270351 === u.getUint32(f, !1) && 82 === u.getUint8(f + 4) && 61 === u.getUint8(f + 5) && (c = !0, a = [], o = u.getUint8(f + 6) / 255, s = u.getUint8(f + 7) / 255, l = u.getUint8(f + 8) / 255);

              for (var d = 0; d < h; d++) {
                var p = 84 + 50 * d,
                    m = u.getFloat32(p, !0),
                    v = u.getFloat32(4 + p, !0),
                    y = u.getFloat32(8 + p, !0);

                if (c) {
                  var g = u.getUint16(48 + p, !0);
                  n = 0 == (32768 & g) ? (r = (31 & g) / 31, i = (g >> 5 & 31) / 31, (g >> 10 & 31) / 31) : (r = o, i = s, l);
                }

                for (var b = new S.default.Vector(m, v, y), _ = 1; _ <= 3; _++) {
                  var x = p + 12 * _,
                      w = new S.default.Vector(u.getFloat32(x, !0), u.getFloat32(4 + x, !0), u.getFloat32(8 + x, !0));
                  e.vertices.push(w), e.vertexNormals.push(b), c && a.push(r, i, n);
                }

                e.faces.push([3 * d, 3 * d + 1, 3 * d + 2]), e.uvs.push([0, 0], [0, 0], [0, 0]);
              }
            }(e, t);else {
              var r = new DataView(t);
              if (!("TextDecoder" in window)) return console.warn("Sorry, ASCII STL loading only works in browsers that support TextDecoder (https://caniuse.com/#feat=textencoder)");
              var i = new TextDecoder("utf-8").decode(r).split("\n");
              !function (e, t) {
                for (var r, i, n = "", a = [], o = 0; o < t.length; ++o) {
                  for (var s = t[o].trim(), l = s.split(" "), u = 0; u < l.length; ++u) "" === l[u] && l.splice(u, 1);

                  if (0 !== l.length) switch (n) {
                    case "":
                      if ("solid" !== l[0]) return console.error(s), console.error('Invalid state "'.concat(l[0], '", should be "solid"'));
                      n = "solid";
                      break;

                    case "solid":
                      if ("facet" !== l[0] || "normal" !== l[1]) return console.error(s), console.error('Invalid state "'.concat(l[0], '", should be "facet normal"'));
                      r = new S.default.Vector(parseFloat(l[2]), parseFloat(l[3]), parseFloat(l[4])), e.vertexNormals.push(r, r, r), n = "facet normal";
                      break;

                    case "facet normal":
                      if ("outer" !== l[0] || "loop" !== l[1]) return console.error(s), console.error('Invalid state "'.concat(l[0], '", should be "outer loop"'));
                      n = "vertex";
                      break;

                    case "vertex":
                      if ("vertex" === l[0]) i = new S.default.Vector(parseFloat(l[1]), parseFloat(l[2]), parseFloat(l[3])), e.vertices.push(i), e.uvs.push([0, 0]), a.push(e.vertices.indexOf(i));else {
                        if ("endloop" !== l[0]) return console.error(s), console.error('Invalid state "'.concat(l[0], '", should be "vertex" or "endloop"'));
                        e.faces.push(a), a = [], n = "endloop";
                      }
                      break;

                    case "endloop":
                      if ("endfacet" !== l[0]) return console.error(s), console.error('Invalid state "'.concat(l[0], '", should be "endfacet"'));
                      n = "endfacet";
                      break;

                    case "endfacet":
                      if ("endsolid" !== l[0]) {
                        if ("facet" !== l[0] || "normal" !== l[1]) return console.error(s), console.error('Invalid state "'.concat(l[0], '", should be "endsolid" or "facet normal"'));
                        r = new S.default.Vector(parseFloat(l[2]), parseFloat(l[3]), parseFloat(l[4])), e.vertexNormals.push(r, r, r), n = "facet normal";
                      }

                      break;

                    default:
                      console.error('Invalid state "'.concat(n, '"'));
                  }
                }
              }(e, i);
            }
          }(a, e), t && a.normalize(), o._decrementPreload(), "function" == typeof r && r(a);
        }, i) : n.match(/\.obj$/i) ? this.loadStrings(e, function (e) {
          !function (e, t) {
            for (var r = {
              v: [],
              vt: [],
              vn: []
            }, i = {}, n = 0; n < t.length; ++n) {
              var a = t[n].trim().split(/\b\s+/);
              if (0 < a.length) if ("v" === a[0] || "vn" === a[0]) {
                var o = new S.default.Vector(parseFloat(a[1]), parseFloat(a[2]), parseFloat(a[3]));
                r[a[0]].push(o);
              } else if ("vt" === a[0]) {
                var s = [parseFloat(a[1]), parseFloat(a[2])];
                r[a[0]].push(s);
              } else if ("f" === a[0]) for (var l = 3; l < a.length; ++l) {
                for (var u = [], h = [1, l - 1, l], c = 0; c < h.length; ++c) {
                  var f = a[h[c]],
                      d = 0;
                  if (void 0 !== i[f]) d = i[f];else {
                    for (var p = f.split("/"), m = 0; m < p.length; m++) p[m] = parseInt(p[m]) - 1;

                    d = i[f] = e.vertices.length, e.vertices.push(r.v[p[0]].copy()), r.vt[p[1]] ? e.uvs.push(r.vt[p[1]].slice()) : e.uvs.push([0, 0]), r.vn[p[2]] && e.vertexNormals.push(r.vn[p[2]].copy());
                  }
                  u.push(d);
                }

                u[0] !== u[1] && u[0] !== u[2] && u[1] !== u[2] && e.faces.push(u);
              }
            }

            0 === e.vertexNormals.length && e.computeNormals();
          }(a, e), t && a.normalize(), o._decrementPreload(), "function" == typeof r && r(a);
        }, i) : (S.default._friendlyFileLoadError(3, e), i ? i() : console.error("Sorry, the file type is invalid. Only OBJ and STL files are supported.")), a;
      }, S.default.prototype.model = function (e) {
        this._assert3d("model"), S.default._validateParameters("model", arguments), 0 < e.vertices.length && (this._renderer.geometryInHash(e.gid) || (e._makeTriangleEdges()._edgesToVertices(), this._renderer.createBuffers(e.gid, e)), this._renderer.drawBuffers(e.gid));
      };
      var n = S.default;
      r.default = n;
    }, {
      "../core/main": 36,
      "./p5.Geometry": 85
    }],
    83: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var i,
          u = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      },
          n = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../core/constants"));

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      e("./p5.Texture"), u.default.prototype.loadShader = function (e, t, r, i) {
        u.default._validateParameters("loadShader", arguments), i = i || console.error;

        function n() {
          o._decrementPreload(), r && r(a);
        }

        var a = new u.default.Shader(),
            o = this,
            s = !1,
            l = !1;
        return this.loadStrings(e, function (e) {
          a._vertSrc = e.join("\n"), l = !0, s && n();
        }, i), this.loadStrings(t, function (e) {
          a._fragSrc = e.join("\n"), s = !0, l && n();
        }, i), a;
      }, u.default.prototype.createShader = function (e, t) {
        return this._assert3d("createShader"), u.default._validateParameters("createShader", arguments), new u.default.Shader(this._renderer, e, t);
      }, u.default.prototype.shader = function (e) {
        return this._assert3d("shader"), u.default._validateParameters("shader", arguments), void 0 === e._renderer && (e._renderer = this._renderer), e.isStrokeShader() ? this._renderer.userStrokeShader = e : (this._renderer.userFillShader = e, this._renderer._useNormalMaterial = !1), e.init(), this;
      }, u.default.prototype.resetShader = function () {
        return this._renderer.userFillShader = this._renderer.userStrokeShader = null, this;
      }, u.default.prototype.normalMaterial = function () {
        this._assert3d("normalMaterial");

        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];

        return u.default._validateParameters("normalMaterial", t), this._renderer.drawMode = n.FILL, this._renderer._useSpecularMaterial = !1, this._renderer._useEmissiveMaterial = !1, this._renderer._useNormalMaterial = !0, this._renderer.curFillColor = [1, 1, 1, 1], this._renderer._setProperty("_doFill", !0), this.noStroke(), this;
      }, u.default.prototype.texture = function (e) {
        return this._assert3d("texture"), u.default._validateParameters("texture", arguments), e.gifProperties && e._animateGif(this), this._renderer.drawMode = n.TEXTURE, this._renderer._useSpecularMaterial = !1, this._renderer._useEmissiveMaterial = !1, this._renderer._useNormalMaterial = !1, this._renderer._tex = e, this._renderer._setProperty("_doFill", !0), this;
      }, u.default.prototype.textureMode = function (e) {
        e !== n.IMAGE && e !== n.NORMAL ? console.warn("You tried to set ".concat(e, " textureMode only supports IMAGE & NORMAL ")) : this._renderer.textureMode = e;
      }, u.default.prototype.textureWrap = function (e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : e;
        this._renderer.textureWrapX = e, this._renderer.textureWrapY = t;

        for (var r = this._renderer.textures, i = 0; i < r.length; i++) r[i].setWrapMode(e, t);
      }, u.default.prototype.ambientMaterial = function (e, t, r) {
        this._assert3d("ambientMaterial"), u.default._validateParameters("ambientMaterial", arguments);
        var i = u.default.prototype.color.apply(this, arguments);
        return this._renderer.curFillColor = i._array, this._renderer._useSpecularMaterial = !1, this._renderer._useEmissiveMaterial = !1, this._renderer._useNormalMaterial = !1, this._renderer._enableLighting = !0, this._renderer._tex = null, this;
      }, u.default.prototype.emissiveMaterial = function (e, t, r, i) {
        this._assert3d("emissiveMaterial"), u.default._validateParameters("emissiveMaterial", arguments);
        var n = u.default.prototype.color.apply(this, arguments);
        return this._renderer.curFillColor = n._array, this._renderer._useSpecularMaterial = !1, this._renderer._useEmissiveMaterial = !0, this._renderer._useNormalMaterial = !1, this._renderer._enableLighting = !0, this._renderer._tex = null, this;
      }, u.default.prototype.specularMaterial = function (e, t, r, i) {
        this._assert3d("specularMaterial"), u.default._validateParameters("specularMaterial", arguments);
        var n = u.default.prototype.color.apply(this, arguments);
        return this._renderer.curFillColor = n._array, this._renderer._useSpecularMaterial = !0, this._renderer._useEmissiveMaterial = !1, this._renderer._useNormalMaterial = !1, this._renderer._enableLighting = !0, this._renderer._tex = null, this;
      }, u.default.prototype.shininess = function (e) {
        return this._assert3d("shininess"), u.default._validateParameters("shininess", arguments), e < 1 && (e = 1), this._renderer._useShininess = e, this;
      }, u.default.RendererGL.prototype._applyColorBlend = function (e) {
        var t = this.GL,
            r = this.drawMode === n.TEXTURE || e[e.length - 1] < 1 || this._isErasing;
        return r !== this._isBlending && (r || this.curBlendMode !== n.BLEND && this.curBlendMode !== n.ADD ? t.enable(t.BLEND) : t.disable(t.BLEND), t.depthMask(!0), this._isBlending = r), this._applyBlendMode(), e;
      }, u.default.RendererGL.prototype._applyBlendMode = function () {
        if (this._cachedBlendMode !== this.curBlendMode) {
          var e = this.GL;

          switch (this.curBlendMode) {
            case n.BLEND:
            case n.ADD:
              e.blendEquation(e.FUNC_ADD), e.blendFunc(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA);
              break;

            case n.REMOVE:
              e.blendEquation(e.FUNC_REVERSE_SUBTRACT), e.blendFunc(e.SRC_ALPHA, e.DST_ALPHA);
              break;

            case n.MULTIPLY:
              e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ONE, e.ONE);
              break;

            case n.SCREEN:
              e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE_MINUS_DST_COLOR, e.ONE, e.ONE, e.ONE);
              break;

            case n.EXCLUSION:
              e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE_MINUS_DST_COLOR, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE);
              break;

            case n.REPLACE:
              e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ONE, e.ZERO);
              break;

            case n.SUBTRACT:
              e.blendEquationSeparate(e.FUNC_REVERSE_SUBTRACT, e.FUNC_ADD), e.blendFuncSeparate(e.SRC_ALPHA, e.ONE, e.ONE, e.ONE);
              break;

            case n.DARKEST:
              this.blendExt ? (e.blendEquationSeparate(this.blendExt.MIN_EXT, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ONE, e.ONE, e.ONE)) : console.warn("blendMode(DARKEST) does not work in your browser in WEBGL mode.");
              break;

            case n.LIGHTEST:
              this.blendExt ? (e.blendEquationSeparate(this.blendExt.MAX_EXT, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ONE, e.ONE, e.ONE)) : console.warn("blendMode(LIGHTEST) does not work in your browser in WEBGL mode.");
              break;

            default:
              console.error("Oops! Somehow RendererGL set curBlendMode to an unsupported mode.");
          }

          this._isErasing || (this._cachedBlendMode = this.curBlendMode);
        }
      };
      var a = u.default;
      r.default = a;
    }, {
      "../core/constants": 26,
      "../core/main": 36,
      "./p5.Texture": 92
    }],
    84: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          m = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      m.default.prototype.camera = function () {
        var e;

        this._assert3d("camera");

        for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];

        return m.default._validateParameters("camera", r), (e = this._renderer._curCamera).camera.apply(e, r), this;
      }, m.default.prototype.perspective = function () {
        var e;

        this._assert3d("perspective");

        for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];

        return m.default._validateParameters("perspective", r), (e = this._renderer._curCamera).perspective.apply(e, r), this;
      }, m.default.prototype.ortho = function () {
        var e;

        this._assert3d("ortho");

        for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];

        return m.default._validateParameters("ortho", r), (e = this._renderer._curCamera).ortho.apply(e, r), this;
      }, m.default.prototype.frustum = function () {
        var e;

        this._assert3d("frustum");

        for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];

        return m.default._validateParameters("frustum", r), (e = this._renderer._curCamera).frustum.apply(e, r), this;
      }, m.default.prototype.createCamera = function () {
        this._assert3d("createCamera");

        var e = new m.default.Camera(this._renderer);
        return e._computeCameraDefaultSettings(), e._setDefaultCamera(), this._renderer._curCamera = e;
      }, m.default.Camera = function (e) {
        this._renderer = e, this.cameraType = "default", this.cameraMatrix = new m.default.Matrix(), this.projMatrix = new m.default.Matrix();
      }, m.default.Camera.prototype.perspective = function (e, t, r, i) {
        this.cameraType = 0 < arguments.length ? "custom" : "default", void 0 === e ? (e = this.defaultCameraFOV, this.cameraFOV = e) : this.cameraFOV = this._renderer._pInst._toRadians(e), void 0 === t && (t = this.defaultAspectRatio), void 0 === r && (r = this.defaultCameraNear), void 0 === i && (i = this.defaultCameraFar), r <= 1e-4 && (r = .01, console.log("Avoid perspective near plane values close to or below 0. Setting value to 0.01.")), i < r && console.log("Perspective far plane value is less than near plane value. Nothing will be shown."), this.aspectRatio = t, this.cameraNear = r, this.cameraFar = i, this.projMatrix = m.default.Matrix.identity();
        var n = 1 / Math.tan(this.cameraFOV / 2),
            a = 1 / (this.cameraNear - this.cameraFar);
        this.projMatrix.set(n / t, 0, 0, 0, 0, -n, 0, 0, 0, 0, (i + r) * a, -1, 0, 0, 2 * i * r * a, 0), this._isActive() && this._renderer.uPMatrix.set(this.projMatrix.mat4[0], this.projMatrix.mat4[1], this.projMatrix.mat4[2], this.projMatrix.mat4[3], this.projMatrix.mat4[4], this.projMatrix.mat4[5], this.projMatrix.mat4[6], this.projMatrix.mat4[7], this.projMatrix.mat4[8], this.projMatrix.mat4[9], this.projMatrix.mat4[10], this.projMatrix.mat4[11], this.projMatrix.mat4[12], this.projMatrix.mat4[13], this.projMatrix.mat4[14], this.projMatrix.mat4[15]);
      }, m.default.Camera.prototype.ortho = function (e, t, r, i, n, a) {
        void 0 === e && (e = -this._renderer.width / 2), void 0 === t && (t = this._renderer.width / 2), void 0 === r && (r = -this._renderer.height / 2), void 0 === i && (i = this._renderer.height / 2), void 0 === n && (n = 0), void 0 === a && (a = Math.max(this._renderer.width, this._renderer.height));
        var o = t - e,
            s = i - r,
            l = a - n,
            u = 2 / o,
            h = 2 / s,
            c = -2 / l,
            f = -(t + e) / o,
            d = -(i + r) / s,
            p = -(a + n) / l;
        this.projMatrix = m.default.Matrix.identity(), this.projMatrix.set(u, 0, 0, 0, 0, -h, 0, 0, 0, 0, c, 0, f, d, p, 1), this._isActive() && this._renderer.uPMatrix.set(this.projMatrix.mat4[0], this.projMatrix.mat4[1], this.projMatrix.mat4[2], this.projMatrix.mat4[3], this.projMatrix.mat4[4], this.projMatrix.mat4[5], this.projMatrix.mat4[6], this.projMatrix.mat4[7], this.projMatrix.mat4[8], this.projMatrix.mat4[9], this.projMatrix.mat4[10], this.projMatrix.mat4[11], this.projMatrix.mat4[12], this.projMatrix.mat4[13], this.projMatrix.mat4[14], this.projMatrix.mat4[15]), this.cameraType = "custom";
      }, m.default.Camera.prototype.frustum = function (e, t, r, i, n, a) {
        void 0 === e && (e = -this._renderer.width / 2), void 0 === t && (t = this._renderer.width / 2), void 0 === r && (r = -this._renderer.height / 2), void 0 === i && (i = this._renderer.height / 2), void 0 === n && (n = 0), void 0 === a && (a = Math.max(this._renderer.width, this._renderer.height));
        var o = t - e,
            s = i - r,
            l = a - n,
            u = 2 * n / o,
            h = 2 * n / s,
            c = -2 * a * n / l,
            f = (t + e) / o,
            d = (i + r) / s,
            p = -(a + n) / l;
        this.projMatrix = m.default.Matrix.identity(), this.projMatrix.set(u, 0, 0, 0, 0, h, 0, 0, f, d, p, -1, 0, 0, c, 0), this._isActive() && this._renderer.uPMatrix.set(this.projMatrix.mat4[0], this.projMatrix.mat4[1], this.projMatrix.mat4[2], this.projMatrix.mat4[3], this.projMatrix.mat4[4], this.projMatrix.mat4[5], this.projMatrix.mat4[6], this.projMatrix.mat4[7], this.projMatrix.mat4[8], this.projMatrix.mat4[9], this.projMatrix.mat4[10], this.projMatrix.mat4[11], this.projMatrix.mat4[12], this.projMatrix.mat4[13], this.projMatrix.mat4[14], this.projMatrix.mat4[15]), this.cameraType = "custom";
      }, m.default.Camera.prototype._rotateView = function (e, t, r, i) {
        var n = this.centerX,
            a = this.centerY,
            o = this.centerZ;
        n -= this.eyeX, a -= this.eyeY, o -= this.eyeZ;
        var s = m.default.Matrix.identity(this._renderer._pInst);
        s.rotate(this._renderer._pInst._toRadians(e), t, r, i);
        var l = [n * s.mat4[0] + a * s.mat4[4] + o * s.mat4[8], n * s.mat4[1] + a * s.mat4[5] + o * s.mat4[9], n * s.mat4[2] + a * s.mat4[6] + o * s.mat4[10]];
        l[0] += this.eyeX, l[1] += this.eyeY, l[2] += this.eyeZ, this.camera(this.eyeX, this.eyeY, this.eyeZ, l[0], l[1], l[2], this.upX, this.upY, this.upZ);
      }, m.default.Camera.prototype.pan = function (e) {
        var t = this._getLocalAxes();

        this._rotateView(e, t.y[0], t.y[1], t.y[2]);
      }, m.default.Camera.prototype.tilt = function (e) {
        var t = this._getLocalAxes();

        this._rotateView(e, t.x[0], t.x[1], t.x[2]);
      }, m.default.Camera.prototype.lookAt = function (e, t, r) {
        this.camera(this.eyeX, this.eyeY, this.eyeZ, e, t, r, this.upX, this.upY, this.upZ);
      }, m.default.Camera.prototype.camera = function (e, t, r, i, n, a, o, s, l) {
        void 0 === e && (e = this.defaultEyeX, t = this.defaultEyeY, r = this.defaultEyeZ, i = e, n = t, s = 1, l = o = a = 0), this.eyeX = e, this.eyeY = t, this.eyeZ = r, void 0 !== i && (this.centerX = i, this.centerY = n, this.centerZ = a), void 0 !== o && (this.upX = o, this.upY = s, this.upZ = l);

        var u = this._getLocalAxes();

        this.cameraMatrix.set(u.x[0], u.y[0], u.z[0], 0, u.x[1], u.y[1], u.z[1], 0, u.x[2], u.y[2], u.z[2], 0, 0, 0, 0, 1);
        var h = -e,
            c = -t,
            f = -r;
        return this.cameraMatrix.translate([h, c, f]), this._isActive() && this._renderer.uMVMatrix.set(this.cameraMatrix.mat4[0], this.cameraMatrix.mat4[1], this.cameraMatrix.mat4[2], this.cameraMatrix.mat4[3], this.cameraMatrix.mat4[4], this.cameraMatrix.mat4[5], this.cameraMatrix.mat4[6], this.cameraMatrix.mat4[7], this.cameraMatrix.mat4[8], this.cameraMatrix.mat4[9], this.cameraMatrix.mat4[10], this.cameraMatrix.mat4[11], this.cameraMatrix.mat4[12], this.cameraMatrix.mat4[13], this.cameraMatrix.mat4[14], this.cameraMatrix.mat4[15]), this;
      }, m.default.Camera.prototype.move = function (e, t, r) {
        var i = this._getLocalAxes(),
            n = [i.x[0] * e, i.x[1] * e, i.x[2] * e],
            a = [i.y[0] * t, i.y[1] * t, i.y[2] * t],
            o = [i.z[0] * r, i.z[1] * r, i.z[2] * r];

        this.camera(this.eyeX + n[0] + a[0] + o[0], this.eyeY + n[1] + a[1] + o[1], this.eyeZ + n[2] + a[2] + o[2], this.centerX + n[0] + a[0] + o[0], this.centerY + n[1] + a[1] + o[1], this.centerZ + n[2] + a[2] + o[2], 0, 1, 0);
      }, m.default.Camera.prototype.setPosition = function (e, t, r) {
        var i = e - this.eyeX,
            n = t - this.eyeY,
            a = r - this.eyeZ;
        this.camera(e, t, r, this.centerX + i, this.centerY + n, this.centerZ + a, 0, 1, 0);
      }, m.default.Camera.prototype._computeCameraDefaultSettings = function () {
        this.defaultCameraFOV = 60 / 180 * Math.PI, this.defaultAspectRatio = this._renderer.width / this._renderer.height, this.defaultEyeX = 0, this.defaultEyeY = 0, this.defaultEyeZ = this._renderer.height / 2 / Math.tan(this.defaultCameraFOV / 2), this.defaultCenterX = 0, this.defaultCenterY = 0, this.defaultCenterZ = 0, this.defaultCameraNear = .1 * this.defaultEyeZ, this.defaultCameraFar = 10 * this.defaultEyeZ;
      }, m.default.Camera.prototype._setDefaultCamera = function () {
        this.cameraFOV = this.defaultCameraFOV, this.aspectRatio = this.defaultAspectRatio, this.eyeX = this.defaultEyeX, this.eyeY = this.defaultEyeY, this.eyeZ = this.defaultEyeZ, this.centerX = this.defaultCenterX, this.centerY = this.defaultCenterY, this.centerZ = this.defaultCenterZ, this.upX = 0, this.upY = 1, this.upZ = 0, this.cameraNear = this.defaultCameraNear, this.cameraFar = this.defaultCameraFar, this.perspective(), this.camera(), this.cameraType = "default";
      }, m.default.Camera.prototype._resize = function () {
        "default" === this.cameraType ? (this._computeCameraDefaultSettings(), this._setDefaultCamera()) : this.perspective(this.cameraFOV, this._renderer.width / this._renderer.height);
      }, m.default.Camera.prototype.copy = function () {
        var e = new m.default.Camera(this._renderer);
        return e.cameraFOV = this.cameraFOV, e.aspectRatio = this.aspectRatio, e.eyeX = this.eyeX, e.eyeY = this.eyeY, e.eyeZ = this.eyeZ, e.centerX = this.centerX, e.centerY = this.centerY, e.centerZ = this.centerZ, e.cameraNear = this.cameraNear, e.cameraFar = this.cameraFar, e.cameraType = this.cameraType, e.cameraMatrix = this.cameraMatrix.copy(), e.projMatrix = this.projMatrix.copy(), e;
      }, m.default.Camera.prototype._getLocalAxes = function () {
        var e = this.eyeX - this.centerX,
            t = this.eyeY - this.centerY,
            r = this.eyeZ - this.centerZ,
            i = Math.sqrt(e * e + t * t + r * r);
        0 !== i && (e /= i, t /= i, r /= i);
        var n = this.upX,
            a = this.upY,
            o = this.upZ,
            s = a * r - o * t,
            l = -n * r + o * e,
            u = n * t - a * e;
        n = t * u - r * l, a = -e * u + r * s, o = e * l - t * s;
        var h = Math.sqrt(s * s + l * l + u * u);
        0 !== h && (s /= h, l /= h, u /= h);
        var c = Math.sqrt(n * n + a * a + o * o);
        return 0 !== c && (n /= c, a /= c, o /= c), {
          x: [s, l, u],
          y: [n, a, o],
          z: [e, t, r]
        };
      }, m.default.Camera.prototype._orbit = function (e, t, r) {
        var i = this.eyeX - this.centerX,
            n = this.eyeY - this.centerY,
            a = this.eyeZ - this.centerZ,
            o = Math.sqrt(i * i + n * n + a * a),
            s = Math.atan2(i, a),
            l = Math.acos(Math.max(-1, Math.min(1, n / o)));
        s += e, (o += r) < 0 && (o = .1), (l += t) > Math.PI ? l = Math.PI : l <= 0 && (l = .001);
        var u = Math.sin(l) * o * Math.sin(s),
            h = Math.cos(l) * o,
            c = Math.sin(l) * o * Math.cos(s);
        this.camera(u + this.centerX, h + this.centerY, c + this.centerZ, this.centerX, this.centerY, this.centerZ, 0, 1, 0);
      }, m.default.Camera.prototype._isActive = function () {
        return this === this._renderer._curCamera;
      }, m.default.prototype.setCamera = function (e) {
        this._renderer._curCamera = e, this._renderer.uPMatrix.set(e.projMatrix.mat4[0], e.projMatrix.mat4[1], e.projMatrix.mat4[2], e.projMatrix.mat4[3], e.projMatrix.mat4[4], e.projMatrix.mat4[5], e.projMatrix.mat4[6], e.projMatrix.mat4[7], e.projMatrix.mat4[8], e.projMatrix.mat4[9], e.projMatrix.mat4[10], e.projMatrix.mat4[11], e.projMatrix.mat4[12], e.projMatrix.mat4[13], e.projMatrix.mat4[14], e.projMatrix.mat4[15]);
      };
      var n = m.default.Camera;
      r.default = n;
    }, {
      "../core/main": 36
    }],
    85: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          h = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      h.default.Geometry = function (e, t, r) {
        return this.vertices = [], this.lineVertices = [], this.lineNormals = [], this.vertexNormals = [], this.faces = [], this.uvs = [], this.edges = [], this.vertexColors = [], this.detailX = void 0 !== e ? e : 1, this.detailY = void 0 !== t ? t : 1, this.dirtyFlags = {}, r instanceof Function && r.call(this), this;
      }, h.default.Geometry.prototype.reset = function () {
        this.lineVertices.length = 0, this.lineNormals.length = 0, this.vertices.length = 0, this.edges.length = 0, this.vertexColors.length = 0, this.vertexNormals.length = 0, this.uvs.length = 0, this.dirtyFlags = {};
      }, h.default.Geometry.prototype.computeFaces = function () {
        this.faces.length = 0;

        for (var e, t, r, i, n = this.detailX + 1, a = 0; a < this.detailY; a++) for (var o = 0; o < this.detailX; o++) t = (e = a * n + o) + 1, r = (a + 1) * n + o + 1, i = (a + 1) * n + o, this.faces.push([e, t, i]), this.faces.push([i, t, r]);

        return this;
      }, h.default.Geometry.prototype._getFaceNormal = function (e) {
        var t = this.faces[e],
            r = this.vertices[t[0]],
            i = this.vertices[t[1]],
            n = this.vertices[t[2]],
            a = h.default.Vector.sub(i, r),
            o = h.default.Vector.sub(n, r),
            s = h.default.Vector.cross(a, o),
            l = h.default.Vector.mag(s),
            u = l / (h.default.Vector.mag(a) * h.default.Vector.mag(o));
        return 0 === u || isNaN(u) ? (console.warn("p5.Geometry.prototype._getFaceNormal:", "face has colinear sides or a repeated vertex"), s) : (1 < u && (u = 1), s.mult(Math.asin(u) / l));
      }, h.default.Geometry.prototype.computeNormals = function () {
        var e,
            t = this.vertexNormals,
            r = this.vertices,
            i = this.faces;

        for (e = t.length = 0; e < r.length; ++e) t.push(new h.default.Vector());

        for (var n = 0; n < i.length; ++n) for (var a = i[n], o = this._getFaceNormal(n), s = 0; s < 3; ++s) {
          t[a[s]].add(o);
        }

        for (e = 0; e < r.length; ++e) t[e].normalize();

        return this;
      }, h.default.Geometry.prototype.averageNormals = function () {
        for (var e = 0; e <= this.detailY; e++) {
          var t = this.detailX + 1,
              r = h.default.Vector.add(this.vertexNormals[e * t], this.vertexNormals[e * t + this.detailX]);
          r = h.default.Vector.div(r, 2), this.vertexNormals[e * t] = r, this.vertexNormals[e * t + this.detailX] = r;
        }

        return this;
      }, h.default.Geometry.prototype.averagePoleNormals = function () {
        for (var e = new h.default.Vector(0, 0, 0), t = 0; t < this.detailX; t++) e.add(this.vertexNormals[t]);

        e = h.default.Vector.div(e, this.detailX);

        for (var r = 0; r < this.detailX; r++) this.vertexNormals[r] = e;

        e = new h.default.Vector(0, 0, 0);

        for (var i = this.vertices.length - 1; i > this.vertices.length - 1 - this.detailX; i--) e.add(this.vertexNormals[i]);

        e = h.default.Vector.div(e, this.detailX);

        for (var n = this.vertices.length - 1; n > this.vertices.length - 1 - this.detailX; n--) this.vertexNormals[n] = e;

        return this;
      }, h.default.Geometry.prototype._makeTriangleEdges = function () {
        if (this.edges.length = 0, Array.isArray(this.strokeIndices)) for (var e = 0, t = this.strokeIndices.length; e < t; e++) this.edges.push(this.strokeIndices[e]);else for (var r = 0; r < this.faces.length; r++) this.edges.push([this.faces[r][0], this.faces[r][1]]), this.edges.push([this.faces[r][1], this.faces[r][2]]), this.edges.push([this.faces[r][2], this.faces[r][0]]);
        return this;
      }, h.default.Geometry.prototype._edgesToVertices = function () {
        this.lineVertices.length = 0;

        for (var e = this.lineNormals.length = 0; e < this.edges.length; e++) {
          var t = this.vertices[this.edges[e][0]],
              r = this.vertices[this.edges[e][1]],
              i = r.copy().sub(t).normalize(),
              n = t.array(),
              a = t.array(),
              o = r.array(),
              s = r.array(),
              l = i.array(),
              u = i.array();
          l.push(1), u.push(-1), this.lineNormals.push(l, u, l, l, u, u), this.lineVertices.push(n, a, o, o, a, s);
        }

        return this;
      }, h.default.Geometry.prototype.normalize = function () {
        if (0 < this.vertices.length) {
          for (var e = this.vertices[0].copy(), t = this.vertices[0].copy(), r = 0; r < this.vertices.length; r++) e.x = Math.max(e.x, this.vertices[r].x), t.x = Math.min(t.x, this.vertices[r].x), e.y = Math.max(e.y, this.vertices[r].y), t.y = Math.min(t.y, this.vertices[r].y), e.z = Math.max(e.z, this.vertices[r].z), t.z = Math.min(t.z, this.vertices[r].z);

          for (var i = h.default.Vector.lerp(e, t, .5), n = h.default.Vector.sub(e, t), a = 200 / Math.max(Math.max(n.x, n.y), n.z), o = 0; o < this.vertices.length; o++) this.vertices[o].sub(i), this.vertices[o].mult(a);
        }

        return this;
      };
      var n = h.default.Geometry;
      r.default = n;
    }, {
      "../core/main": 36
    }],
    86: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          P = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };

      var n = Array,
          R = function (e) {
        return e instanceof Array;
      };

      "undefined" != typeof Float32Array && (n = Float32Array, R = function (e) {
        return e instanceof Array || e instanceof Float32Array;
      }), P.default.Matrix = function () {
        for (var e = new Array(arguments.length), t = 0; t < e.length; ++t) e[t] = arguments[t];

        return e.length && e[e.length - 1] instanceof P.default && (this.p5 = e[e.length - 1]), "mat3" === e[0] ? this.mat3 = Array.isArray(e[1]) ? e[1] : new n([1, 0, 0, 0, 1, 0, 0, 0, 1]) : this.mat4 = Array.isArray(e[0]) ? e[0] : new n([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this;
      }, P.default.Matrix.prototype.set = function (e) {
        return e instanceof P.default.Matrix ? this.mat4 = e.mat4 : R(e) ? this.mat4 = e : 16 === arguments.length && (this.mat4[0] = e, this.mat4[1] = arguments[1], this.mat4[2] = arguments[2], this.mat4[3] = arguments[3], this.mat4[4] = arguments[4], this.mat4[5] = arguments[5], this.mat4[6] = arguments[6], this.mat4[7] = arguments[7], this.mat4[8] = arguments[8], this.mat4[9] = arguments[9], this.mat4[10] = arguments[10], this.mat4[11] = arguments[11], this.mat4[12] = arguments[12], this.mat4[13] = arguments[13], this.mat4[14] = arguments[14], this.mat4[15] = arguments[15]), this;
      }, P.default.Matrix.prototype.get = function () {
        return new P.default.Matrix(this.mat4, this.p5);
      }, P.default.Matrix.prototype.copy = function () {
        var e = new P.default.Matrix(this.p5);
        return e.mat4[0] = this.mat4[0], e.mat4[1] = this.mat4[1], e.mat4[2] = this.mat4[2], e.mat4[3] = this.mat4[3], e.mat4[4] = this.mat4[4], e.mat4[5] = this.mat4[5], e.mat4[6] = this.mat4[6], e.mat4[7] = this.mat4[7], e.mat4[8] = this.mat4[8], e.mat4[9] = this.mat4[9], e.mat4[10] = this.mat4[10], e.mat4[11] = this.mat4[11], e.mat4[12] = this.mat4[12], e.mat4[13] = this.mat4[13], e.mat4[14] = this.mat4[14], e.mat4[15] = this.mat4[15], e;
      }, P.default.Matrix.identity = function (e) {
        return new P.default.Matrix(e);
      }, P.default.Matrix.prototype.transpose = function (e) {
        var t, r, i, n, a, o;
        return e instanceof P.default.Matrix ? (t = e.mat4[1], r = e.mat4[2], i = e.mat4[3], n = e.mat4[6], a = e.mat4[7], o = e.mat4[11], this.mat4[0] = e.mat4[0], this.mat4[1] = e.mat4[4], this.mat4[2] = e.mat4[8], this.mat4[3] = e.mat4[12], this.mat4[4] = t, this.mat4[5] = e.mat4[5], this.mat4[6] = e.mat4[9], this.mat4[7] = e.mat4[13], this.mat4[8] = r, this.mat4[9] = n, this.mat4[10] = e.mat4[10], this.mat4[11] = e.mat4[14], this.mat4[12] = i, this.mat4[13] = a, this.mat4[14] = o, this.mat4[15] = e.mat4[15]) : R(e) && (t = e[1], r = e[2], i = e[3], n = e[6], a = e[7], o = e[11], this.mat4[0] = e[0], this.mat4[1] = e[4], this.mat4[2] = e[8], this.mat4[3] = e[12], this.mat4[4] = t, this.mat4[5] = e[5], this.mat4[6] = e[9], this.mat4[7] = e[13], this.mat4[8] = r, this.mat4[9] = n, this.mat4[10] = e[10], this.mat4[11] = e[14], this.mat4[12] = i, this.mat4[13] = a, this.mat4[14] = o, this.mat4[15] = e[15]), this;
      }, P.default.Matrix.prototype.invert = function (e) {
        var t, r, i, n, a, o, s, l, u, h, c, f, d, p, m, v;
        e instanceof P.default.Matrix ? (t = e.mat4[0], r = e.mat4[1], i = e.mat4[2], n = e.mat4[3], a = e.mat4[4], o = e.mat4[5], s = e.mat4[6], l = e.mat4[7], u = e.mat4[8], h = e.mat4[9], c = e.mat4[10], f = e.mat4[11], d = e.mat4[12], p = e.mat4[13], m = e.mat4[14], v = e.mat4[15]) : R(e) && (t = e[0], r = e[1], i = e[2], n = e[3], a = e[4], o = e[5], s = e[6], l = e[7], u = e[8], h = e[9], c = e[10], f = e[11], d = e[12], p = e[13], m = e[14], v = e[15]);

        var y = t * o - r * a,
            g = t * s - i * a,
            b = t * l - n * a,
            _ = r * s - i * o,
            x = r * l - n * o,
            w = i * l - n * s,
            S = u * p - h * d,
            M = u * m - c * d,
            T = u * v - f * d,
            E = h * m - c * p,
            C = h * v - f * p,
            L = c * v - f * m,
            O = y * L - g * C + b * E + _ * T - x * M + w * S;

        return O ? (O = 1 / O, this.mat4[0] = (o * L - s * C + l * E) * O, this.mat4[1] = (i * C - r * L - n * E) * O, this.mat4[2] = (p * w - m * x + v * _) * O, this.mat4[3] = (c * x - h * w - f * _) * O, this.mat4[4] = (s * T - a * L - l * M) * O, this.mat4[5] = (t * L - i * T + n * M) * O, this.mat4[6] = (m * b - d * w - v * g) * O, this.mat4[7] = (u * w - c * b + f * g) * O, this.mat4[8] = (a * C - o * T + l * S) * O, this.mat4[9] = (r * T - t * C - n * S) * O, this.mat4[10] = (d * x - p * b + v * y) * O, this.mat4[11] = (h * b - u * x - f * y) * O, this.mat4[12] = (o * M - a * E - s * S) * O, this.mat4[13] = (t * E - r * M + i * S) * O, this.mat4[14] = (p * g - d * _ - m * y) * O, this.mat4[15] = (u * _ - h * g + c * y) * O, this) : null;
      }, P.default.Matrix.prototype.invert3x3 = function () {
        var e = this.mat3[0],
            t = this.mat3[1],
            r = this.mat3[2],
            i = this.mat3[3],
            n = this.mat3[4],
            a = this.mat3[5],
            o = this.mat3[6],
            s = this.mat3[7],
            l = this.mat3[8],
            u = l * n - a * s,
            h = -l * i + a * o,
            c = s * i - n * o,
            f = e * u + t * h + r * c;
        return f ? (f = 1 / f, this.mat3[0] = u * f, this.mat3[1] = (-l * t + r * s) * f, this.mat3[2] = (a * t - r * n) * f, this.mat3[3] = h * f, this.mat3[4] = (l * e - r * o) * f, this.mat3[5] = (-a * e + r * i) * f, this.mat3[6] = c * f, this.mat3[7] = (-s * e + t * o) * f, this.mat3[8] = (n * e - t * i) * f, this) : null;
      }, P.default.Matrix.prototype.transpose3x3 = function (e) {
        var t = e[1],
            r = e[2],
            i = e[5];
        return this.mat3[1] = e[3], this.mat3[2] = e[6], this.mat3[3] = t, this.mat3[5] = e[7], this.mat3[6] = r, this.mat3[7] = i, this;
      }, P.default.Matrix.prototype.inverseTranspose = function (e) {
        void 0 === this.mat3 ? console.error("sorry, this function only works with mat3") : (this.mat3[0] = e.mat4[0], this.mat3[1] = e.mat4[1], this.mat3[2] = e.mat4[2], this.mat3[3] = e.mat4[4], this.mat3[4] = e.mat4[5], this.mat3[5] = e.mat4[6], this.mat3[6] = e.mat4[8], this.mat3[7] = e.mat4[9], this.mat3[8] = e.mat4[10]);
        var t = this.invert3x3();
        if (t) t.transpose3x3(this.mat3);else for (var r = 0; r < 9; r++) this.mat3[r] = 0;
        return this;
      }, P.default.Matrix.prototype.determinant = function () {
        var e = this.mat4[0] * this.mat4[5] - this.mat4[1] * this.mat4[4],
            t = this.mat4[0] * this.mat4[6] - this.mat4[2] * this.mat4[4],
            r = this.mat4[0] * this.mat4[7] - this.mat4[3] * this.mat4[4],
            i = this.mat4[1] * this.mat4[6] - this.mat4[2] * this.mat4[5],
            n = this.mat4[1] * this.mat4[7] - this.mat4[3] * this.mat4[5],
            a = this.mat4[2] * this.mat4[7] - this.mat4[3] * this.mat4[6],
            o = this.mat4[8] * this.mat4[13] - this.mat4[9] * this.mat4[12],
            s = this.mat4[8] * this.mat4[14] - this.mat4[10] * this.mat4[12],
            l = this.mat4[8] * this.mat4[15] - this.mat4[11] * this.mat4[12],
            u = this.mat4[9] * this.mat4[14] - this.mat4[10] * this.mat4[13],
            h = this.mat4[9] * this.mat4[15] - this.mat4[11] * this.mat4[13];
        return e * (this.mat4[10] * this.mat4[15] - this.mat4[11] * this.mat4[14]) - t * h + r * u + i * l - n * s + a * o;
      }, P.default.Matrix.prototype.mult = function (e) {
        var t;
        if (e === this || e === this.mat4) t = this.copy().mat4;else if (e instanceof P.default.Matrix) t = e.mat4;else if (R(e)) t = e;else {
          if (16 !== arguments.length) return;
          t = arguments;
        }
        var r = this.mat4[0],
            i = this.mat4[1],
            n = this.mat4[2],
            a = this.mat4[3];
        return this.mat4[0] = r * t[0] + i * t[4] + n * t[8] + a * t[12], this.mat4[1] = r * t[1] + i * t[5] + n * t[9] + a * t[13], this.mat4[2] = r * t[2] + i * t[6] + n * t[10] + a * t[14], this.mat4[3] = r * t[3] + i * t[7] + n * t[11] + a * t[15], r = this.mat4[4], i = this.mat4[5], n = this.mat4[6], a = this.mat4[7], this.mat4[4] = r * t[0] + i * t[4] + n * t[8] + a * t[12], this.mat4[5] = r * t[1] + i * t[5] + n * t[9] + a * t[13], this.mat4[6] = r * t[2] + i * t[6] + n * t[10] + a * t[14], this.mat4[7] = r * t[3] + i * t[7] + n * t[11] + a * t[15], r = this.mat4[8], i = this.mat4[9], n = this.mat4[10], a = this.mat4[11], this.mat4[8] = r * t[0] + i * t[4] + n * t[8] + a * t[12], this.mat4[9] = r * t[1] + i * t[5] + n * t[9] + a * t[13], this.mat4[10] = r * t[2] + i * t[6] + n * t[10] + a * t[14], this.mat4[11] = r * t[3] + i * t[7] + n * t[11] + a * t[15], r = this.mat4[12], i = this.mat4[13], n = this.mat4[14], a = this.mat4[15], this.mat4[12] = r * t[0] + i * t[4] + n * t[8] + a * t[12], this.mat4[13] = r * t[1] + i * t[5] + n * t[9] + a * t[13], this.mat4[14] = r * t[2] + i * t[6] + n * t[10] + a * t[14], this.mat4[15] = r * t[3] + i * t[7] + n * t[11] + a * t[15], this;
      }, P.default.Matrix.prototype.apply = function (e) {
        var t;
        if (e === this || e === this.mat4) t = this.copy().mat4;else if (e instanceof P.default.Matrix) t = e.mat4;else if (R(e)) t = e;else {
          if (16 !== arguments.length) return;
          t = arguments;
        }
        var r = this.mat4,
            i = r[0],
            n = r[4],
            a = r[8],
            o = r[12];
        r[0] = t[0] * i + t[1] * n + t[2] * a + t[3] * o, r[4] = t[4] * i + t[5] * n + t[6] * a + t[7] * o, r[8] = t[8] * i + t[9] * n + t[10] * a + t[11] * o, r[12] = t[12] * i + t[13] * n + t[14] * a + t[15] * o;
        var s = r[1],
            l = r[5],
            u = r[9],
            h = r[13];
        r[1] = t[0] * s + t[1] * l + t[2] * u + t[3] * h, r[5] = t[4] * s + t[5] * l + t[6] * u + t[7] * h, r[9] = t[8] * s + t[9] * l + t[10] * u + t[11] * h, r[13] = t[12] * s + t[13] * l + t[14] * u + t[15] * h;
        var c = r[2],
            f = r[6],
            d = r[10],
            p = r[14];
        r[2] = t[0] * c + t[1] * f + t[2] * d + t[3] * p, r[6] = t[4] * c + t[5] * f + t[6] * d + t[7] * p, r[10] = t[8] * c + t[9] * f + t[10] * d + t[11] * p, r[14] = t[12] * c + t[13] * f + t[14] * d + t[15] * p;
        var m = r[3],
            v = r[7],
            y = r[11],
            g = r[15];
        return r[3] = t[0] * m + t[1] * v + t[2] * y + t[3] * g, r[7] = t[4] * m + t[5] * v + t[6] * y + t[7] * g, r[11] = t[8] * m + t[9] * v + t[10] * y + t[11] * g, r[15] = t[12] * m + t[13] * v + t[14] * y + t[15] * g, this;
      }, P.default.Matrix.prototype.scale = function (e, t, r) {
        return e instanceof P.default.Vector ? (t = e.y, r = e.z, e = e.x) : e instanceof Array && (t = e[1], r = e[2], e = e[0]), this.mat4[0] *= e, this.mat4[1] *= e, this.mat4[2] *= e, this.mat4[3] *= e, this.mat4[4] *= t, this.mat4[5] *= t, this.mat4[6] *= t, this.mat4[7] *= t, this.mat4[8] *= r, this.mat4[9] *= r, this.mat4[10] *= r, this.mat4[11] *= r, this;
      }, P.default.Matrix.prototype.rotate = function (e, t, r, i) {
        t instanceof P.default.Vector ? (r = t.y, i = t.z, t = t.x) : t instanceof Array && (r = t[1], i = t[2], t = t[0]);
        var n = Math.sqrt(t * t + r * r + i * i);
        t *= 1 / n, r *= 1 / n, i *= 1 / n;

        var a = this.mat4[0],
            o = this.mat4[1],
            s = this.mat4[2],
            l = this.mat4[3],
            u = this.mat4[4],
            h = this.mat4[5],
            c = this.mat4[6],
            f = this.mat4[7],
            d = this.mat4[8],
            p = this.mat4[9],
            m = this.mat4[10],
            v = this.mat4[11],
            y = Math.sin(e),
            g = Math.cos(e),
            b = 1 - g,
            _ = t * t * b + g,
            x = r * t * b + i * y,
            w = i * t * b - r * y,
            S = t * r * b - i * y,
            M = r * r * b + g,
            T = i * r * b + t * y,
            E = t * i * b + r * y,
            C = r * i * b - t * y,
            L = i * i * b + g;

        return this.mat4[0] = a * _ + u * x + d * w, this.mat4[1] = o * _ + h * x + p * w, this.mat4[2] = s * _ + c * x + m * w, this.mat4[3] = l * _ + f * x + v * w, this.mat4[4] = a * S + u * M + d * T, this.mat4[5] = o * S + h * M + p * T, this.mat4[6] = s * S + c * M + m * T, this.mat4[7] = l * S + f * M + v * T, this.mat4[8] = a * E + u * C + d * L, this.mat4[9] = o * E + h * C + p * L, this.mat4[10] = s * E + c * C + m * L, this.mat4[11] = l * E + f * C + v * L, this;
      }, P.default.Matrix.prototype.translate = function (e) {
        var t = e[0],
            r = e[1],
            i = e[2] || 0;
        this.mat4[12] += this.mat4[0] * t + this.mat4[4] * r + this.mat4[8] * i, this.mat4[13] += this.mat4[1] * t + this.mat4[5] * r + this.mat4[9] * i, this.mat4[14] += this.mat4[2] * t + this.mat4[6] * r + this.mat4[10] * i, this.mat4[15] += this.mat4[3] * t + this.mat4[7] * r + this.mat4[11] * i;
      }, P.default.Matrix.prototype.rotateX = function (e) {
        this.rotate(e, 1, 0, 0);
      }, P.default.Matrix.prototype.rotateY = function (e) {
        this.rotate(e, 0, 1, 0);
      }, P.default.Matrix.prototype.rotateZ = function (e) {
        this.rotate(e, 0, 0, 1);
      }, P.default.Matrix.prototype.perspective = function (e, t, r, i) {
        var n = 1 / Math.tan(e / 2),
            a = 1 / (r - i);
        return this.mat4[0] = n / t, this.mat4[1] = 0, this.mat4[2] = 0, this.mat4[3] = 0, this.mat4[4] = 0, this.mat4[5] = n, this.mat4[6] = 0, this.mat4[7] = 0, this.mat4[8] = 0, this.mat4[9] = 0, this.mat4[10] = (i + r) * a, this.mat4[11] = -1, this.mat4[12] = 0, this.mat4[13] = 0, this.mat4[14] = 2 * i * r * a, this.mat4[15] = 0, this;
      }, P.default.Matrix.prototype.ortho = function (e, t, r, i, n, a) {
        var o = 1 / (e - t),
            s = 1 / (r - i),
            l = 1 / (n - a);
        return this.mat4[0] = -2 * o, this.mat4[1] = 0, this.mat4[2] = 0, this.mat4[3] = 0, this.mat4[4] = 0, this.mat4[5] = -2 * s, this.mat4[6] = 0, this.mat4[7] = 0, this.mat4[8] = 0, this.mat4[9] = 0, this.mat4[10] = 2 * l, this.mat4[11] = 0, this.mat4[12] = (e + t) * o, this.mat4[13] = (i + r) * s, this.mat4[14] = (a + n) * l, this.mat4[15] = 1, this;
      };
      var a = P.default.Matrix;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    87: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      n.default.RenderBuffer = function (e, t, r, i, n, a) {
        this.size = e, this.src = t, this.dst = r, this.attr = i, this._renderer = n, this.map = a;
      }, n.default.RenderBuffer.prototype._prepareBuffer = function (e, t) {
        var r,
            i = t.attributes,
            n = this._renderer.GL;
        r = e.model ? e.model : e;
        var a = i[this.attr];

        if (a) {
          var o = e[this.dst],
              s = r[this.src];

          if (0 < s.length) {
            var l = !o;

            if (l && (e[this.dst] = o = n.createBuffer()), n.bindBuffer(n.ARRAY_BUFFER, o), l || !1 !== r.dirtyFlags[this.src]) {
              var u = this.map,
                  h = u ? u(s) : s;
              this._renderer._bindBuffer(o, n.ARRAY_BUFFER, h), r.dirtyFlags[this.src] = !1;
            }

            t.enableAttrib(a, this.size);
          }
        }
      };
      var a = n.default.RenderBuffer;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    88: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var i,
          s = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      },
          l = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = u();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../core/constants"));

      function u() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return u = function () {
          return e;
        }, e;
      }

      e("./p5.RenderBuffer"), s.default.RendererGL.prototype.beginShape = function (e) {
        return this.immediateMode.shapeMode = void 0 !== e ? e : l.TRIANGLE_FAN, this.immediateMode.geometry.reset(), this;
      }, s.default.RendererGL.prototype.vertex = function (e, t) {
        var r, i, n;
        r = i = n = 0, 3 === arguments.length ? r = arguments[2] : 4 === arguments.length ? (i = arguments[2], n = arguments[3]) : 5 === arguments.length && (r = arguments[2], i = arguments[3], n = arguments[4]);
        var a = new s.default.Vector(e, t, r);
        this.immediateMode.geometry.vertices.push(a);
        var o = this.curFillColor || [.5, .5, .5, 1];
        return this.immediateMode.geometry.vertexColors.push(o[0], o[1], o[2], o[3]), this.textureMode === l.IMAGE && (null !== this._tex ? 0 < this._tex.width && 0 < this._tex.height && (i /= this._tex.width, n /= this._tex.height) : null === this._tex && 4 <= arguments.length && console.warn("You must first call texture() before using vertex() with image based u and v coordinates")), this.immediateMode.geometry.uvs.push(i, n), this.immediateMode._bezierVertex[0] = e, this.immediateMode._bezierVertex[1] = t, this.immediateMode._bezierVertex[2] = r, this.immediateMode._quadraticVertex[0] = e, this.immediateMode._quadraticVertex[1] = t, this.immediateMode._quadraticVertex[2] = r, this;
      }, s.default.RendererGL.prototype.endShape = function (e, t, r, i, n, a) {
        return this.immediateMode.shapeMode === l.POINTS ? this._drawPoints(this.immediateMode.geometry.vertices, this.immediateMode.buffers.point) : (this._processVertices.apply(this, arguments), this._doFill && 1 < this.immediateMode.geometry.vertices.length && this._drawImmediateFill(), this._doStroke && 1 < this.immediateMode.geometry.lineVertices.length && this._drawImmediateStroke(), this.isBezier = !1, this.isQuadratic = !1, this.isCurve = !1, this.immediateMode._bezierVertex.length = 0, this.immediateMode._quadraticVertex.length = 0, this.immediateMode._curveVertex.length = 0), this;
      }, s.default.RendererGL.prototype._processVertices = function (e) {
        if (0 !== this.immediateMode.geometry.vertices.length) {
          var t = this._doStroke && this.drawMode !== l.TEXTURE,
              r = e === l.CLOSE;
          t && (this.immediateMode.geometry.edges = this._calculateEdges(this.immediateMode.shapeMode, this.immediateMode.geometry.vertices, r), this.immediateMode.geometry._edgesToVertices());
          var i = this.immediateMode.shapeMode === l.TESS;
          (this.isBezier || this.isQuadratic || this.isCurve || i) && this.immediateMode.shapeMode !== l.LINES && this._tesselateShape();
        }
      }, s.default.RendererGL.prototype._calculateEdges = function (e, t, r) {
        var i = [],
            n = 0;

        switch (e) {
          case l.TRIANGLE_STRIP:
            for (n = 0; n < t.length - 2; n++) i.push([n, n + 1]), i.push([n, n + 2]);

            i.push([n, n + 1]);
            break;

          case l.TRIANGLES:
            for (n = 0; n < t.length - 2; n += 3) i.push([n, n + 1]), i.push([n + 1, n + 2]), i.push([n + 2, n]);

            break;

          case l.LINES:
            for (n = 0; n < t.length - 1; n += 2) i.push([n, n + 1]);

            break;

          default:
            for (n = 0; n < t.length - 1; n++) i.push([n, n + 1]);

        }

        return r && i.push([t.length - 1, 0]), i;
      }, s.default.RendererGL.prototype._tesselateShape = function () {
        this.immediateMode.shapeMode = l.TRIANGLES;

        var e = [new Float32Array(this._vToNArray(this.immediateMode.geometry.vertices))],
            t = this._triangulate(e);

        this.immediateMode.geometry.vertices = [];

        for (var r = 0, i = t.length; r < i; r += 3) this.vertex(t[r], t[r + 1], t[r + 2]);
      }, s.default.RendererGL.prototype._drawImmediateFill = function () {
        var e = this.GL,
            t = this._getImmediateFillShader();

        this._calculateNormals(this.immediateMode.geometry), this._setFillUniforms(t);
        var r = !0,
            i = !1,
            n = void 0;

        try {
          for (var a, o = this.immediateMode.buffers.fill[Symbol.iterator](); !(r = (a = o.next()).done); r = !0) {
            a.value._prepareBuffer(this.immediateMode.geometry, t);
          }
        } catch (e) {
          i = !0, n = e;
        } finally {
          try {
            r || null == o.return || o.return();
          } finally {
            if (i) throw n;
          }
        }

        this.immediateMode.shapeMode !== l.LINE_STRIP && this.immediateMode.shapeMode !== l.LINES || (this.immediateMode.shapeMode = l.TRIANGLE_FAN), this._applyColorBlend(this.curFillColor), e.drawArrays(this.immediateMode.shapeMode, 0, this.immediateMode.geometry.vertices.length), t.unbindShader();
      }, s.default.RendererGL.prototype._drawImmediateStroke = function () {
        var e = this.GL,
            t = this._getImmediateStrokeShader();

        this._setStrokeUniforms(t);

        var r = !0,
            i = !1,
            n = void 0;

        try {
          for (var a, o = this.immediateMode.buffers.stroke[Symbol.iterator](); !(r = (a = o.next()).done); r = !0) {
            a.value._prepareBuffer(this.immediateMode.geometry, t);
          }
        } catch (e) {
          i = !0, n = e;
        } finally {
          try {
            r || null == o.return || o.return();
          } finally {
            if (i) throw n;
          }
        }

        this._applyColorBlend(this.curStrokeColor), e.drawArrays(e.TRIANGLES, 0, this.immediateMode.geometry.lineVertices.length), t.unbindShader();
      }, s.default.RendererGL.prototype._calculateNormals = function (e) {
        e.vertices.forEach(function () {
          e.vertexNormals.push(new s.default.Vector(0, 0, 1));
        });
      };
      var n = s.default.RendererGL;
      r.default = n;
    }, {
      "../core/constants": 26,
      "../core/main": 36,
      "./p5.RenderBuffer": 87
    }],
    89: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          o = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      e("./p5.RendererGL"), e("./p5.RenderBuffer");
      var n = 0;
      o.default.RendererGL.prototype._initBufferDefaults = function (e) {
        if (this._freeBuffers(e), 1e3 < ++n) {
          var t = Object.keys(this.retainedMode.geometry)[0];
          delete this.retainedMode.geometry[t], n--;
        }

        return this.retainedMode.geometry[e] = {};
      }, o.default.RendererGL.prototype._freeBuffers = function (e) {
        var s = this.retainedMode.geometry[e];

        if (s) {
          delete this.retainedMode.geometry[e], n--;
          var l = this.GL;
          s.indexBuffer && l.deleteBuffer(s.indexBuffer), t(this.retainedMode.buffers.stroke), t(this.retainedMode.buffers.fill);
        }

        function t(e) {
          var t = !0,
              r = !1,
              i = void 0;

          try {
            for (var n, a = e[Symbol.iterator](); !(t = (n = a.next()).done); t = !0) {
              var o = n.value;
              s[o.dst] && (l.deleteBuffer(s[o.dst]), s[o.dst] = null);
            }
          } catch (e) {
            r = !0, i = e;
          } finally {
            try {
              t || null == a.return || a.return();
            } finally {
              if (r) throw i;
            }
          }
        }
      }, o.default.RendererGL.prototype.createBuffers = function (e, t) {
        var r = this.GL,
            i = this._initBufferDefaults(e);

        i.model = t;
        var n = i.indexBuffer;

        if (t.faces.length) {
          n = n || (i.indexBuffer = r.createBuffer());

          var a = o.default.RendererGL.prototype._flatten(t.faces);

          this._bindBuffer(n, r.ELEMENT_ARRAY_BUFFER, a, Uint16Array), i.vertexCount = 3 * t.faces.length;
        } else n && (r.deleteBuffer(n), i.indexBuffer = null), i.vertexCount = t.vertices ? t.vertices.length : 0;

        return i.lineVertexCount = t.lineVertices ? t.lineVertices.length : 0, i;
      }, o.default.RendererGL.prototype.drawBuffers = function (e) {
        var t = this.GL,
            r = this.retainedMode.geometry[e];

        if (this._doStroke && 0 < r.lineVertexCount) {
          var i = this._getRetainedStrokeShader();

          this._setStrokeUniforms(i);

          var n = !0,
              a = !1,
              o = void 0;

          try {
            for (var s, l = this.retainedMode.buffers.stroke[Symbol.iterator](); !(n = (s = l.next()).done); n = !0) {
              s.value._prepareBuffer(r, i);
            }
          } catch (e) {
            a = !0, o = e;
          } finally {
            try {
              n || null == l.return || l.return();
            } finally {
              if (a) throw o;
            }
          }

          this._applyColorBlend(this.curStrokeColor), this._drawArrays(t.TRIANGLES, e), i.unbindShader();
        }

        if (this._doFill) {
          var u = this._getRetainedFillShader();

          this._setFillUniforms(u);

          var h = !0,
              c = !1,
              f = void 0;

          try {
            for (var d, p = this.retainedMode.buffers.fill[Symbol.iterator](); !(h = (d = p.next()).done); h = !0) {
              d.value._prepareBuffer(r, u);
            }
          } catch (e) {
            c = !0, f = e;
          } finally {
            try {
              h || null == p.return || p.return();
            } finally {
              if (c) throw f;
            }
          }

          r.indexBuffer && this._bindBuffer(r.indexBuffer, t.ELEMENT_ARRAY_BUFFER), this._applyColorBlend(this.curFillColor), this._drawElements(t.TRIANGLES, e), u.unbindShader();
        }

        return this;
      }, o.default.RendererGL.prototype.drawBuffersScaled = function (e, t, r, i) {
        var n = this.uMVMatrix.copy();

        try {
          this.uMVMatrix.scale(t, r, i), this.drawBuffers(e);
        } finally {
          this.uMVMatrix = n;
        }
      }, o.default.RendererGL.prototype._drawArrays = function (e, t) {
        return this.GL.drawArrays(e, 0, this.retainedMode.geometry[t].lineVertexCount), this;
      }, o.default.RendererGL.prototype._drawElements = function (e, t) {
        var r = this.retainedMode.geometry[t],
            i = this.GL;
        r.indexBuffer ? i.drawElements(i.TRIANGLES, r.vertexCount, i.UNSIGNED_SHORT, 0) : i.drawArrays(e || i.TRIANGLES, 0, r.vertexCount);
      }, o.default.RendererGL.prototype._drawPoints = function (e, t) {
        var r = this.GL,
            i = this._getImmediatePointShader();

        this._setPointUniforms(i), this._bindBuffer(t, r.ARRAY_BUFFER, this._vToNArray(e), Float32Array, r.STATIC_DRAW), i.enableAttrib(i.attributes.aPosition, 3), r.drawArrays(r.Points, 0, e.length), i.unbindShader();
      };
      var a = o.default.RendererGL;
      r.default = a;
    }, {
      "../core/main": 36,
      "./p5.RenderBuffer": 87,
      "./p5.RendererGL": 90
    }],
    90: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var u = n(e("../core/main")),
          a = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../core/constants")),
          i = n(e("libtess"));

      e("./p5.Shader"), e("./p5.Camera"), e("../core/p5.Renderer"), e("./p5.Matrix");
      e("path");

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      function n(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      function l(e) {
        return function (e) {
          if (Array.isArray(e)) {
            for (var t = 0, r = new Array(e.length); t < e.length; t++) r[t] = e[t];

            return r;
          }
        }(e) || function (e) {
          if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e);
        }(e) || function () {
          throw new TypeError("Invalid attempt to spread non-iterable instance");
        }();
      }

      var h = "precision highp float;\nprecision highp int;\n\nuniform mat4 uViewMatrix;\n\nuniform bool uUseLighting;\n\nuniform int uAmbientLightCount;\nuniform vec3 uAmbientColor[5];\n\nuniform int uDirectionalLightCount;\nuniform vec3 uLightingDirection[5];\nuniform vec3 uDirectionalDiffuseColors[5];\nuniform vec3 uDirectionalSpecularColors[5];\n\nuniform int uPointLightCount;\nuniform vec3 uPointLightLocation[5];\nuniform vec3 uPointLightDiffuseColors[5];\t\nuniform vec3 uPointLightSpecularColors[5];\n\nuniform int uSpotLightCount;\nuniform float uSpotLightAngle[5];\nuniform float uSpotLightConc[5];\nuniform vec3 uSpotLightDiffuseColors[5];\nuniform vec3 uSpotLightSpecularColors[5];\nuniform vec3 uSpotLightLocation[5];\nuniform vec3 uSpotLightDirection[5];\n\nuniform bool uSpecular;\nuniform float uShininess;\n\nuniform float uConstantAttenuation;\nuniform float uLinearAttenuation;\nuniform float uQuadraticAttenuation;\n\nconst float specularFactor = 2.0;\nconst float diffuseFactor = 0.73;\n\nstruct LightResult {\n  float specular;\n  float diffuse;\n};\n\nfloat _phongSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n\n  vec3 R = reflect(lightDirection, surfaceNormal);\n  return pow(max(0.0, dot(R, viewDirection)), shininess);\n}\n\nfloat _lambertDiffuse(vec3 lightDirection, vec3 surfaceNormal) {\n  return max(0.0, dot(-lightDirection, surfaceNormal));\n}\n\nLightResult _light(vec3 viewDirection, vec3 normal, vec3 lightVector) {\n\n  vec3 lightDir = normalize(lightVector);\n\n  //compute our diffuse & specular terms\n  LightResult lr;\n  if (uSpecular)\n    lr.specular = _phongSpecular(lightDir, viewDirection, normal, uShininess);\n  lr.diffuse = _lambertDiffuse(lightDir, normal);\n  return lr;\n}\n\nvoid totalLight(\n  vec3 modelPosition,\n  vec3 normal,\n  out vec3 totalDiffuse,\n  out vec3 totalSpecular\n) {\n\n  totalSpecular = vec3(0.0);\n\n  if (!uUseLighting) {\n    totalDiffuse = vec3(1.0);\n    return;\n  }\n\n  totalDiffuse = vec3(0.0);\n\n  vec3 viewDirection = normalize(-modelPosition);\n\n  for (int j = 0; j < 5; j++) {\n    if (j < uDirectionalLightCount) {\n      vec3 lightVector = (uViewMatrix * vec4(uLightingDirection[j], 0.0)).xyz;\n      vec3 lightColor = uDirectionalDiffuseColors[j];\n      vec3 specularColor = uDirectionalSpecularColors[j];\n      LightResult result = _light(viewDirection, normal, lightVector);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if (j < uPointLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uPointLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n    \n      //calculate attenuation\n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n      vec3 lightColor = lightFalloff * uPointLightDiffuseColors[j];\n      vec3 specularColor = lightFalloff * uPointLightSpecularColors[j];\n\n      LightResult result = _light(viewDirection, normal, lightVector);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if(j < uSpotLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uSpotLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n    \n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n\n      vec3 lightDirection = (uViewMatrix * vec4(uSpotLightDirection[j], 0.0)).xyz;\n      float spotDot = dot(normalize(lightVector), normalize(lightDirection));\n      float spotFalloff;\n      if(spotDot < uSpotLightAngle[j]) {\n        spotFalloff = 0.0;\n      }\n      else {\n        spotFalloff = pow(spotDot, uSpotLightConc[j]);\n      }\n      lightFalloff *= spotFalloff;\n\n      vec3 lightColor = uSpotLightDiffuseColors[j];\n      vec3 specularColor = uSpotLightSpecularColors[j];\n     \n      LightResult result = _light(viewDirection, normal, lightVector);\n      \n      totalDiffuse += result.diffuse * lightColor * lightFalloff;\n      totalSpecular += result.specular * lightColor * specularColor * lightFalloff;\n    }\n  }\n\n  totalDiffuse *= diffuseFactor;\n  totalSpecular *= specularFactor;\n}\n",
          c = {
        immediateVert: "attribute vec3 aPosition;\nattribute vec4 aVertexColor;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float uResolution;\nuniform float uPointSize;\n\nvarying vec4 vColor;\nvoid main(void) {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vColor = aVertexColor;\n  gl_PointSize = uPointSize;\n}\n",
        vertexColorVert: "attribute vec3 aPosition;\nattribute vec4 aVertexColor;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vColor = aVertexColor;\n}\n",
        vertexColorFrag: "precision mediump float;\nvarying vec4 vColor;\nvoid main(void) {\n  gl_FragColor = vColor;\n}",
        normalVert: "attribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nvarying vec3 vVertexNormal;\nvarying highp vec2 vVertTexCoord;\n\nvoid main(void) {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vVertexNormal = normalize(vec3( uNormalMatrix * aNormal ));\n  vVertTexCoord = aTexCoord;\n}\n",
        normalFrag: "precision mediump float;\nvarying vec3 vVertexNormal;\nvoid main(void) {\n  gl_FragColor = vec4(vVertexNormal, 1.0);\n}",
        basicFrag: "precision mediump float;\nuniform vec4 uMaterialColor;\nvoid main(void) {\n  gl_FragColor = uMaterialColor;\n}",
        lightVert: h + "// include lighting.glgl\n\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nvarying highp vec2 vVertTexCoord;\nvarying vec3 vDiffuseColor;\nvarying vec3 vSpecularColor;\n\nvoid main(void) {\n\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * viewModelPosition;\n\n  vec3 vertexNormal = normalize(uNormalMatrix * aNormal);\n  vVertTexCoord = aTexCoord;\n\n  totalLight(viewModelPosition.xyz, vertexNormal, vDiffuseColor, vSpecularColor);\n\n  for (int i = 0; i < 8; i++) {\n    if (i < uAmbientLightCount) {\n      vDiffuseColor += uAmbientColor[i];\n    }\n  }\n}\n",
        lightTextureFrag: "precision highp float;\n\nuniform vec4 uMaterialColor;\nuniform vec4 uTint;\nuniform sampler2D uSampler;\nuniform bool isTexture;\nuniform bool uEmissive;\n\nvarying highp vec2 vVertTexCoord;\nvarying vec3 vDiffuseColor;\nvarying vec3 vSpecularColor;\n\nvoid main(void) {\n  if(uEmissive && !isTexture) {\n    gl_FragColor = uMaterialColor;\n  }\n  else {\n    gl_FragColor = isTexture ? texture2D(uSampler, vVertTexCoord) * (uTint / vec4(255, 255, 255, 255)) : uMaterialColor;\n    gl_FragColor.rgb = gl_FragColor.rgb * vDiffuseColor + vSpecularColor;\n  }\n}",
        phongVert: "precision highp float;\nprecision highp int;\n\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nuniform vec3 uAmbientColor[5];\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform int uAmbientLightCount;\n\nvarying vec3 vNormal;\nvarying vec2 vTexCoord;\nvarying vec3 vViewPosition;\nvarying vec3 vAmbientColor;\n\nvoid main(void) {\n\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n\n  // Pass varyings to fragment shader\n  vViewPosition = viewModelPosition.xyz;\n  gl_Position = uProjectionMatrix * viewModelPosition;  \n\n  vNormal = uNormalMatrix * aNormal;\n  vTexCoord = aTexCoord;\n\n  // TODO: this should be a uniform\n  vAmbientColor = vec3(0.0);\n  for (int i = 0; i < 5; i++) {\n    if (i < uAmbientLightCount) {\n      vAmbientColor += uAmbientColor[i];\n    }\n  }\n}\n",
        phongFrag: h + "// include lighting.glsl\nprecision highp float;\nprecision highp int;\n\nuniform vec4 uMaterialColor;\nuniform vec4 uTint;\nuniform sampler2D uSampler;\nuniform bool isTexture;\nuniform bool uEmissive;\n\nvarying vec3 vNormal;\nvarying vec2 vTexCoord;\nvarying vec3 vViewPosition;\nvarying vec3 vAmbientColor;\n\nvoid main(void) {\n\n  vec3 diffuse;\n  vec3 specular;\n  totalLight(vViewPosition, normalize(vNormal), diffuse, specular);\n\n  if(uEmissive && !isTexture) {\n    gl_FragColor = uMaterialColor;\n  }\n  else {\n    gl_FragColor = isTexture ? texture2D(uSampler, vTexCoord) * (uTint / vec4(255, 255, 255, 255)) : uMaterialColor;\n    gl_FragColor.rgb = gl_FragColor.rgb * (diffuse + vAmbientColor) + specular;\n  }\n}",
        fontVert: "precision mediump float;\n\nattribute vec3 aPosition;\nattribute vec2 aTexCoord;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nuniform vec4 uGlyphRect;\nuniform float uGlyphOffset;\n\nvarying vec2 vTexCoord;\nvarying float w;\n\nvoid main() {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n\n  // scale by the size of the glyph's rectangle\n  positionVec4.xy *= uGlyphRect.zw - uGlyphRect.xy;\n\n  // move to the corner of the glyph\n  positionVec4.xy += uGlyphRect.xy;\n\n  // move to the letter's line offset\n  positionVec4.x += uGlyphOffset;\n  \n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vTexCoord = aTexCoord;\n  w = gl_Position.w;\n}\n",
        fontFrag: "#extension GL_OES_standard_derivatives : enable\nprecision mediump float;\n\n#if 0\n  // simulate integer math using floats\n\t#define int float\n\t#define ivec2 vec2\n\t#define INT(x) float(x)\n\n\tint ifloor(float v) { return floor(v); }\n\tivec2 ifloor(vec2 v) { return floor(v); }\n\n#else\n  // use native integer math\n\tprecision highp int;\n\t#define INT(x) x\n\n\tint ifloor(float v) { return int(v); }\n\tint ifloor(int v) { return v; }\n\tivec2 ifloor(vec2 v) { return ivec2(v); }\n\n#endif\n\nuniform sampler2D uSamplerStrokes;\nuniform sampler2D uSamplerRowStrokes;\nuniform sampler2D uSamplerRows;\nuniform sampler2D uSamplerColStrokes;\nuniform sampler2D uSamplerCols;\n\nuniform ivec2 uStrokeImageSize;\nuniform ivec2 uCellsImageSize;\nuniform ivec2 uGridImageSize;\n\nuniform ivec2 uGridOffset;\nuniform ivec2 uGridSize;\nuniform vec4 uMaterialColor;\n\nvarying vec2 vTexCoord;\n\n// some helper functions\nint round(float v) { return ifloor(v + 0.5); }\nivec2 round(vec2 v) { return ifloor(v + 0.5); }\nfloat saturate(float v) { return clamp(v, 0.0, 1.0); }\nvec2 saturate(vec2 v) { return clamp(v, 0.0, 1.0); }\n\nint mul(float v1, int v2) {\n  return ifloor(v1 * float(v2));\n}\n\nivec2 mul(vec2 v1, ivec2 v2) {\n  return ifloor(v1 * vec2(v2) + 0.5);\n}\n\n// unpack a 16-bit integer from a float vec2\nint getInt16(vec2 v) {\n  ivec2 iv = round(v * 255.0);\n  return iv.x * INT(128) + iv.y;\n}\n\nvec2 pixelScale;\nvec2 coverage = vec2(0.0);\nvec2 weight = vec2(0.5);\nconst float minDistance = 1.0/8192.0;\nconst float hardness = 1.05; // amount of antialias\n\n// the maximum number of curves in a glyph\nconst int N = INT(250);\n\n// retrieves an indexed pixel from a sampler\nvec4 getTexel(sampler2D sampler, int pos, ivec2 size) {\n  int width = size.x;\n  int y = ifloor(pos / width);\n  int x = pos - y * width;  // pos % width\n\n  return texture2D(sampler, (vec2(x, y) + 0.5) / vec2(size));\n}\n\nvoid calulateCrossings(vec2 p0, vec2 p1, vec2 p2, out vec2 C1, out vec2 C2) {\n\n  // get the coefficients of the quadratic in t\n  vec2 a = p0 - p1 * 2.0 + p2;\n  vec2 b = p0 - p1;\n  vec2 c = p0 - vTexCoord;\n\n  // found out which values of 't' it crosses the axes\n  vec2 surd = sqrt(max(vec2(0.0), b * b - a * c));\n  vec2 t1 = ((b - surd) / a).yx;\n  vec2 t2 = ((b + surd) / a).yx;\n\n  // approximate straight lines to avoid rounding errors\n  if (abs(a.y) < 0.001)\n    t1.x = t2.x = c.y / (2.0 * b.y);\n\n  if (abs(a.x) < 0.001)\n    t1.y = t2.y = c.x / (2.0 * b.x);\n\n  // plug into quadratic formula to find the corrdinates of the crossings\n  C1 = ((a * t1 - b * 2.0) * t1 + c) * pixelScale;\n  C2 = ((a * t2 - b * 2.0) * t2 + c) * pixelScale;\n}\n\nvoid coverageX(vec2 p0, vec2 p1, vec2 p2) {\n\n  vec2 C1, C2;\n  calulateCrossings(p0, p1, p2, C1, C2);\n\n  // determine on which side of the x-axis the points lie\n  bool y0 = p0.y > vTexCoord.y;\n  bool y1 = p1.y > vTexCoord.y;\n  bool y2 = p2.y > vTexCoord.y;\n\n  // could web be under the curve (after t1)?\n  if (y1 ? !y2 : y0) {\n    // add the coverage for t1\n    coverage.x += saturate(C1.x + 0.5);\n    // calculate the anti-aliasing for t1\n    weight.x = min(weight.x, abs(C1.x));\n  }\n\n  // are we outside the curve (after t2)?\n  if (y1 ? !y0 : y2) {\n    // subtract the coverage for t2\n    coverage.x -= saturate(C2.x + 0.5);\n    // calculate the anti-aliasing for t2\n    weight.x = min(weight.x, abs(C2.x));\n  }\n}\n\n// this is essentially the same as coverageX, but with the axes swapped\nvoid coverageY(vec2 p0, vec2 p1, vec2 p2) {\n\n  vec2 C1, C2;\n  calulateCrossings(p0, p1, p2, C1, C2);\n\n  bool x0 = p0.x > vTexCoord.x;\n  bool x1 = p1.x > vTexCoord.x;\n  bool x2 = p2.x > vTexCoord.x;\n\n  if (x1 ? !x2 : x0) {\n    coverage.y -= saturate(C1.y + 0.5);\n    weight.y = min(weight.y, abs(C1.y));\n  }\n\n  if (x1 ? !x0 : x2) {\n    coverage.y += saturate(C2.y + 0.5);\n    weight.y = min(weight.y, abs(C2.y));\n  }\n}\n\nvoid main() {\n\n  // calculate the pixel scale based on screen-coordinates\n  pixelScale = hardness / fwidth(vTexCoord);\n\n  // which grid cell is this pixel in?\n  ivec2 gridCoord = ifloor(vTexCoord * vec2(uGridSize));\n\n  // intersect curves in this row\n  {\n    // the index into the row info bitmap\n    int rowIndex = gridCoord.y + uGridOffset.y;\n    // fetch the info texel\n    vec4 rowInfo = getTexel(uSamplerRows, rowIndex, uGridImageSize);\n    // unpack the rowInfo\n    int rowStrokeIndex = getInt16(rowInfo.xy);\n    int rowStrokeCount = getInt16(rowInfo.zw);\n\n    for (int iRowStroke = INT(0); iRowStroke < N; iRowStroke++) {\n      if (iRowStroke >= rowStrokeCount)\n        break;\n\n      // each stroke is made up of 3 points: the start and control point\n      // and the start of the next curve.\n      // fetch the indices of this pair of strokes:\n      vec4 strokeIndices = getTexel(uSamplerRowStrokes, rowStrokeIndex++, uCellsImageSize);\n\n      // unpack the stroke index\n      int strokePos = getInt16(strokeIndices.xy);\n\n      // fetch the two strokes\n      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);\n      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);\n\n      // calculate the coverage\n      coverageX(stroke0.xy, stroke0.zw, stroke1.xy);\n    }\n  }\n\n  // intersect curves in this column\n  {\n    int colIndex = gridCoord.x + uGridOffset.x;\n    vec4 colInfo = getTexel(uSamplerCols, colIndex, uGridImageSize);\n    int colStrokeIndex = getInt16(colInfo.xy);\n    int colStrokeCount = getInt16(colInfo.zw);\n    \n    for (int iColStroke = INT(0); iColStroke < N; iColStroke++) {\n      if (iColStroke >= colStrokeCount)\n        break;\n\n      vec4 strokeIndices = getTexel(uSamplerColStrokes, colStrokeIndex++, uCellsImageSize);\n\n      int strokePos = getInt16(strokeIndices.xy);\n      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);\n      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);\n      coverageY(stroke0.xy, stroke0.zw, stroke1.xy);\n    }\n  }\n\n  weight = saturate(1.0 - weight * 2.0);\n  float distance = max(weight.x + weight.y, minDistance); // manhattan approx.\n  float antialias = abs(dot(coverage, weight) / distance);\n  float cover = min(abs(coverage.x), abs(coverage.y));\n  gl_FragColor = uMaterialColor;\n  gl_FragColor.a *= saturate(max(antialias, cover));\n}",
        lineVert: "/*\n  Part of the Processing project - http://processing.org\n  Copyright (c) 2012-15 The Processing Foundation\n  Copyright (c) 2004-12 Ben Fry and Casey Reas\n  Copyright (c) 2001-04 Massachusetts Institute of Technology\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation, version 2.1.\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n  You should have received a copy of the GNU Lesser General\n  Public License along with this library; if not, write to the\n  Free Software Foundation, Inc., 59 Temple Place, Suite 330,\n  Boston, MA  02111-1307  USA\n*/\n\n#define PROCESSING_LINE_SHADER\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float uStrokeWeight;\n\nuniform vec4 uViewport;\nuniform int uPerspective;\n\nattribute vec4 aPosition;\nattribute vec4 aDirection;\n  \nvoid main() {\n  // using a scale <1 moves the lines towards the camera\n  // in order to prevent popping effects due to half of\n  // the line disappearing behind the geometry faces.\n  vec3 scale = vec3(0.9995);\n\n  vec4 posp = uModelViewMatrix * aPosition;\n  vec4 posq = uModelViewMatrix * (aPosition + vec4(aDirection.xyz, 0));\n\n  // Moving vertices slightly toward the camera\n  // to avoid depth-fighting with the fill triangles.\n  // Discussed here:\n  // http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&Number=252848  \n  posp.xyz = posp.xyz * scale;\n  posq.xyz = posq.xyz * scale;\n\n  vec4 p = uProjectionMatrix * posp;\n  vec4 q = uProjectionMatrix * posq;\n\n  // formula to convert from clip space (range -1..1) to screen space (range 0..[width or height])\n  // screen_p = (p.xy/p.w + <1,1>) * 0.5 * uViewport.zw\n\n  // prevent division by W by transforming the tangent formula (div by 0 causes\n  // the line to disappear, see https://github.com/processing/processing/issues/5183)\n  // t = screen_q - screen_p\n  //\n  // tangent is normalized and we don't care which aDirection it points to (+-)\n  // t = +- normalize( screen_q - screen_p )\n  // t = +- normalize( (q.xy/q.w+<1,1>)*0.5*uViewport.zw - (p.xy/p.w+<1,1>)*0.5*uViewport.zw )\n  //\n  // extract common factor, <1,1> - <1,1> cancels out\n  // t = +- normalize( (q.xy/q.w - p.xy/p.w) * 0.5 * uViewport.zw )\n  //\n  // convert to common divisor\n  // t = +- normalize( ((q.xy*p.w - p.xy*q.w) / (p.w*q.w)) * 0.5 * uViewport.zw )\n  //\n  // remove the common scalar divisor/factor, not needed due to normalize and +-\n  // (keep uViewport - can't remove because it has different components for x and y\n  //  and corrects for aspect ratio, see https://github.com/processing/processing/issues/5181)\n  // t = +- normalize( (q.xy*p.w - p.xy*q.w) * uViewport.zw )\n\n  vec2 tangent = normalize((q.xy*p.w - p.xy*q.w) * uViewport.zw);\n\n  // flip tangent to normal (it's already normalized)\n  vec2 normal = vec2(-tangent.y, tangent.x);\n\n  float thickness = aDirection.w * uStrokeWeight;\n  vec2 offset = normal * thickness / 2.0;\n\n  vec2 curPerspScale;\n\n  if(uPerspective == 1) {\n    // Perspective ---\n    // convert from world to clip by multiplying with projection scaling factor\n    // to get the right thickness (see https://github.com/processing/processing/issues/5182)\n    // invert Y, projections in Processing invert Y\n    curPerspScale = (uProjectionMatrix * vec4(1, -1, 0, 0)).xy;\n  } else {\n    // No Perspective ---\n    // multiply by W (to cancel out division by W later in the pipeline) and\n    // convert from screen to clip (derived from clip to screen above)\n    curPerspScale = p.w / (0.5 * uViewport.zw);\n  }\n\n  gl_Position.xy = p.xy + offset.xy * curPerspScale;\n  gl_Position.zw = p.zw;\n}\n",
        lineFrag: "precision mediump float;\nprecision mediump int;\n\nuniform vec4 uMaterialColor;\n\nvoid main() {\n  gl_FragColor = uMaterialColor;\n}",
        pointVert: "attribute vec3 aPosition;\nuniform float uPointSize;\nvarying float vStrokeWeight;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nvoid main() {\n\tvec4 positionVec4 =  vec4(aPosition, 1.0);\n\tgl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n\tgl_PointSize = uPointSize;\n\tvStrokeWeight = uPointSize;\n}",
        pointFrag: "precision mediump float;\nprecision mediump int;\nuniform vec4 uMaterialColor;\nvarying float vStrokeWeight;\n\nvoid main(){\n\tfloat mask = 0.0;\n\n\t// make a circular mask using the gl_PointCoord (goes from 0 - 1 on a point)\n    // might be able to get a nicer edge on big strokeweights with smoothstep but slightly less performant\n\n\tmask = step(0.98, length(gl_PointCoord * 2.0 - 1.0));\n\n\t// if strokeWeight is 1 or less lets just draw a square\n\t// this prevents weird artifacting from carving circles when our points are really small\n\t// if strokeWeight is larger than 1, we just use it as is\n\n\tmask = mix(0.0, mask, clamp(floor(vStrokeWeight - 0.5),0.0,1.0));\n\n\t// throw away the borders of the mask\n    // otherwise we get weird alpha blending issues\n\n\tif(mask > 0.98){\n      discard;\n  \t}\n\n  \tgl_FragColor = vec4(uMaterialColor.rgb * (1.0 - mask), uMaterialColor.a) ;\n}"
      };
      u.default.RendererGL = function (e, t, r, i) {
        return u.default.Renderer.call(this, e, t, r), this._setAttributeDefaults(t), this._initContext(), this.isP3D = !0, this.GL = this.drawingContext, this._pInst._setProperty("drawingContext", this.drawingContext), this._isErasing = !1, this._enableLighting = !1, this.ambientLightColors = [], this.specularColors = [1, 1, 1], this.directionalLightDirections = [], this.directionalLightDiffuseColors = [], this.directionalLightSpecularColors = [], this.pointLightPositions = [], this.pointLightDiffuseColors = [], this.pointLightSpecularColors = [], this.spotLightPositions = [], this.spotLightDirections = [], this.spotLightDiffuseColors = [], this.spotLightSpecularColors = [], this.spotLightAngle = [], this.spotLightConc = [], this.drawMode = a.FILL, this.curFillColor = this._cachedFillStyle = [1, 1, 1, 1], this.curStrokeColor = this._cachedStrokeStyle = [0, 0, 0, 1], this.curBlendMode = a.BLEND, this._cachedBlendMode = void 0, this.blendExt = this.GL.getExtension("EXT_blend_minmax"), this._isBlending = !1, this._useSpecularMaterial = !1, this._useEmissiveMaterial = !1, this._useNormalMaterial = !1, this._useShininess = 1, this._tint = [255, 255, 255, 255], this.constantAttenuation = 1, this.linearAttenuation = 0, this.quadraticAttenuation = 0, this.uMVMatrix = new u.default.Matrix(), this.uPMatrix = new u.default.Matrix(), this.uNMatrix = new u.default.Matrix("mat3"), this._curCamera = new u.default.Camera(this), this._curCamera._computeCameraDefaultSettings(), this._curCamera._setDefaultCamera(), this._defaultLightShader = void 0, this._defaultImmediateModeShader = void 0, this._defaultNormalShader = void 0, this._defaultColorShader = void 0, this._defaultPointShader = void 0, this.userFillShader = void 0, this.userStrokeShader = void 0, this.userPointShader = void 0, this.retainedMode = {
          geometry: {},
          buffers: {
            stroke: [new u.default.RenderBuffer(3, "lineVertices", "lineVertexBuffer", "aPosition", this, this._flatten), new u.default.RenderBuffer(4, "lineNormals", "lineNormalBuffer", "aDirection", this, this._flatten)],
            fill: [new u.default.RenderBuffer(3, "vertices", "vertexBuffer", "aPosition", this, this._vToNArray), new u.default.RenderBuffer(3, "vertexNormals", "normalBuffer", "aNormal", this, this._vToNArray), new u.default.RenderBuffer(4, "vertexColors", "colorBuffer", "aMaterialColor", this), new u.default.RenderBuffer(3, "vertexAmbients", "ambientBuffer", "aAmbientColor", this), new u.default.RenderBuffer(2, "uvs", "uvBuffer", "aTexCoord", this, this._flatten)],
            text: [new u.default.RenderBuffer(3, "vertices", "vertexBuffer", "aPosition", this, this._vToNArray), new u.default.RenderBuffer(2, "uvs", "uvBuffer", "aTexCoord", this, this._flatten)]
          }
        }, this.immediateMode = {
          geometry: new u.default.Geometry(),
          shapeMode: a.TRIANGLE_FAN,
          _bezierVertex: [],
          _quadraticVertex: [],
          _curveVertex: [],
          buffers: {
            fill: [new u.default.RenderBuffer(3, "vertices", "vertexBuffer", "aPosition", this, this._vToNArray), new u.default.RenderBuffer(3, "vertexNormals", "normalBuffer", "aNormal", this, this._vToNArray), new u.default.RenderBuffer(4, "vertexColors", "colorBuffer", "aVertexColor", this), new u.default.RenderBuffer(3, "vertexAmbients", "ambientBuffer", "aAmbientColor", this), new u.default.RenderBuffer(2, "uvs", "uvBuffer", "aTexCoord", this, this._flatten)],
            stroke: [new u.default.RenderBuffer(3, "lineVertices", "lineVertexBuffer", "aPosition", this, this._flatten), new u.default.RenderBuffer(4, "lineNormals", "lineNormalBuffer", "aDirection", this, this._flatten)],
            point: this.GL.createBuffer()
          }
        }, this.pointSize = 5, this.curStrokeWeight = 1, this.textures = [], this.textureMode = a.IMAGE, this.textureWrapX = a.CLAMP, this.textureWrapY = a.CLAMP, this._tex = null, this._curveTightness = 6, this._lookUpTableBezier = [], this._lookUpTableQuadratic = [], this._lutBezierDetail = 0, this._lutQuadraticDetail = 0, this._tessy = this._initTessy(), this.fontInfos = {}, this._curShader = void 0, this;
      }, u.default.RendererGL.prototype = Object.create(u.default.Renderer.prototype), u.default.RendererGL.prototype._setAttributeDefaults = function (e) {
        var t = {
          alpha: !0,
          depth: !0,
          stencil: !0,
          antialias: navigator.userAgent.toLowerCase().includes("safari"),
          premultipliedAlpha: !1,
          preserveDrawingBuffer: !0,
          perPixelLighting: !0
        };
        null === e._glAttributes ? e._glAttributes = t : e._glAttributes = Object.assign(t, e._glAttributes);
      }, u.default.RendererGL.prototype._initContext = function () {
        try {
          if (this.drawingContext = this.canvas.getContext("webgl", this._pInst._glAttributes) || this.canvas.getContext("experimental-webgl", this._pInst._glAttributes), null === this.drawingContext) throw new Error("Error creating webgl context");
          var e = this.drawingContext;
          e.enable(e.DEPTH_TEST), e.depthFunc(e.LEQUAL), e.viewport(0, 0, e.drawingBufferWidth, e.drawingBufferHeight), this._viewport = this.drawingContext.getParameter(this.drawingContext.VIEWPORT);
        } catch (e) {
          throw e;
        }
      }, u.default.RendererGL.prototype._resetContext = function (e, t) {
        var r = this.width,
            i = this.height,
            n = this.canvas.id,
            a = this._pInst instanceof u.default.Graphics;

        if (a) {
          var o = this._pInst;
          o.canvas.parentNode.removeChild(o.canvas), o.canvas = document.createElement("canvas"), (o._pInst._userNode || document.body).appendChild(o.canvas), u.default.Element.call(o, o.canvas, o._pInst), o.width = r, o.height = i;
        } else {
          var s = this.canvas;
          s && s.parentNode.removeChild(s), (s = document.createElement("canvas")).id = n, this._pInst._userNode ? this._pInst._userNode.appendChild(s) : document.body.appendChild(s), this._pInst.canvas = s;
        }

        var l = new u.default.RendererGL(this._pInst.canvas, this._pInst, !a);
        this._pInst._setProperty("_renderer", l), l.resize(r, i), l._applyDefaults(), a || this._pInst._elements.push(l), "function" == typeof t && setTimeout(function () {
          t.apply(window._renderer, e);
        }, 0);
      }, u.default.prototype.setAttributes = function (e, t) {
        if (void 0 !== this._glAttributes) {
          var r = !0;

          if (void 0 !== t ? (null === this._glAttributes && (this._glAttributes = {}), this._glAttributes[e] !== t && (this._glAttributes[e] = t, r = !1)) : e instanceof Object && this._glAttributes !== e && (this._glAttributes = e, r = !1), this._renderer.isP3D && !r) {
            if (!this._setupDone) for (var i in this._renderer.retainedMode.geometry) if (this._renderer.retainedMode.geometry.hasOwnProperty(i)) return void console.error("Sorry, Could not set the attributes, you need to call setAttributes() before calling the other drawing methods in setup()");
            this.push(), this._renderer._resetContext(), this.pop(), this._renderer._curCamera && (this._renderer._curCamera._renderer = this._renderer);
          }
        } else console.log("You are trying to use setAttributes on a p5.Graphics object that does not use a WEBGL renderer.");
      }, u.default.RendererGL.prototype._update = function () {
        this.uMVMatrix.set(this._curCamera.cameraMatrix.mat4[0], this._curCamera.cameraMatrix.mat4[1], this._curCamera.cameraMatrix.mat4[2], this._curCamera.cameraMatrix.mat4[3], this._curCamera.cameraMatrix.mat4[4], this._curCamera.cameraMatrix.mat4[5], this._curCamera.cameraMatrix.mat4[6], this._curCamera.cameraMatrix.mat4[7], this._curCamera.cameraMatrix.mat4[8], this._curCamera.cameraMatrix.mat4[9], this._curCamera.cameraMatrix.mat4[10], this._curCamera.cameraMatrix.mat4[11], this._curCamera.cameraMatrix.mat4[12], this._curCamera.cameraMatrix.mat4[13], this._curCamera.cameraMatrix.mat4[14], this._curCamera.cameraMatrix.mat4[15]), this.ambientLightColors.length = 0, this.specularColors = [1, 1, 1], this.directionalLightDirections.length = 0, this.directionalLightDiffuseColors.length = 0, this.directionalLightSpecularColors.length = 0, this.pointLightPositions.length = 0, this.pointLightDiffuseColors.length = 0, this.pointLightSpecularColors.length = 0, this.spotLightPositions.length = 0, this.spotLightDirections.length = 0, this.spotLightDiffuseColors.length = 0, this.spotLightSpecularColors.length = 0, this.spotLightAngle.length = 0, this.spotLightConc.length = 0, this._enableLighting = !1, this._tint = [255, 255, 255, 255], this.GL.clear(this.GL.DEPTH_BUFFER_BIT);
      }, u.default.RendererGL.prototype.background = function () {
        var e,
            t = (e = this._pInst).color.apply(e, arguments),
            r = t.levels[0] / 255,
            i = t.levels[1] / 255,
            n = t.levels[2] / 255,
            a = t.levels[3] / 255;

        this.GL.clearColor(r, i, n, a), this.GL.clear(this.GL.COLOR_BUFFER_BIT);
      }, u.default.RendererGL.prototype.fill = function (e, t, r, i) {
        var n = u.default.prototype.color.apply(this._pInst, arguments);
        this.curFillColor = n._array, this.drawMode = a.FILL, this._useNormalMaterial = !1, this._tex = null;
      }, u.default.RendererGL.prototype.stroke = function (e, t, r, i) {
        arguments[3] = 255;
        var n = u.default.prototype.color.apply(this._pInst, arguments);
        this.curStrokeColor = n._array;
      }, u.default.RendererGL.prototype.strokeCap = function (e) {
        console.error("Sorry, strokeCap() is not yet implemented in WEBGL mode");
      }, u.default.RendererGL.prototype.strokeJoin = function (e) {
        console.error("Sorry, strokeJoin() is not yet implemented in WEBGL mode");
      }, u.default.RendererGL.prototype.filter = function (e) {
        console.error("filter() does not work in WEBGL mode");
      }, u.default.RendererGL.prototype.blendMode = function (e) {
        e === a.DARKEST || e === a.LIGHTEST || e === a.ADD || e === a.BLEND || e === a.SUBTRACT || e === a.SCREEN || e === a.EXCLUSION || e === a.REPLACE || e === a.MULTIPLY || e === a.REMOVE ? this.curBlendMode = e : e !== a.BURN && e !== a.OVERLAY && e !== a.HARD_LIGHT && e !== a.SOFT_LIGHT && e !== a.DODGE || console.warn("BURN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, and DODGE only work for blendMode in 2D mode.");
      }, u.default.RendererGL.prototype.erase = function (e, t) {
        this._isErasing || (this._applyBlendMode(a.REMOVE), this._isErasing = !0, this._cachedFillStyle = this.curFillColor.slice(), this.curFillColor = [1, 1, 1, e / 255], this._cachedStrokeStyle = this.curStrokeColor.slice(), this.curStrokeColor = [1, 1, 1, t / 255]);
      }, u.default.RendererGL.prototype.noErase = function () {
        this._isErasing && (this._isErasing = !1, this.curFillColor = this._cachedFillStyle.slice(), this.curStrokeColor = this._cachedStrokeStyle.slice(), this.blendMode(this._cachedBlendMode));
      }, u.default.RendererGL.prototype.strokeWeight = function (e) {
        this.curStrokeWeight !== e && (this.pointSize = e, this.curStrokeWeight = e);
      }, u.default.RendererGL.prototype._getPixel = function (e, t) {
        var r;
        return r = new Uint8Array(4), this.drawingContext.readPixels(e, t, 1, 1, this.drawingContext.RGBA, this.drawingContext.UNSIGNED_BYTE, r), [r[0], r[1], r[2], r[3]];
      }, u.default.RendererGL.prototype.loadPixels = function () {
        var e = this._pixelsState;

        if (!0 === this._pInst._glAttributes.preserveDrawingBuffer) {
          var t = e.pixels,
              r = this.GL.drawingBufferWidth * this.GL.drawingBufferHeight * 4;
          t instanceof Uint8Array && t.length === r || (t = new Uint8Array(r), this._pixelsState._setProperty("pixels", t));
          var i = this._pInst._pixelDensity;
          this.GL.readPixels(0, 0, this.width * i, this.height * i, this.GL.RGBA, this.GL.UNSIGNED_BYTE, t);
        } else console.log("loadPixels only works in WebGL when preserveDrawingBuffer is true.");
      }, u.default.RendererGL.prototype.geometryInHash = function (e) {
        return void 0 !== this.retainedMode.geometry[e];
      }, u.default.RendererGL.prototype.resize = function (e, t) {
        u.default.Renderer.prototype.resize.call(this, e, t), this.GL.viewport(0, 0, this.GL.drawingBufferWidth, this.GL.drawingBufferHeight), this._viewport = this.GL.getParameter(this.GL.VIEWPORT), this._curCamera._resize();
        var r = this._pixelsState;
        void 0 !== r.pixels && r._setProperty("pixels", new Uint8Array(this.GL.drawingBufferWidth * this.GL.drawingBufferHeight * 4));
      }, u.default.RendererGL.prototype.clear = function () {
        var e = (arguments.length <= 0 ? void 0 : arguments[0]) || 0,
            t = (arguments.length <= 1 ? void 0 : arguments[1]) || 0,
            r = (arguments.length <= 2 ? void 0 : arguments[2]) || 0,
            i = (arguments.length <= 3 ? void 0 : arguments[3]) || 0;
        this.GL.clearColor(e, t, r, i), this.GL.clear(this.GL.COLOR_BUFFER_BIT | this.GL.DEPTH_BUFFER_BIT);
      }, u.default.RendererGL.prototype.applyMatrix = function (e, t, r, i, n, a) {
        16 === arguments.length ? u.default.Matrix.prototype.apply.apply(this.uMVMatrix, arguments) : this.uMVMatrix.apply([e, t, 0, 0, r, i, 0, 0, 0, 0, 1, 0, n, a, 0, 1]);
      }, u.default.RendererGL.prototype.translate = function (e, t, r) {
        return e instanceof u.default.Vector && (r = e.z, t = e.y, e = e.x), this.uMVMatrix.translate([e, t, r]), this;
      }, u.default.RendererGL.prototype.scale = function (e, t, r) {
        return this.uMVMatrix.scale(e, t, r), this;
      }, u.default.RendererGL.prototype.rotate = function (e, t) {
        return void 0 === t ? this.rotateZ(e) : (u.default.Matrix.prototype.rotate.apply(this.uMVMatrix, arguments), this);
      }, u.default.RendererGL.prototype.rotateX = function (e) {
        return this.rotate(e, 1, 0, 0), this;
      }, u.default.RendererGL.prototype.rotateY = function (e) {
        return this.rotate(e, 0, 1, 0), this;
      }, u.default.RendererGL.prototype.rotateZ = function (e) {
        return this.rotate(e, 0, 0, 1), this;
      }, u.default.RendererGL.prototype.push = function () {
        var e = u.default.Renderer.prototype.push.apply(this),
            t = e.properties;
        return t.uMVMatrix = this.uMVMatrix.copy(), t.uPMatrix = this.uPMatrix.copy(), t._curCamera = this._curCamera, this._curCamera = this._curCamera.copy(), t.ambientLightColors = this.ambientLightColors.slice(), t.specularColors = this.specularColors.slice(), t.directionalLightDirections = this.directionalLightDirections.slice(), t.directionalLightDiffuseColors = this.directionalLightDiffuseColors.slice(), t.directionalLightSpecularColors = this.directionalLightSpecularColors.slice(), t.pointLightPositions = this.pointLightPositions.slice(), t.pointLightDiffuseColors = this.pointLightDiffuseColors.slice(), t.pointLightSpecularColors = this.pointLightSpecularColors.slice(), t.spotLightPositions = this.spotLightPositions.slice(), t.spotLightDirections = this.spotLightDirections.slice(), t.spotLightDiffuseColors = this.spotLightDiffuseColors.slice(), t.spotLightSpecularColors = this.spotLightSpecularColors.slice(), t.spotLightAngle = this.spotLightAngle.slice(), t.spotLightConc = this.spotLightConc.slice(), t.userFillShader = this.userFillShader, t.userStrokeShader = this.userStrokeShader, t.userPointShader = this.userPointShader, t.pointSize = this.pointSize, t.curStrokeWeight = this.curStrokeWeight, t.curStrokeColor = this.curStrokeColor, t.curFillColor = this.curFillColor, t._useSpecularMaterial = this._useSpecularMaterial, t._useEmissiveMaterial = this._useEmissiveMaterial, t._useShininess = this._useShininess, t.constantAttenuation = this.constantAttenuation, t.linearAttenuation = this.linearAttenuation, t.quadraticAttenuation = this.quadraticAttenuation, t._enableLighting = this._enableLighting, t._useNormalMaterial = this._useNormalMaterial, t._tex = this._tex, t.drawMode = this.drawMode, e;
      }, u.default.RendererGL.prototype.resetMatrix = function () {
        return this.uMVMatrix = u.default.Matrix.identity(this._pInst), this;
      }, u.default.RendererGL.prototype._getImmediateStrokeShader = function () {
        var e = this.userStrokeShader;
        return e && e.isStrokeShader() ? e : this._getLineShader();
      }, u.default.RendererGL.prototype._getRetainedStrokeShader = u.default.RendererGL.prototype._getImmediateStrokeShader, u.default.RendererGL.prototype._getImmediateFillShader = function () {
        var e = this.userFillShader;
        if (this._useNormalMaterial && (!e || !e.isNormalShader())) return this._getNormalShader();

        if (this._enableLighting) {
          if (!e || !e.isLightShader()) return this._getLightShader();
        } else if (this._tex) {
          if (!e || !e.isTextureShader()) return this._getLightShader();
        } else if (!e) return this._getImmediateModeShader();

        return e;
      }, u.default.RendererGL.prototype._getRetainedFillShader = function () {
        if (this._useNormalMaterial) return this._getNormalShader();
        var e = this.userFillShader;

        if (this._enableLighting) {
          if (!e || !e.isLightShader()) return this._getLightShader();
        } else if (this._tex) {
          if (!e || !e.isTextureShader()) return this._getLightShader();
        } else if (!e) return this._getColorShader();

        return e;
      }, u.default.RendererGL.prototype._getImmediatePointShader = function () {
        var e = this.userPointShader;
        return e && e.isPointShader() ? e : this._getPointShader();
      }, u.default.RendererGL.prototype._getRetainedLineShader = u.default.RendererGL.prototype._getImmediateLineShader, u.default.RendererGL.prototype._getLightShader = function () {
        return this._defaultLightShader || (this._pInst._glAttributes.perPixelLighting ? this._defaultLightShader = new u.default.Shader(this, c.phongVert, c.phongFrag) : this._defaultLightShader = new u.default.Shader(this, c.lightVert, c.lightTextureFrag)), this._defaultLightShader;
      }, u.default.RendererGL.prototype._getImmediateModeShader = function () {
        return this._defaultImmediateModeShader || (this._defaultImmediateModeShader = new u.default.Shader(this, c.immediateVert, c.vertexColorFrag)), this._defaultImmediateModeShader;
      }, u.default.RendererGL.prototype._getNormalShader = function () {
        return this._defaultNormalShader || (this._defaultNormalShader = new u.default.Shader(this, c.normalVert, c.normalFrag)), this._defaultNormalShader;
      }, u.default.RendererGL.prototype._getColorShader = function () {
        return this._defaultColorShader || (this._defaultColorShader = new u.default.Shader(this, c.normalVert, c.basicFrag)), this._defaultColorShader;
      }, u.default.RendererGL.prototype._getPointShader = function () {
        return this._defaultPointShader || (this._defaultPointShader = new u.default.Shader(this, c.pointVert, c.pointFrag)), this._defaultPointShader;
      }, u.default.RendererGL.prototype._getLineShader = function () {
        return this._defaultLineShader || (this._defaultLineShader = new u.default.Shader(this, c.lineVert, c.lineFrag)), this._defaultLineShader;
      }, u.default.RendererGL.prototype._getFontShader = function () {
        return this._defaultFontShader || (this.GL.getExtension("OES_standard_derivatives"), this._defaultFontShader = new u.default.Shader(this, c.fontVert, c.fontFrag)), this._defaultFontShader;
      }, u.default.RendererGL.prototype._getEmptyTexture = function () {
        if (!this._emptyTexture) {
          var e = new u.default.Image(1, 1);
          e.set(0, 0, 255), this._emptyTexture = new u.default.Texture(this, e);
        }

        return this._emptyTexture;
      }, u.default.RendererGL.prototype.getTexture = function (e) {
        var t = this.textures,
            r = !0,
            i = !1,
            n = void 0;

        try {
          for (var a, o = t[Symbol.iterator](); !(r = (a = o.next()).done); r = !0) {
            var s = a.value;
            if (s.src === e) return s;
          }
        } catch (e) {
          i = !0, n = e;
        } finally {
          try {
            r || null == o.return || o.return();
          } finally {
            if (i) throw n;
          }
        }

        var l = new u.default.Texture(this, e);
        return t.push(l), l;
      }, u.default.RendererGL.prototype._setStrokeUniforms = function (e) {
        e.bindShader(), e.setUniform("uMaterialColor", this.curStrokeColor), e.setUniform("uStrokeWeight", this.curStrokeWeight);
      }, u.default.RendererGL.prototype._setFillUniforms = function (e) {
        e.bindShader(), e.setUniform("uMaterialColor", this.curFillColor), e.setUniform("isTexture", !!this._tex), this._tex && e.setUniform("uSampler", this._tex), e.setUniform("uTint", this._tint), e.setUniform("uSpecular", this._useSpecularMaterial), e.setUniform("uEmissive", this._useEmissiveMaterial), e.setUniform("uShininess", this._useShininess), e.setUniform("uUseLighting", this._enableLighting);
        var t = this.pointLightDiffuseColors.length / 3;
        e.setUniform("uPointLightCount", t), e.setUniform("uPointLightLocation", this.pointLightPositions), e.setUniform("uPointLightDiffuseColors", this.pointLightDiffuseColors), e.setUniform("uPointLightSpecularColors", this.pointLightSpecularColors);
        var r = this.directionalLightDiffuseColors.length / 3;
        e.setUniform("uDirectionalLightCount", r), e.setUniform("uLightingDirection", this.directionalLightDirections), e.setUniform("uDirectionalDiffuseColors", this.directionalLightDiffuseColors), e.setUniform("uDirectionalSpecularColors", this.directionalLightSpecularColors);
        var i = this.ambientLightColors.length / 3;
        e.setUniform("uAmbientLightCount", i), e.setUniform("uAmbientColor", this.ambientLightColors);
        var n = this.spotLightDiffuseColors.length / 3;
        e.setUniform("uSpotLightCount", n), e.setUniform("uSpotLightAngle", this.spotLightAngle), e.setUniform("uSpotLightConc", this.spotLightConc), e.setUniform("uSpotLightDiffuseColors", this.spotLightDiffuseColors), e.setUniform("uSpotLightSpecularColors", this.spotLightSpecularColors), e.setUniform("uSpotLightLocation", this.spotLightPositions), e.setUniform("uSpotLightDirection", this.spotLightDirections), e.setUniform("uConstantAttenuation", this.constantAttenuation), e.setUniform("uLinearAttenuation", this.linearAttenuation), e.setUniform("uQuadraticAttenuation", this.quadraticAttenuation), e.bindTextures();
      }, u.default.RendererGL.prototype._setPointUniforms = function (e) {
        e.bindShader(), e.setUniform("uMaterialColor", this.curStrokeColor), e.setUniform("uPointSize", this.pointSize * this._pInst._pixelDensity);
      }, u.default.RendererGL.prototype._bindBuffer = function (e, t, r, i, n) {
        if (t = t || this.GL.ARRAY_BUFFER, this.GL.bindBuffer(t, e), void 0 !== r) {
          var a = new (i || Float32Array)(r);
          this.GL.bufferData(t, a, n || this.GL.STATIC_DRAW);
        }
      }, u.default.RendererGL.prototype._arraysEqual = function (e, t) {
        var r = e.length;
        if (r !== t.length) return !1;

        for (var i = 0; i < r; i++) if (e[i] !== t[i]) return !1;

        return !0;
      }, u.default.RendererGL.prototype._isTypedArray = function (e) {
        return Float32Array, Float64Array, Int16Array, Uint16Array, e instanceof Uint32Array;
      }, u.default.RendererGL.prototype._flatten = function (e) {
        if (0 === e.length) return [];

        if (2e4 < e.length) {
          var t,
              r = Object.prototype.toString,
              i = [],
              n = e.slice();

          for (t = n.pop(); "[object Array]" === r.call(t) ? n.push.apply(n, l(t)) : i.push(t), n.length && void 0 !== (t = n.pop()););

          return i.reverse(), i;
        }

        var a;
        return (a = []).concat.apply(a, l(e));
      }, u.default.RendererGL.prototype._vToNArray = function (e) {
        var t = [],
            r = !0,
            i = !1,
            n = void 0;

        try {
          for (var a, o = e[Symbol.iterator](); !(r = (a = o.next()).done); r = !0) {
            var s = a.value;
            t.push(s.x, s.y, s.z);
          }
        } catch (e) {
          i = !0, n = e;
        } finally {
          try {
            r || null == o.return || o.return();
          } finally {
            if (i) throw n;
          }
        }

        return t;
      }, u.default.prototype._assert3d = function (e) {
        if (!this._renderer.isP3D) throw new Error("".concat(e, "() is only supported in WEBGL mode. If you'd like to use 3D graphics and WebGL, see  https://p5js.org/examples/form-3d-primitives.html for more information."));
      }, u.default.RendererGL.prototype._initTessy = function () {
        var e = new i.default.GluTesselator();
        return e.gluTessCallback(i.default.gluEnum.GLU_TESS_VERTEX_DATA, function (e, t) {
          t[t.length] = e[0], t[t.length] = e[1], t[t.length] = e[2];
        }), e.gluTessCallback(i.default.gluEnum.GLU_TESS_BEGIN, function (e) {
          e !== i.default.primitiveType.GL_TRIANGLES && console.log("expected TRIANGLES but got type: ".concat(e));
        }), e.gluTessCallback(i.default.gluEnum.GLU_TESS_ERROR, function (e) {
          console.log("error callback"), console.log("error number: ".concat(e));
        }), e.gluTessCallback(i.default.gluEnum.GLU_TESS_COMBINE, function (e, t, r) {
          return [e[0], e[1], e[2]];
        }), e.gluTessCallback(i.default.gluEnum.GLU_TESS_EDGE_FLAG, function (e) {}), e;
      }, u.default.RendererGL.prototype._triangulate = function (e) {
        this._tessy.gluTessNormal(0, 0, 1);

        var t = [];

        this._tessy.gluTessBeginPolygon(t);

        for (var r = 0; r < e.length; r++) {
          this._tessy.gluTessBeginContour();

          for (var i = e[r], n = 0; n < i.length; n += 3) {
            var a = [i[n], i[n + 1], i[n + 2]];

            this._tessy.gluTessVertex(a, a);
          }

          this._tessy.gluTessEndContour();
        }

        return this._tessy.gluTessEndPolygon(), t;
      }, u.default.RendererGL.prototype._bezierCoefficients = function (e) {
        var t = e * e,
            r = 1 - e,
            i = r * r;
        return [i * r, 3 * i * e, 3 * r * t, t * e];
      }, u.default.RendererGL.prototype._quadraticCoefficients = function (e) {
        var t = 1 - e;
        return [t * t, 2 * t * e, e * e];
      }, u.default.RendererGL.prototype._bezierToCatmull = function (e) {
        return [e[1], e[1] + (e[2] - e[0]) / this._curveTightness, e[2] - (e[3] - e[1]) / this._curveTightness, e[2]];
      };
      var f = u.default.RendererGL;
      r.default = f;
    }, {
      "../core/constants": 26,
      "../core/main": 36,
      "../core/p5.Renderer": 39,
      "./p5.Camera": 84,
      "./p5.Matrix": 86,
      "./p5.Shader": 91,
      libtess: 10,
      path: 13
    }],
    91: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;
      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      };
      n.default.Shader = function (e, t, r) {
        this._renderer = e, this._vertSrc = t, this._fragSrc = r, this._vertShader = -1, this._fragShader = -1, this._glProgram = 0, this._loadedAttributes = !1, this.attributes = {}, this._loadedUniforms = !1, this.uniforms = {}, this._bound = !1, this.samplers = [];
      }, n.default.Shader.prototype.init = function () {
        if (0 === this._glProgram) {
          var e = this._renderer.GL;
          if (this._vertShader = e.createShader(e.VERTEX_SHADER), e.shaderSource(this._vertShader, this._vertSrc), e.compileShader(this._vertShader), !e.getShaderParameter(this._vertShader, e.COMPILE_STATUS)) return console.error("Yikes! An error occurred compiling the vertex shader:".concat(e.getShaderInfoLog(this._vertShader))), null;
          if (this._fragShader = e.createShader(e.FRAGMENT_SHADER), e.shaderSource(this._fragShader, this._fragSrc), e.compileShader(this._fragShader), !e.getShaderParameter(this._fragShader, e.COMPILE_STATUS)) return console.error("Darn! An error occurred compiling the fragment shader:".concat(e.getShaderInfoLog(this._fragShader))), null;
          this._glProgram = e.createProgram(), e.attachShader(this._glProgram, this._vertShader), e.attachShader(this._glProgram, this._fragShader), e.linkProgram(this._glProgram), e.getProgramParameter(this._glProgram, e.LINK_STATUS) || console.error("Snap! Error linking shader program: ".concat(e.getProgramInfoLog(this._glProgram))), this._loadAttributes(), this._loadUniforms();
        }

        return this;
      }, n.default.Shader.prototype._loadAttributes = function () {
        if (!this._loadedAttributes) {
          this.attributes = {};

          for (var e = this._renderer.GL, t = e.getProgramParameter(this._glProgram, e.ACTIVE_ATTRIBUTES), r = 0; r < t; ++r) {
            var i = e.getActiveAttrib(this._glProgram, r),
                n = i.name,
                a = e.getAttribLocation(this._glProgram, n),
                o = {};
            o.name = n, o.location = a, o.index = r, o.type = i.type, o.size = i.size, this.attributes[n] = o;
          }

          this._loadedAttributes = !0;
        }
      }, n.default.Shader.prototype._loadUniforms = function () {
        if (!this._loadedUniforms) {
          for (var e = this._renderer.GL, t = e.getProgramParameter(this._glProgram, e.ACTIVE_UNIFORMS), r = 0, i = 0; i < t; ++i) {
            var n = e.getActiveUniform(this._glProgram, i),
                a = {};
            a.location = e.getUniformLocation(this._glProgram, n.name), a.size = n.size;
            var o = n.name;
            1 < n.size && (o = o.substring(0, o.indexOf("[0]"))), a.name = o, a.type = n.type, a._cachedData = void 0, a.type === e.SAMPLER_2D && (a.samplerIndex = r, r++, this.samplers.push(a)), a.isArray = a.type === e.FLOAT_MAT3 || a.type === e.FLOAT_MAT4 || a.type === e.FLOAT_VEC2 || a.type === e.FLOAT_VEC3 || a.type === e.FLOAT_VEC4 || a.type === e.INT_VEC2 || a.type === e.INT_VEC3 || a.type === e.INT_VEC4, this.uniforms[o] = a;
          }

          this._loadedUniforms = !0;
        }
      }, n.default.Shader.prototype.compile = function () {}, n.default.Shader.prototype.bindShader = function () {
        this.init(), this._bound || (this.useProgram(), this._bound = !0, this._setMatrixUniforms(), this.setUniform("uViewport", this._renderer._viewport));
      }, n.default.Shader.prototype.unbindShader = function () {
        return this._bound && (this.unbindTextures(), this._bound = !1), this;
      }, n.default.Shader.prototype.bindTextures = function () {
        var e = this._renderer.GL,
            t = !0,
            r = !1,
            i = void 0;

        try {
          for (var n, a = this.samplers[Symbol.iterator](); !(t = (n = a.next()).done); t = !0) {
            var o = n.value,
                s = o.texture;
            void 0 === s && (s = this._renderer._getEmptyTexture()), e.activeTexture(e.TEXTURE0 + o.samplerIndex), s.bindTexture(), s.update(), e.uniform1i(o.location, o.samplerIndex);
          }
        } catch (e) {
          r = !0, i = e;
        } finally {
          try {
            t || null == a.return || a.return();
          } finally {
            if (r) throw i;
          }
        }
      }, n.default.Shader.prototype.updateTextures = function () {
        var e = !0,
            t = !1,
            r = void 0;

        try {
          for (var i, n = this.samplers[Symbol.iterator](); !(e = (i = n.next()).done); e = !0) {
            var a = i.value.texture;
            a && a.update();
          }
        } catch (e) {
          t = !0, r = e;
        } finally {
          try {
            e || null == n.return || n.return();
          } finally {
            if (t) throw r;
          }
        }
      }, n.default.Shader.prototype.unbindTextures = function () {}, n.default.Shader.prototype._setMatrixUniforms = function () {
        this.setUniform("uProjectionMatrix", this._renderer.uPMatrix.mat4), this.isStrokeShader() && ("default" === this._renderer._curCamera.cameraType ? this.setUniform("uPerspective", 1) : this.setUniform("uPerspective", 0)), this.setUniform("uModelViewMatrix", this._renderer.uMVMatrix.mat4), this.setUniform("uViewMatrix", this._renderer._curCamera.cameraMatrix.mat4), this.uniforms.uNormalMatrix && (this._renderer.uNMatrix.inverseTranspose(this._renderer.uMVMatrix), this.setUniform("uNormalMatrix", this._renderer.uNMatrix.mat3));
      }, n.default.Shader.prototype.useProgram = function () {
        var e = this._renderer.GL;
        return this._renderer._curShader !== this && (e.useProgram(this._glProgram), this._renderer._curShader = this), this;
      }, n.default.Shader.prototype.setUniform = function (e, t) {
        var r = this.uniforms[e];

        if (r) {
          var i = this._renderer.GL;

          if (r.isArray) {
            if (r._cachedData && this._renderer._arraysEqual(r._cachedData, t)) return;
            r._cachedData = t.slice(0);
          } else {
            if (r._cachedData && r._cachedData === t) return;
            r._cachedData = t;
          }

          var n = r.location;

          switch (this.useProgram(), r.type) {
            case i.BOOL:
              !0 === t ? i.uniform1i(n, 1) : i.uniform1i(n, 0);
              break;

            case i.INT:
              1 < r.size ? t.length && i.uniform1iv(n, t) : i.uniform1i(n, t);
              break;

            case i.FLOAT:
              1 < r.size ? t.length && i.uniform1fv(n, t) : i.uniform1f(n, t);
              break;

            case i.FLOAT_MAT3:
              i.uniformMatrix3fv(n, !1, t);
              break;

            case i.FLOAT_MAT4:
              i.uniformMatrix4fv(n, !1, t);
              break;

            case i.FLOAT_VEC2:
              1 < r.size ? t.length && i.uniform2fv(n, t) : i.uniform2f(n, t[0], t[1]);
              break;

            case i.FLOAT_VEC3:
              1 < r.size ? t.length && i.uniform3fv(n, t) : i.uniform3f(n, t[0], t[1], t[2]);
              break;

            case i.FLOAT_VEC4:
              1 < r.size ? t.length && i.uniform4fv(n, t) : i.uniform4f(n, t[0], t[1], t[2], t[3]);
              break;

            case i.INT_VEC2:
              1 < r.size ? t.length && i.uniform2iv(n, t) : i.uniform2i(n, t[0], t[1]);
              break;

            case i.INT_VEC3:
              1 < r.size ? t.length && i.uniform3iv(n, t) : i.uniform3i(n, t[0], t[1], t[2]);
              break;

            case i.INT_VEC4:
              1 < r.size ? t.length && i.uniform4iv(n, t) : i.uniform4i(n, t[0], t[1], t[2], t[3]);
              break;

            case i.SAMPLER_2D:
              i.activeTexture(i.TEXTURE0 + r.samplerIndex), r.texture = this._renderer.getTexture(t), i.uniform1i(r.location, r.samplerIndex);
          }

          return this;
        }
      }, n.default.Shader.prototype.isLightShader = function () {
        return void 0 !== this.attributes.aNormal || void 0 !== this.uniforms.uUseLighting || void 0 !== this.uniforms.uAmbientLightCount || void 0 !== this.uniforms.uDirectionalLightCount || void 0 !== this.uniforms.uPointLightCount || void 0 !== this.uniforms.uAmbientColor || void 0 !== this.uniforms.uDirectionalDiffuseColors || void 0 !== this.uniforms.uDirectionalSpecularColors || void 0 !== this.uniforms.uPointLightLocation || void 0 !== this.uniforms.uPointLightDiffuseColors || void 0 !== this.uniforms.uPointLightSpecularColors || void 0 !== this.uniforms.uLightingDirection || void 0 !== this.uniforms.uSpecular;
      }, n.default.Shader.prototype.isNormalShader = function () {
        return void 0 !== this.attributes.aNormal;
      }, n.default.Shader.prototype.isTextureShader = function () {
        return 0 < this.samplerIndex;
      }, n.default.Shader.prototype.isColorShader = function () {
        return void 0 !== this.attributes.aVertexColor || void 0 !== this.uniforms.uMaterialColor;
      }, n.default.Shader.prototype.isTexLightShader = function () {
        return this.isLightShader() && this.isTextureShader();
      }, n.default.Shader.prototype.isStrokeShader = function () {
        return void 0 !== this.uniforms.uStrokeWeight;
      }, n.default.Shader.prototype.enableAttrib = function (e, t, r, i, n, a) {
        if (e) {
          0;
          var o = e.location;

          if (-1 !== o) {
            var s = this._renderer.GL;
            e.enabled || (s.enableVertexAttribArray(o), e.enabled = !0), this._renderer.GL.vertexAttribPointer(o, t, r || s.FLOAT, i || !1, n || 0, a || 0);
          }
        }

        return this;
      };
      var a = n.default.Shader;
      r.default = a;
    }, {
      "../core/main": 36
    }],
    92: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = void 0;

      var i,
          n = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      },
          s = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = l();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../core/constants"));

      function l() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return l = function () {
          return e;
        }, e;
      }

      n.default.Texture = function (e, t) {
        this._renderer = e;
        var r = this._renderer.GL;
        this.src = t, this.glTex = void 0, this.glTarget = r.TEXTURE_2D, this.glFormat = r.RGBA, this.mipmaps = !1, this.glMinFilter = r.LINEAR, this.glMagFilter = r.LINEAR, this.glWrapS = r.CLAMP_TO_EDGE, this.glWrapT = r.CLAMP_TO_EDGE, this.isSrcMediaElement = void 0 !== n.default.MediaElement && t instanceof n.default.MediaElement, this._videoPrevUpdateTime = 0, this.isSrcHTMLElement = void 0 !== n.default.Element && t instanceof n.default.Element && !(t instanceof n.default.Graphics), this.isSrcP5Image = t instanceof n.default.Image, this.isSrcP5Graphics = t instanceof n.default.Graphics, this.isImageData = "undefined" != typeof ImageData && t instanceof ImageData;

        var i = this._getTextureDataFromSource();

        return this.width = i.width, this.height = i.height, this.init(i), this;
      }, n.default.Texture.prototype._getTextureDataFromSource = function () {
        var e;
        return this.isSrcP5Image ? e = this.src.canvas : this.isSrcMediaElement || this.isSrcP5Graphics || this.isSrcHTMLElement ? e = this.src.elt : this.isImageData && (e = this.src), e;
      }, n.default.Texture.prototype.init = function (e) {
        var t = this._renderer.GL;

        if (this.glTex = t.createTexture(), this.glWrapS = this._renderer.textureWrapX, this.glWrapT = this._renderer.textureWrapY, this.setWrapMode(this.glWrapS, this.glWrapT), this.bindTexture(), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, this.glMagFilter), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, this.glMinFilter), 0 === this.width || 0 === this.height || this.isSrcMediaElement && !this.src.loadedmetadata) {
          var r = new Uint8Array([1, 1, 1, 1]);
          t.texImage2D(this.glTarget, 0, t.RGBA, 1, 1, 0, this.glFormat, t.UNSIGNED_BYTE, r);
        } else t.texImage2D(this.glTarget, 0, this.glFormat, this.glFormat, t.UNSIGNED_BYTE, e);
      }, n.default.Texture.prototype.update = function () {
        var e = this.src;
        if (0 === e.width || 0 === e.height) return !1;

        var t = this._getTextureDataFromSource(),
            r = !1,
            i = this._renderer.GL;

        return t.width !== this.width || t.height !== this.height ? (r = !0, this.width = t.width, this.height = t.height, this.isSrcP5Image ? e.setModified(!1) : (this.isSrcMediaElement || this.isSrcHTMLElement) && e.setModified(!0)) : this.isSrcP5Image ? e.isModified() && (r = !0, e.setModified(!1)) : this.isSrcMediaElement ? e.isModified() ? (r = !0, e.setModified(!1)) : e.loadedmetadata && this._videoPrevUpdateTime !== e.time() && (this._videoPrevUpdateTime = e.time(), r = !0) : this.isImageData ? e._dirty && (r = !(e._dirty = !1)) : r = !0, r && (this.bindTexture(), i.texImage2D(this.glTarget, 0, this.glFormat, this.glFormat, i.UNSIGNED_BYTE, t)), r;
      }, n.default.Texture.prototype.bindTexture = function () {
        return this._renderer.GL.bindTexture(this.glTarget, this.glTex), this;
      }, n.default.Texture.prototype.unbindTexture = function () {
        this._renderer.GL.bindTexture(this.glTarget, null);
      }, n.default.Texture.prototype.setInterpolation = function (e, t) {
        var r = this._renderer.GL;
        e === s.NEAREST ? this.glMinFilter = r.NEAREST : this.glMinFilter = r.LINEAR, t === s.NEAREST ? this.glMagFilter = r.NEAREST : this.glMagFilter = r.LINEAR, this.bindTexture(), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, this.glMinFilter), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, this.glMagFilter), this.unbindTexture();
      }, n.default.Texture.prototype.setWrapMode = function (e, t) {
        function r(e) {
          return 0 == (e & e - 1);
        }

        var i = this._renderer.GL,
            n = r(this.width),
            a = r(this.height);
        e === s.REPEAT ? n && a ? this.glWrapS = i.REPEAT : (console.warn("You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead"), this.glWrapS = i.CLAMP_TO_EDGE) : e === s.MIRROR ? n && a ? this.glWrapS = i.MIRRORED_REPEAT : (console.warn("You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead"), this.glWrapS = i.CLAMP_TO_EDGE) : this.glWrapS = i.CLAMP_TO_EDGE, t === s.REPEAT ? n && a ? this.glWrapT = i.REPEAT : (console.warn("You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead"), this.glWrapT = i.CLAMP_TO_EDGE) : t === s.MIRROR ? n && a ? this.glWrapT = i.MIRRORED_REPEAT : (console.warn("You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead"), this.glWrapT = i.CLAMP_TO_EDGE) : this.glWrapT = i.CLAMP_TO_EDGE, this.bindTexture(), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, this.glWrapS), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, this.glWrapT), this.unbindTexture();
      };
      var a = n.default.Texture;
      r.default = a;
    }, {
      "../core/constants": 26,
      "../core/main": 36
    }],
    93: [function (e, t, r) {
      "use strict";

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      var i,
          j = (i = e("../core/main")) && i.__esModule ? i : {
        default: i
      },
          k = function (e) {
        if (e && e.__esModule) return e;
        if (null === e || "object" !== o(e) && "function" != typeof e) return {
          default: e
        };
        var t = s();
        if (t && t.has(e)) return t.get(e);
        var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;

        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) {
          var a = i ? Object.getOwnPropertyDescriptor(e, n) : null;
          a && (a.get || a.set) ? Object.defineProperty(r, n, a) : r[n] = e[n];
        }

        r.default = e, t && t.set(e, r);
        return r;
      }(e("../core/constants"));

      function s() {
        if ("function" != typeof WeakMap) return null;
        var e = new WeakMap();
        return s = function () {
          return e;
        }, e;
      }

      e("./p5.Shader"), e("./p5.RendererGL.Retained"), j.default.RendererGL.prototype._applyTextProperties = function () {}, j.default.RendererGL.prototype.textWidth = function (e) {
        return this._isOpenType() ? this._textFont._textWidth(e, this._textSize) : 0;
      };

      function n(e, t) {
        this.width = e, this.height = t, this.infos = [], this.findImage = function (e) {
          var t,
              r,
              i = this.width * this.height;
          if (i < e) throw new Error("font is too complex to render in 3D");

          for (var n = this.infos.length - 1; 0 <= n; --n) {
            var a = this.infos[n];

            if (a.index + e < i) {
              r = (t = a).imageData;
              break;
            }
          }

          if (!t) {
            try {
              r = new ImageData(this.width, this.height);
            } catch (e) {
              var o = document.getElementsByTagName("canvas")[0],
                  s = !o;
              o || ((o = document.createElement("canvas")).style.display = "none", document.body.appendChild(o));
              var l = o.getContext("2d");
              l && (r = l.createImageData(this.width, this.height)), s && document.body.removeChild(o);
            }

            t = {
              index: 0,
              imageData: r
            }, this.infos.push(t);
          }

          var u = t.index;
          return t.index += e, r._dirty = !0, {
            imageData: r,
            index: u
          };
        };
      }

      function V(e, t, r, i, n) {
        var a = e.imageData.data,
            o = 4 * e.index++;
        a[o++] = t, a[o++] = r, a[o++] = i, a[o++] = n;
      }

      function A(e) {
        this.font = e, this.strokeImageInfos = new n(64, 64), this.colDimImageInfos = new n(64, 64), this.rowDimImageInfos = new n(64, 64), this.colCellImageInfos = new n(64, 64), this.rowCellImageInfos = new n(64, 64), this.glyphInfos = {}, this.getGlyphInfo = function (e) {
          var t = this.glyphInfos[e.index];
          if (t) return t;
          var r,
              i = e.getBoundingBox(),
              n = i.x1,
              a = i.y1,
              o = i.x2 - n,
              s = i.y2 - a,
              l = e.path.commands;
          if (0 == o || 0 == s || !l.length) return this.glyphInfos[e.index] = {};
          var u,
              h,
              c,
              f,
              d = [],
              p = [],
              m = [];

          for (r = 8; 0 <= r; --r) m.push([]);

          for (r = 8; 0 <= r; --r) p.push([]);

          function v(e, t, r) {
            var i = d.length;

            function n(e, t, r) {
              for (var i = e.length; 0 < i--;) {
                var n = e[i];
                n < t && (t = n), r < n && (r = n);
              }

              return {
                min: t,
                max: r
              };
            }

            d.push(r);

            for (var a = n(e, 1, 0), o = Math.max(Math.floor(9 * a.min), 0), s = Math.min(Math.ceil(9 * a.max), 9), l = o; l < s; ++l) m[l].push(i);

            for (var u = n(t, 1, 0), h = Math.max(Math.floor(9 * u.min), 0), c = Math.min(Math.ceil(9 * u.max), 9), f = h; f < c; ++f) p[f].push(i);
          }

          function y(e) {
            return (t = (i = 255) * e) < (r = 0) ? r : i < t ? i : t;
            var t, r, i;
          }

          function w(e, t, r, i) {
            this.p0 = e, this.c0 = t, this.c1 = r, this.p1 = i, this.toQuadratic = function () {
              return {
                x: this.p0.x,
                y: this.p0.y,
                x1: this.p1.x,
                y1: this.p1.y,
                cx: (3 * (this.c0.x + this.c1.x) - (this.p0.x + this.p1.x)) / 4,
                cy: (3 * (this.c0.y + this.c1.y) - (this.p0.y + this.p1.y)) / 4
              };
            }, this.quadError = function () {
              return j.default.Vector.sub(j.default.Vector.sub(this.p1, this.p0), j.default.Vector.mult(j.default.Vector.sub(this.c1, this.c0), 3)).mag() / 2;
            }, this.split = function (e) {
              var t = j.default.Vector.lerp(this.p0, this.c0, e),
                  r = j.default.Vector.lerp(this.c0, this.c1, e),
                  i = j.default.Vector.lerp(t, r, e);
              this.c1 = j.default.Vector.lerp(this.c1, this.p1, e), this.c0 = j.default.Vector.lerp(r, this.c1, e);
              var n = j.default.Vector.lerp(i, this.c0, e),
                  a = new w(this.p0, t, i, n);
              return this.p0 = n, a;
            }, this.splitInflections = function () {
              var e = j.default.Vector.sub(this.c0, this.p0),
                  t = j.default.Vector.sub(j.default.Vector.sub(this.c1, this.c0), e),
                  r = j.default.Vector.sub(j.default.Vector.sub(j.default.Vector.sub(this.p1, this.c1), e), j.default.Vector.mult(t, 2)),
                  i = [],
                  n = t.x * r.y - t.y * r.x;

              if (0 !== n) {
                var a = e.x * r.y - e.y * r.x,
                    o = e.x * t.y - e.y * t.x,
                    s = a * a - 4 * n * o;

                if (0 <= s) {
                  n < 0 && (n = -n, a = -a, o = -o);
                  var l = Math.sqrt(s),
                      u = (-a - l) / (2 * n),
                      h = (-a + l) / (2 * n);
                  0 < u && u < 1 && (i.push(this.split(u)), h = 1 - (1 - h) / (1 - u)), 0 < h && h < 1 && i.push(this.split(h));
                }
              }

              return i.push(this), i;
            };
          }

          function g(e, t, r, i, n, a, o, s) {
            var l = new w(new j.default.Vector(e, t), new j.default.Vector(r, i), new j.default.Vector(n, a), new j.default.Vector(o, s)).splitInflections(),
                u = [],
                h = 30 / z,
                c = !0,
                f = !1,
                d = void 0;

            try {
              for (var p, m = l[Symbol.iterator](); !(c = (p = m.next()).done); c = !0) {
                for (var v = p.value, y = [], g = void 0; !(.125 <= (g = h / v.quadError()));) {
                  var b = Math.pow(g, 1 / 3),
                      _ = v.split(b),
                      x = v.split(1 - b / (1 - b));

                  u.push(_), y.push(v), v = x;
                }

                g < 1 && u.push(v.split(.5)), u.push(v), Array.prototype.push.apply(u, y.reverse());
              }
            } catch (e) {
              f = !0, d = e;
            } finally {
              try {
                c || null == m.return || m.return();
              } finally {
                if (f) throw d;
              }
            }

            return u;
          }

          function b(e, t, r, i) {
            v([e, r], [t, i], {
              x: e,
              y: t,
              cx: (e + r) / 2,
              cy: (t + i) / 2
            });
          }

          function _(e, t, r, i) {
            return Math.abs(r - e) < 1e-5 && Math.abs(i - t) < 1e-5;
          }

          var x = !0,
              S = !1,
              M = void 0;

          try {
            for (var T, E = l[Symbol.iterator](); !(x = (T = E.next()).done); x = !0) {
              var C = T.value,
                  L = (C.x - n) / o,
                  O = (C.y - a) / s;

              if (!_(u, h, L, O)) {
                switch (C.type) {
                  case "M":
                    c = L, f = O;
                    break;

                  case "L":
                    b(u, h, L, O);
                    break;

                  case "Q":
                    var P = (C.x1 - n) / o,
                        R = (C.y1 - a) / s;
                    v([u, L, P], [h, O, R], {
                      x: u,
                      y: h,
                      cx: P,
                      cy: R
                    });
                    break;

                  case "Z":
                    _(u, h, c, f) ? d.push({
                      x: u,
                      y: h
                    }) : (b(u, h, c, f), d.push({
                      x: c,
                      y: f
                    }));
                    break;

                  case "C":
                    for (var D = g(u, h, (C.x1 - n) / o, (C.y1 - a) / s, (C.x2 - n) / o, (C.y2 - a) / s, L, O), k = 0; k < D.length; k++) {
                      var A = D[k].toQuadratic();
                      v([A.x, A.x1, A.cx], [A.y, A.y1, A.cy], A);
                    }

                    break;

                  default:
                    throw new Error("unknown command type: ".concat(C.type));
                }

                u = L, h = O;
              }
            }
          } catch (e) {
            S = !0, M = e;
          } finally {
            try {
              x || null == E.return || E.return();
            } finally {
              if (S) throw M;
            }
          }

          for (var I = d.length, U = this.strokeImageInfos.findImage(I), N = U.index, F = 0; F < I; ++F) {
            var B = d[F];
            V(U, y(B.x), y(B.y), y(B.cx), y(B.cy));
          }

          function G(e, t, r) {
            for (var i = e.length, n = t.findImage(i), a = n.index, o = 0, s = 0; s < i; ++s) o += e[s].length;

            for (var l = r.findImage(o), u = 0; u < i; ++u) {
              var h = e[u],
                  c = h.length,
                  f = l.index;
              V(n, f >> 7, 127 & f, c >> 7, 127 & c);

              for (var d = 0; d < c; ++d) {
                var p = h[d] + N;
                V(l, p >> 7, 127 & p, 0, 0);
              }
            }

            return {
              cellImageInfo: l,
              dimOffset: a,
              dimImageInfo: n
            };
          }

          return (t = this.glyphInfos[e.index] = {
            glyph: e,
            uGlyphRect: [i.x1, -i.y1, i.x2, -i.y2],
            strokeImageInfo: U,
            strokes: d,
            colInfo: G(m, this.colDimImageInfos, this.colCellImageInfos),
            rowInfo: G(p, this.rowDimImageInfos, this.rowCellImageInfos)
          }).uGridOffset = [t.colInfo.dimOffset, t.rowInfo.dimOffset], t;
        };
      }

      var z = Math.sqrt(3);

      j.default.RendererGL.prototype._renderText = function (e, t, r, i, n) {
        if (this._textFont && "string" != typeof this._textFont) {
          if (!(n <= i) && this._doFill) {
            if (!this._isOpenType()) return console.log("WEBGL: only Opentype (.otf) and Truetype (.ttf) fonts are supported"), e;
            e.push();
            var a = this._doStroke,
                o = this.drawMode;
            this._doStroke = !1, this.drawMode = k.TEXTURE;
            var s = this._textFont.font,
                l = this._textFont._fontInfo;
            l = l || (this._textFont._fontInfo = new A(s));

            var u = this._textFont._handleAlignment(this, t, r, i),
                h = this._textSize / s.unitsPerEm;

            this.translate(u.x, u.y, 0), this.scale(h, h, 1);

            var c = this.GL,
                f = !this._defaultFontShader,
                d = this._getFontShader();

            d.init(), d.bindShader(), f && (d.setUniform("uGridImageSize", [64, 64]), d.setUniform("uCellsImageSize", [64, 64]), d.setUniform("uStrokeImageSize", [64, 64]), d.setUniform("uGridSize", [9, 9])), this._applyColorBlend(this.curFillColor);
            var p = this.retainedMode.geometry.glyph;

            if (!p) {
              var m = this._textGeom = new j.default.Geometry(1, 1, function () {
                for (var e = 0; e <= 1; e++) for (var t = 0; t <= 1; t++) this.vertices.push(new j.default.Vector(t, e, 0)), this.uvs.push(t, e);
              });
              m.computeFaces().computeNormals(), p = this.createBuffers("glyph", m);
            }

            var v = !0,
                y = !1,
                g = void 0;

            try {
              for (var b, _ = this.retainedMode.buffers.text[Symbol.iterator](); !(v = (b = _.next()).done); v = !0) {
                b.value._prepareBuffer(p, d);
              }
            } catch (e) {
              y = !0, g = e;
            } finally {
              try {
                v || null == _.return || _.return();
              } finally {
                if (y) throw g;
              }
            }

            this._bindBuffer(p.indexBuffer, c.ELEMENT_ARRAY_BUFFER), d.setUniform("uMaterialColor", this.curFillColor);

            try {
              var x = 0,
                  w = null,
                  S = s.stringToGlyphs(t),
                  M = !0,
                  T = !1,
                  E = void 0;

              try {
                for (var C, L = S[Symbol.iterator](); !(M = (C = L.next()).done); M = !0) {
                  var O = C.value;
                  w && (x += s.getKerningValue(w, O));
                  var P = l.getGlyphInfo(O);

                  if (P.uGlyphRect) {
                    var R = P.rowInfo,
                        D = P.colInfo;
                    d.setUniform("uSamplerStrokes", P.strokeImageInfo.imageData), d.setUniform("uSamplerRowStrokes", R.cellImageInfo.imageData), d.setUniform("uSamplerRows", R.dimImageInfo.imageData), d.setUniform("uSamplerColStrokes", D.cellImageInfo.imageData), d.setUniform("uSamplerCols", D.dimImageInfo.imageData), d.setUniform("uGridOffset", P.uGridOffset), d.setUniform("uGlyphRect", P.uGlyphRect), d.setUniform("uGlyphOffset", x), d.bindTextures(), c.drawElements(c.TRIANGLES, 6, this.GL.UNSIGNED_SHORT, 0);
                  }

                  x += O.advanceWidth, w = O;
                }
              } catch (e) {
                T = !0, E = e;
              } finally {
                try {
                  M || null == L.return || L.return();
                } finally {
                  if (T) throw E;
                }
              }
            } finally {
              d.unbindShader(), this._doStroke = a, this.drawMode = o, e.pop();
            }

            return e;
          }
        } else console.log("WEBGL: you must load and set a font before drawing text. See `loadFont` and `textFont` for more details.");
      };
    }, {
      "../core/constants": 26,
      "../core/main": 36,
      "./p5.RendererGL.Retained": 89,
      "./p5.Shader": 91
    }]
  }, {}, [21])(21);
});
},{}],"globals.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GLOBALS = void 0;

var _GLOBALS;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var GLOBALS = (_GLOBALS = {
  camera: null,
  trees: [],
  // I created a "stain" class and put all the stains in an array
  //let aux = new Stain(mouseX, mouseY);
  //stains.push(aux);
  font: null,
  font_size: 8,
  hopes: [],
  raindrops: [],
  wind: 0,
  // current wind value
  wind_values: [],
  // list of wind data
  wind_index: 0,
  // index to read from wind data
  wind_new: 0,
  // the most recently read value that gets dampened over time
  wind_interval: 30,
  // interval in millis for picking up new wind values
  wind_time_acum: 0,
  // time acummulation 
  w_area: 300,
  h_area: 200,
  tree_amt: 5,
  min_tree_dist: 20,
  previz: true
}, _defineProperty(_GLOBALS, "font", null), _defineProperty(_GLOBALS, "rain_thresh", 0.4), _defineProperty(_GLOBALS, "rain_sounds", []), _defineProperty(_GLOBALS, "growth_sounds", []), _defineProperty(_GLOBALS, "flower_sounds", []), _defineProperty(_GLOBALS, "wind_sound", null), _defineProperty(_GLOBALS, "sound_enabled", false), _defineProperty(_GLOBALS, "lastGeometryMergeTimeMs", null), _GLOBALS);
exports.GLOBALS = GLOBALS;
},{}],"node_modules/three/build/three.module.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AmbientLight = AmbientLight;
exports.AmbientLightProbe = AmbientLightProbe;
exports.AnimationClip = AnimationClip;
exports.AnimationLoader = AnimationLoader;
exports.AnimationMixer = AnimationMixer;
exports.AnimationObjectGroup = AnimationObjectGroup;
exports.ArcCurve = ArcCurve;
exports.ArrayCamera = ArrayCamera;
exports.AudioLoader = AudioLoader;
exports.AxisHelper = AxisHelper;
exports.BinaryTextureLoader = BinaryTextureLoader;
exports.Bone = Bone;
exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
exports.BoundingBoxHelper = BoundingBoxHelper;
exports.BufferAttribute = BufferAttribute;
exports.BufferGeometry = BufferGeometry;
exports.BufferGeometryLoader = BufferGeometryLoader;
exports.Camera = Camera;
exports.CanvasRenderer = CanvasRenderer;
exports.CanvasTexture = CanvasTexture;
exports.CatmullRomCurve3 = CatmullRomCurve3;
exports.ClosedSplineCurve3 = ClosedSplineCurve3;
exports.ColorKeyframeTrack = ColorKeyframeTrack;
exports.CompressedTexture = CompressedTexture;
exports.CompressedTextureLoader = CompressedTextureLoader;
exports.CubeCamera = CubeCamera;
exports.CubeTexture = CubeTexture;
exports.CubeTextureLoader = CubeTextureLoader;
exports.CubicBezierCurve = CubicBezierCurve;
exports.CubicBezierCurve3 = CubicBezierCurve3;
exports.CubicInterpolant = CubicInterpolant;
exports.Curve = Curve;
exports.CurvePath = CurvePath;
exports.DataTexture = DataTexture;
exports.DataTexture2DArray = DataTexture2DArray;
exports.DataTexture3D = DataTexture3D;
exports.DataTextureLoader = DataTextureLoader;
exports.DepthTexture = DepthTexture;
exports.DirectionalLight = DirectionalLight;
exports.DiscreteInterpolant = DiscreteInterpolant;
exports.DynamicBufferAttribute = DynamicBufferAttribute;
exports.EdgesHelper = EdgesHelper;
exports.EllipseCurve = EllipseCurve;
exports.EventDispatcher = EventDispatcher;
exports.Face4 = Face4;
exports.FileLoader = FileLoader;
exports.Float32Attribute = Float32Attribute;
exports.Float32BufferAttribute = Float32BufferAttribute;
exports.Float64Attribute = Float64Attribute;
exports.Float64BufferAttribute = Float64BufferAttribute;
exports.Font = Font;
exports.FontLoader = FontLoader;
exports.GLBufferAttribute = GLBufferAttribute;
exports.Geometry = Geometry;
exports.Group = Group;
exports.HemisphereLight = HemisphereLight;
exports.HemisphereLightProbe = HemisphereLightProbe;
exports.ImageBitmapLoader = ImageBitmapLoader;
exports.ImageLoader = ImageLoader;
exports.ImmediateRenderObject = ImmediateRenderObject;
exports.InstancedBufferAttribute = InstancedBufferAttribute;
exports.InstancedBufferGeometry = InstancedBufferGeometry;
exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
exports.InstancedMesh = InstancedMesh;
exports.Int16Attribute = Int16Attribute;
exports.Int16BufferAttribute = Int16BufferAttribute;
exports.Int32Attribute = Int32Attribute;
exports.Int32BufferAttribute = Int32BufferAttribute;
exports.Int8Attribute = Int8Attribute;
exports.Int8BufferAttribute = Int8BufferAttribute;
exports.InterleavedBuffer = InterleavedBuffer;
exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
exports.Interpolant = Interpolant;
exports.JSONLoader = JSONLoader;
exports.KeyframeTrack = KeyframeTrack;
exports.LOD = LOD;
exports.LensFlare = LensFlare;
exports.Light = Light;
exports.LightProbe = LightProbe;
exports.LightShadow = LightShadow;
exports.Line = Line;
exports.LineBasicMaterial = LineBasicMaterial;
exports.LineCurve = LineCurve;
exports.LineCurve3 = LineCurve3;
exports.LineDashedMaterial = LineDashedMaterial;
exports.LineLoop = LineLoop;
exports.LineSegments = LineSegments;
exports.LinearInterpolant = LinearInterpolant;
exports.Loader = Loader;
exports.LoadingManager = LoadingManager;
exports.Material = Material;
exports.MaterialLoader = MaterialLoader;
exports.Mesh = Mesh;
exports.MeshBasicMaterial = MeshBasicMaterial;
exports.MeshDepthMaterial = MeshDepthMaterial;
exports.MeshDistanceMaterial = MeshDistanceMaterial;
exports.MeshFaceMaterial = MeshFaceMaterial;
exports.MeshLambertMaterial = MeshLambertMaterial;
exports.MeshMatcapMaterial = MeshMatcapMaterial;
exports.MeshNormalMaterial = MeshNormalMaterial;
exports.MeshPhongMaterial = MeshPhongMaterial;
exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
exports.MeshStandardMaterial = MeshStandardMaterial;
exports.MeshToonMaterial = MeshToonMaterial;
exports.MultiMaterial = MultiMaterial;
exports.NumberKeyframeTrack = NumberKeyframeTrack;
exports.Object3D = Object3D;
exports.ObjectLoader = ObjectLoader;
exports.OrthographicCamera = OrthographicCamera;
exports.ParametricBufferGeometry = ParametricBufferGeometry;
exports.ParametricGeometry = ParametricGeometry;
exports.Particle = Particle;
exports.ParticleBasicMaterial = ParticleBasicMaterial;
exports.ParticleSystem = ParticleSystem;
exports.ParticleSystemMaterial = ParticleSystemMaterial;
exports.Path = Path;
exports.PerspectiveCamera = PerspectiveCamera;
exports.PointCloud = PointCloud;
exports.PointCloudMaterial = PointCloudMaterial;
exports.PointLight = PointLight;
exports.Points = Points;
exports.PointsMaterial = PointsMaterial;
exports.PropertyBinding = PropertyBinding;
exports.PropertyMixer = PropertyMixer;
exports.QuadraticBezierCurve = QuadraticBezierCurve;
exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
exports.RawShaderMaterial = RawShaderMaterial;
exports.Raycaster = Raycaster;
exports.RectAreaLight = RectAreaLight;
exports.ShaderMaterial = ShaderMaterial;
exports.ShadowMaterial = ShadowMaterial;
exports.Shape = Shape;
exports.ShapePath = ShapePath;
exports.Skeleton = Skeleton;
exports.SkinnedMesh = SkinnedMesh;
exports.Spline = Spline;
exports.SplineCurve = SplineCurve;
exports.SplineCurve3 = SplineCurve3;
exports.SpotLight = SpotLight;
exports.Sprite = Sprite;
exports.SpriteMaterial = SpriteMaterial;
exports.StereoCamera = StereoCamera;
exports.StringKeyframeTrack = StringKeyframeTrack;
exports.Texture = Texture;
exports.TextureLoader = TextureLoader;
exports.Uint16Attribute = Uint16Attribute;
exports.Uint16BufferAttribute = Uint16BufferAttribute;
exports.Uint32Attribute = Uint32Attribute;
exports.Uint32BufferAttribute = Uint32BufferAttribute;
exports.Uint8Attribute = Uint8Attribute;
exports.Uint8BufferAttribute = Uint8BufferAttribute;
exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
exports.VectorKeyframeTrack = VectorKeyframeTrack;
exports.Vertex = Vertex;
exports.VideoTexture = VideoTexture;
exports.WebGL1Renderer = WebGL1Renderer;
exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
exports.WebGLRenderTarget = WebGLRenderTarget;
exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
exports.WebGLRenderer = WebGLRenderer;
exports.WebGLUtils = WebGLUtils;
exports.WireframeHelper = WireframeHelper;
exports.XHRLoader = XHRLoader;
exports.InvertStencilOp = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = exports.IntType = exports.IncrementWrapStencilOp = exports.IncrementStencilOp = exports.ImageUtils = exports.IcosahedronGeometry = exports.IcosahedronBufferGeometry = exports.HemisphereLightHelper = exports.HalfFloatType = exports.GridHelper = exports.GreaterStencilFunc = exports.GreaterEqualStencilFunc = exports.GreaterEqualDepth = exports.GreaterDepth = exports.GeometryUtils = exports.GammaEncoding = exports.GLSL3 = exports.GLSL1 = exports.Frustum = exports.FrontSide = exports.FogExp2 = exports.Fog = exports.FloatType = exports.FlatShading = exports.FaceColors = exports.Face3 = exports.ExtrudeGeometry = exports.ExtrudeBufferGeometry = exports.Euler = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.EqualStencilFunc = exports.EqualDepth = exports.EdgesGeometry = exports.DynamicReadUsage = exports.DynamicDrawUsage = exports.DynamicCopyUsage = exports.DstColorFactor = exports.DstAlphaFactor = exports.DoubleSide = exports.DodecahedronGeometry = exports.DodecahedronBufferGeometry = exports.DirectionalLightHelper = exports.DepthStencilFormat = exports.DepthFormat = exports.DefaultLoadingManager = exports.DecrementWrapStencilOp = exports.DecrementStencilOp = exports.Cylindrical = exports.CylinderGeometry = exports.CylinderBufferGeometry = exports.CustomToneMapping = exports.CustomBlending = exports.CullFaceNone = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = exports.CubeUVRefractionMapping = exports.CubeUVReflectionMapping = exports.CubeRefractionMapping = exports.CubeReflectionMapping = exports.ConeGeometry = exports.ConeBufferGeometry = exports.Color = exports.Clock = exports.ClampToEdgeWrapping = exports.CircleGeometry = exports.CircleBufferGeometry = exports.CineonToneMapping = exports.CameraHelper = exports.Cache = exports.ByteType = exports.BoxHelper = exports.CubeGeometry = exports.BoxGeometry = exports.BoxBufferGeometry = exports.Box3Helper = exports.Box3 = exports.Box2 = exports.BasicShadowMap = exports.BasicDepthPacking = exports.BackSide = exports.AxesHelper = exports.AudioListener = exports.AudioContext = exports.AudioAnalyser = exports.Audio = exports.ArrowHelper = exports.AnimationUtils = exports.AlwaysStencilFunc = exports.AlwaysDepth = exports.AlphaFormat = exports.AdditiveBlending = exports.AdditiveAnimationBlendMode = exports.AddOperation = exports.AddEquation = exports.ACESFilmicToneMapping = void 0;
exports.RGBFormat = exports.RGBEFormat = exports.RGBEEncoding = exports.RGBDEncoding = exports.RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_ETC2_EAC_Format = exports.RGBA_BPTC_Format = exports.RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBAIntegerFormat = exports.RGBAFormat = exports.RGBADepthPacking = exports.REVISION = exports.Quaternion = exports.PositionalAudio = exports.PolyhedronGeometry = exports.PolyhedronBufferGeometry = exports.PolarGridHelper = exports.PointLightHelper = exports.PlaneHelper = exports.PlaneGeometry = exports.PlaneBufferGeometry = exports.Plane = exports.PMREMGenerator = exports.PCFSoftShadowMap = exports.PCFShadowMap = exports.OneMinusSrcColorFactor = exports.OneMinusSrcAlphaFactor = exports.OneMinusDstColorFactor = exports.OneMinusDstAlphaFactor = exports.OneFactor = exports.OctahedronGeometry = exports.OctahedronBufferGeometry = exports.ObjectSpaceNormalMap = exports.NotEqualStencilFunc = exports.NotEqualDepth = exports.NormalBlending = exports.NormalAnimationBlendMode = exports.NoToneMapping = exports.NoColors = exports.NoBlending = exports.NeverStencilFunc = exports.NeverDepth = exports.NearestMipmapNearestFilter = exports.NearestMipmapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestMipMapLinearFilter = exports.NearestFilter = exports.MultiplyOperation = exports.MultiplyBlending = exports.MixOperation = exports.MirroredRepeatWrapping = exports.MinEquation = exports.MaxEquation = exports.Matrix4 = exports.Matrix3 = exports.MathUtils = exports.Math = exports.MOUSE = exports.LuminanceFormat = exports.LuminanceAlphaFormat = exports.LoopRepeat = exports.LoopPingPong = exports.LoopOnce = exports.LogLuvEncoding = exports.LoaderUtils = exports.LinearToneMapping = exports.LinearMipmapNearestFilter = exports.LinearMipmapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearMipMapLinearFilter = exports.LinearFilter = exports.LinearEncoding = exports.LineStrip = exports.LinePieces = exports.Line3 = exports.LessStencilFunc = exports.LessEqualStencilFunc = exports.LessEqualDepth = exports.LessDepth = exports.Layers = exports.LatheGeometry = exports.LatheBufferGeometry = exports.KeepStencilOp = void 0;
exports.sRGBEncoding = exports.ZeroStencilOp = exports.ZeroSlopeEnding = exports.ZeroFactor = exports.ZeroCurvatureEnding = exports.WrapAroundEnding = exports.WireframeGeometry = exports.VertexColors = exports.Vector4 = exports.Vector3 = exports.Vector2 = exports.VSMShadowMap = exports.UnsignedShortType = exports.UnsignedShort565Type = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.UnsignedIntType = exports.UnsignedInt248Type = exports.UnsignedByteType = exports.UniformsUtils = exports.UniformsLib = exports.Uniform = exports.UVMapping = exports.TubeGeometry = exports.TubeBufferGeometry = exports.TrianglesDrawMode = exports.TriangleStripDrawMode = exports.TriangleFanDrawMode = exports.Triangle = exports.TorusKnotGeometry = exports.TorusKnotBufferGeometry = exports.TorusGeometry = exports.TorusBufferGeometry = exports.TextGeometry = exports.TextBufferGeometry = exports.TetrahedronGeometry = exports.TetrahedronBufferGeometry = exports.TangentSpaceNormalMap = exports.TOUCH = exports.SubtractiveBlending = exports.SubtractEquation = exports.StreamReadUsage = exports.StreamDrawUsage = exports.StreamCopyUsage = exports.StaticReadUsage = exports.StaticDrawUsage = exports.StaticCopyUsage = exports.SrcColorFactor = exports.SrcAlphaSaturateFactor = exports.SrcAlphaFactor = exports.SpotLightHelper = exports.SphericalHarmonics3 = exports.Spherical = exports.SphereGeometry = exports.SphereBufferGeometry = exports.Sphere = exports.SmoothShading = exports.SkeletonHelper = exports.ShortType = exports.ShapeUtils = exports.ShapeGeometry = exports.ShapeBufferGeometry = exports.ShaderLib = exports.ShaderChunk = exports.SceneUtils = exports.Scene = exports.SRGB8_ALPHA8_ASTC_8x8_Format = exports.SRGB8_ALPHA8_ASTC_8x6_Format = exports.SRGB8_ALPHA8_ASTC_8x5_Format = exports.SRGB8_ALPHA8_ASTC_6x6_Format = exports.SRGB8_ALPHA8_ASTC_6x5_Format = exports.SRGB8_ALPHA8_ASTC_5x5_Format = exports.SRGB8_ALPHA8_ASTC_5x4_Format = exports.SRGB8_ALPHA8_ASTC_4x4_Format = exports.SRGB8_ALPHA8_ASTC_12x12_Format = exports.SRGB8_ALPHA8_ASTC_12x10_Format = exports.SRGB8_ALPHA8_ASTC_10x8_Format = exports.SRGB8_ALPHA8_ASTC_10x6_Format = exports.SRGB8_ALPHA8_ASTC_10x5_Format = exports.SRGB8_ALPHA8_ASTC_10x10_Format = exports.RingGeometry = exports.RingBufferGeometry = exports.ReverseSubtractEquation = exports.ReplaceStencilOp = exports.RepeatWrapping = exports.ReinhardToneMapping = exports.RedIntegerFormat = exports.RedFormat = exports.Ray = exports.RGIntegerFormat = exports.RGFormat = exports.RGB_S3TC_DXT1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_ETC2_Format = exports.RGB_ETC1_Format = exports.RGBM7Encoding = exports.RGBM16Encoding = exports.RGBIntegerFormat = void 0;

// Polyfills
if (Number.EPSILON === undefined) {
  Number.EPSILON = Math.pow(2, -52);
}

if (Number.isInteger === undefined) {
  // Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
  Number.isInteger = function (value) {
    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
  };
} //


if (Math.sign === undefined) {
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
  Math.sign = function (x) {
    return x < 0 ? -1 : x > 0 ? 1 : +x;
  };
}

if ('name' in Function.prototype === false) {
  // Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
  Object.defineProperty(Function.prototype, 'name', {
    get: function () {
      return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
    }
  });
}

if (Object.assign === undefined) {
  // Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
  Object.assign = function (target) {
    if (target === undefined || target === null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    const output = Object(target);

    for (let index = 1; index < arguments.length; index++) {
      const source = arguments[index];

      if (source !== undefined && source !== null) {
        for (const nextKey in source) {
          if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
            output[nextKey] = source[nextKey];
          }
        }
      }
    }

    return output;
  };
}

const REVISION = '120';
exports.REVISION = REVISION;
const MOUSE = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2
};
exports.MOUSE = MOUSE;
const TOUCH = {
  ROTATE: 0,
  PAN: 1,
  DOLLY_PAN: 2,
  DOLLY_ROTATE: 3
};
exports.TOUCH = TOUCH;
const CullFaceNone = 0;
exports.CullFaceNone = CullFaceNone;
const CullFaceBack = 1;
exports.CullFaceBack = CullFaceBack;
const CullFaceFront = 2;
exports.CullFaceFront = CullFaceFront;
const CullFaceFrontBack = 3;
exports.CullFaceFrontBack = CullFaceFrontBack;
const BasicShadowMap = 0;
exports.BasicShadowMap = BasicShadowMap;
const PCFShadowMap = 1;
exports.PCFShadowMap = PCFShadowMap;
const PCFSoftShadowMap = 2;
exports.PCFSoftShadowMap = PCFSoftShadowMap;
const VSMShadowMap = 3;
exports.VSMShadowMap = VSMShadowMap;
const FrontSide = 0;
exports.FrontSide = FrontSide;
const BackSide = 1;
exports.BackSide = BackSide;
const DoubleSide = 2;
exports.DoubleSide = DoubleSide;
const FlatShading = 1;
exports.FlatShading = FlatShading;
const SmoothShading = 2;
exports.SmoothShading = SmoothShading;
const NoBlending = 0;
exports.NoBlending = NoBlending;
const NormalBlending = 1;
exports.NormalBlending = NormalBlending;
const AdditiveBlending = 2;
exports.AdditiveBlending = AdditiveBlending;
const SubtractiveBlending = 3;
exports.SubtractiveBlending = SubtractiveBlending;
const MultiplyBlending = 4;
exports.MultiplyBlending = MultiplyBlending;
const CustomBlending = 5;
exports.CustomBlending = CustomBlending;
const AddEquation = 100;
exports.AddEquation = AddEquation;
const SubtractEquation = 101;
exports.SubtractEquation = SubtractEquation;
const ReverseSubtractEquation = 102;
exports.ReverseSubtractEquation = ReverseSubtractEquation;
const MinEquation = 103;
exports.MinEquation = MinEquation;
const MaxEquation = 104;
exports.MaxEquation = MaxEquation;
const ZeroFactor = 200;
exports.ZeroFactor = ZeroFactor;
const OneFactor = 201;
exports.OneFactor = OneFactor;
const SrcColorFactor = 202;
exports.SrcColorFactor = SrcColorFactor;
const OneMinusSrcColorFactor = 203;
exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
const SrcAlphaFactor = 204;
exports.SrcAlphaFactor = SrcAlphaFactor;
const OneMinusSrcAlphaFactor = 205;
exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
const DstAlphaFactor = 206;
exports.DstAlphaFactor = DstAlphaFactor;
const OneMinusDstAlphaFactor = 207;
exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
const DstColorFactor = 208;
exports.DstColorFactor = DstColorFactor;
const OneMinusDstColorFactor = 209;
exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
const SrcAlphaSaturateFactor = 210;
exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
const NeverDepth = 0;
exports.NeverDepth = NeverDepth;
const AlwaysDepth = 1;
exports.AlwaysDepth = AlwaysDepth;
const LessDepth = 2;
exports.LessDepth = LessDepth;
const LessEqualDepth = 3;
exports.LessEqualDepth = LessEqualDepth;
const EqualDepth = 4;
exports.EqualDepth = EqualDepth;
const GreaterEqualDepth = 5;
exports.GreaterEqualDepth = GreaterEqualDepth;
const GreaterDepth = 6;
exports.GreaterDepth = GreaterDepth;
const NotEqualDepth = 7;
exports.NotEqualDepth = NotEqualDepth;
const MultiplyOperation = 0;
exports.MultiplyOperation = MultiplyOperation;
const MixOperation = 1;
exports.MixOperation = MixOperation;
const AddOperation = 2;
exports.AddOperation = AddOperation;
const NoToneMapping = 0;
exports.NoToneMapping = NoToneMapping;
const LinearToneMapping = 1;
exports.LinearToneMapping = LinearToneMapping;
const ReinhardToneMapping = 2;
exports.ReinhardToneMapping = ReinhardToneMapping;
const CineonToneMapping = 3;
exports.CineonToneMapping = CineonToneMapping;
const ACESFilmicToneMapping = 4;
exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
const CustomToneMapping = 5;
exports.CustomToneMapping = CustomToneMapping;
const UVMapping = 300;
exports.UVMapping = UVMapping;
const CubeReflectionMapping = 301;
exports.CubeReflectionMapping = CubeReflectionMapping;
const CubeRefractionMapping = 302;
exports.CubeRefractionMapping = CubeRefractionMapping;
const EquirectangularReflectionMapping = 303;
exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
const EquirectangularRefractionMapping = 304;
exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
const CubeUVReflectionMapping = 306;
exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
const CubeUVRefractionMapping = 307;
exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
const RepeatWrapping = 1000;
exports.RepeatWrapping = RepeatWrapping;
const ClampToEdgeWrapping = 1001;
exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
const MirroredRepeatWrapping = 1002;
exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
const NearestFilter = 1003;
exports.NearestFilter = NearestFilter;
const NearestMipmapNearestFilter = 1004;
exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
const NearestMipMapNearestFilter = 1004;
exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
const NearestMipmapLinearFilter = 1005;
exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
const NearestMipMapLinearFilter = 1005;
exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
const LinearFilter = 1006;
exports.LinearFilter = LinearFilter;
const LinearMipmapNearestFilter = 1007;
exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
const LinearMipMapNearestFilter = 1007;
exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
const LinearMipmapLinearFilter = 1008;
exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
const LinearMipMapLinearFilter = 1008;
exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
const UnsignedByteType = 1009;
exports.UnsignedByteType = UnsignedByteType;
const ByteType = 1010;
exports.ByteType = ByteType;
const ShortType = 1011;
exports.ShortType = ShortType;
const UnsignedShortType = 1012;
exports.UnsignedShortType = UnsignedShortType;
const IntType = 1013;
exports.IntType = IntType;
const UnsignedIntType = 1014;
exports.UnsignedIntType = UnsignedIntType;
const FloatType = 1015;
exports.FloatType = FloatType;
const HalfFloatType = 1016;
exports.HalfFloatType = HalfFloatType;
const UnsignedShort4444Type = 1017;
exports.UnsignedShort4444Type = UnsignedShort4444Type;
const UnsignedShort5551Type = 1018;
exports.UnsignedShort5551Type = UnsignedShort5551Type;
const UnsignedShort565Type = 1019;
exports.UnsignedShort565Type = UnsignedShort565Type;
const UnsignedInt248Type = 1020;
exports.UnsignedInt248Type = UnsignedInt248Type;
const AlphaFormat = 1021;
exports.AlphaFormat = AlphaFormat;
const RGBFormat = 1022;
exports.RGBFormat = RGBFormat;
const RGBAFormat = 1023;
exports.RGBAFormat = RGBAFormat;
const LuminanceFormat = 1024;
exports.LuminanceFormat = LuminanceFormat;
const LuminanceAlphaFormat = 1025;
exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
const RGBEFormat = RGBAFormat;
exports.RGBEFormat = RGBEFormat;
const DepthFormat = 1026;
exports.DepthFormat = DepthFormat;
const DepthStencilFormat = 1027;
exports.DepthStencilFormat = DepthStencilFormat;
const RedFormat = 1028;
exports.RedFormat = RedFormat;
const RedIntegerFormat = 1029;
exports.RedIntegerFormat = RedIntegerFormat;
const RGFormat = 1030;
exports.RGFormat = RGFormat;
const RGIntegerFormat = 1031;
exports.RGIntegerFormat = RGIntegerFormat;
const RGBIntegerFormat = 1032;
exports.RGBIntegerFormat = RGBIntegerFormat;
const RGBAIntegerFormat = 1033;
exports.RGBAIntegerFormat = RGBAIntegerFormat;
const RGB_S3TC_DXT1_Format = 33776;
exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
const RGBA_S3TC_DXT1_Format = 33777;
exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
const RGBA_S3TC_DXT3_Format = 33778;
exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
const RGBA_S3TC_DXT5_Format = 33779;
exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
const RGB_PVRTC_4BPPV1_Format = 35840;
exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
const RGB_PVRTC_2BPPV1_Format = 35841;
exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
const RGBA_PVRTC_4BPPV1_Format = 35842;
exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
const RGBA_PVRTC_2BPPV1_Format = 35843;
exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
const RGB_ETC1_Format = 36196;
exports.RGB_ETC1_Format = RGB_ETC1_Format;
const RGB_ETC2_Format = 37492;
exports.RGB_ETC2_Format = RGB_ETC2_Format;
const RGBA_ETC2_EAC_Format = 37496;
exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
const RGBA_ASTC_4x4_Format = 37808;
exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
const RGBA_ASTC_5x4_Format = 37809;
exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
const RGBA_ASTC_5x5_Format = 37810;
exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
const RGBA_ASTC_6x5_Format = 37811;
exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
const RGBA_ASTC_6x6_Format = 37812;
exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
const RGBA_ASTC_8x5_Format = 37813;
exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
const RGBA_ASTC_8x6_Format = 37814;
exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
const RGBA_ASTC_8x8_Format = 37815;
exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
const RGBA_ASTC_10x5_Format = 37816;
exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
const RGBA_ASTC_10x6_Format = 37817;
exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
const RGBA_ASTC_10x8_Format = 37818;
exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
const RGBA_ASTC_10x10_Format = 37819;
exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
const RGBA_ASTC_12x10_Format = 37820;
exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
const RGBA_ASTC_12x12_Format = 37821;
exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
const RGBA_BPTC_Format = 36492;
exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
exports.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
exports.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
exports.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
exports.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
exports.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
exports.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
exports.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
exports.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
exports.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
exports.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
exports.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
exports.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
exports.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
exports.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format;
const LoopOnce = 2200;
exports.LoopOnce = LoopOnce;
const LoopRepeat = 2201;
exports.LoopRepeat = LoopRepeat;
const LoopPingPong = 2202;
exports.LoopPingPong = LoopPingPong;
const InterpolateDiscrete = 2300;
exports.InterpolateDiscrete = InterpolateDiscrete;
const InterpolateLinear = 2301;
exports.InterpolateLinear = InterpolateLinear;
const InterpolateSmooth = 2302;
exports.InterpolateSmooth = InterpolateSmooth;
const ZeroCurvatureEnding = 2400;
exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
const ZeroSlopeEnding = 2401;
exports.ZeroSlopeEnding = ZeroSlopeEnding;
const WrapAroundEnding = 2402;
exports.WrapAroundEnding = WrapAroundEnding;
const NormalAnimationBlendMode = 2500;
exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
const AdditiveAnimationBlendMode = 2501;
exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
const TrianglesDrawMode = 0;
exports.TrianglesDrawMode = TrianglesDrawMode;
const TriangleStripDrawMode = 1;
exports.TriangleStripDrawMode = TriangleStripDrawMode;
const TriangleFanDrawMode = 2;
exports.TriangleFanDrawMode = TriangleFanDrawMode;
const LinearEncoding = 3000;
exports.LinearEncoding = LinearEncoding;
const sRGBEncoding = 3001;
exports.sRGBEncoding = sRGBEncoding;
const GammaEncoding = 3007;
exports.GammaEncoding = GammaEncoding;
const RGBEEncoding = 3002;
exports.RGBEEncoding = RGBEEncoding;
const LogLuvEncoding = 3003;
exports.LogLuvEncoding = LogLuvEncoding;
const RGBM7Encoding = 3004;
exports.RGBM7Encoding = RGBM7Encoding;
const RGBM16Encoding = 3005;
exports.RGBM16Encoding = RGBM16Encoding;
const RGBDEncoding = 3006;
exports.RGBDEncoding = RGBDEncoding;
const BasicDepthPacking = 3200;
exports.BasicDepthPacking = BasicDepthPacking;
const RGBADepthPacking = 3201;
exports.RGBADepthPacking = RGBADepthPacking;
const TangentSpaceNormalMap = 0;
exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
const ObjectSpaceNormalMap = 1;
exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
const ZeroStencilOp = 0;
exports.ZeroStencilOp = ZeroStencilOp;
const KeepStencilOp = 7680;
exports.KeepStencilOp = KeepStencilOp;
const ReplaceStencilOp = 7681;
exports.ReplaceStencilOp = ReplaceStencilOp;
const IncrementStencilOp = 7682;
exports.IncrementStencilOp = IncrementStencilOp;
const DecrementStencilOp = 7683;
exports.DecrementStencilOp = DecrementStencilOp;
const IncrementWrapStencilOp = 34055;
exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
const DecrementWrapStencilOp = 34056;
exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
const InvertStencilOp = 5386;
exports.InvertStencilOp = InvertStencilOp;
const NeverStencilFunc = 512;
exports.NeverStencilFunc = NeverStencilFunc;
const LessStencilFunc = 513;
exports.LessStencilFunc = LessStencilFunc;
const EqualStencilFunc = 514;
exports.EqualStencilFunc = EqualStencilFunc;
const LessEqualStencilFunc = 515;
exports.LessEqualStencilFunc = LessEqualStencilFunc;
const GreaterStencilFunc = 516;
exports.GreaterStencilFunc = GreaterStencilFunc;
const NotEqualStencilFunc = 517;
exports.NotEqualStencilFunc = NotEqualStencilFunc;
const GreaterEqualStencilFunc = 518;
exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
const AlwaysStencilFunc = 519;
exports.AlwaysStencilFunc = AlwaysStencilFunc;
const StaticDrawUsage = 35044;
exports.StaticDrawUsage = StaticDrawUsage;
const DynamicDrawUsage = 35048;
exports.DynamicDrawUsage = DynamicDrawUsage;
const StreamDrawUsage = 35040;
exports.StreamDrawUsage = StreamDrawUsage;
const StaticReadUsage = 35045;
exports.StaticReadUsage = StaticReadUsage;
const DynamicReadUsage = 35049;
exports.DynamicReadUsage = DynamicReadUsage;
const StreamReadUsage = 35041;
exports.StreamReadUsage = StreamReadUsage;
const StaticCopyUsage = 35046;
exports.StaticCopyUsage = StaticCopyUsage;
const DynamicCopyUsage = 35050;
exports.DynamicCopyUsage = DynamicCopyUsage;
const StreamCopyUsage = 35042;
exports.StreamCopyUsage = StreamCopyUsage;
const GLSL1 = "100";
exports.GLSL1 = GLSL1;
const GLSL3 = "300 es";
/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

exports.GLSL3 = GLSL3;

function EventDispatcher() {}

Object.assign(EventDispatcher.prototype, {
  addEventListener: function (type, listener) {
    if (this._listeners === undefined) this._listeners = {};
    const listeners = this._listeners;

    if (listeners[type] === undefined) {
      listeners[type] = [];
    }

    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  },
  hasEventListener: function (type, listener) {
    if (this._listeners === undefined) return false;
    const listeners = this._listeners;
    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
  },
  removeEventListener: function (type, listener) {
    if (this._listeners === undefined) return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];

    if (listenerArray !== undefined) {
      const index = listenerArray.indexOf(listener);

      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  },
  dispatchEvent: function (event) {
    if (this._listeners === undefined) return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {
      event.target = this; // Make a copy, in case listeners are removed while iterating.

      const array = listenerArray.slice(0);

      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }
  }
});
const _lut = [];

for (let i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? '0' : '') + i.toString(16);
}

let _seed = 1234567;
const MathUtils = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function () {
    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
    const d0 = Math.random() * 0xffffffff | 0;
    const d1 = Math.random() * 0xffffffff | 0;
    const d2 = Math.random() * 0xffffffff | 0;
    const d3 = Math.random() * 0xffffffff | 0;
    const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.

    return uuid.toUpperCase();
  },
  clamp: function (value, min, max) {
    return Math.max(min, Math.min(max, value));
  },
  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  euclideanModulo: function (n, m) {
    return (n % m + m) % m;
  },
  // Linear mapping from range <a1, a2> to range <b1, b2>
  mapLinear: function (x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  },
  // https://en.wikipedia.org/wiki/Linear_interpolation
  lerp: function (x, y, t) {
    return (1 - t) * x + t * y;
  },
  // http://en.wikipedia.org/wiki/Smoothstep
  smoothstep: function (x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  },
  smootherstep: function (x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  },
  // Random integer from <low, high> interval
  randInt: function (low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  // Random float from <low, high> interval
  randFloat: function (low, high) {
    return low + Math.random() * (high - low);
  },
  // Random float from <-range/2, range/2> interval
  randFloatSpread: function (range) {
    return range * (0.5 - Math.random());
  },
  // Deterministic pseudo-random float in the interval [ 0, 1 ]
  seededRandom: function (s) {
    if (s !== undefined) _seed = s % 2147483647; // Park-Miller algorithm

    _seed = _seed * 16807 % 2147483647;
    return (_seed - 1) / 2147483646;
  },
  degToRad: function (degrees) {
    return degrees * MathUtils.DEG2RAD;
  },
  radToDeg: function (radians) {
    return radians * MathUtils.RAD2DEG;
  },
  isPowerOfTwo: function (value) {
    return (value & value - 1) === 0 && value !== 0;
  },
  ceilPowerOfTwo: function (value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  },
  floorPowerOfTwo: function (value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  },
  setQuaternionFromProperEuler: function (q, a, b, c, order) {
    // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
    // rotations are applied to the axes in the order specified by 'order'
    // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
    // angles are in radians
    const cos = Math.cos;
    const sin = Math.sin;
    const c2 = cos(b / 2);
    const s2 = sin(b / 2);
    const c13 = cos((a + c) / 2);
    const s13 = sin((a + c) / 2);
    const c1_3 = cos((a - c) / 2);
    const s1_3 = sin((a - c) / 2);
    const c3_1 = cos((c - a) / 2);
    const s3_1 = sin((c - a) / 2);

    switch (order) {
      case 'XYX':
        q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
        break;

      case 'YZY':
        q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
        break;

      case 'ZXZ':
        q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
        break;

      case 'XZX':
        q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
        break;

      case 'YXY':
        q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
        break;

      case 'ZYZ':
        q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
        break;

      default:
        console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
    }
  }
};
exports.MathUtils = exports.Math = MathUtils;

class Vector2 {
  constructor(x = 0, y = 0) {
    Object.defineProperty(this, 'isVector2', {
      value: true
    });
    this.x = x;
    this.y = y;
  }

  get width() {
    return this.x;
  }

  set width(value) {
    this.x = value;
  }

  get height() {
    return this.y;
  }

  set height(value) {
    this.y = value;
  }

  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }

  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }

  setX(x) {
    this.x = x;
    return this;
  }

  setY(y) {
    this.y = y;
    return this;
  }

  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  }

  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      default:
        throw new Error('index is out of range: ' + index);
    }
  }

  clone() {
    return new this.constructor(this.x, this.y);
  }

  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }

  add(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    return this;
  }

  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }

  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }

  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }

  sub(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    return this;
  }

  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }

  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }

  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }

  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }

  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }

  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }

  applyMatrix3(m) {
    const x = this.x,
          y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }

  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }

  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }

  clamp(min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }

  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }

  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }

  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }

  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }

  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }

  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }

  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }

  dot(v) {
    return this.x * v.x + this.y * v.y;
  }

  cross(v) {
    return this.x * v.y - this.y * v.x;
  }

  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }

  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }

  normalize() {
    return this.divideScalar(this.length() || 1);
  }

  angle() {
    // computes the angle in radians with respect to the positive x-axis
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }

  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }

  distanceToSquared(v) {
    const dx = this.x - v.x,
          dy = this.y - v.y;
    return dx * dx + dy * dy;
  }

  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }

  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }

  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }

  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }

  equals(v) {
    return v.x === this.x && v.y === this.y;
  }

  fromArray(array, offset) {
    if (offset === undefined) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }

  toArray(array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }

  fromBufferAttribute(attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }

  rotateAround(center, angle) {
    const c = Math.cos(angle),
          s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }

  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }

}

exports.Vector2 = Vector2;

class Matrix3 {
  constructor() {
    Object.defineProperty(this, 'isMatrix3', {
      value: true
    });
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    if (arguments.length > 0) {
      console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
    }
  }

  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }

  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }

  clone() {
    return new this.constructor().fromArray(this.elements);
  }

  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }

  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }

  setFromMatrix4(m) {
    const me = m.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }

  multiply(m) {
    return this.multiplyMatrices(this, m);
  }

  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }

  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
          a12 = ae[3],
          a13 = ae[6];
    const a21 = ae[1],
          a22 = ae[4],
          a23 = ae[7];
    const a31 = ae[2],
          a32 = ae[5],
          a33 = ae[8];
    const b11 = be[0],
          b12 = be[3],
          b13 = be[6];
    const b21 = be[1],
          b22 = be[4],
          b23 = be[7];
    const b31 = be[2],
          b32 = be[5],
          b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }

  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }

  determinant() {
    const te = this.elements;
    const a = te[0],
          b = te[1],
          c = te[2],
          d = te[3],
          e = te[4],
          f = te[5],
          g = te[6],
          h = te[7],
          i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  }

  getInverse(matrix, throwOnDegenerate) {
    if (throwOnDegenerate !== undefined) {
      console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
    }

    const me = matrix.elements,
          te = this.elements,
          n11 = me[0],
          n21 = me[1],
          n31 = me[2],
          n12 = me[3],
          n22 = me[4],
          n32 = me[5],
          n13 = me[6],
          n23 = me[7],
          n33 = me[8],
          t11 = n33 * n22 - n32 * n23,
          t12 = n32 * n13 - n33 * n12,
          t13 = n23 * n12 - n22 * n13,
          det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }

  transpose() {
    let tmp;
    const m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  }

  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).getInverse(this).transpose();
  }

  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }

  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
  }

  scale(sx, sy) {
    const te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  }

  rotate(theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    const te = this.elements;
    const a11 = te[0],
          a12 = te[3],
          a13 = te[6];
    const a21 = te[1],
          a22 = te[4],
          a23 = te[7];
    te[0] = c * a11 + s * a21;
    te[3] = c * a12 + s * a22;
    te[6] = c * a13 + s * a23;
    te[1] = -s * a11 + c * a21;
    te[4] = -s * a12 + c * a22;
    te[7] = -s * a13 + c * a23;
    return this;
  }

  translate(tx, ty) {
    const te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  }

  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;

    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  }

  fromArray(array, offset) {
    if (offset === undefined) offset = 0;

    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  }

  toArray(array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }

}

exports.Matrix3 = Matrix3;

let _canvas;

const ImageUtils = {
  getDataURL: function (image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }

    if (typeof HTMLCanvasElement == 'undefined') {
      return image.src;
    }

    let canvas;

    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
      _canvas.width = image.width;
      _canvas.height = image.height;

      const context = _canvas.getContext('2d');

      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }

      canvas = _canvas;
    }

    if (canvas.width > 2048 || canvas.height > 2048) {
      return canvas.toDataURL('image/jpeg', 0.6);
    } else {
      return canvas.toDataURL('image/png');
    }
  }
};
exports.ImageUtils = ImageUtils;
let textureId = 0;

function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
  Object.defineProperty(this, 'id', {
    value: textureId++
  });
  this.uuid = MathUtils.generateUUID();
  this.name = '';
  this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
  this.mipmaps = [];
  this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
  this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
  this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
  this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
  this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;
  this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
  this.format = format !== undefined ? format : RGBAFormat;
  this.internalFormat = null;
  this.type = type !== undefined ? type : UnsignedByteType;
  this.offset = new Vector2(0, 0);
  this.repeat = new Vector2(1, 1);
  this.center = new Vector2(0, 0);
  this.rotation = 0;
  this.matrixAutoUpdate = true;
  this.matrix = new Matrix3();
  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
  // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
  //
  // Also changing the encoding after already used by a Material will not automatically make the Material
  // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.

  this.encoding = encoding !== undefined ? encoding : LinearEncoding;
  this.version = 0;
  this.onUpdate = null;
}

Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Texture,
  isTexture: true,
  updateMatrix: function () {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  },
  toJSON: function (meta) {
    const isRootObject = meta === undefined || typeof meta === 'string';

    if (!isRootObject && meta.textures[this.uuid] !== undefined) {
      return meta.textures[this.uuid];
    }

    const output = {
      metadata: {
        version: 4.5,
        type: 'Texture',
        generator: 'Texture.toJSON'
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };

    if (this.image !== undefined) {
      // TODO: Move to THREE.Image
      const image = this.image;

      if (image.uuid === undefined) {
        image.uuid = MathUtils.generateUUID(); // UGH
      }

      if (!isRootObject && meta.images[image.uuid] === undefined) {
        let url;

        if (Array.isArray(image)) {
          // process array of images e.g. CubeTexture
          url = [];

          for (let i = 0, l = image.length; i < l; i++) {
            url.push(ImageUtils.getDataURL(image[i]));
          }
        } else {
          // process single image
          url = ImageUtils.getDataURL(image);
        }

        meta.images[image.uuid] = {
          uuid: image.uuid,
          url: url
        };
      }

      output.image = image.uuid;
    }

    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }

    return output;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  },
  transformUv: function (uv) {
    if (this.mapping !== UVMapping) return uv;
    uv.applyMatrix3(this.matrix);

    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;

        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;

        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }

          break;
      }
    }

    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;

        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;

        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }

          break;
      }
    }

    if (this.flipY) {
      uv.y = 1 - uv.y;
    }

    return uv;
  }
});
Object.defineProperty(Texture.prototype, "needsUpdate", {
  set: function (value) {
    if (value === true) this.version++;
  }
});

class Vector4 {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    Object.defineProperty(this, 'isVector4', {
      value: true
    });
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }

  get width() {
    return this.z;
  }

  set width(value) {
    this.z = value;
  }

  get height() {
    return this.w;
  }

  set height(value) {
    this.w = value;
  }

  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }

  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }

  setX(x) {
    this.x = x;
    return this;
  }

  setY(y) {
    this.y = y;
    return this;
  }

  setZ(z) {
    this.z = z;
    return this;
  }

  setW(w) {
    this.w = w;
    return this;
  }

  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      case 2:
        this.z = value;
        break;

      case 3:
        this.w = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  }

  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      case 3:
        return this.w;

      default:
        throw new Error('index is out of range: ' + index);
    }
  }

  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }

  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== undefined ? v.w : 1;
    return this;
  }

  add(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  }

  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  }

  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }

  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  }

  sub(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  }

  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  }

  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }

  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }

  applyMatrix4(m) {
    const x = this.x,
          y = this.y,
          z = this.z,
          w = this.w;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  }

  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }

  setAxisAngleFromQuaternion(q) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
    // q is assumed to be normalized
    this.w = 2 * Math.acos(q.w);
    const s = Math.sqrt(1 - q.w * q.w);

    if (s < 0.0001) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }

    return this;
  }

  setAxisAngleFromRotationMatrix(m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    let angle, x, y, z; // variables for result

    const epsilon = 0.01,
          // margin to allow for rounding errors
    epsilon2 = 0.1,
          // margin to distinguish between 0 and 180 degrees
    te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10];

    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      // singularity found
      // first check for identity matrix which must have +1 for all terms
      // in leading diagonal and zero in other terms
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        // this singularity is identity matrix so angle = 0
        this.set(1, 0, 0, 0);
        return this; // zero angle, arbitrary axis
      } // otherwise this singularity is angle = 180


      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;

      if (xx > yy && xx > zz) {
        // m11 is the largest diagonal term
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        // m22 is the largest diagonal term
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        // m33 is the largest diagonal term so base result on this
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }

      this.set(x, y, z, angle);
      return this; // return 180 deg rotation
    } // as we have reached here there are no singularities so we can handle normally


    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

    if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be
    // caught by singularity test above, but I've left it in just in case

    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }

  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  }

  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  }

  clamp(min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }

  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }

  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }

  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }

  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }

  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }

  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }

  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }

  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }

  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }

  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }

  normalize() {
    return this.divideScalar(this.length() || 1);
  }

  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }

  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  }

  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }

  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }

  fromArray(array, offset) {
    if (offset === undefined) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }

  toArray(array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }

  fromBufferAttribute(attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }

  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }

}
/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/


exports.Vector4 = Vector4;

function WebGLRenderTarget(width, height, options) {
  this.width = width;
  this.height = height;
  this.scissor = new Vector4(0, 0, width, height);
  this.scissorTest = false;
  this.viewport = new Vector4(0, 0, width, height);
  options = options || {};
  this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
  this.texture.image = {};
  this.texture.image.width = width;
  this.texture.image.height = height;
  this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
  this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
  this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
  this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
}

WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: WebGLRenderTarget,
  isWebGLRenderTarget: true,
  setSize: function (width, height) {
    if (this.width !== width || this.height !== height) {
      this.width = width;
      this.height = height;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.dispose();
    }

    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.width = source.width;
    this.height = source.height;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});

function WebGLMultisampleRenderTarget(width, height, options) {
  WebGLRenderTarget.call(this, width, height, options);
  this.samples = 4;
}

WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
  constructor: WebGLMultisampleRenderTarget,
  isWebGLMultisampleRenderTarget: true,
  copy: function (source) {
    WebGLRenderTarget.prototype.copy.call(this, source);
    this.samples = source.samples;
    return this;
  }
});

class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    Object.defineProperty(this, 'isQuaternion', {
      value: true
    });
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }

  static slerp(qa, qb, qm, t) {
    return qm.copy(qa).slerp(qb, t);
  }

  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    // fuzz-free, array-based Quaternion SLERP operation
    let x0 = src0[srcOffset0 + 0],
        y0 = src0[srcOffset0 + 1],
        z0 = src0[srcOffset0 + 2],
        w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0],
          y1 = src1[srcOffset1 + 1],
          z1 = src1[srcOffset1 + 2],
          w1 = src1[srcOffset1 + 3];

    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
            dir = cos >= 0 ? 1 : -1,
            sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin),
              len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }

      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }

    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }

  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }

  get x() {
    return this._x;
  }

  set x(value) {
    this._x = value;

    this._onChangeCallback();
  }

  get y() {
    return this._y;
  }

  set y(value) {
    this._y = value;

    this._onChangeCallback();
  }

  get z() {
    return this._z;
  }

  set z(value) {
    this._z = value;

    this._onChangeCallback();
  }

  get w() {
    return this._w;
  }

  set w(value) {
    this._w = value;

    this._onChangeCallback();
  }

  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;

    this._onChangeCallback();

    return this;
  }

  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }

  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;

    this._onChangeCallback();

    return this;
  }

  setFromEuler(euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
    }

    const x = euler._x,
          y = euler._y,
          z = euler._z,
          order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/
    // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //	content/SpinCalc.m

    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);

    switch (order) {
      case 'XYZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'YXZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      case 'ZXY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'ZYX':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      case 'YZX':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'XZY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      default:
        console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
    }

    if (update !== false) this._onChangeCallback();
    return this;
  }

  setFromAxisAngle(axis, angle) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
    // assumes axis is normalized
    const halfAngle = angle / 2,
          s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);

    this._onChangeCallback();

    return this;
  }

  setFromRotationMatrix(m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    const te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10],
          trace = m11 + m22 + m33;

    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1.0);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }

    this._onChangeCallback();

    return this;
  }

  setFromUnitVectors(vFrom, vTo) {
    // assumes direction vectors vFrom and vTo are normalized
    const EPS = 0.000001;
    let r = vFrom.dot(vTo) + 1;

    if (r < EPS) {
      r = 0;

      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }

    return this.normalize();
  }

  angleTo(q) {
    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
  }

  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }

  identity() {
    return this.set(0, 0, 0, 1);
  }

  inverse() {
    // quaternion is assumed to have unit length
    return this.conjugate();
  }

  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;

    this._onChangeCallback();

    return this;
  }

  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }

  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }

  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }

  normalize() {
    let l = this.length();

    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }

    this._onChangeCallback();

    return this;
  }

  multiply(q, p) {
    if (p !== undefined) {
      console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
      return this.multiplyQuaternions(q, p);
    }

    return this.multiplyQuaternions(this, q);
  }

  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }

  multiplyQuaternions(a, b) {
    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
    const qax = a._x,
          qay = a._y,
          qaz = a._z,
          qaw = a._w;
    const qbx = b._x,
          qby = b._y,
          qbz = b._z,
          qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    this._onChangeCallback();

    return this;
  }

  slerp(qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    const x = this._x,
          y = this._y,
          z = this._z,
          w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }

    if (cosHalfTheta >= 1.0) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }

    const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();

      this._onChangeCallback();

      return this;
    }

    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;

    this._onChangeCallback();

    return this;
  }

  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }

  fromArray(array, offset) {
    if (offset === undefined) offset = 0;
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];

    this._onChangeCallback();

    return this;
  }

  toArray(array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }

  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }

  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }

  _onChangeCallback() {}

}

exports.Quaternion = Quaternion;

class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    Object.defineProperty(this, 'isVector3', {
      value: true
    });
    this.x = x;
    this.y = y;
    this.z = z;
  }

  set(x, y, z) {
    if (z === undefined) z = this.z; // sprite.scale.set(x,y)

    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }

  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }

  setX(x) {
    this.x = x;
    return this;
  }

  setY(y) {
    this.y = y;
    return this;
  }

  setZ(z) {
    this.z = z;
    return this;
  }

  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      case 2:
        this.z = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  }

  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      default:
        throw new Error('index is out of range: ' + index);
    }
  }

  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }

  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }

  add(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }

  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }

  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }

  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }

  sub(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }

  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }

  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }

  multiply(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
      return this.multiplyVectors(v, w);
    }

    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }

  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }

  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }

  applyEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
    }

    return this.applyQuaternion(_quaternion.setFromEuler(euler));
  }

  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
  }

  applyMatrix3(m) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }

  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }

  applyMatrix4(m) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }

  applyQuaternion(q) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const qx = q.x,
          qy = q.y,
          qz = q.z,
          qw = q.w; // calculate quat * vector

    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }

  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }

  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }

  transformDirection(m) {
    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }

  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }

  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }

  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }

  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }

  clamp(min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }

  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }

  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }

  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }

  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }

  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }

  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }

  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }

  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  } // TODO lengthSquared?


  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }

  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }

  normalize() {
    return this.divideScalar(this.length() || 1);
  }

  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }

  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }

  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }

  cross(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
      return this.crossVectors(v, w);
    }

    return this.crossVectors(this, v);
  }

  crossVectors(a, b) {
    const ax = a.x,
          ay = a.y,
          az = a.z;
    const bx = b.x,
          by = b.y,
          bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }

  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }

  projectOnPlane(planeNormal) {
    _vector.copy(this).projectOnVector(planeNormal);

    return this.sub(_vector);
  }

  reflect(normal) {
    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length
    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }

  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator; // clamp, to handle numerical problems

    return Math.acos(MathUtils.clamp(theta, -1, 1));
  }

  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }

  distanceToSquared(v) {
    const dx = this.x - v.x,
          dy = this.y - v.y,
          dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }

  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }

  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }

  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }

  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }

  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }

  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }

  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }

  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }

  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }

  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }

  fromArray(array, offset) {
    if (offset === undefined) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }

  toArray(array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }

  fromBufferAttribute(attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }

  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }

}

exports.Vector3 = Vector3;

const _vector = new Vector3();

const _quaternion = new Quaternion();

class Box3 {
  constructor(min, max) {
    Object.defineProperty(this, 'isBox3', {
      value: true
    });
    this.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);
    this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
  }

  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }

  setFromArray(array) {
    let minX = +Infinity;
    let minY = +Infinity;
    let minZ = +Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;

    for (let i = 0, l = array.length; i < l; i += 3) {
      const x = array[i];
      const y = array[i + 1];
      const z = array[i + 2];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }

    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }

  setFromBufferAttribute(attribute) {
    let minX = +Infinity;
    let minY = +Infinity;
    let minZ = +Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;

    for (let i = 0, l = attribute.count; i < l; i++) {
      const x = attribute.getX(i);
      const y = attribute.getY(i);
      const z = attribute.getZ(i);
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }

    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }

  setFromPoints(points) {
    this.makeEmpty();

    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }

    return this;
  }

  setFromCenterAndSize(center, size) {
    const halfSize = _vector$1.copy(size).multiplyScalar(0.5);

    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }

  setFromObject(object) {
    this.makeEmpty();
    return this.expandByObject(object);
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }

  makeEmpty() {
    this.min.x = this.min.y = this.min.z = +Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }

  isEmpty() {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }

  getCenter(target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .getCenter() target is now required');
      target = new Vector3();
    }

    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }

  getSize(target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .getSize() target is now required');
      target = new Vector3();
    }

    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }

  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }

  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }

  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }

  expandByObject(object) {
    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and children's, world transforms
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;

    if (geometry !== undefined) {
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }

      _box.copy(geometry.boundingBox);

      _box.applyMatrix4(object.matrixWorld);

      this.union(_box);
    }

    const children = object.children;

    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i]);
    }

    return this;
  }

  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }

  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }

  getParameter(point, target) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.
    if (target === undefined) {
      console.warn('THREE.Box3: .getParameter() target is now required');
      target = new Vector3();
    }

    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  }

  intersectsBox(box) {
    // using 6 splitting planes to rule out intersections.
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }

  intersectsSphere(sphere) {
    // Find the point on the AABB closest to the sphere center.
    this.clampPoint(sphere.center, _vector$1); // If that point is inside the sphere, the AABB and sphere intersect.

    return _vector$1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }

  intersectsPlane(plane) {
    // We compute the minimum and maximum dot product values. If those values
    // are on the same side (back or front) of the plane, then there is no intersection.
    let min, max;

    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }

    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }

    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }

    return min <= -plane.constant && max >= -plane.constant;
  }

  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    } // compute box center and extents


    this.getCenter(_center);

    _extents.subVectors(this.max, _center); // translate triangle to aabb origin


    _v0.subVectors(triangle.a, _center);

    _v1.subVectors(triangle.b, _center);

    _v2.subVectors(triangle.c, _center); // compute edge vectors for triangle


    _f0.subVectors(_v1, _v0);

    _f1.subVectors(_v2, _v1);

    _f2.subVectors(_v0, _v2); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)


    let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];

    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    } // test 3 face normals from the aabb


    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    } // finally testing the face normal of the triangle
    // use already existing triangle edge vectors here


    _triangleNormal.crossVectors(_f0, _f1);

    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0, _v1, _v2, _extents);
  }

  clampPoint(point, target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .clampPoint() target is now required');
      target = new Vector3();
    }

    return target.copy(point).clamp(this.min, this.max);
  }

  distanceToPoint(point) {
    const clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);

    return clampedPoint.sub(point).length();
  }

  getBoundingSphere(target) {
    if (target === undefined) {
      console.error('THREE.Box3: .getBoundingSphere() target is now required'); //target = new Sphere(); // removed to avoid cyclic dependency
    }

    this.getCenter(target.center);
    target.radius = this.getSize(_vector$1).length() * 0.5;
    return target;
  }

  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

    if (this.isEmpty()) this.makeEmpty();
    return this;
  }

  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }

  applyMatrix4(matrix) {
    // transform of empty box is an empty box.
    if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000


    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001


    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010


    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011


    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100


    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101


    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110


    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111


    this.setFromPoints(_points);
    return this;
  }

  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }

  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }

}

exports.Box3 = Box3;

function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i); // project the aabb onto the seperating axis


    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the seperating axis

    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      // points of the projected triangle are outside the projected half-length of the aabb
      // the axis is seperating and we can exit
      return false;
    }
  }

  return true;
}

const _points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];

const _vector$1 = new Vector3();

const _box = new Box3(); // triangle centered vertices


const _v0 = new Vector3();

const _v1 = new Vector3();

const _v2 = new Vector3(); // triangle edge vectors


const _f0 = new Vector3();

const _f1 = new Vector3();

const _f2 = new Vector3();

const _center = new Vector3();

const _extents = new Vector3();

const _triangleNormal = new Vector3();

const _testAxis = new Vector3();

const _box$1 = new Box3();

class Sphere {
  constructor(center, radius) {
    this.center = center !== undefined ? center : new Vector3();
    this.radius = radius !== undefined ? radius : -1;
  }

  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }

  setFromPoints(points, optionalCenter) {
    const center = this.center;

    if (optionalCenter !== undefined) {
      center.copy(optionalCenter);
    } else {
      _box$1.setFromPoints(points).getCenter(center);
    }

    let maxRadiusSq = 0;

    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }

    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }

  isEmpty() {
    return this.radius < 0;
  }

  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }

  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }

  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }

  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }

  intersectsBox(box) {
    return box.intersectsSphere(this);
  }

  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }

  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);

    if (target === undefined) {
      console.warn('THREE.Sphere: .clampPoint() target is now required');
      target = new Vector3();
    }

    target.copy(point);

    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }

    return target;
  }

  getBoundingBox(target) {
    if (target === undefined) {
      console.warn('THREE.Sphere: .getBoundingBox() target is now required');
      target = new Box3();
    }

    if (this.isEmpty()) {
      // Empty sphere produces empty bounding box
      target.makeEmpty();
      return target;
    }

    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }

  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }

  translate(offset) {
    this.center.add(offset);
    return this;
  }

  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }

}

exports.Sphere = Sphere;

const _vector$2 = new Vector3();

const _segCenter = new Vector3();

const _segDir = new Vector3();

const _diff = new Vector3();

const _edge1 = new Vector3();

const _edge2 = new Vector3();

const _normal = new Vector3();

class Ray {
  constructor(origin, direction) {
    this.origin = origin !== undefined ? origin : new Vector3();
    this.direction = direction !== undefined ? direction : new Vector3(0, 0, -1);
  }

  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }

  at(t, target) {
    if (target === undefined) {
      console.warn('THREE.Ray: .at() target is now required');
      target = new Vector3();
    }

    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
  }

  lookAt(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  }

  recast(t) {
    this.origin.copy(this.at(t, _vector$2));
    return this;
  }

  closestPointToPoint(point, target) {
    if (target === undefined) {
      console.warn('THREE.Ray: .closestPointToPoint() target is now required');
      target = new Vector3();
    }

    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);

    if (directionDistance < 0) {
      return target.copy(this.origin);
    }

    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  }

  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }

  distanceSqToPoint(point) {
    const directionDistance = _vector$2.subVectors(point, this.origin).dot(this.direction); // point behind the ray


    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }

    _vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

    return _vector$2.distanceToSquared(point);
  }

  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
    // It returns the min distance between the ray and the segment
    // defined by v0 and v1
    // It can also set two optional targets :
    // - The closest point on the ray
    // - The closest point on the segment
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);

    _segDir.copy(v1).sub(v0).normalize();

    _diff.copy(this.origin).sub(_segCenter);

    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);

    const b0 = _diff.dot(this.direction);

    const b1 = -_diff.dot(_segDir);

    const c = _diff.lengthSq();

    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;

    if (det > 0) {
      // The ray and segment are not parallel.
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;

      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            // region 0
            // Minimum at interior points of ray and segment.
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            // region 1
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          // region 5
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          // region 4
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          // region 3
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          // region 2
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      // Ray and segment are parallel.
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }

    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }

    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }

    return sqrDist;
  }

  intersectSphere(sphere, target) {
    _vector$2.subVectors(sphere.center, this.origin);

    const tca = _vector$2.dot(this.direction);

    const d2 = _vector$2.dot(_vector$2) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2) return null;
    const thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere

    const t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere

    const t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null

    if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:
    // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
    // in order to always return an intersect point that is in front of the ray.

    if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0

    return this.at(t0, target);
  }

  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }

  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);

    if (denominator === 0) {
      // line is coplanar, return origin
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      } // Null is preferable to undefined since undefined means.... it is undefined


      return null;
    }

    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane

    return t >= 0 ? t : null;
  }

  intersectPlane(plane, target) {
    const t = this.distanceToPlane(plane);

    if (t === null) {
      return null;
    }

    return this.at(t, target);
  }

  intersectsPlane(plane) {
    // check if the ray lies on the plane first
    const distToPoint = plane.distanceToPoint(this.origin);

    if (distToPoint === 0) {
      return true;
    }

    const denominator = plane.normal.dot(this.direction);

    if (denominator * distToPoint < 0) {
      return true;
    } // ray origin is behind the plane (and is pointing behind it)


    return false;
  }

  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x,
          invdiry = 1 / this.direction.y,
          invdirz = 1 / this.direction.z;
    const origin = this.origin;

    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }

    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }

    if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN
    // (result of 0 * Infinity). x !== x returns true if x is NaN

    if (tymin > tmin || tmin !== tmin) tmin = tymin;
    if (tymax < tmax || tmax !== tmax) tmax = tymax;

    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }

    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)

    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }

  intersectsBox(box) {
    return this.intersectBox(box, _vector$2) !== null;
  }

  intersectTriangle(a, b, c, backfaceCulling, target) {
    // Compute the offset origin, edges, and normal.
    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
    _edge1.subVectors(b, a);

    _edge2.subVectors(c, a);

    _normal.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
    // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
    //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
    //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
    //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)


    let DdN = this.direction.dot(_normal);
    let sign;

    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign = 1;
    } else if (DdN < 0) {
      sign = -1;
      DdN = -DdN;
    } else {
      return null;
    }

    _diff.subVectors(this.origin, a);

    const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection

    if (DdQxE2 < 0) {
      return null;
    }

    const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection

    if (DdE1xQ < 0) {
      return null;
    } // b1+b2 > 1, no intersection


    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    } // Line intersects triangle, check if ray does.


    const QdN = -sign * _diff.dot(_normal); // t < 0, no intersection


    if (QdN < 0) {
      return null;
    } // Ray intersects triangle.


    return this.at(QdN / DdN, target);
  }

  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }

  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }

}

exports.Ray = Ray;

class Matrix4 {
  constructor() {
    Object.defineProperty(this, 'isMatrix4', {
      value: true
    });
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

    if (arguments.length > 0) {
      console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
    }
  }

  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }

  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }

  clone() {
    return new Matrix4().fromArray(this.elements);
  }

  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }

  copyPosition(m) {
    const te = this.elements,
          me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }

  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }

  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }

  extractRotation(m) {
    // this method does not support reflection matrices
    const te = this.elements;
    const me = m.elements;

    const scaleX = 1 / _v1$1.setFromMatrixColumn(m, 0).length();

    const scaleY = 1 / _v1$1.setFromMatrixColumn(m, 1).length();

    const scaleZ = 1 / _v1$1.setFromMatrixColumn(m, 2).length();

    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }

  makeRotationFromEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
    }

    const te = this.elements;
    const x = euler.x,
          y = euler.y,
          z = euler.z;
    const a = Math.cos(x),
          b = Math.sin(x);
    const c = Math.cos(y),
          d = Math.sin(y);
    const e = Math.cos(z),
          f = Math.sin(z);

    if (euler.order === 'XYZ') {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === 'YXZ') {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === 'ZXY') {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === 'ZYX') {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === 'YZX') {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === 'XZY') {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    } // bottom row


    te[3] = 0;
    te[7] = 0;
    te[11] = 0; // last column

    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }

  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }

  lookAt(eye, target, up) {
    const te = this.elements;

    _z.subVectors(eye, target);

    if (_z.lengthSq() === 0) {
      // eye and target are in the same position
      _z.z = 1;
    }

    _z.normalize();

    _x.crossVectors(up, _z);

    if (_x.lengthSq() === 0) {
      // up and z are parallel
      if (Math.abs(up.z) === 1) {
        _z.x += 0.0001;
      } else {
        _z.z += 0.0001;
      }

      _z.normalize();

      _x.crossVectors(up, _z);
    }

    _x.normalize();

    _y.crossVectors(_z, _x);

    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }

  multiply(m, n) {
    if (n !== undefined) {
      console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
      return this.multiplyMatrices(m, n);
    }

    return this.multiplyMatrices(this, m);
  }

  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }

  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
          a12 = ae[4],
          a13 = ae[8],
          a14 = ae[12];
    const a21 = ae[1],
          a22 = ae[5],
          a23 = ae[9],
          a24 = ae[13];
    const a31 = ae[2],
          a32 = ae[6],
          a33 = ae[10],
          a34 = ae[14];
    const a41 = ae[3],
          a42 = ae[7],
          a43 = ae[11],
          a44 = ae[15];
    const b11 = be[0],
          b12 = be[4],
          b13 = be[8],
          b14 = be[12];
    const b21 = be[1],
          b22 = be[5],
          b23 = be[9],
          b24 = be[13];
    const b31 = be[2],
          b32 = be[6],
          b33 = be[10],
          b34 = be[14];
    const b41 = be[3],
          b42 = be[7],
          b43 = be[11],
          b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }

  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }

  determinant() {
    const te = this.elements;
    const n11 = te[0],
          n12 = te[4],
          n13 = te[8],
          n14 = te[12];
    const n21 = te[1],
          n22 = te[5],
          n23 = te[9],
          n24 = te[13];
    const n31 = te[2],
          n32 = te[6],
          n33 = te[10],
          n34 = te[14];
    const n41 = te[3],
          n42 = te[7],
          n43 = te[11],
          n44 = te[15]; //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }

  transpose() {
    const te = this.elements;
    let tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  }

  setPosition(x, y, z) {
    const te = this.elements;

    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }

    return this;
  }

  getInverse(m, throwOnDegenerate) {
    if (throwOnDegenerate !== undefined) {
      console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
    } // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm


    const te = this.elements,
          me = m.elements,
          n11 = me[0],
          n21 = me[1],
          n31 = me[2],
          n41 = me[3],
          n12 = me[4],
          n22 = me[5],
          n32 = me[6],
          n42 = me[7],
          n13 = me[8],
          n23 = me[9],
          n33 = me[10],
          n43 = me[11],
          n14 = me[12],
          n24 = me[13],
          n34 = me[14],
          n44 = me[15],
          t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
          t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
          t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
          t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }

  scale(v) {
    const te = this.elements;
    const x = v.x,
          y = v.y,
          z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }

  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }

  makeTranslation(x, y, z) {
    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    return this;
  }

  makeRotationX(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationY(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationZ(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationAxis(axis, angle) {
    // Based on http://www.gamedev.net/reference/articles/article1199.asp
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x,
          y = axis.y,
          z = axis.z;
    const tx = t * x,
          ty = t * y;
    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    return this;
  }

  makeScale(x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  }

  makeShear(x, y, z) {
    this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
    return this;
  }

  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x,
          y = quaternion._y,
          z = quaternion._z,
          w = quaternion._w;
    const x2 = x + x,
          y2 = y + y,
          z2 = z + z;
    const xx = x * x2,
          xy = x * y2,
          xz = x * z2;
    const yy = y * y2,
          yz = y * z2,
          zz = z * z2;
    const wx = w * x2,
          wy = w * y2,
          wz = w * z2;
    const sx = scale.x,
          sy = scale.y,
          sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }

  decompose(position, quaternion, scale) {
    const te = this.elements;

    let sx = _v1$1.set(te[0], te[1], te[2]).length();

    const sy = _v1$1.set(te[4], te[5], te[6]).length();

    const sz = _v1$1.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale


    const det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14]; // scale the rotation part

    _m1.copy(this);

    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1.elements[0] *= invSX;
    _m1.elements[1] *= invSX;
    _m1.elements[2] *= invSX;
    _m1.elements[4] *= invSY;
    _m1.elements[5] *= invSY;
    _m1.elements[6] *= invSY;
    _m1.elements[8] *= invSZ;
    _m1.elements[9] *= invSZ;
    _m1.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }

  makePerspective(left, right, top, bottom, near, far) {
    if (far === undefined) {
      console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
    }

    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    const c = -(far + near) / (far - near);
    const d = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }

  makeOrthographic(left, right, top, bottom, near, far) {
    const te = this.elements;
    const w = 1.0 / (right - left);
    const h = 1.0 / (top - bottom);
    const p = 1.0 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h;
    const z = (far + near) * p;
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }

  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;

    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  }

  fromArray(array, offset) {
    if (offset === undefined) offset = 0;

    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  }

  toArray(array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }

}

exports.Matrix4 = Matrix4;

const _v1$1 = new Vector3();

const _m1 = new Matrix4();

const _zero = new Vector3(0, 0, 0);

const _one = new Vector3(1, 1, 1);

const _x = new Vector3();

const _y = new Vector3();

const _z = new Vector3();

class Euler {
  constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
    Object.defineProperty(this, 'isEuler', {
      value: true
    });
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }

  get x() {
    return this._x;
  }

  set x(value) {
    this._x = value;

    this._onChangeCallback();
  }

  get y() {
    return this._y;
  }

  set y(value) {
    this._y = value;

    this._onChangeCallback();
  }

  get z() {
    return this._z;
  }

  set z(value) {
    this._z = value;

    this._onChangeCallback();
  }

  get order() {
    return this._order;
  }

  set order(value) {
    this._order = value;

    this._onChangeCallback();
  }

  set(x, y, z, order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;

    this._onChangeCallback();

    return this;
  }

  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }

  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;

    this._onChangeCallback();

    return this;
  }

  setFromRotationMatrix(m, order, update) {
    const clamp = MathUtils.clamp; // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    const te = m.elements;
    const m11 = te[0],
          m12 = te[4],
          m13 = te[8];
    const m21 = te[1],
          m22 = te[5],
          m23 = te[9];
    const m31 = te[2],
          m32 = te[6],
          m33 = te[10];
    order = order || this._order;

    switch (order) {
      case 'XYZ':
        this._y = Math.asin(clamp(m13, -1, 1));

        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }

        break;

      case 'YXZ':
        this._x = Math.asin(-clamp(m23, -1, 1));

        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }

        break;

      case 'ZXY':
        this._x = Math.asin(clamp(m32, -1, 1));

        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }

        break;

      case 'ZYX':
        this._y = Math.asin(-clamp(m31, -1, 1));

        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }

        break;

      case 'YZX':
        this._z = Math.asin(clamp(m21, -1, 1));

        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }

        break;

      case 'XZY':
        this._z = Math.asin(-clamp(m12, -1, 1));

        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }

        break;

      default:
        console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
    }

    this._order = order;
    if (update !== false) this._onChangeCallback();
    return this;
  }

  setFromQuaternion(q, order, update) {
    _matrix.makeRotationFromQuaternion(q);

    return this.setFromRotationMatrix(_matrix, order, update);
  }

  setFromVector3(v, order) {
    return this.set(v.x, v.y, v.z, order || this._order);
  }

  reorder(newOrder) {
    // WARNING: this discards revolution information -bhouston
    _quaternion$1.setFromEuler(this);

    return this.setFromQuaternion(_quaternion$1, newOrder);
  }

  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }

  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== undefined) this._order = array[3];

    this._onChangeCallback();

    return this;
  }

  toArray(array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }

  toVector3(optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  }

  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }

  _onChangeCallback() {}

}

exports.Euler = Euler;
Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

const _matrix = new Matrix4();

const _quaternion$1 = new Quaternion();

class Layers {
  constructor() {
    this.mask = 1 | 0;
  }

  set(channel) {
    this.mask = 1 << channel | 0;
  }

  enable(channel) {
    this.mask |= 1 << channel | 0;
  }

  enableAll() {
    this.mask = 0xffffffff | 0;
  }

  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }

  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }

  disableAll() {
    this.mask = 0;
  }

  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }

}

exports.Layers = Layers;
let _object3DId = 0;

const _v1$2 = new Vector3();

const _q1 = new Quaternion();

const _m1$1 = new Matrix4();

const _target = new Vector3();

const _position = new Vector3();

const _scale = new Vector3();

const _quaternion$2 = new Quaternion();

const _xAxis = new Vector3(1, 0, 0);

const _yAxis = new Vector3(0, 1, 0);

const _zAxis = new Vector3(0, 0, 1);

const _addedEvent = {
  type: 'added'
};
const _removedEvent = {
  type: 'removed'
};

function Object3D() {
  Object.defineProperty(this, 'id', {
    value: _object3DId++
  });
  this.uuid = MathUtils.generateUUID();
  this.name = '';
  this.type = 'Object3D';
  this.parent = null;
  this.children = [];
  this.up = Object3D.DefaultUp.clone();
  const position = new Vector3();
  const rotation = new Euler();
  const quaternion = new Quaternion();
  const scale = new Vector3(1, 1, 1);

  function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
  }

  function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, undefined, false);
  }

  rotation._onChange(onRotationChange);

  quaternion._onChange(onQuaternionChange);

  Object.defineProperties(this, {
    position: {
      configurable: true,
      enumerable: true,
      value: position
    },
    rotation: {
      configurable: true,
      enumerable: true,
      value: rotation
    },
    quaternion: {
      configurable: true,
      enumerable: true,
      value: quaternion
    },
    scale: {
      configurable: true,
      enumerable: true,
      value: scale
    },
    modelViewMatrix: {
      value: new Matrix4()
    },
    normalMatrix: {
      value: new Matrix3()
    }
  });
  this.matrix = new Matrix4();
  this.matrixWorld = new Matrix4();
  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;
  this.layers = new Layers();
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.renderOrder = 0;
  this.userData = {};
}

Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Object3D,
  isObject3D: true,
  onBeforeRender: function () {},
  onAfterRender: function () {},
  applyMatrix4: function (matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function (q) {
    this.quaternion.premultiply(q);
    return this;
  },
  setRotationFromAxisAngle: function (axis, angle) {
    // assumes axis is normalized
    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function (euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function (m) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    this.quaternion.setFromRotationMatrix(m);
  },
  setRotationFromQuaternion: function (q) {
    // assumes q is normalized
    this.quaternion.copy(q);
  },
  rotateOnAxis: function (axis, angle) {
    // rotate object on axis in object space
    // axis is assumed to be normalized
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.multiply(_q1);
    return this;
  },
  rotateOnWorldAxis: function (axis, angle) {
    // rotate object on axis in world space
    // axis is assumed to be normalized
    // method assumes no rotated parent
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.premultiply(_q1);
    return this;
  },
  rotateX: function (angle) {
    return this.rotateOnAxis(_xAxis, angle);
  },
  rotateY: function (angle) {
    return this.rotateOnAxis(_yAxis, angle);
  },
  rotateZ: function (angle) {
    return this.rotateOnAxis(_zAxis, angle);
  },
  translateOnAxis: function (axis, distance) {
    // translate object by distance along axis in object space
    // axis is assumed to be normalized
    _v1$2.copy(axis).applyQuaternion(this.quaternion);

    this.position.add(_v1$2.multiplyScalar(distance));
    return this;
  },
  translateX: function (distance) {
    return this.translateOnAxis(_xAxis, distance);
  },
  translateY: function (distance) {
    return this.translateOnAxis(_yAxis, distance);
  },
  translateZ: function (distance) {
    return this.translateOnAxis(_zAxis, distance);
  },
  localToWorld: function (vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function (vector) {
    return vector.applyMatrix4(_m1$1.getInverse(this.matrixWorld));
  },
  lookAt: function (x, y, z) {
    // This method does not support objects having non-uniformly-scaled parent(s)
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }

    const parent = this.parent;
    this.updateWorldMatrix(true, false);

    _position.setFromMatrixPosition(this.matrixWorld);

    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position, this.up);
    }

    this.quaternion.setFromRotationMatrix(_m1$1);

    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);

      _q1.setFromRotationMatrix(_m1$1);

      this.quaternion.premultiply(_q1.inverse());
    }
  },
  add: function (object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }

      return this;
    }

    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }

    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }

      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }

    return this;
  },
  remove: function (object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }

      return this;
    }

    const index = this.children.indexOf(object);

    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }

    return this;
  },
  attach: function (object) {
    // adds object as a child of this, while maintaining the object's world transform
    this.updateWorldMatrix(true, false);

    _m1$1.getInverse(this.matrixWorld);

    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);

      _m1$1.multiply(object.parent.matrixWorld);
    }

    object.applyMatrix4(_m1$1);
    object.updateWorldMatrix(false, false);
    this.add(object);
    return this;
  },
  getObjectById: function (id) {
    return this.getObjectByProperty('id', id);
  },
  getObjectByName: function (name) {
    return this.getObjectByProperty('name', name);
  },
  getObjectByProperty: function (name, value) {
    if (this[name] === value) return this;

    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);

      if (object !== undefined) {
        return object;
      }
    }

    return undefined;
  },
  getWorldPosition: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldPosition() target is now required');
      target = new Vector3();
    }

    this.updateMatrixWorld(true);
    return target.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
      target = new Quaternion();
    }

    this.updateMatrixWorld(true);
    this.matrixWorld.decompose(_position, target, _scale);
    return target;
  },
  getWorldScale: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldScale() target is now required');
      target = new Vector3();
    }

    this.updateMatrixWorld(true);
    this.matrixWorld.decompose(_position, _quaternion$2, target);
    return target;
  },
  getWorldDirection: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldDirection() target is now required');
      target = new Vector3();
    }

    this.updateMatrixWorld(true);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  },
  raycast: function () {},
  traverse: function (callback) {
    callback(this);
    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  },
  traverseVisible: function (callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  },
  traverseAncestors: function (callback) {
    const parent = this.parent;

    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  },
  updateMatrix: function () {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function (force) {
    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }

      this.matrixWorldNeedsUpdate = false;
      force = true;
    } // update children


    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(force);
    }
  },
  updateWorldMatrix: function (updateParents, updateChildren) {
    const parent = this.parent;

    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }

    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    } // update children


    if (updateChildren === true) {
      const children = this.children;

      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateWorldMatrix(false, true);
      }
    }
  },
  toJSON: function (meta) {
    // meta is a string when called from JSON.stringify
    const isRootObject = meta === undefined || typeof meta === 'string';
    const output = {}; // meta is a hash used to collect geometries, materials.
    // not providing it implies that this is the root object
    // being serialized.

    if (isRootObject) {
      // initialize meta obj
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {}
      };
      output.metadata = {
        version: 4.5,
        type: 'Object',
        generator: 'Object3D.toJSON'
      };
    } // standard Object3D serialization


    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== '') object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

    if (this.isInstancedMesh) {
      object.type = 'InstancedMesh';
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
    } //


    function serialize(library, element) {
      if (library[element.uuid] === undefined) {
        library[element.uuid] = element.toJSON(meta);
      }

      return element.uuid;
    }

    if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;

      if (parameters !== undefined && parameters.shapes !== undefined) {
        const shapes = parameters.shapes;

        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }

    if (this.material !== undefined) {
      if (Array.isArray(this.material)) {
        const uuids = [];

        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }

        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    } //


    if (this.children.length > 0) {
      object.children = [];

      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }

    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
    }

    output.object = object;
    return output; // extract data from the cache hash
    // remove metadata on each item
    // and return as array

    function extractFromCache(cache) {
      const values = [];

      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }

      return values;
    }
  },
  clone: function (recursive) {
    return new this.constructor().copy(this, recursive);
  },
  copy: function (source, recursive) {
    if (recursive === undefined) recursive = true;
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));

    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }

    return this;
  }
});

const _vector1 = new Vector3();

const _vector2 = new Vector3();

const _normalMatrix = new Matrix3();

class Plane {
  constructor(normal, constant) {
    Object.defineProperty(this, 'isPlane', {
      value: true
    }); // normal is assumed to be normalized

    this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
    this.constant = constant !== undefined ? constant : 0;
  }

  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }

  setComponents(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  }

  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }

  setFromCoplanarPoints(a, b, c) {
    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?


    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }

  normalize() {
    // Note: will lead to a divide by zero if the plane is invalid.
    const inverseNormalLength = 1.0 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }

  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }

  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }

  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }

  projectPoint(point, target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .projectPoint() target is now required');
      target = new Vector3();
    }

    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  }

  intersectLine(line, target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .intersectLine() target is now required');
      target = new Vector3();
    }

    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);

    if (denominator === 0) {
      // line is coplanar, return origin
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      } // Unsure if this is the correct method to handle this case.


      return undefined;
    }

    const t = -(line.start.dot(this.normal) + this.constant) / denominator;

    if (t < 0 || t > 1) {
      return undefined;
    }

    return target.copy(direction).multiplyScalar(t).add(line.start);
  }

  intersectsLine(line) {
    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }

  intersectsBox(box) {
    return box.intersectsPlane(this);
  }

  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }

  coplanarPoint(target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .coplanarPoint() target is now required');
      target = new Vector3();
    }

    return target.copy(this.normal).multiplyScalar(-this.constant);
  }

  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);

    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }

  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }

  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }

}

exports.Plane = Plane;

const _v0$1 = new Vector3();

const _v1$3 = new Vector3();

const _v2$1 = new Vector3();

const _v3 = new Vector3();

const _vab = new Vector3();

const _vac = new Vector3();

const _vbc = new Vector3();

const _vap = new Vector3();

const _vbp = new Vector3();

const _vcp = new Vector3();

class Triangle {
  constructor(a, b, c) {
    this.a = a !== undefined ? a : new Vector3();
    this.b = b !== undefined ? b : new Vector3();
    this.c = c !== undefined ? c : new Vector3();
  }

  static getNormal(a, b, c, target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getNormal() target is now required');
      target = new Vector3();
    }

    target.subVectors(c, b);

    _v0$1.subVectors(a, b);

    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();

    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }

    return target.set(0, 0, 0);
  } // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html


  static getBarycoord(point, a, b, c, target) {
    _v0$1.subVectors(c, a);

    _v1$3.subVectors(b, a);

    _v2$1.subVectors(point, a);

    const dot00 = _v0$1.dot(_v0$1);

    const dot01 = _v0$1.dot(_v1$3);

    const dot02 = _v0$1.dot(_v2$1);

    const dot11 = _v1$3.dot(_v1$3);

    const dot12 = _v1$3.dot(_v2$1);

    const denom = dot00 * dot11 - dot01 * dot01;

    if (target === undefined) {
      console.warn('THREE.Triangle: .getBarycoord() target is now required');
      target = new Vector3();
    } // collinear or singular triangle


    if (denom === 0) {
      // arbitrary location outside of triangle?
      // not sure if this is the best idea, maybe should be returning undefined
      return target.set(-2, -1, -1);
    }

    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1

    return target.set(1 - u - v, v, u);
  }

  static containsPoint(point, a, b, c) {
    this.getBarycoord(point, a, b, c, _v3);
    return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
  }

  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3.x);
    target.addScaledVector(uv2, _v3.y);
    target.addScaledVector(uv3, _v3.z);
    return target;
  }

  static isFrontFacing(a, b, c, direction) {
    _v0$1.subVectors(c, b);

    _v1$3.subVectors(a, b); // strictly front facing


    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }

  set(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }

  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }

  getArea() {
    _v0$1.subVectors(this.c, this.b);

    _v1$3.subVectors(this.a, this.b);

    return _v0$1.cross(_v1$3).length() * 0.5;
  }

  getMidpoint(target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getMidpoint() target is now required');
      target = new Vector3();
    }

    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }

  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }

  getPlane(target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getPlane() target is now required');
      target = new Plane();
    }

    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }

  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }

  getUV(point, uv1, uv2, uv3, target) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }

  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }

  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }

  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }

  closestPointToPoint(p, target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
      target = new Vector3();
    }

    const a = this.a,
          b = this.b,
          c = this.c;
    let v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
    // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
    // under the accompanying license; see chapter 5.1.5 for detailed explanation.
    // basically, we're distinguishing which of the voronoi regions of the triangle
    // the point lies in with the minimum amount of redundant computation.

    _vab.subVectors(b, a);

    _vac.subVectors(c, a);

    _vap.subVectors(p, a);

    const d1 = _vab.dot(_vap);

    const d2 = _vac.dot(_vap);

    if (d1 <= 0 && d2 <= 0) {
      // vertex region of A; barycentric coords (1, 0, 0)
      return target.copy(a);
    }

    _vbp.subVectors(p, b);

    const d3 = _vab.dot(_vbp);

    const d4 = _vac.dot(_vbp);

    if (d3 >= 0 && d4 <= d3) {
      // vertex region of B; barycentric coords (0, 1, 0)
      return target.copy(b);
    }

    const vc = d1 * d4 - d3 * d2;

    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)

      return target.copy(a).addScaledVector(_vab, v);
    }

    _vcp.subVectors(p, c);

    const d5 = _vab.dot(_vcp);

    const d6 = _vac.dot(_vcp);

    if (d6 >= 0 && d5 <= d6) {
      // vertex region of C; barycentric coords (0, 0, 1)
      return target.copy(c);
    }

    const vb = d5 * d2 - d1 * d6;

    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)

      return target.copy(a).addScaledVector(_vac, w);
    }

    const va = d3 * d6 - d5 * d4;

    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);

      w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)

      return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
    } // face region


    const denom = 1 / (va + vb + vc); // u = va * denom

    v = vb * denom;
    w = vc * denom;
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
  }

  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }

}

exports.Triangle = Triangle;
const _colorKeywords = {
  'aliceblue': 0xF0F8FF,
  'antiquewhite': 0xFAEBD7,
  'aqua': 0x00FFFF,
  'aquamarine': 0x7FFFD4,
  'azure': 0xF0FFFF,
  'beige': 0xF5F5DC,
  'bisque': 0xFFE4C4,
  'black': 0x000000,
  'blanchedalmond': 0xFFEBCD,
  'blue': 0x0000FF,
  'blueviolet': 0x8A2BE2,
  'brown': 0xA52A2A,
  'burlywood': 0xDEB887,
  'cadetblue': 0x5F9EA0,
  'chartreuse': 0x7FFF00,
  'chocolate': 0xD2691E,
  'coral': 0xFF7F50,
  'cornflowerblue': 0x6495ED,
  'cornsilk': 0xFFF8DC,
  'crimson': 0xDC143C,
  'cyan': 0x00FFFF,
  'darkblue': 0x00008B,
  'darkcyan': 0x008B8B,
  'darkgoldenrod': 0xB8860B,
  'darkgray': 0xA9A9A9,
  'darkgreen': 0x006400,
  'darkgrey': 0xA9A9A9,
  'darkkhaki': 0xBDB76B,
  'darkmagenta': 0x8B008B,
  'darkolivegreen': 0x556B2F,
  'darkorange': 0xFF8C00,
  'darkorchid': 0x9932CC,
  'darkred': 0x8B0000,
  'darksalmon': 0xE9967A,
  'darkseagreen': 0x8FBC8F,
  'darkslateblue': 0x483D8B,
  'darkslategray': 0x2F4F4F,
  'darkslategrey': 0x2F4F4F,
  'darkturquoise': 0x00CED1,
  'darkviolet': 0x9400D3,
  'deeppink': 0xFF1493,
  'deepskyblue': 0x00BFFF,
  'dimgray': 0x696969,
  'dimgrey': 0x696969,
  'dodgerblue': 0x1E90FF,
  'firebrick': 0xB22222,
  'floralwhite': 0xFFFAF0,
  'forestgreen': 0x228B22,
  'fuchsia': 0xFF00FF,
  'gainsboro': 0xDCDCDC,
  'ghostwhite': 0xF8F8FF,
  'gold': 0xFFD700,
  'goldenrod': 0xDAA520,
  'gray': 0x808080,
  'green': 0x008000,
  'greenyellow': 0xADFF2F,
  'grey': 0x808080,
  'honeydew': 0xF0FFF0,
  'hotpink': 0xFF69B4,
  'indianred': 0xCD5C5C,
  'indigo': 0x4B0082,
  'ivory': 0xFFFFF0,
  'khaki': 0xF0E68C,
  'lavender': 0xE6E6FA,
  'lavenderblush': 0xFFF0F5,
  'lawngreen': 0x7CFC00,
  'lemonchiffon': 0xFFFACD,
  'lightblue': 0xADD8E6,
  'lightcoral': 0xF08080,
  'lightcyan': 0xE0FFFF,
  'lightgoldenrodyellow': 0xFAFAD2,
  'lightgray': 0xD3D3D3,
  'lightgreen': 0x90EE90,
  'lightgrey': 0xD3D3D3,
  'lightpink': 0xFFB6C1,
  'lightsalmon': 0xFFA07A,
  'lightseagreen': 0x20B2AA,
  'lightskyblue': 0x87CEFA,
  'lightslategray': 0x778899,
  'lightslategrey': 0x778899,
  'lightsteelblue': 0xB0C4DE,
  'lightyellow': 0xFFFFE0,
  'lime': 0x00FF00,
  'limegreen': 0x32CD32,
  'linen': 0xFAF0E6,
  'magenta': 0xFF00FF,
  'maroon': 0x800000,
  'mediumaquamarine': 0x66CDAA,
  'mediumblue': 0x0000CD,
  'mediumorchid': 0xBA55D3,
  'mediumpurple': 0x9370DB,
  'mediumseagreen': 0x3CB371,
  'mediumslateblue': 0x7B68EE,
  'mediumspringgreen': 0x00FA9A,
  'mediumturquoise': 0x48D1CC,
  'mediumvioletred': 0xC71585,
  'midnightblue': 0x191970,
  'mintcream': 0xF5FFFA,
  'mistyrose': 0xFFE4E1,
  'moccasin': 0xFFE4B5,
  'navajowhite': 0xFFDEAD,
  'navy': 0x000080,
  'oldlace': 0xFDF5E6,
  'olive': 0x808000,
  'olivedrab': 0x6B8E23,
  'orange': 0xFFA500,
  'orangered': 0xFF4500,
  'orchid': 0xDA70D6,
  'palegoldenrod': 0xEEE8AA,
  'palegreen': 0x98FB98,
  'paleturquoise': 0xAFEEEE,
  'palevioletred': 0xDB7093,
  'papayawhip': 0xFFEFD5,
  'peachpuff': 0xFFDAB9,
  'peru': 0xCD853F,
  'pink': 0xFFC0CB,
  'plum': 0xDDA0DD,
  'powderblue': 0xB0E0E6,
  'purple': 0x800080,
  'rebeccapurple': 0x663399,
  'red': 0xFF0000,
  'rosybrown': 0xBC8F8F,
  'royalblue': 0x4169E1,
  'saddlebrown': 0x8B4513,
  'salmon': 0xFA8072,
  'sandybrown': 0xF4A460,
  'seagreen': 0x2E8B57,
  'seashell': 0xFFF5EE,
  'sienna': 0xA0522D,
  'silver': 0xC0C0C0,
  'skyblue': 0x87CEEB,
  'slateblue': 0x6A5ACD,
  'slategray': 0x708090,
  'slategrey': 0x708090,
  'snow': 0xFFFAFA,
  'springgreen': 0x00FF7F,
  'steelblue': 0x4682B4,
  'tan': 0xD2B48C,
  'teal': 0x008080,
  'thistle': 0xD8BFD8,
  'tomato': 0xFF6347,
  'turquoise': 0x40E0D0,
  'violet': 0xEE82EE,
  'wheat': 0xF5DEB3,
  'white': 0xFFFFFF,
  'whitesmoke': 0xF5F5F5,
  'yellow': 0xFFFF00,
  'yellowgreen': 0x9ACD32
};
const _hslA = {
  h: 0,
  s: 0,
  l: 0
};
const _hslB = {
  h: 0,
  s: 0,
  l: 0
};

function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}

function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}

function LinearToSRGB(c) {
  return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}

class Color {
  constructor(r, g, b) {
    Object.defineProperty(this, 'isColor', {
      value: true
    });

    if (g === undefined && b === undefined) {
      // r is THREE.Color, hex or string
      return this.set(r);
    }

    return this.setRGB(r, g, b);
  }

  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === 'number') {
      this.setHex(value);
    } else if (typeof value === 'string') {
      this.setStyle(value);
    }

    return this;
  }

  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }

  setHex(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  }

  setRGB(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  }

  setHSL(h, s, l) {
    // h,s,l ranges are in 0.0 - 1.0
    h = MathUtils.euclideanModulo(h, 1);
    s = MathUtils.clamp(s, 0, 1);
    l = MathUtils.clamp(l, 0, 1);

    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }

    return this;
  }

  setStyle(style) {
    function handleAlpha(string) {
      if (string === undefined) return;

      if (parseFloat(string) < 1) {
        console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
      }
    }

    let m;

    if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
      // rgb / hsl
      let color;
      const name = m[1];
      const components = m[2];

      switch (name) {
        case 'rgb':
        case 'rgba':
          if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            // rgb(255,0,0) rgba(255,0,0,0.5)
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[5]);
            return this;
          }

          if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[5]);
            return this;
          }

          break;

        case 'hsl':
        case 'hsla':
          if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
            const h = parseFloat(color[1]) / 360;
            const s = parseInt(color[2], 10) / 100;
            const l = parseInt(color[3], 10) / 100;
            handleAlpha(color[5]);
            return this.setHSL(h, s, l);
          }

          break;
      }
    } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
      // hex color
      const hex = m[1];
      const size = hex.length;

      if (size === 3) {
        // #ff0
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        // #ff0000
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }

    if (style && style.length > 0) {
      return this.setColorName(style);
    }

    return this;
  }

  setColorName(style) {
    // color keywords
    const hex = _colorKeywords[style];

    if (hex !== undefined) {
      // red
      this.setHex(hex);
    } else {
      // unknown color
      console.warn('THREE.Color: Unknown color ' + style);
    }

    return this;
  }

  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }

  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }

  copyGammaToLinear(color, gammaFactor) {
    if (gammaFactor === undefined) gammaFactor = 2.0;
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  }

  copyLinearToGamma(color, gammaFactor) {
    if (gammaFactor === undefined) gammaFactor = 2.0;
    const safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  }

  convertGammaToLinear(gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  }

  convertLinearToGamma(gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  }

  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }

  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }

  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }

  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }

  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }

  getHexString() {
    return ('000000' + this.getHex().toString(16)).slice(-6);
  }

  getHSL(target) {
    // h,s,l ranges are in 0.0 - 1.0
    if (target === undefined) {
      console.warn('THREE.Color: .getHSL() target is now required');
      target = {
        h: 0,
        s: 0,
        l: 0
      };
    }

    const r = this.r,
          g = this.g,
          b = this.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min + max) / 2.0;

    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;

        case g:
          hue = (b - r) / delta + 2;
          break;

        case b:
          hue = (r - g) / delta + 4;
          break;
      }

      hue /= 6;
    }

    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }

  getStyle() {
    return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
  }

  offsetHSL(h, s, l) {
    this.getHSL(_hslA);
    _hslA.h += h;
    _hslA.s += s;
    _hslA.l += l;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }

  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }

  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }

  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }

  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }

  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }

  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }

  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }

  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
    const s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
    const l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h, s, l);
    return this;
  }

  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }

  fromArray(array, offset) {
    if (offset === undefined) offset = 0;
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }

  toArray(array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }

  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);

    if (attribute.normalized === true) {
      // assuming Uint8Array
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }

    return this;
  }

  toJSON() {
    return this.getHex();
  }

}

exports.Color = Color;
Color.NAMES = _colorKeywords;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;

class Face3 {
  constructor(a, b, c, normal, color, materialIndex) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.normal = normal && normal.isVector3 ? normal : new Vector3();
    this.vertexNormals = Array.isArray(normal) ? normal : [];
    this.color = color && color.isColor ? color : new Color();
    this.vertexColors = Array.isArray(color) ? color : [];
    this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(source) {
    this.a = source.a;
    this.b = source.b;
    this.c = source.c;
    this.normal.copy(source.normal);
    this.color.copy(source.color);
    this.materialIndex = source.materialIndex;

    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {
      this.vertexNormals[i] = source.vertexNormals[i].clone();
    }

    for (let i = 0, il = source.vertexColors.length; i < il; i++) {
      this.vertexColors[i] = source.vertexColors[i].clone();
    }

    return this;
  }

}

exports.Face3 = Face3;
let materialId = 0;

function Material() {
  Object.defineProperty(this, 'id', {
    value: materialId++
  });
  this.uuid = MathUtils.generateUUID();
  this.name = '';
  this.type = 'Material';
  this.fog = true;
  this.blending = NormalBlending;
  this.side = FrontSide;
  this.flatShading = false;
  this.vertexColors = false;
  this.opacity = 1;
  this.transparent = false;
  this.blendSrc = SrcAlphaFactor;
  this.blendDst = OneMinusSrcAlphaFactor;
  this.blendEquation = AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;
  this.depthFunc = LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;
  this.stencilWriteMask = 0xff;
  this.stencilFunc = AlwaysStencilFunc;
  this.stencilRef = 0;
  this.stencilFuncMask = 0xff;
  this.stencilFail = KeepStencilOp;
  this.stencilZFail = KeepStencilOp;
  this.stencilZPass = KeepStencilOp;
  this.stencilWrite = false;
  this.clippingPlanes = null;
  this.clipIntersection = false;
  this.clipShadows = false;
  this.shadowSide = null;
  this.colorWrite = true;
  this.precision = null; // override the renderer's default precision for this material

  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.dithering = false;
  this.alphaTest = 0;
  this.premultipliedAlpha = false;
  this.visible = true;
  this.toneMapped = true;
  this.userData = {};
  this.version = 0;
}

Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Material,
  isMaterial: true,
  onBeforeCompile: function ()
  /* shaderobject, renderer */
  {},
  customProgramCacheKey: function () {
    return this.onBeforeCompile.toString();
  },
  setValues: function (values) {
    if (values === undefined) return;

    for (const key in values) {
      const newValue = values[key];

      if (newValue === undefined) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      } // for backward compatability if shading is set in the constructor


      if (key === 'shading') {
        console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }

      const currentValue = this[key];

      if (currentValue === undefined) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }

      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  },
  toJSON: function (meta) {
    const isRoot = meta === undefined || typeof meta === 'string';

    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }

    const data = {
      metadata: {
        version: 4.5,
        type: 'Material',
        generator: 'Material.toJSON'
      }
    }; // standard Material serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== undefined) data.roughness = this.roughness;
    if (this.metalness !== undefined) data.metalness = this.metalness;
    if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
    if (this.shininess !== undefined) data.shininess = this.shininess;
    if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;

    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }

    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }

    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }

    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;

    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }

    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }

    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }

    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }

    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;

    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      data.reflectivity = this.reflectivity; // Scale behind envMap

      data.refractionRatio = this.refractionRatio;
      if (this.combine !== undefined) data.combine = this.combine;
      if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
    }

    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }

    if (this.size !== undefined) data.size = this.size;
    if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending) data.blending = this.blending;
    if (this.flatShading === true) data.flatShading = this.flatShading;
    if (this.side !== FrontSide) data.side = this.side;
    if (this.vertexColors) data.vertexColors = true;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)

    if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
    if (this.dashSize !== undefined) data.dashSize = this.dashSize;
    if (this.gapSize !== undefined) data.gapSize = this.gapSize;
    if (this.scale !== undefined) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true) data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.morphTargets === true) data.morphTargets = true;
    if (this.morphNormals === true) data.morphNormals = true;
    if (this.skinning === true) data.skinning = true;
    if (this.visible === false) data.visible = false;
    if (this.toneMapped === false) data.toneMapped = false;
    if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON

    function extractFromCache(cache) {
      const values = [];

      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }

      return values;
    }

    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }

    return data;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.name = source.name;
    this.fog = source.fog;
    this.blending = source.blending;
    this.side = source.side;
    this.flatShading = source.flatShading;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;

    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);

      for (let i = 0; i !== n; ++i) {
        dstPlanes[i] = srcPlanes[i].clone();
      }
    }

    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
Object.defineProperty(Material.prototype, 'needsUpdate', {
  set: function (value) {
    if (value === true) this.version++;
  }
});
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

function MeshBasicMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshBasicMaterial';
  this.color = new Color(0xffffff); // emissive

  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.setValues(parameters);
}

MeshBasicMaterial.prototype = Object.create(Material.prototype);
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

MeshBasicMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  return this;
};

const _vector$3 = new Vector3();

const _vector2$1 = new Vector2();

function BufferAttribute(array, itemSize, normalized) {
  if (Array.isArray(array)) {
    throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
  }

  this.name = '';
  this.array = array;
  this.itemSize = itemSize;
  this.count = array !== undefined ? array.length / itemSize : 0;
  this.normalized = normalized === true;
  this.usage = StaticDrawUsage;
  this.updateRange = {
    offset: 0,
    count: -1
  };
  this.version = 0;
}

Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {
  set: function (value) {
    if (value === true) this.version++;
  }
});
Object.assign(BufferAttribute.prototype, {
  isBufferAttribute: true,
  onUploadCallback: function () {},
  setUsage: function (value) {
    this.usage = value;
    return this;
  },
  copy: function (source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    return this;
  },
  copyAt: function (index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;

    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }

    return this;
  },
  copyArray: function (array) {
    this.array.set(array);
    return this;
  },
  copyColorsArray: function (colors) {
    const array = this.array;
    let offset = 0;

    for (let i = 0, l = colors.length; i < l; i++) {
      let color = colors[i];

      if (color === undefined) {
        console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
        color = new Color();
      }

      array[offset++] = color.r;
      array[offset++] = color.g;
      array[offset++] = color.b;
    }

    return this;
  },
  copyVector2sArray: function (vectors) {
    const array = this.array;
    let offset = 0;

    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
        vector = new Vector2();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }

    return this;
  },
  copyVector3sArray: function (vectors) {
    const array = this.array;
    let offset = 0;

    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
        vector = new Vector3();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }

    return this;
  },
  copyVector4sArray: function (vectors) {
    const array = this.array;
    let offset = 0;

    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
        vector = new Vector4();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }

    return this;
  },
  applyMatrix3: function (m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2$1.fromBufferAttribute(this, i);

        _vector2$1.applyMatrix3(m);

        this.setXY(i, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$3.fromBufferAttribute(this, i);

        _vector$3.applyMatrix3(m);

        this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
      }
    }

    return this;
  },
  applyMatrix4: function (m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$3.x = this.getX(i);
      _vector$3.y = this.getY(i);
      _vector$3.z = this.getZ(i);

      _vector$3.applyMatrix4(m);

      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
    }

    return this;
  },
  applyNormalMatrix: function (m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$3.x = this.getX(i);
      _vector$3.y = this.getY(i);
      _vector$3.z = this.getZ(i);

      _vector$3.applyNormalMatrix(m);

      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
    }

    return this;
  },
  transformDirection: function (m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$3.x = this.getX(i);
      _vector$3.y = this.getY(i);
      _vector$3.z = this.getZ(i);

      _vector$3.transformDirection(m);

      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
    }

    return this;
  },
  set: function (value, offset) {
    if (offset === undefined) offset = 0;
    this.array.set(value, offset);
    return this;
  },
  getX: function (index) {
    return this.array[index * this.itemSize];
  },
  setX: function (index, x) {
    this.array[index * this.itemSize] = x;
    return this;
  },
  getY: function (index) {
    return this.array[index * this.itemSize + 1];
  },
  setY: function (index, y) {
    this.array[index * this.itemSize + 1] = y;
    return this;
  },
  getZ: function (index) {
    return this.array[index * this.itemSize + 2];
  },
  setZ: function (index, z) {
    this.array[index * this.itemSize + 2] = z;
    return this;
  },
  getW: function (index) {
    return this.array[index * this.itemSize + 3];
  },
  setW: function (index, w) {
    this.array[index * this.itemSize + 3] = w;
    return this;
  },
  setXY: function (index, x, y) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  },
  setXYZ: function (index, x, y, z) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  },
  setXYZW: function (index, x, y, z, w) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  },
  onUpload: function (callback) {
    this.onUploadCallback = callback;
    return this;
  },
  clone: function () {
    return new this.constructor(this.array, this.itemSize).copy(this);
  },
  toJSON: function () {
    return {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
  }
}); //

function Int8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}

Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;

function Uint8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}

Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;

function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}

Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;

function Int16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}

Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;

function Uint16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}

Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;

function Int32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}

Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;

function Uint32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}

Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

function Float32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}

Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;

function Float64BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}

Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

class DirectGeometry {
  constructor() {
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];
    this.groups = [];
    this.morphTargets = {};
    this.skinWeights = [];
    this.skinIndices = []; // this.lineDistances = [];

    this.boundingBox = null;
    this.boundingSphere = null; // update flags

    this.verticesNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.groupsNeedUpdate = false;
  }

  computeGroups(geometry) {
    const groups = [];
    let group, i;
    let materialIndex = undefined;
    const faces = geometry.faces;

    for (i = 0; i < faces.length; i++) {
      const face = faces[i]; // materials

      if (face.materialIndex !== materialIndex) {
        materialIndex = face.materialIndex;

        if (group !== undefined) {
          group.count = i * 3 - group.start;
          groups.push(group);
        }

        group = {
          start: i * 3,
          materialIndex: materialIndex
        };
      }
    }

    if (group !== undefined) {
      group.count = i * 3 - group.start;
      groups.push(group);
    }

    this.groups = groups;
  }

  fromGeometry(geometry) {
    const faces = geometry.faces;
    const vertices = geometry.vertices;
    const faceVertexUvs = geometry.faceVertexUvs;
    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs

    const morphTargets = geometry.morphTargets;
    const morphTargetsLength = morphTargets.length;
    let morphTargetsPosition;

    if (morphTargetsLength > 0) {
      morphTargetsPosition = [];

      for (let i = 0; i < morphTargetsLength; i++) {
        morphTargetsPosition[i] = {
          name: morphTargets[i].name,
          data: []
        };
      }

      this.morphTargets.position = morphTargetsPosition;
    }

    const morphNormals = geometry.morphNormals;
    const morphNormalsLength = morphNormals.length;
    let morphTargetsNormal;

    if (morphNormalsLength > 0) {
      morphTargetsNormal = [];

      for (let i = 0; i < morphNormalsLength; i++) {
        morphTargetsNormal[i] = {
          name: morphNormals[i].name,
          data: []
        };
      }

      this.morphTargets.normal = morphTargetsNormal;
    } // skins


    const skinIndices = geometry.skinIndices;
    const skinWeights = geometry.skinWeights;
    const hasSkinIndices = skinIndices.length === vertices.length;
    const hasSkinWeights = skinWeights.length === vertices.length; //

    if (vertices.length > 0 && faces.length === 0) {
      console.error('THREE.DirectGeometry: Faceless geometries are not supported.');
    }

    for (let i = 0; i < faces.length; i++) {
      const face = faces[i];
      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
      const vertexNormals = face.vertexNormals;

      if (vertexNormals.length === 3) {
        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
      } else {
        const normal = face.normal;
        this.normals.push(normal, normal, normal);
      }

      const vertexColors = face.vertexColors;

      if (vertexColors.length === 3) {
        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
      } else {
        const color = face.color;
        this.colors.push(color, color, color);
      }

      if (hasFaceVertexUv === true) {
        const vertexUvs = faceVertexUvs[0][i];

        if (vertexUvs !== undefined) {
          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
          this.uvs.push(new Vector2(), new Vector2(), new Vector2());
        }
      }

      if (hasFaceVertexUv2 === true) {
        const vertexUvs = faceVertexUvs[1][i];

        if (vertexUvs !== undefined) {
          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
        }
      } // morphs


      for (let j = 0; j < morphTargetsLength; j++) {
        const morphTarget = morphTargets[j].vertices;
        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
      }

      for (let j = 0; j < morphNormalsLength; j++) {
        const morphNormal = morphNormals[j].vertexNormals[i];
        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
      } // skins


      if (hasSkinIndices) {
        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
      }

      if (hasSkinWeights) {
        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
      }
    }

    this.computeGroups(geometry);
    this.verticesNeedUpdate = geometry.verticesNeedUpdate;
    this.normalsNeedUpdate = geometry.normalsNeedUpdate;
    this.colorsNeedUpdate = geometry.colorsNeedUpdate;
    this.uvsNeedUpdate = geometry.uvsNeedUpdate;
    this.groupsNeedUpdate = geometry.groupsNeedUpdate;

    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }

    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }

    return this;
  }

}

function arrayMax(array) {
  if (array.length === 0) return -Infinity;
  let max = array[0];

  for (let i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max) max = array[i];
  }

  return max;
}

let _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

const _m1$2 = new Matrix4();

const _obj = new Object3D();

const _offset = new Vector3();

const _box$2 = new Box3();

const _boxMorphTargets = new Box3();

const _vector$4 = new Vector3();

function BufferGeometry() {
  Object.defineProperty(this, 'id', {
    value: _bufferGeometryId += 2
  });
  this.uuid = MathUtils.generateUUID();
  this.name = '';
  this.type = 'BufferGeometry';
  this.index = null;
  this.attributes = {};
  this.morphAttributes = {};
  this.morphTargetsRelative = false;
  this.groups = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.drawRange = {
    start: 0,
    count: Infinity
  };
  this.userData = {};
}

BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: BufferGeometry,
  isBufferGeometry: true,
  getIndex: function () {
    return this.index;
  },
  setIndex: function (index) {
    if (Array.isArray(index)) {
      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
  },
  getAttribute: function (name) {
    return this.attributes[name];
  },
  setAttribute: function (name, attribute) {
    this.attributes[name] = attribute;
    return this;
  },
  deleteAttribute: function (name) {
    delete this.attributes[name];
    return this;
  },
  addGroup: function (start, count, materialIndex) {
    this.groups.push({
      start: start,
      count: count,
      materialIndex: materialIndex !== undefined ? materialIndex : 0
    });
  },
  clearGroups: function () {
    this.groups = [];
  },
  setDrawRange: function (start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  },
  applyMatrix4: function (matrix) {
    const position = this.attributes.position;

    if (position !== undefined) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }

    const normal = this.attributes.normal;

    if (normal !== undefined) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }

    const tangent = this.attributes.tangent;

    if (tangent !== undefined) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    return this;
  },
  rotateX: function (angle) {
    // rotate geometry around world x-axis
    _m1$2.makeRotationX(angle);

    this.applyMatrix4(_m1$2);
    return this;
  },
  rotateY: function (angle) {
    // rotate geometry around world y-axis
    _m1$2.makeRotationY(angle);

    this.applyMatrix4(_m1$2);
    return this;
  },
  rotateZ: function (angle) {
    // rotate geometry around world z-axis
    _m1$2.makeRotationZ(angle);

    this.applyMatrix4(_m1$2);
    return this;
  },
  translate: function (x, y, z) {
    // translate geometry
    _m1$2.makeTranslation(x, y, z);

    this.applyMatrix4(_m1$2);
    return this;
  },
  scale: function (x, y, z) {
    // scale geometry
    _m1$2.makeScale(x, y, z);

    this.applyMatrix4(_m1$2);
    return this;
  },
  lookAt: function (vector) {
    _obj.lookAt(vector);

    _obj.updateMatrix();

    this.applyMatrix4(_obj.matrix);
    return this;
  },
  center: function () {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  },
  setFromObject: function (object) {
    // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
    const geometry = object.geometry;

    if (object.isPoints || object.isLine) {
      const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
      const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
      this.setAttribute('position', positions.copyVector3sArray(geometry.vertices));
      this.setAttribute('color', colors.copyColorsArray(geometry.colors));

      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
        const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
        this.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
      }

      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }

      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }
    } else if (object.isMesh) {
      if (geometry && geometry.isGeometry) {
        this.fromGeometry(geometry);
      }
    }

    return this;
  },
  setFromPoints: function (points) {
    const position = [];

    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }

    this.setAttribute('position', new Float32BufferAttribute(position, 3));
    return this;
  },
  updateFromObject: function (object) {
    let geometry = object.geometry;

    if (object.isMesh) {
      let direct = geometry.__directGeometry;

      if (geometry.elementsNeedUpdate === true) {
        direct = undefined;
        geometry.elementsNeedUpdate = false;
      }

      if (direct === undefined) {
        return this.fromGeometry(geometry);
      }

      direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
      direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
      direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
      direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
      direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
      geometry.verticesNeedUpdate = false;
      geometry.normalsNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.uvsNeedUpdate = false;
      geometry.groupsNeedUpdate = false;
      geometry = direct;
    }

    if (geometry.verticesNeedUpdate === true) {
      const attribute = this.attributes.position;

      if (attribute !== undefined) {
        attribute.copyVector3sArray(geometry.vertices);
        attribute.needsUpdate = true;
      }

      geometry.verticesNeedUpdate = false;
    }

    if (geometry.normalsNeedUpdate === true) {
      const attribute = this.attributes.normal;

      if (attribute !== undefined) {
        attribute.copyVector3sArray(geometry.normals);
        attribute.needsUpdate = true;
      }

      geometry.normalsNeedUpdate = false;
    }

    if (geometry.colorsNeedUpdate === true) {
      const attribute = this.attributes.color;

      if (attribute !== undefined) {
        attribute.copyColorsArray(geometry.colors);
        attribute.needsUpdate = true;
      }

      geometry.colorsNeedUpdate = false;
    }

    if (geometry.uvsNeedUpdate) {
      const attribute = this.attributes.uv;

      if (attribute !== undefined) {
        attribute.copyVector2sArray(geometry.uvs);
        attribute.needsUpdate = true;
      }

      geometry.uvsNeedUpdate = false;
    }

    if (geometry.lineDistancesNeedUpdate) {
      const attribute = this.attributes.lineDistance;

      if (attribute !== undefined) {
        attribute.copyArray(geometry.lineDistances);
        attribute.needsUpdate = true;
      }

      geometry.lineDistancesNeedUpdate = false;
    }

    if (geometry.groupsNeedUpdate) {
      geometry.computeGroups(object.geometry);
      this.groups = geometry.groups;
      geometry.groupsNeedUpdate = false;
    }

    return this;
  },
  fromGeometry: function (geometry) {
    geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
    return this.fromDirectGeometry(geometry.__directGeometry);
  },
  fromDirectGeometry: function (geometry) {
    const positions = new Float32Array(geometry.vertices.length * 3);
    this.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));

    if (geometry.normals.length > 0) {
      const normals = new Float32Array(geometry.normals.length * 3);
      this.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
    }

    if (geometry.colors.length > 0) {
      const colors = new Float32Array(geometry.colors.length * 3);
      this.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
    }

    if (geometry.uvs.length > 0) {
      const uvs = new Float32Array(geometry.uvs.length * 2);
      this.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
    }

    if (geometry.uvs2.length > 0) {
      const uvs2 = new Float32Array(geometry.uvs2.length * 2);
      this.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
    } // groups


    this.groups = geometry.groups; // morphs

    for (const name in geometry.morphTargets) {
      const array = [];
      const morphTargets = geometry.morphTargets[name];

      for (let i = 0, l = morphTargets.length; i < l; i++) {
        const morphTarget = morphTargets[i];
        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
        attribute.name = morphTarget.name;
        array.push(attribute.copyVector3sArray(morphTarget.data));
      }

      this.morphAttributes[name] = array;
    } // skinning


    if (geometry.skinIndices.length > 0) {
      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
      this.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
    }

    if (geometry.skinWeights.length > 0) {
      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
      this.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
    } //


    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }

    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }

    return this;
  },
  computeBoundingBox: function () {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }

    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;

    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
      return;
    }

    if (position !== undefined) {
      this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present

      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];

          _box$2.setFromBufferAttribute(morphAttribute);

          if (this.morphTargetsRelative) {
            _vector$4.addVectors(this.boundingBox.min, _box$2.min);

            this.boundingBox.expandByPoint(_vector$4);

            _vector$4.addVectors(this.boundingBox.max, _box$2.max);

            this.boundingBox.expandByPoint(_vector$4);
          } else {
            this.boundingBox.expandByPoint(_box$2.min);
            this.boundingBox.expandByPoint(_box$2.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }

    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeBoundingSphere: function () {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }

    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;

    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }

    if (position) {
      // first, find the center of the bounding sphere
      const center = this.boundingSphere.center;

      _box$2.setFromBufferAttribute(position); // process morph attributes if present


      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];

          _boxMorphTargets.setFromBufferAttribute(morphAttribute);

          if (this.morphTargetsRelative) {
            _vector$4.addVectors(_box$2.min, _boxMorphTargets.min);

            _box$2.expandByPoint(_vector$4);

            _vector$4.addVectors(_box$2.max, _boxMorphTargets.max);

            _box$2.expandByPoint(_vector$4);
          } else {
            _box$2.expandByPoint(_boxMorphTargets.min);

            _box$2.expandByPoint(_boxMorphTargets.max);
          }
        }
      }

      _box$2.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case


      let maxRadiusSq = 0;

      for (let i = 0, il = position.count; i < il; i++) {
        _vector$4.fromBufferAttribute(position, i);

        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
      } // process morph attributes if present


      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;

          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$4.fromBufferAttribute(morphAttribute, j);

            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);

              _vector$4.add(_offset);
            }

            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
          }
        }
      }

      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  },
  computeFaceNormals: function () {// backwards compatibility
  },
  computeVertexNormals: function () {
    const index = this.index;
    const positionAttribute = this.getAttribute('position');

    if (positionAttribute !== undefined) {
      let normalAttribute = this.getAttribute('normal');

      if (normalAttribute === undefined) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute('normal', normalAttribute);
      } else {
        // reset existing normals to zero
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }

      const pA = new Vector3(),
            pB = new Vector3(),
            pC = new Vector3();
      const nA = new Vector3(),
            nB = new Vector3(),
            nC = new Vector3();
      const cb = new Vector3(),
            ab = new Vector3(); // indexed elements

      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0);
          const vB = index.getX(i + 1);
          const vC = index.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        // non-indexed elements (unconnected triangle soup)
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }

      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  },
  merge: function (geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
      return;
    }

    if (offset === undefined) {
      offset = 0;
      console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
    }

    const attributes = this.attributes;

    for (const key in attributes) {
      if (geometry.attributes[key] === undefined) continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset;
      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);

      for (let i = 0, j = attributeOffset; i < length; i++, j++) {
        attributeArray1[j] = attributeArray2[i];
      }
    }

    return this;
  },
  normalizeNormals: function () {
    const normals = this.attributes.normal;

    for (let i = 0, il = normals.count; i < il; i++) {
      _vector$4.fromBufferAttribute(normals, i);

      _vector$4.normalize();

      normals.setXYZ(i, _vector$4.x, _vector$4.y, _vector$4.z);
    }
  },
  toNonIndexed: function () {
    function convertBufferAttribute(attribute, indices) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices.length * itemSize);
      let index = 0,
          index2 = 0;

      for (let i = 0, l = indices.length; i < l; i++) {
        index = indices[i] * itemSize;

        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }

      return new BufferAttribute(array2, itemSize, normalized);
    } //


    if (this.index === null) {
      console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
      return this;
    }

    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes; // attributes

    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    } // morph attributes


    const morphAttributes = this.morphAttributes;

    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }

      geometry2.morphAttributes[name] = morphArray;
    }

    geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups

    const groups = this.groups;

    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }

    return geometry2;
  },
  toJSON: function () {
    const data = {
      metadata: {
        version: 4.5,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    }; // standard BufferGeometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;

    if (this.parameters !== undefined) {
      const parameters = this.parameters;

      for (const key in parameters) {
        if (parameters[key] !== undefined) data[key] = parameters[key];
      }

      return data;
    }

    data.data = {
      attributes: {}
    };
    const index = this.index;

    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }

    const attributes = this.attributes;

    for (const key in attributes) {
      const attribute = attributes[key];
      const attributeData = attribute.toJSON(data.data);
      if (attribute.name !== '') attributeData.name = attribute.name;
      data.data.attributes[key] = attributeData;
    }

    const morphAttributes = {};
    let hasMorphAttributes = false;

    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];

      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        const attributeData = attribute.toJSON(data.data);
        if (attribute.name !== '') attributeData.name = attribute.name;
        array.push(attributeData);
      }

      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }

    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }

    const groups = this.groups;

    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }

    const boundingSphere = this.boundingSphere;

    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }

    return data;
  },
  clone: function () {
    /*
     // Handle primitives
    	 const parameters = this.parameters;
    	 if ( parameters !== undefined ) {
    	 const values = [];
    	 for ( const key in parameters ) {
    	 values.push( parameters[ key ] );
    	 }
    	 const geometry = Object.create( this.constructor.prototype );
     this.constructor.apply( geometry, values );
     return geometry;
    	 }
    	 return new this.constructor().copy( this );
     */
    return new BufferGeometry().copy(this);
  },
  copy: function (source) {
    // reset
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null; // used for storing cloned, shared data

    const data = {}; // name

    this.name = source.name; // index

    const index = source.index;

    if (index !== null) {
      this.setIndex(index.clone(data));
    } // attributes


    const attributes = source.attributes;

    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    } // morph attributes


    const morphAttributes = source.morphAttributes;

    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data));
      }

      this.morphAttributes[name] = array;
    }

    this.morphTargetsRelative = source.morphTargetsRelative; // groups

    const groups = source.groups;

    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    } // bounding box


    const boundingBox = source.boundingBox;

    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    } // bounding sphere


    const boundingSphere = source.boundingSphere;

    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    } // draw range


    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count; // user data

    this.userData = source.userData;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});

const _inverseMatrix = new Matrix4();

const _ray = new Ray();

const _sphere = new Sphere();

const _vA = new Vector3();

const _vB = new Vector3();

const _vC = new Vector3();

const _tempA = new Vector3();

const _tempB = new Vector3();

const _tempC = new Vector3();

const _morphA = new Vector3();

const _morphB = new Vector3();

const _morphC = new Vector3();

const _uvA = new Vector2();

const _uvB = new Vector2();

const _uvC = new Vector2();

const _intersectionPoint = new Vector3();

const _intersectionPointWorld = new Vector3();

function Mesh(geometry, material) {
  Object3D.call(this);
  this.type = 'Mesh';
  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  this.material = material !== undefined ? material : new MeshBasicMaterial();
  this.updateMorphTargets();
}

Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Mesh,
  isMesh: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);

    if (source.morphTargetInfluences !== undefined) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }

    if (source.morphTargetDictionary !== undefined) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }

    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  updateMorphTargets: function () {
    const geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);

      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];

        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};

          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;

      if (morphTargets !== undefined && morphTargets.length > 0) {
        console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  },
  raycast: function (raycaster, intersects) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === undefined) return; // Checking boundingSphere distance to ray

    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

    _sphere.copy(geometry.boundingSphere);

    _sphere.applyMatrix4(matrixWorld);

    if (raycaster.ray.intersectsSphere(_sphere) === false) return; //

    _inverseMatrix.getInverse(matrixWorld);

    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing


    if (geometry.boundingBox !== null) {
      if (_ray.intersectsBox(geometry.boundingBox) === false) return;
    }

    let intersection;

    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const position = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      const uv = geometry.attributes.uv;
      const uv2 = geometry.attributes.uv2;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;

      if (index !== null) {
        // indexed buffer geometry
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

            for (let j = start, jl = end; j < jl; j += 3) {
              const a = index.getX(j);
              const b = index.getX(j + 1);
              const c = index.getX(j + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics

                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);

          for (let i = start, il = end; i < il; i += 3) {
            const a = index.getX(i);
            const b = index.getX(i + 1);
            const c = index.getX(i + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics

              intersects.push(intersection);
            }
          }
        }
      } else if (position !== undefined) {
        // non-indexed buffer geometry
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

            for (let j = start, jl = end; j < jl; j += 3) {
              const a = j;
              const b = j + 1;
              const c = j + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics

                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);

          for (let i = start, il = end; i < il; i += 3) {
            const a = i;
            const b = i + 1;
            const c = i + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics

              intersects.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      const isMultiMaterial = Array.isArray(material);
      const vertices = geometry.vertices;
      const faces = geometry.faces;
      let uvs;
      const faceVertexUvs = geometry.faceVertexUvs[0];
      if (faceVertexUvs.length > 0) uvs = faceVertexUvs;

      for (let f = 0, fl = faces.length; f < fl; f++) {
        const face = faces[f];
        const faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
        if (faceMaterial === undefined) continue;
        const fvA = vertices[face.a];
        const fvB = vertices[face.b];
        const fvC = vertices[face.c];
        intersection = checkIntersection(this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint);

        if (intersection) {
          if (uvs && uvs[f]) {
            const uvs_f = uvs[f];

            _uvA.copy(uvs_f[0]);

            _uvB.copy(uvs_f[1]);

            _uvC.copy(uvs_f[2]);

            intersection.uv = Triangle.getUV(_intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2());
          }

          intersection.face = face;
          intersection.faceIndex = f;
          intersects.push(intersection);
        }
      }
    }
  }
});

function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect;

  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
  }

  if (intersect === null) return null;

  _intersectionPointWorld.copy(point);

  _intersectionPointWorld.applyMatrix4(object.matrixWorld);

  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far) return null;
  return {
    distance: distance,
    point: _intersectionPointWorld.clone(),
    object: object
  };
}

function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
  _vA.fromBufferAttribute(position, a);

  _vB.fromBufferAttribute(position, b);

  _vC.fromBufferAttribute(position, c);

  const morphInfluences = object.morphTargetInfluences;

  if (material.morphTargets && morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);

    _morphB.set(0, 0, 0);

    _morphC.set(0, 0, 0);

    for (let i = 0, il = morphPosition.length; i < il; i++) {
      const influence = morphInfluences[i];
      const morphAttribute = morphPosition[i];
      if (influence === 0) continue;

      _tempA.fromBufferAttribute(morphAttribute, a);

      _tempB.fromBufferAttribute(morphAttribute, b);

      _tempC.fromBufferAttribute(morphAttribute, c);

      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);

        _morphB.addScaledVector(_tempB, influence);

        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA), influence);

        _morphB.addScaledVector(_tempB.sub(_vB), influence);

        _morphC.addScaledVector(_tempC.sub(_vC), influence);
      }
    }

    _vA.add(_morphA);

    _vB.add(_morphB);

    _vC.add(_morphC);
  }

  if (object.isSkinnedMesh) {
    object.boneTransform(a, _vA);
    object.boneTransform(b, _vB);
    object.boneTransform(c, _vC);
  }

  const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);

  if (intersection) {
    if (uv) {
      _uvA.fromBufferAttribute(uv, a);

      _uvB.fromBufferAttribute(uv, b);

      _uvC.fromBufferAttribute(uv, c);

      intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }

    if (uv2) {
      _uvA.fromBufferAttribute(uv2, a);

      _uvB.fromBufferAttribute(uv2, b);

      _uvC.fromBufferAttribute(uv2, c);

      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }

    const face = new Face3(a, b, c);
    Triangle.getNormal(_vA, _vB, _vC, face.normal);
    intersection.face = face;
  }

  return intersection;
}

let _geometryId = 0; // Geometry uses even numbers as Id

const _m1$3 = new Matrix4();

const _obj$1 = new Object3D();

const _offset$1 = new Vector3();

function Geometry() {
  Object.defineProperty(this, 'id', {
    value: _geometryId += 2
  });
  this.uuid = MathUtils.generateUUID();
  this.name = '';
  this.type = 'Geometry';
  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [[]];
  this.morphTargets = [];
  this.morphNormals = [];
  this.skinWeights = [];
  this.skinIndices = [];
  this.lineDistances = [];
  this.boundingBox = null;
  this.boundingSphere = null; // update flags

  this.elementsNeedUpdate = false;
  this.verticesNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.lineDistancesNeedUpdate = false;
  this.groupsNeedUpdate = false;
}

Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Geometry,
  isGeometry: true,
  applyMatrix4: function (matrix) {
    const normalMatrix = new Matrix3().getNormalMatrix(matrix);

    for (let i = 0, il = this.vertices.length; i < il; i++) {
      const vertex = this.vertices[i];
      vertex.applyMatrix4(matrix);
    }

    for (let i = 0, il = this.faces.length; i < il; i++) {
      const face = this.faces[i];
      face.normal.applyMatrix3(normalMatrix).normalize();

      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {
        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
      }
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    this.verticesNeedUpdate = true;
    this.normalsNeedUpdate = true;
    return this;
  },
  rotateX: function (angle) {
    // rotate geometry around world x-axis
    _m1$3.makeRotationX(angle);

    this.applyMatrix4(_m1$3);
    return this;
  },
  rotateY: function (angle) {
    // rotate geometry around world y-axis
    _m1$3.makeRotationY(angle);

    this.applyMatrix4(_m1$3);
    return this;
  },
  rotateZ: function (angle) {
    // rotate geometry around world z-axis
    _m1$3.makeRotationZ(angle);

    this.applyMatrix4(_m1$3);
    return this;
  },
  translate: function (x, y, z) {
    // translate geometry
    _m1$3.makeTranslation(x, y, z);

    this.applyMatrix4(_m1$3);
    return this;
  },
  scale: function (x, y, z) {
    // scale geometry
    _m1$3.makeScale(x, y, z);

    this.applyMatrix4(_m1$3);
    return this;
  },
  lookAt: function (vector) {
    _obj$1.lookAt(vector);

    _obj$1.updateMatrix();

    this.applyMatrix4(_obj$1.matrix);
    return this;
  },
  fromBufferGeometry: function (geometry) {
    const scope = this;
    const index = geometry.index !== null ? geometry.index : undefined;
    const attributes = geometry.attributes;

    if (attributes.position === undefined) {
      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');
      return this;
    }

    const position = attributes.position;
    const normal = attributes.normal;
    const color = attributes.color;
    const uv = attributes.uv;
    const uv2 = attributes.uv2;
    if (uv2 !== undefined) this.faceVertexUvs[1] = [];

    for (let i = 0; i < position.count; i++) {
      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));

      if (color !== undefined) {
        scope.colors.push(new Color().fromBufferAttribute(color, i));
      }
    }

    function addFace(a, b, c, materialIndex) {
      const vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];
      const vertexNormals = normal === undefined ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];
      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
      scope.faces.push(face);

      if (uv !== undefined) {
        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);
      }

      if (uv2 !== undefined) {
        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);
      }
    }

    const groups = geometry.groups;

    if (groups.length > 0) {
      for (let i = 0; i < groups.length; i++) {
        const group = groups[i];
        const start = group.start;
        const count = group.count;

        for (let j = start, jl = start + count; j < jl; j += 3) {
          if (index !== undefined) {
            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);
          } else {
            addFace(j, j + 1, j + 2, group.materialIndex);
          }
        }
      }
    } else {
      if (index !== undefined) {
        for (let i = 0; i < index.count; i += 3) {
          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));
        }
      } else {
        for (let i = 0; i < position.count; i += 3) {
          addFace(i, i + 1, i + 2);
        }
      }
    }

    this.computeFaceNormals();

    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }

    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }

    return this;
  },
  center: function () {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset$1).negate();
    this.translate(_offset$1.x, _offset$1.y, _offset$1.z);
    return this;
  },
  normalize: function () {
    this.computeBoundingSphere();
    const center = this.boundingSphere.center;
    const radius = this.boundingSphere.radius;
    const s = radius === 0 ? 1 : 1.0 / radius;
    const matrix = new Matrix4();
    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
    this.applyMatrix4(matrix);
    return this;
  },
  computeFaceNormals: function () {
    const cb = new Vector3(),
          ab = new Vector3();

    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      const vA = this.vertices[face.a];
      const vB = this.vertices[face.b];
      const vC = this.vertices[face.c];
      cb.subVectors(vC, vB);
      ab.subVectors(vA, vB);
      cb.cross(ab);
      cb.normalize();
      face.normal.copy(cb);
    }
  },
  computeVertexNormals: function (areaWeighted) {
    if (areaWeighted === undefined) areaWeighted = true;
    const vertices = new Array(this.vertices.length);

    for (let v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v] = new Vector3();
    }

    if (areaWeighted) {
      // vertex normals weighted by triangle areas
      // http://www.iquilezles.org/www/articles/normals/normals.htm
      const cb = new Vector3(),
            ab = new Vector3();

      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        const vA = this.vertices[face.a];
        const vB = this.vertices[face.b];
        const vC = this.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        vertices[face.a].add(cb);
        vertices[face.b].add(cb);
        vertices[face.c].add(cb);
      }
    } else {
      this.computeFaceNormals();

      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        vertices[face.a].add(face.normal);
        vertices[face.b].add(face.normal);
        vertices[face.c].add(face.normal);
      }
    }

    for (let v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v].normalize();
    }

    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      const vertexNormals = face.vertexNormals;

      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(vertices[face.a]);
        vertexNormals[1].copy(vertices[face.b]);
        vertexNormals[2].copy(vertices[face.c]);
      } else {
        vertexNormals[0] = vertices[face.a].clone();
        vertexNormals[1] = vertices[face.b].clone();
        vertexNormals[2] = vertices[face.c].clone();
      }
    }

    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  },
  computeFlatVertexNormals: function () {
    this.computeFaceNormals();

    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      const vertexNormals = face.vertexNormals;

      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(face.normal);
        vertexNormals[1].copy(face.normal);
        vertexNormals[2].copy(face.normal);
      } else {
        vertexNormals[0] = face.normal.clone();
        vertexNormals[1] = face.normal.clone();
        vertexNormals[2] = face.normal.clone();
      }
    }

    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  },
  computeMorphNormals: function () {
    // save original normals
    // - create temp variables on first access
    //   otherwise just copy (for faster repeated calls)
    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];

      if (!face.__originalFaceNormal) {
        face.__originalFaceNormal = face.normal.clone();
      } else {
        face.__originalFaceNormal.copy(face.normal);
      }

      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];

      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {
        if (!face.__originalVertexNormals[i]) {
          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
        } else {
          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
        }
      }
    } // use temp geometry to compute face and vertex normals for each morph


    const tmpGeo = new Geometry();
    tmpGeo.faces = this.faces;

    for (let i = 0, il = this.morphTargets.length; i < il; i++) {
      // create on first access
      if (!this.morphNormals[i]) {
        this.morphNormals[i] = {};
        this.morphNormals[i].faceNormals = [];
        this.morphNormals[i].vertexNormals = [];
        const dstNormalsFace = this.morphNormals[i].faceNormals;
        const dstNormalsVertex = this.morphNormals[i].vertexNormals;

        for (let f = 0, fl = this.faces.length; f < fl; f++) {
          const faceNormal = new Vector3();
          const vertexNormals = {
            a: new Vector3(),
            b: new Vector3(),
            c: new Vector3()
          };
          dstNormalsFace.push(faceNormal);
          dstNormalsVertex.push(vertexNormals);
        }
      }

      const morphNormals = this.morphNormals[i]; // set vertices to morph target

      tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals

      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals(); // store morph normals

      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        const faceNormal = morphNormals.faceNormals[f];
        const vertexNormals = morphNormals.vertexNormals[f];
        faceNormal.copy(face.normal);
        vertexNormals.a.copy(face.vertexNormals[0]);
        vertexNormals.b.copy(face.vertexNormals[1]);
        vertexNormals.c.copy(face.vertexNormals[2]);
      }
    } // restore original normals


    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;
    }
  },
  computeBoundingBox: function () {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }

    this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function () {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }

    this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function (geometry, matrix, materialIndexOffset) {
    if (!(geometry && geometry.isGeometry)) {
      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
      return;
    }

    let normalMatrix;
    const vertexOffset = this.vertices.length,
          vertices1 = this.vertices,
          vertices2 = geometry.vertices,
          faces1 = this.faces,
          faces2 = geometry.faces,
          colors1 = this.colors,
          colors2 = geometry.colors;
    if (materialIndexOffset === undefined) materialIndexOffset = 0;

    if (matrix !== undefined) {
      normalMatrix = new Matrix3().getNormalMatrix(matrix);
    } // vertices


    for (let i = 0, il = vertices2.length; i < il; i++) {
      const vertex = vertices2[i];
      const vertexCopy = vertex.clone();
      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);
      vertices1.push(vertexCopy);
    } // colors


    for (let i = 0, il = colors2.length; i < il; i++) {
      colors1.push(colors2[i].clone());
    } // faces


    for (let i = 0, il = faces2.length; i < il; i++) {
      const face = faces2[i];
      let normal, color;
      const faceVertexNormals = face.vertexNormals,
            faceVertexColors = face.vertexColors;
      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
      faceCopy.normal.copy(face.normal);

      if (normalMatrix !== undefined) {
        faceCopy.normal.applyMatrix3(normalMatrix).normalize();
      }

      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {
        normal = faceVertexNormals[j].clone();

        if (normalMatrix !== undefined) {
          normal.applyMatrix3(normalMatrix).normalize();
        }

        faceCopy.vertexNormals.push(normal);
      }

      faceCopy.color.copy(face.color);

      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {
        color = faceVertexColors[j];
        faceCopy.vertexColors.push(color.clone());
      }

      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
      faces1.push(faceCopy);
    } // uvs


    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {
      const faceVertexUvs2 = geometry.faceVertexUvs[i];
      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];

      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {
        const uvs2 = faceVertexUvs2[j],
              uvsCopy = [];

        for (let k = 0, kl = uvs2.length; k < kl; k++) {
          uvsCopy.push(uvs2[k].clone());
        }

        this.faceVertexUvs[i].push(uvsCopy);
      }
    }
  },
  mergeMesh: function (mesh) {
    if (!(mesh && mesh.isMesh)) {
      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
      return;
    }

    if (mesh.matrixAutoUpdate) mesh.updateMatrix();
    this.merge(mesh.geometry, mesh.matrix);
  },

  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */
  mergeVertices: function () {
    const verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)

    const unique = [],
          changes = [];
    const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001

    const precision = Math.pow(10, precisionPoints);

    for (let i = 0, il = this.vertices.length; i < il; i++) {
      const v = this.vertices[i];
      const key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);

      if (verticesMap[key] === undefined) {
        verticesMap[key] = i;
        unique.push(this.vertices[i]);
        changes[i] = unique.length - 1;
      } else {
        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
        changes[i] = changes[verticesMap[key]];
      }
    } // if faces are completely degenerate after merging vertices, we
    // have to remove them from the geometry.


    const faceIndicesToRemove = [];

    for (let i = 0, il = this.faces.length; i < il; i++) {
      const face = this.faces[i];
      face.a = changes[face.a];
      face.b = changes[face.b];
      face.c = changes[face.c];
      const indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3
      // we have to remove the face as nothing can be saved

      for (let n = 0; n < 3; n++) {
        if (indices[n] === indices[(n + 1) % 3]) {
          faceIndicesToRemove.push(i);
          break;
        }
      }
    }

    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {
      const idx = faceIndicesToRemove[i];
      this.faces.splice(idx, 1);

      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
        this.faceVertexUvs[j].splice(idx, 1);
      }
    } // Use unique set of vertices


    const diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;
  },
  setFromPoints: function (points) {
    this.vertices = [];

    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
    }

    return this;
  },
  sortFacesByMaterialIndex: function () {
    const faces = this.faces;
    const length = faces.length; // tag faces

    for (let i = 0; i < length; i++) {
      faces[i]._id = i;
    } // sort faces


    function materialIndexSort(a, b) {
      return a.materialIndex - b.materialIndex;
    }

    faces.sort(materialIndexSort); // sort uvs

    const uvs1 = this.faceVertexUvs[0];
    const uvs2 = this.faceVertexUvs[1];
    let newUvs1, newUvs2;
    if (uvs1 && uvs1.length === length) newUvs1 = [];
    if (uvs2 && uvs2.length === length) newUvs2 = [];

    for (let i = 0; i < length; i++) {
      const id = faces[i]._id;
      if (newUvs1) newUvs1.push(uvs1[id]);
      if (newUvs2) newUvs2.push(uvs2[id]);
    }

    if (newUvs1) this.faceVertexUvs[0] = newUvs1;
    if (newUvs2) this.faceVertexUvs[1] = newUvs2;
  },
  toJSON: function () {
    const data = {
      metadata: {
        version: 4.5,
        type: 'Geometry',
        generator: 'Geometry.toJSON'
      }
    }; // standard Geometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;

    if (this.parameters !== undefined) {
      const parameters = this.parameters;

      for (const key in parameters) {
        if (parameters[key] !== undefined) data[key] = parameters[key];
      }

      return data;
    }

    const vertices = [];

    for (let i = 0; i < this.vertices.length; i++) {
      const vertex = this.vertices[i];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }

    const faces = [];
    const normals = [];
    const normalsHash = {};
    const colors = [];
    const colorsHash = {};
    const uvs = [];
    const uvsHash = {};

    for (let i = 0; i < this.faces.length; i++) {
      const face = this.faces[i];
      const hasMaterial = true;
      const hasFaceUv = false; // deprecated

      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
      const hasFaceNormal = face.normal.length() > 0;
      const hasFaceVertexNormal = face.vertexNormals.length > 0;
      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
      const hasFaceVertexColor = face.vertexColors.length > 0;
      let faceType = 0;
      faceType = setBit(faceType, 0, 0); // isQuad

      faceType = setBit(faceType, 1, hasMaterial);
      faceType = setBit(faceType, 2, hasFaceUv);
      faceType = setBit(faceType, 3, hasFaceVertexUv);
      faceType = setBit(faceType, 4, hasFaceNormal);
      faceType = setBit(faceType, 5, hasFaceVertexNormal);
      faceType = setBit(faceType, 6, hasFaceColor);
      faceType = setBit(faceType, 7, hasFaceVertexColor);
      faces.push(faceType);
      faces.push(face.a, face.b, face.c);
      faces.push(face.materialIndex);

      if (hasFaceVertexUv) {
        const faceVertexUvs = this.faceVertexUvs[0][i];
        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
      }

      if (hasFaceNormal) {
        faces.push(getNormalIndex(face.normal));
      }

      if (hasFaceVertexNormal) {
        const vertexNormals = face.vertexNormals;
        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
      }

      if (hasFaceColor) {
        faces.push(getColorIndex(face.color));
      }

      if (hasFaceVertexColor) {
        const vertexColors = face.vertexColors;
        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
      }
    }

    function setBit(value, position, enabled) {
      return enabled ? value | 1 << position : value & ~(1 << position);
    }

    function getNormalIndex(normal) {
      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

      if (normalsHash[hash] !== undefined) {
        return normalsHash[hash];
      }

      normalsHash[hash] = normals.length / 3;
      normals.push(normal.x, normal.y, normal.z);
      return normalsHash[hash];
    }

    function getColorIndex(color) {
      const hash = color.r.toString() + color.g.toString() + color.b.toString();

      if (colorsHash[hash] !== undefined) {
        return colorsHash[hash];
      }

      colorsHash[hash] = colors.length;
      colors.push(color.getHex());
      return colorsHash[hash];
    }

    function getUvIndex(uv) {
      const hash = uv.x.toString() + uv.y.toString();

      if (uvsHash[hash] !== undefined) {
        return uvsHash[hash];
      }

      uvsHash[hash] = uvs.length / 2;
      uvs.push(uv.x, uv.y);
      return uvsHash[hash];
    }

    data.data = {};
    data.data.vertices = vertices;
    data.data.normals = normals;
    if (colors.length > 0) data.data.colors = colors;
    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility

    data.data.faces = faces;
    return data;
  },
  clone: function () {
    /*
     // Handle primitives
    	 const parameters = this.parameters;
    	 if ( parameters !== undefined ) {
    	 const values = [];
    	 for ( const key in parameters ) {
    	 values.push( parameters[ key ] );
    	 }
    	 const geometry = Object.create( this.constructor.prototype );
     this.constructor.apply( geometry, values );
     return geometry;
    	 }
    	 return new this.constructor().copy( this );
     */
    return new Geometry().copy(this);
  },
  copy: function (source) {
    // reset
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null; // name

    this.name = source.name; // vertices

    const vertices = source.vertices;

    for (let i = 0, il = vertices.length; i < il; i++) {
      this.vertices.push(vertices[i].clone());
    } // colors


    const colors = source.colors;

    for (let i = 0, il = colors.length; i < il; i++) {
      this.colors.push(colors[i].clone());
    } // faces


    const faces = source.faces;

    for (let i = 0, il = faces.length; i < il; i++) {
      this.faces.push(faces[i].clone());
    } // face vertex uvs


    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {
      const faceVertexUvs = source.faceVertexUvs[i];

      if (this.faceVertexUvs[i] === undefined) {
        this.faceVertexUvs[i] = [];
      }

      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {
        const uvs = faceVertexUvs[j],
              uvsCopy = [];

        for (let k = 0, kl = uvs.length; k < kl; k++) {
          const uv = uvs[k];
          uvsCopy.push(uv.clone());
        }

        this.faceVertexUvs[i].push(uvsCopy);
      }
    } // morph targets


    const morphTargets = source.morphTargets;

    for (let i = 0, il = morphTargets.length; i < il; i++) {
      const morphTarget = {};
      morphTarget.name = morphTargets[i].name; // vertices

      if (morphTargets[i].vertices !== undefined) {
        morphTarget.vertices = [];

        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
        }
      } // normals


      if (morphTargets[i].normals !== undefined) {
        morphTarget.normals = [];

        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
          morphTarget.normals.push(morphTargets[i].normals[j].clone());
        }
      }

      this.morphTargets.push(morphTarget);
    } // morph normals


    const morphNormals = source.morphNormals;

    for (let i = 0, il = morphNormals.length; i < il; i++) {
      const morphNormal = {}; // vertex normals

      if (morphNormals[i].vertexNormals !== undefined) {
        morphNormal.vertexNormals = [];

        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
          const srcVertexNormal = morphNormals[i].vertexNormals[j];
          const destVertexNormal = {};
          destVertexNormal.a = srcVertexNormal.a.clone();
          destVertexNormal.b = srcVertexNormal.b.clone();
          destVertexNormal.c = srcVertexNormal.c.clone();
          morphNormal.vertexNormals.push(destVertexNormal);
        }
      } // face normals


      if (morphNormals[i].faceNormals !== undefined) {
        morphNormal.faceNormals = [];

        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
        }
      }

      this.morphNormals.push(morphNormal);
    } // skin weights


    const skinWeights = source.skinWeights;

    for (let i = 0, il = skinWeights.length; i < il; i++) {
      this.skinWeights.push(skinWeights[i].clone());
    } // skin indices


    const skinIndices = source.skinIndices;

    for (let i = 0, il = skinIndices.length; i < il; i++) {
      this.skinIndices.push(skinIndices[i].clone());
    } // line distances


    const lineDistances = source.lineDistances;

    for (let i = 0, il = lineDistances.length; i < il; i++) {
      this.lineDistances.push(lineDistances[i]);
    } // bounding box


    const boundingBox = source.boundingBox;

    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    } // bounding sphere


    const boundingSphere = source.boundingSphere;

    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    } // update flags


    this.elementsNeedUpdate = source.elementsNeedUpdate;
    this.verticesNeedUpdate = source.verticesNeedUpdate;
    this.uvsNeedUpdate = source.uvsNeedUpdate;
    this.normalsNeedUpdate = source.normalsNeedUpdate;
    this.colorsNeedUpdate = source.colorsNeedUpdate;
    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
    this.groupsNeedUpdate = source.groupsNeedUpdate;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
}); // BoxGeometry

class BoxGeometry extends Geometry {
  constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {
    super();
    this.type = 'BoxGeometry';
    this.parameters = {
      width: width,
      height: height,
      depth: depth,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      depthSegments: depthSegments
    };
    this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
    this.mergeVertices();
  }

} // BoxBufferGeometry


exports.CubeGeometry = exports.BoxGeometry = BoxGeometry;

class BoxBufferGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = 'BoxBufferGeometry';
    this.parameters = {
      width: width,
      height: height,
      depth: depth,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      depthSegments: depthSegments
    };
    const scope = this; // segments

    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    let numberOfVertices = 0;
    let groupStart = 0; // build each side of the box geometry

    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px

    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx

    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py

    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny

    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz

    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
    // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
      const segmentWidth = width / gridX;
      const segmentHeight = height / gridY;
      const widthHalf = width / 2;
      const heightHalf = height / 2;
      const depthHalf = depth / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3(); // generate vertices, normals and uvs

      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf;

        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf; // set values to correct vector component

          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf; // now apply vector to vertex buffer

          vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component

          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer

          normals.push(vector.x, vector.y, vector.z); // uvs

          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY); // counters

          vertexCounter += 1;
        }
      } // indices
      // 1. you need three indices to draw a single face
      // 2. a single segment consists of two faces
      // 3. so we need to generate six (2*3) indices per segment


      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces

          indices.push(a, b, d);
          indices.push(b, c, d); // increase counter

          groupCount += 6;
        }
      } // add a group to the geometry. this will ensure multi material support


      scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups

      groupStart += groupCount; // update total number of vertices

      numberOfVertices += vertexCounter;
    }
  }

}
/**
 * Uniform Utilities
 */


exports.BoxBufferGeometry = BoxBufferGeometry;

function cloneUniforms(src) {
  const dst = {};

  for (const u in src) {
    dst[u] = {};

    for (const p in src[u]) {
      const property = src[u][p];

      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) {
        dst[u][p] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }

  return dst;
}

function mergeUniforms(uniforms) {
  const merged = {};

  for (let u = 0; u < uniforms.length; u++) {
    const tmp = cloneUniforms(uniforms[u]);

    for (const p in tmp) {
      merged[p] = tmp[p];
    }
  }

  return merged;
} // Legacy


const UniformsUtils = {
  clone: cloneUniforms,
  merge: mergeUniforms
};
exports.UniformsUtils = UniformsUtils;
var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
/**
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function ShaderMaterial(parameters) {
  Material.call(this);
  this.type = 'ShaderMaterial';
  this.defines = {};
  this.uniforms = {};
  this.vertexShader = default_vertex;
  this.fragmentShader = default_fragment;
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false; // set to use scene fog

  this.lights = false; // set to use scene lights

  this.clipping = false; // set to use user-defined clipping planes

  this.skinning = false; // set to use skinning attribute streams

  this.morphTargets = false; // set to use morph targets

  this.morphNormals = false; // set to use morph normals

  this.extensions = {
    derivatives: false,
    // set to use derivatives
    fragDepth: false,
    // set to use fragment depth values
    drawBuffers: false,
    // set to use draw buffers
    shaderTextureLOD: false // set to use shader texture LOD

  }; // When rendered geometry doesn't include these attributes but the material does,
  // use these default values in WebGL. This avoids errors when buffer data is missing.

  this.defaultAttributeValues = {
    'color': [1, 1, 1],
    'uv': [0, 0],
    'uv2': [0, 0]
  };
  this.index0AttributeName = undefined;
  this.uniformsNeedUpdate = false;
  this.glslVersion = null;

  if (parameters !== undefined) {
    if (parameters.attributes !== undefined) {
      console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
    }

    this.setValues(parameters);
  }
}

ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;

ShaderMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;
  this.uniforms = cloneUniforms(source.uniforms);
  this.defines = Object.assign({}, source.defines);
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.lights = source.lights;
  this.clipping = source.clipping;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.extensions = Object.assign({}, source.extensions);
  this.glslVersion = source.glslVersion;
  return this;
};

ShaderMaterial.prototype.toJSON = function (meta) {
  const data = Material.prototype.toJSON.call(this, meta);
  data.glslVersion = this.glslVersion;
  data.uniforms = {};

  for (const name in this.uniforms) {
    const uniform = this.uniforms[name];
    const value = uniform.value;

    if (value && value.isTexture) {
      data.uniforms[name] = {
        type: 't',
        value: value.toJSON(meta).uuid
      };
    } else if (value && value.isColor) {
      data.uniforms[name] = {
        type: 'c',
        value: value.getHex()
      };
    } else if (value && value.isVector2) {
      data.uniforms[name] = {
        type: 'v2',
        value: value.toArray()
      };
    } else if (value && value.isVector3) {
      data.uniforms[name] = {
        type: 'v3',
        value: value.toArray()
      };
    } else if (value && value.isVector4) {
      data.uniforms[name] = {
        type: 'v4',
        value: value.toArray()
      };
    } else if (value && value.isMatrix3) {
      data.uniforms[name] = {
        type: 'm3',
        value: value.toArray()
      };
    } else if (value && value.isMatrix4) {
      data.uniforms[name] = {
        type: 'm4',
        value: value.toArray()
      };
    } else {
      data.uniforms[name] = {
        value: value
      }; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
    }
  }

  if (Object.keys(this.defines).length > 0) data.defines = this.defines;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;
  const extensions = {};

  for (const key in this.extensions) {
    if (this.extensions[key] === true) extensions[key] = true;
  }

  if (Object.keys(extensions).length > 0) data.extensions = extensions;
  return data;
};

function Camera() {
  Object3D.call(this);
  this.type = 'Camera';
  this.matrixWorldInverse = new Matrix4();
  this.projectionMatrix = new Matrix4();
  this.projectionMatrixInverse = new Matrix4();
}

Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Camera,
  isCamera: true,
  copy: function (source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  },
  getWorldDirection: function (target) {
    if (target === undefined) {
      console.warn('THREE.Camera: .getWorldDirection() target is now required');
      target = new Vector3();
    }

    this.updateMatrixWorld(true);
    const e = this.matrixWorld.elements;
    return target.set(-e[8], -e[9], -e[10]).normalize();
  },
  updateMatrixWorld: function (force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  updateWorldMatrix: function (updateParents, updateChildren) {
    Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
    this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  clone: function () {
    return new this.constructor().copy(this);
  }
});

function PerspectiveCamera(fov, aspect, near, far) {
  Camera.call(this);
  this.type = 'PerspectiveCamera';
  this.fov = fov !== undefined ? fov : 50;
  this.zoom = 1;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;
  this.focus = 10;
  this.aspect = aspect !== undefined ? aspect : 1;
  this.view = null;
  this.filmGauge = 35; // width of the film (default in millimeters)

  this.filmOffset = 0; // horizontal film offset (same unit as gauge)

  this.updateProjectionMatrix();
}

PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: PerspectiveCamera,
  isPerspectiveCamera: true,
  copy: function (source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  },

  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength: function (focalLength) {
    // see http://www.bobatkins.com/photography/technical/field_of_view.html
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  },

  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength: function () {
    const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  },
  getEffectiveFOV: function () {
    return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
  },
  getFilmWidth: function () {
    // film not completely covered in portrait format (aspect < 1)
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function () {
    // film not completely covered in landscape format (aspect > 1)
    return this.filmGauge / Math.max(this.aspect, 1);
  },

  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;

    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }

    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function () {
    if (this.view !== null) {
      this.view.enabled = false;
    }

    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function () {
    const near = this.near;
    let top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;

    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth,
            fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }

    const skew = this.filmOffset;
    if (skew !== 0) left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function (meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
});
const fov = 90,
      aspect = 1;

function CubeCamera(near, far, renderTarget) {
  Object3D.call(this);
  this.type = 'CubeCamera';

  if (renderTarget.isWebGLCubeRenderTarget !== true) {
    console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
    return;
  }

  this.renderTarget = renderTarget;
  const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
  cameraPX.layers = this.layers;
  cameraPX.up.set(0, -1, 0);
  cameraPX.lookAt(new Vector3(1, 0, 0));
  this.add(cameraPX);
  const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
  cameraNX.layers = this.layers;
  cameraNX.up.set(0, -1, 0);
  cameraNX.lookAt(new Vector3(-1, 0, 0));
  this.add(cameraNX);
  const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
  cameraPY.layers = this.layers;
  cameraPY.up.set(0, 0, 1);
  cameraPY.lookAt(new Vector3(0, 1, 0));
  this.add(cameraPY);
  const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
  cameraNY.layers = this.layers;
  cameraNY.up.set(0, 0, -1);
  cameraNY.lookAt(new Vector3(0, -1, 0));
  this.add(cameraNY);
  const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
  cameraPZ.layers = this.layers;
  cameraPZ.up.set(0, -1, 0);
  cameraPZ.lookAt(new Vector3(0, 0, 1));
  this.add(cameraPZ);
  const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
  cameraNZ.layers = this.layers;
  cameraNZ.up.set(0, -1, 0);
  cameraNZ.lookAt(new Vector3(0, 0, -1));
  this.add(cameraNZ);

  this.update = function (renderer, scene) {
    if (this.parent === null) this.updateMatrixWorld();
    const currentXrEnabled = renderer.xr.enabled;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.xr.enabled = currentXrEnabled;
  };

  this.clear = function (renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();

    for (let i = 0; i < 6; i++) {
      renderer.setRenderTarget(renderTarget, i);
      renderer.clear(color, depth, stencil);
    }

    renderer.setRenderTarget(currentRenderTarget);
  };
}

CubeCamera.prototype = Object.create(Object3D.prototype);
CubeCamera.prototype.constructor = CubeCamera;

function WebGLCubeRenderTarget(size, options, dummy) {
  if (Number.isInteger(options)) {
    console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
    options = dummy;
  }

  WebGLRenderTarget.call(this, size, size, options);
  this.texture.isWebGLCubeRenderTargetTexture = true; // HACK Why is texture not a CubeTexture?
}

WebGLCubeRenderTarget.prototype = Object.create(WebGLRenderTarget.prototype);
WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function (renderer, texture) {
  this.texture.type = texture.type;
  this.texture.format = RGBAFormat; // see #18859

  this.texture.encoding = texture.encoding;
  this.texture.generateMipmaps = texture.generateMipmaps;
  this.texture.minFilter = texture.minFilter;
  this.texture.magFilter = texture.magFilter;
  const shader = {
    uniforms: {
      tEquirect: {
        value: null
      }
    },
    vertexShader:
    /* glsl */
    `

			varying vec3 vWorldDirection;

			vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

				return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

			}

			void main() {

				vWorldDirection = transformDirection( position, modelMatrix );

				#include <begin_vertex>
				#include <project_vertex>

			}
		`,
    fragmentShader:
    /* glsl */
    `

			uniform sampler2D tEquirect;

			varying vec3 vWorldDirection;

			#include <common>

			void main() {

				vec3 direction = normalize( vWorldDirection );

				vec2 sampleUV = equirectUv( direction );

				gl_FragColor = texture2D( tEquirect, sampleUV );

			}
		`
  };
  const geometry = new BoxBufferGeometry(5, 5, 5);
  const material = new ShaderMaterial({
    name: 'CubemapFromEquirect',
    uniforms: cloneUniforms(shader.uniforms),
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader,
    side: BackSide,
    blending: NoBlending
  });
  material.uniforms.tEquirect.value = texture;
  const mesh = new Mesh(geometry, material);
  const currentMinFilter = texture.minFilter; // Avoid blurred poles

  if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
  const camera = new CubeCamera(1, 10, this);
  camera.update(renderer, mesh);
  texture.minFilter = currentMinFilter;
  mesh.geometry.dispose();
  mesh.material.dispose();
  return this;
};

function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.image = {
    data: data || null,
    width: width || 1,
    height: height || 1
  };
  this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
  this.generateMipmaps = false;
  this.flipY = false;
  this.unpackAlignment = 1;
  this.needsUpdate = true;
}

DataTexture.prototype = Object.create(Texture.prototype);
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = true;

const _sphere$1 = new Sphere();

const _vector$5 = new Vector3();

class Frustum {
  constructor(p0, p1, p2, p3, p4, p5) {
    this.planes = [p0 !== undefined ? p0 : new Plane(), p1 !== undefined ? p1 : new Plane(), p2 !== undefined ? p2 : new Plane(), p3 !== undefined ? p3 : new Plane(), p4 !== undefined ? p4 : new Plane(), p5 !== undefined ? p5 : new Plane()];
  }

  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(frustum) {
    const planes = this.planes;

    for (let i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }

    return this;
  }

  setFromProjectionMatrix(m) {
    const planes = this.planes;
    const me = m.elements;
    const me0 = me[0],
          me1 = me[1],
          me2 = me[2],
          me3 = me[3];
    const me4 = me[4],
          me5 = me[5],
          me6 = me[6],
          me7 = me[7];
    const me8 = me[8],
          me9 = me[9],
          me10 = me[10],
          me11 = me[11];
    const me12 = me[12],
          me13 = me[13],
          me14 = me[14],
          me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  }

  intersectsObject(object) {
    const geometry = object.geometry;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

    _sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

    return this.intersectsSphere(_sphere$1);
  }

  intersectsSprite(sprite) {
    _sphere$1.center.set(0, 0, 0);

    _sphere$1.radius = 0.7071067811865476;

    _sphere$1.applyMatrix4(sprite.matrixWorld);

    return this.intersectsSphere(_sphere$1);
  }

  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;

    for (let i = 0; i < 6; i++) {
      const distance = planes[i].distanceToPoint(center);

      if (distance < negRadius) {
        return false;
      }
    }

    return true;
  }

  intersectsBox(box) {
    const planes = this.planes;

    for (let i = 0; i < 6; i++) {
      const plane = planes[i]; // corner at max distance

      _vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;

      if (plane.distanceToPoint(_vector$5) < 0) {
        return false;
      }
    }

    return true;
  }

  containsPoint(point) {
    const planes = this.planes;

    for (let i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }

    return true;
  }

}

exports.Frustum = Frustum;

function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;

  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }

  return {
    start: function () {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function () {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function (callback) {
      animationLoop = callback;
    },
    setContext: function (value) {
      context = value;
    }
  };
}

function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = new WeakMap();

  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type = 5126;

    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Float64Array) {
      console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
    } else if (array instanceof Uint16Array) {
      type = 5123;
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    }

    return {
      buffer: buffer,
      type: type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }

  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);

    if (updateRange.count === -1) {
      // Not using update ranges
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }

      updateRange.count = -1; // reset range
    }
  } //


  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }

  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers.get(attribute);

    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }

  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      var cached = buffers.get(attribute);

      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }

      return;
    }

    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers.get(attribute);

    if (data === undefined) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }

  return {
    get: get,
    remove: remove,
    update: update
  };
} // PlaneGeometry


class PlaneGeometry extends Geometry {
  constructor(width, height, widthSegments, heightSegments) {
    super();
    this.type = 'PlaneGeometry';
    this.parameters = {
      width: width,
      height: height,
      widthSegments: widthSegments,
      heightSegments: heightSegments
    };
    this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
    this.mergeVertices();
  }

} // PlaneBufferGeometry


exports.PlaneGeometry = PlaneGeometry;

class PlaneBufferGeometry extends BufferGeometry {
  constructor(width, height, widthSegments, heightSegments) {
    super();
    this.type = 'PlaneBufferGeometry';
    this.parameters = {
      width: width,
      height: height,
      widthSegments: widthSegments,
      heightSegments: heightSegments
    };
    width = width || 1;
    height = height || 1;
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments) || 1;
    const gridY = Math.floor(heightSegments) || 1;
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY; // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // generate vertices, normals and uvs

    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segment_height - height_half;

      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    } // indices


    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }

}

exports.PlaneBufferGeometry = PlaneBufferGeometry;
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";
var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";
var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
const ShaderChunk = {
  alphamap_fragment: alphamap_fragment,
  alphamap_pars_fragment: alphamap_pars_fragment,
  alphatest_fragment: alphatest_fragment,
  aomap_fragment: aomap_fragment,
  aomap_pars_fragment: aomap_pars_fragment,
  begin_vertex: begin_vertex,
  beginnormal_vertex: beginnormal_vertex,
  bsdfs: bsdfs,
  bumpmap_pars_fragment: bumpmap_pars_fragment,
  clipping_planes_fragment: clipping_planes_fragment,
  clipping_planes_pars_fragment: clipping_planes_pars_fragment,
  clipping_planes_pars_vertex: clipping_planes_pars_vertex,
  clipping_planes_vertex: clipping_planes_vertex,
  color_fragment: color_fragment,
  color_pars_fragment: color_pars_fragment,
  color_pars_vertex: color_pars_vertex,
  color_vertex: color_vertex,
  common: common,
  cube_uv_reflection_fragment: cube_uv_reflection_fragment,
  defaultnormal_vertex: defaultnormal_vertex,
  displacementmap_pars_vertex: displacementmap_pars_vertex,
  displacementmap_vertex: displacementmap_vertex,
  emissivemap_fragment: emissivemap_fragment,
  emissivemap_pars_fragment: emissivemap_pars_fragment,
  encodings_fragment: encodings_fragment,
  encodings_pars_fragment: encodings_pars_fragment,
  envmap_fragment: envmap_fragment,
  envmap_common_pars_fragment: envmap_common_pars_fragment,
  envmap_pars_fragment: envmap_pars_fragment,
  envmap_pars_vertex: envmap_pars_vertex,
  envmap_physical_pars_fragment: envmap_physical_pars_fragment,
  envmap_vertex: envmap_vertex,
  fog_vertex: fog_vertex,
  fog_pars_vertex: fog_pars_vertex,
  fog_fragment: fog_fragment,
  fog_pars_fragment: fog_pars_fragment,
  gradientmap_pars_fragment: gradientmap_pars_fragment,
  lightmap_fragment: lightmap_fragment,
  lightmap_pars_fragment: lightmap_pars_fragment,
  lights_lambert_vertex: lights_lambert_vertex,
  lights_pars_begin: lights_pars_begin,
  lights_toon_fragment: lights_toon_fragment,
  lights_toon_pars_fragment: lights_toon_pars_fragment,
  lights_phong_fragment: lights_phong_fragment,
  lights_phong_pars_fragment: lights_phong_pars_fragment,
  lights_physical_fragment: lights_physical_fragment,
  lights_physical_pars_fragment: lights_physical_pars_fragment,
  lights_fragment_begin: lights_fragment_begin,
  lights_fragment_maps: lights_fragment_maps,
  lights_fragment_end: lights_fragment_end,
  logdepthbuf_fragment: logdepthbuf_fragment,
  logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
  logdepthbuf_vertex: logdepthbuf_vertex,
  map_fragment: map_fragment,
  map_pars_fragment: map_pars_fragment,
  map_particle_fragment: map_particle_fragment,
  map_particle_pars_fragment: map_particle_pars_fragment,
  metalnessmap_fragment: metalnessmap_fragment,
  metalnessmap_pars_fragment: metalnessmap_pars_fragment,
  morphnormal_vertex: morphnormal_vertex,
  morphtarget_pars_vertex: morphtarget_pars_vertex,
  morphtarget_vertex: morphtarget_vertex,
  normal_fragment_begin: normal_fragment_begin,
  normal_fragment_maps: normal_fragment_maps,
  normalmap_pars_fragment: normalmap_pars_fragment,
  clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment: clearcoat_pars_fragment,
  packing: packing,
  premultiplied_alpha_fragment: premultiplied_alpha_fragment,
  project_vertex: project_vertex,
  dithering_fragment: dithering_fragment,
  dithering_pars_fragment: dithering_pars_fragment,
  roughnessmap_fragment: roughnessmap_fragment,
  roughnessmap_pars_fragment: roughnessmap_pars_fragment,
  shadowmap_pars_fragment: shadowmap_pars_fragment,
  shadowmap_pars_vertex: shadowmap_pars_vertex,
  shadowmap_vertex: shadowmap_vertex,
  shadowmask_pars_fragment: shadowmask_pars_fragment,
  skinbase_vertex: skinbase_vertex,
  skinning_pars_vertex: skinning_pars_vertex,
  skinning_vertex: skinning_vertex,
  skinnormal_vertex: skinnormal_vertex,
  specularmap_fragment: specularmap_fragment,
  specularmap_pars_fragment: specularmap_pars_fragment,
  tonemapping_fragment: tonemapping_fragment,
  tonemapping_pars_fragment: tonemapping_pars_fragment,
  transmissionmap_fragment: transmissionmap_fragment,
  transmissionmap_pars_fragment: transmissionmap_pars_fragment,
  uv_pars_fragment: uv_pars_fragment,
  uv_pars_vertex: uv_pars_vertex,
  uv_vertex: uv_vertex,
  uv2_pars_fragment: uv2_pars_fragment,
  uv2_pars_vertex: uv2_pars_vertex,
  uv2_vertex: uv2_vertex,
  worldpos_vertex: worldpos_vertex,
  background_frag: background_frag,
  background_vert: background_vert,
  cube_frag: cube_frag,
  cube_vert: cube_vert,
  depth_frag: depth_frag,
  depth_vert: depth_vert,
  distanceRGBA_frag: distanceRGBA_frag,
  distanceRGBA_vert: distanceRGBA_vert,
  equirect_frag: equirect_frag,
  equirect_vert: equirect_vert,
  linedashed_frag: linedashed_frag,
  linedashed_vert: linedashed_vert,
  meshbasic_frag: meshbasic_frag,
  meshbasic_vert: meshbasic_vert,
  meshlambert_frag: meshlambert_frag,
  meshlambert_vert: meshlambert_vert,
  meshmatcap_frag: meshmatcap_frag,
  meshmatcap_vert: meshmatcap_vert,
  meshtoon_frag: meshtoon_frag,
  meshtoon_vert: meshtoon_vert,
  meshphong_frag: meshphong_frag,
  meshphong_vert: meshphong_vert,
  meshphysical_frag: meshphysical_frag,
  meshphysical_vert: meshphysical_vert,
  normal_frag: normal_frag,
  normal_vert: normal_vert,
  points_frag: points_frag,
  points_vert: points_vert,
  shadow_frag: shadow_frag,
  shadow_vert: shadow_vert,
  sprite_frag: sprite_frag,
  sprite_vert: sprite_vert
};
/**
 * Uniforms library for shared webgl shaders
 */

exports.ShaderChunk = ShaderChunk;
const UniformsLib = {
  common: {
    diffuse: {
      value: new Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    map: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    },
    uv2Transform: {
      value: new Matrix3()
    },
    alphaMap: {
      value: null
    }
  },
  specularmap: {
    specularMap: {
      value: null
    }
  },
  envmap: {
    envMap: {
      value: null
    },
    flipEnvMap: {
      value: -1
    },
    reflectivity: {
      value: 1.0
    },
    refractionRatio: {
      value: 0.98
    },
    maxMipLevel: {
      value: 0
    }
  },
  aomap: {
    aoMap: {
      value: null
    },
    aoMapIntensity: {
      value: 1
    }
  },
  lightmap: {
    lightMap: {
      value: null
    },
    lightMapIntensity: {
      value: 1
    }
  },
  emissivemap: {
    emissiveMap: {
      value: null
    }
  },
  bumpmap: {
    bumpMap: {
      value: null
    },
    bumpScale: {
      value: 1
    }
  },
  normalmap: {
    normalMap: {
      value: null
    },
    normalScale: {
      value: new Vector2(1, 1)
    }
  },
  displacementmap: {
    displacementMap: {
      value: null
    },
    displacementScale: {
      value: 1
    },
    displacementBias: {
      value: 0
    }
  },
  roughnessmap: {
    roughnessMap: {
      value: null
    }
  },
  metalnessmap: {
    metalnessMap: {
      value: null
    }
  },
  gradientmap: {
    gradientMap: {
      value: null
    }
  },
  fog: {
    fogDensity: {
      value: 0.00025
    },
    fogNear: {
      value: 1
    },
    fogFar: {
      value: 2000
    },
    fogColor: {
      value: new Color(0xffffff)
    }
  },
  lights: {
    ambientLightColor: {
      value: []
    },
    lightProbe: {
      value: []
    },
    directionalLights: {
      value: [],
      properties: {
        direction: {},
        color: {}
      }
    },
    directionalLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    directionalShadowMap: {
      value: []
    },
    directionalShadowMatrix: {
      value: []
    },
    spotLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {}
      }
    },
    spotLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    spotShadowMap: {
      value: []
    },
    spotShadowMatrix: {
      value: []
    },
    pointLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        decay: {},
        distance: {}
      }
    },
    pointLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      }
    },
    pointShadowMap: {
      value: []
    },
    pointShadowMatrix: {
      value: []
    },
    hemisphereLights: {
      value: [],
      properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      }
    },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      }
    },
    ltc_1: {
      value: null
    },
    ltc_2: {
      value: null
    }
  },
  points: {
    diffuse: {
      value: new Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    size: {
      value: 1.0
    },
    scale: {
      value: 1.0
    },
    map: {
      value: null
    },
    alphaMap: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    }
  },
  sprite: {
    diffuse: {
      value: new Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    center: {
      value: new Vector2(0.5, 0.5)
    },
    rotation: {
      value: 0.0
    },
    map: {
      value: null
    },
    alphaMap: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    }
  }
};
exports.UniformsLib = UniformsLib;
const ShaderLib = {
  basic: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      }
    }]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      },
      specular: {
        value: new Color(0x111111)
      },
      shininess: {
        value: 30
      }
    }]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      },
      roughness: {
        value: 1.0
      },
      metalness: {
        value: 0.0
      },
      envMapIntensity: {
        value: 1
      } // temporary

    }]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      }
    }]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
      matcap: {
        value: null
      }
    }]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
      scale: {
        value: 1
      },
      dashSize: {
        value: 1
      },
      totalSize: {
        value: 2
      }
    }]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: {
        value: new Matrix3()
      },
      t2D: {
        value: null
      }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },

  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: mergeUniforms([UniformsLib.envmap, {
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {
        value: null
      }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
      referencePosition: {
        value: new Vector3()
      },
      nearDistance: {
        value: 1
      },
      farDistance: {
        value: 1000
      }
    }]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
      color: {
        value: new Color(0x00000)
      },
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
exports.ShaderLib = ShaderLib;
ShaderLib.physical = {
  uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
    clearcoat: {
      value: 0
    },
    clearcoatMap: {
      value: null
    },
    clearcoatRoughness: {
      value: 0
    },
    clearcoatRoughnessMap: {
      value: null
    },
    clearcoatNormalScale: {
      value: new Vector2(1, 1)
    },
    clearcoatNormalMap: {
      value: null
    },
    sheen: {
      value: new Color(0x000000)
    },
    transmission: {
      value: 0
    },
    transmissionMap: {
      value: null
    }
  }]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};

function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
  const clearColor = new Color(0x000000);
  let clearAlpha = 0;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;

  function render(renderList, scene, camera, forceClear) {
    let background = scene.isScene === true ? scene.background : null;

    if (background && background.isTexture) {
      background = cubemaps.get(background);
    } // Ignore background in AR
    // TODO: Reconsider this.


    const xr = renderer.xr;
    const session = xr.getSession && xr.getSession();

    if (session && session.environmentBlendMode === 'additive') {
      background = null;
    }

    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }

    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }

    if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.isWebGLCubeRenderTargetTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === undefined) {
        boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
          name: 'BackgroundCubeMaterial',
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute('normal');
        boxMesh.geometry.deleteAttribute('uv');

        boxMesh.onBeforeRender = function (renderer, scene, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        }; // enable code injection for non-built-in material


        Object.defineProperty(boxMesh.material, 'envMap', {
          get: function () {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }

      if (background.isWebGLCubeRenderTarget) {
        // TODO Deprecate
        background = background.texture;
      }

      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture ? -1 : 1;

      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      } // push to the pre-sorted opaque render list


      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === undefined) {
        planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({
          name: 'BackgroundMaterial',
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute('normal'); // enable code injection for non-built-in material

        Object.defineProperty(planeMesh.material, 'map', {
          get: function () {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }

      planeMesh.material.uniforms.t2D.value = background;

      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }

      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      } // push to the pre-sorted opaque render list


      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }

  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }

  return {
    getClearColor: function () {
      return clearColor;
    },
    setClearColor: function (color, alpha) {
      clearColor.set(color);
      clearAlpha = alpha !== undefined ? alpha : 1;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function () {
      return clearAlpha;
    },
    setClearAlpha: function (alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render: render
  };
}

function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(34921);
  const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;

  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;

    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);

      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }

      updateBuffers = needsUpdate(geometry, index);
      if (updateBuffers) saveCache(geometry, index);
    } else {
      const wireframe = material.wireframe === true;

      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }

    if (object.isInstancedMesh === true) {
      updateBuffers = true;
    }

    if (index !== null) {
      attributes.update(index, 34963);
    }

    if (updateBuffers) {
      setupVertexAttributes(object, material, program, geometry);

      if (index !== null) {
        gl.bindBuffer(34963, attributes.get(index).buffer);
      }
    }
  }

  function createVertexArrayObject() {
    if (capabilities.isWebGL2) return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }

  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }

  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }

  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];

    if (programMap === undefined) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }

    let stateMap = programMap[program.id];

    if (stateMap === undefined) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }

    let state = stateMap[wireframe];

    if (state === undefined) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }

    return state;
  }

  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];

    for (let i = 0; i < maxVertexAttributes; i++) {
      newAttributes[i] = 0;
      enabledAttributes[i] = 0;
      attributeDivisors[i] = 0;
    }

    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes: newAttributes,
      enabledAttributes: enabledAttributes,
      attributeDivisors: attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }

  function needsUpdate(geometry, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    if (Object.keys(cachedAttributes).length !== Object.keys(geometryAttributes).length) return true;

    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === undefined) return true;
      if (cachedAttribute.attribute !== geometryAttribute) return true;
      if (cachedAttribute.data !== geometryAttribute.data) return true;
    }

    if (currentState.index !== index) return true;
    return false;
  }

  function saveCache(geometry, index) {
    const cache = {};
    const attributes = geometry.attributes;

    for (const key in attributes) {
      const attribute = attributes[key];
      const data = {};
      data.attribute = attribute;

      if (attribute.data) {
        data.data = attribute.data;
      }

      cache[key] = data;
    }

    currentState.attributes = cache;
    currentState.index = index;
  }

  function initAttributes() {
    const newAttributes = currentState.newAttributes;

    for (let i = 0, il = newAttributes.length; i < il; i++) {
      newAttributes[i] = 0;
    }
  }

  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }

  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;

    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }

    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
      extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }

  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;

    for (let i = 0, il = enabledAttributes.length; i < il; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }

  function vertexAttribPointer(index, size, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }

  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get('ANGLE_instanced_arrays') === null) return;
    }

    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;

    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];

      if (programAttribute >= 0) {
        const geometryAttribute = geometryAttributes[name];

        if (geometryAttribute !== undefined) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore

          if (attribute === undefined) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;

          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;

            if (data && data.isInstancedInterleavedBuffer) {
              enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

              if (geometry._maxInstanceCount === undefined) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              enableAttribute(programAttribute);
            }

            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

              if (geometry._maxInstanceCount === undefined) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              enableAttribute(programAttribute);
            }

            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
          }
        } else if (name === 'instanceMatrix') {
          const attribute = attributes.get(object.instanceMatrix); // TODO Attribute may not be available on context restore

          if (attribute === undefined) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute + 0, 1);
          enableAttributeAndDivisor(programAttribute + 1, 1);
          enableAttributeAndDivisor(programAttribute + 2, 1);
          enableAttributeAndDivisor(programAttribute + 3, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
          gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
          gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
          gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
        } else if (name === 'instanceColor') {
          const attribute = attributes.get(object.instanceColor); // TODO Attribute may not be available on context restore

          if (attribute === undefined) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
        } else if (materialDefaultAttributeValues !== undefined) {
          const value = materialDefaultAttributeValues[name];

          if (value !== undefined) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute, value);
                break;

              case 3:
                gl.vertexAttrib3fv(programAttribute, value);
                break;

              case 4:
                gl.vertexAttrib4fv(programAttribute, value);
                break;

              default:
                gl.vertexAttrib1fv(programAttribute, value);
            }
          }
        }
      }
    }

    disableUnusedAttributes();
  }

  function dispose() {
    reset();

    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];

      for (const programId in programMap) {
        const stateMap = programMap[programId];

        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }

        delete programMap[programId];
      }

      delete bindingStates[geometryId];
    }
  }

  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === undefined) return;
    const programMap = bindingStates[geometry.id];

    for (const programId in programMap) {
      const stateMap = programMap[programId];

      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }

      delete programMap[programId];
    }

    delete bindingStates[geometry.id];
  }

  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === undefined) continue;
      const stateMap = programMap[program.id];

      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }

      delete programMap[program.id];
    }
  }

  function reset() {
    resetDefaultState();
    if (currentState === defaultState) return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  } // for backward-compatilibity


  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }

  return {
    setup: setup,
    reset: reset,
    resetDefaultState: resetDefaultState,
    dispose: dispose,
    releaseStatesOfGeometry: releaseStatesOfGeometry,
    releaseStatesOfProgram: releaseStatesOfProgram,
    initAttributes: initAttributes,
    enableAttribute: enableAttribute,
    disableUnusedAttributes: disableUnusedAttributes
  };
}

function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;

  function setMode(value) {
    mode = value;
  }

  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }

  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    let extension, methodName;

    if (isWebGL2) {
      extension = gl;
      methodName = 'drawArraysInstanced';
    } else {
      extension = extensions.get('ANGLE_instanced_arrays');
      methodName = 'drawArraysInstancedANGLE';

      if (extension === null) {
        console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }

    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  } //


  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}

function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;

  function getMaxAnisotropy() {
    if (maxAnisotropy !== undefined) return maxAnisotropy;
    const extension = extensions.get('EXT_texture_filter_anisotropic');

    if (extension !== null) {
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }

    return maxAnisotropy;
  }

  function getMaxPrecision(precision) {
    if (precision === 'highp') {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return 'highp';
      }

      precision = 'mediump';
    }

    if (precision === 'mediump') {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return 'mediump';
      }
    }

    return 'lowp';
  }
  /* eslint-disable no-undef */


  const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
  /* eslint-enable no-undef */

  let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
  const maxPrecision = getMaxPrecision(precision);

  if (maxPrecision !== precision) {
    console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
    precision = maxPrecision;
  }

  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(34930);
  const maxVertexTextures = gl.getParameter(35660);
  const maxTextureSize = gl.getParameter(3379);
  const maxCubemapSize = gl.getParameter(34076);
  const maxAttributes = gl.getParameter(34921);
  const maxVertexUniforms = gl.getParameter(36347);
  const maxVaryings = gl.getParameter(36348);
  const maxFragmentUniforms = gl.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2: isWebGL2,
    getMaxAnisotropy: getMaxAnisotropy,
    getMaxPrecision: getMaxPrecision,
    precision: precision,
    logarithmicDepthBuffer: logarithmicDepthBuffer,
    maxTextures: maxTextures,
    maxVertexTextures: maxVertexTextures,
    maxTextureSize: maxTextureSize,
    maxCubemapSize: maxCubemapSize,
    maxAttributes: maxAttributes,
    maxVertexUniforms: maxVertexUniforms,
    maxVaryings: maxVaryings,
    maxFragmentUniforms: maxFragmentUniforms,
    vertexTextures: vertexTextures,
    floatFragmentTextures: floatFragmentTextures,
    floatVertexTextures: floatVertexTextures,
    maxSamples: maxSamples
  };
}

function WebGLClipping(properties) {
  const scope = this;
  let globalState = null,
      numGlobalPlanes = 0,
      localClippingEnabled = false,
      renderingShadows = false;
  const plane = new Plane(),
        viewNormalMatrix = new Matrix3(),
        uniform = {
    value: null,
    needsUpdate: false
  };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;

  this.init = function (planes, enableLocalClipping, camera) {
    const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };

  this.beginShadows = function () {
    renderingShadows = true;
    projectPlanes(null);
  };

  this.endShadows = function () {
    renderingShadows = false;
    resetGlobalState();
  };

  this.setState = function (material, camera, useCache) {
    const planes = material.clippingPlanes,
          clipIntersection = material.clipIntersection,
          clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);

    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      // there's no local clipping
      if (renderingShadows) {
        // there's no global clipping
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
            lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray; // ensure unique state

      dstArray = projectPlanes(planes, camera, lGlobal, useCache);

      for (let i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }

      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };

  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }

    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }

  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;

    if (nPlanes !== 0) {
      dstArray = uniform.value;

      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4,
              viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);

        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }

        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }

      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }

    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}

function WebGLCubeMaps(renderer) {
  let cubemaps = new WeakMap();

  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }

    return texture;
  }

  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;

      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;

          if (image && image.height > 0) {
            const currentRenderList = renderer.getRenderList();
            const currentRenderTarget = renderer.getRenderTarget();
            const currentRenderState = renderer.getRenderState();
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            renderer.setRenderTarget(currentRenderTarget);
            renderer.setRenderList(currentRenderList);
            renderer.setRenderState(currentRenderState);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            // image not yet ready. try the conversion next frame
            return null;
          }
        }
      }
    }

    return texture;
  }

  function dispose() {
    cubemaps = new WeakMap();
  }

  return {
    get: get,
    dispose: dispose
  };
}

function WebGLExtensions(gl) {
  const extensions = {};
  return {
    has: function (name) {
      if (extensions[name] !== undefined) {
        return extensions[name] !== null;
      }

      let extension;

      switch (name) {
        case 'WEBGL_depth_texture':
          extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
          break;

        case 'EXT_texture_filter_anisotropic':
          extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
          break;

        case 'WEBGL_compressed_texture_s3tc':
          extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
          break;

        case 'WEBGL_compressed_texture_pvrtc':
          extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
          break;

        default:
          extension = gl.getExtension(name);
      }

      extensions[name] = extension;
      return extension !== null;
    },
    get: function (name) {
      if (!this.has(name)) {
        console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
      }

      return extensions[name];
    }
  };
}

function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = new WeakMap();
  const wireframeAttributes = new WeakMap();

  function onGeometryDispose(event) {
    const geometry = event.target;
    const buffergeometry = geometries.get(geometry);

    if (buffergeometry.index !== null) {
      attributes.remove(buffergeometry.index);
    }

    for (const name in buffergeometry.attributes) {
      attributes.remove(buffergeometry.attributes[name]);
    }

    geometry.removeEventListener('dispose', onGeometryDispose);
    geometries.delete(geometry);
    const attribute = wireframeAttributes.get(buffergeometry);

    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(buffergeometry);
    }

    bindingStates.releaseStatesOfGeometry(geometry);

    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    } //


    info.memory.geometries--;
  }

  function get(object, geometry) {
    let buffergeometry = geometries.get(geometry);
    if (buffergeometry) return buffergeometry;
    geometry.addEventListener('dispose', onGeometryDispose);

    if (geometry.isBufferGeometry) {
      buffergeometry = geometry;
    } else if (geometry.isGeometry) {
      if (geometry._bufferGeometry === undefined) {
        geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
      }

      buffergeometry = geometry._bufferGeometry;
    }

    geometries.set(geometry, buffergeometry);
    info.memory.geometries++;
    return buffergeometry;
  }

  function update(geometry) {
    const geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.

    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    } // morph targets


    const morphAttributes = geometry.morphAttributes;

    for (const name in morphAttributes) {
      const array = morphAttributes[name];

      for (let i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], 34962);
      }
    }
  }

  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;

    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;

      for (let i = 0, l = array.length; i < l; i += 3) {
        const a = array[i + 0];
        const b = array[i + 1];
        const c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      const array = geometryPosition.array;
      version = geometryPosition.version;

      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        const a = i + 0;
        const b = i + 1;
        const c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    }

    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates
    //

    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) attributes.remove(previousAttribute); //

    wireframeAttributes.set(geometry, attribute);
  }

  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);

    if (currentAttribute) {
      const geometryIndex = geometry.index;

      if (geometryIndex !== null) {
        // if the attribute is obsolete, create a new one
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }

    return wireframeAttributes.get(geometry);
  }

  return {
    get: get,
    update: update,
    getWireframeAttribute: getWireframeAttribute
  };
}

function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;

  function setMode(value) {
    mode = value;
  }

  let type, bytesPerElement;

  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }

  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }

  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    let extension, methodName;

    if (isWebGL2) {
      extension = gl;
      methodName = 'drawElementsInstanced';
    } else {
      extension = extensions.get('ANGLE_instanced_arrays');
      methodName = 'drawElementsInstancedANGLE';

      if (extension === null) {
        console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }

    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  } //


  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}

function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };

  function update(count, mode, instanceCount) {
    render.calls++;

    switch (mode) {
      case 4:
        render.triangles += instanceCount * (count / 3);
        break;

      case 1:
        render.lines += instanceCount * (count / 2);
        break;

      case 3:
        render.lines += instanceCount * (count - 1);
        break;

      case 2:
        render.lines += instanceCount * count;
        break;

      case 0:
        render.points += instanceCount * count;
        break;

      default:
        console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
        break;
    }
  }

  function reset() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }

  return {
    memory: memory,
    render: render,
    programs: null,
    autoReset: true,
    reset: reset,
    update: update
  };
}

function numericalSort(a, b) {
  return a[0] - b[0];
}

function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}

function WebGLMorphtargets(gl) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const workInfluences = [];

  for (let i = 0; i < 8; i++) {
    workInfluences[i] = [i, 0];
  }

  function update(object, geometry, material, program) {
    const objectInfluences = object.morphTargetInfluences; // When object doesn't have morph target influences defined, we treat it as a 0-length array
    // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

    const length = objectInfluences === undefined ? 0 : objectInfluences.length;
    let influences = influencesList[geometry.id];

    if (influences === undefined) {
      // initialise list
      influences = [];

      for (let i = 0; i < length; i++) {
        influences[i] = [i, 0];
      }

      influencesList[geometry.id] = influences;
    } // Collect influences


    for (let i = 0; i < length; i++) {
      const influence = influences[i];
      influence[0] = i;
      influence[1] = objectInfluences[i];
    }

    influences.sort(absNumericalSort);

    for (let i = 0; i < 8; i++) {
      if (i < length && influences[i][1]) {
        workInfluences[i][0] = influences[i][0];
        workInfluences[i][1] = influences[i][1];
      } else {
        workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
        workInfluences[i][1] = 0;
      }
    }

    workInfluences.sort(numericalSort);
    const morphTargets = material.morphTargets && geometry.morphAttributes.position;
    const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
    let morphInfluencesSum = 0;

    for (let i = 0; i < 8; i++) {
      const influence = workInfluences[i];
      const index = influence[0];
      const value = influence[1];

      if (index !== Number.MAX_SAFE_INTEGER && value) {
        if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {
          geometry.setAttribute('morphTarget' + i, morphTargets[index]);
        }

        if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {
          geometry.setAttribute('morphNormal' + i, morphNormals[index]);
        }

        morphInfluences[i] = value;
        morphInfluencesSum += value;
      } else {
        if (morphTargets && geometry.getAttribute('morphTarget' + i) !== undefined) {
          geometry.deleteAttribute('morphTarget' + i);
        }

        if (morphNormals && geometry.getAttribute('morphNormal' + i) !== undefined) {
          geometry.deleteAttribute('morphNormal' + i);
        }

        morphInfluences[i] = 0;
      }
    } // GLSL shader uses formula baseinfluence * base + sum(target * influence)
    // This allows us to switch between absolute morphs and relative morphs without changing shader code
    // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)


    const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
    program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
  }

  return {
    update: update
  };
}

function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = new WeakMap();

  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry); // Update once per frame

    if (updateMap.get(buffergeometry) !== frame) {
      if (geometry.isGeometry) {
        buffergeometry.updateFromObject(object);
      }

      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }

    if (object.isInstancedMesh) {
      attributes.update(object.instanceMatrix, 34962);

      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, 34962);
      }
    }

    return buffergeometry;
  }

  function dispose() {
    updateMap = new WeakMap();
  }

  return {
    update: update,
    dispose: dispose
  };
}

function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
  images = images !== undefined ? images : [];
  mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
  format = format !== undefined ? format : RGBFormat;
  Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.flipY = false;
}

CubeTexture.prototype = Object.create(Texture.prototype);
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;
Object.defineProperty(CubeTexture.prototype, 'images', {
  get: function () {
    return this.image;
  },
  set: function (value) {
    this.image = value;
  }
});

function DataTexture2DArray(data, width, height, depth) {
  Texture.call(this, null);
  this.image = {
    data: data || null,
    width: width || 1,
    height: height || 1,
    depth: depth || 1
  };
  this.magFilter = NearestFilter;
  this.minFilter = NearestFilter;
  this.wrapR = ClampToEdgeWrapping;
  this.generateMipmaps = false;
  this.flipY = false;
  this.needsUpdate = true;
}

DataTexture2DArray.prototype = Object.create(Texture.prototype);
DataTexture2DArray.prototype.constructor = DataTexture2DArray;
DataTexture2DArray.prototype.isDataTexture2DArray = true;

function DataTexture3D(data, width, height, depth) {
  // We're going to add .setXXX() methods for setting properties later.
  // Users can still set in DataTexture3D directly.
  //
  //	const texture = new THREE.DataTexture3D( data, width, height, depth );
  // 	texture.anisotropy = 16;
  //
  // See #14839
  Texture.call(this, null);
  this.image = {
    data: data || null,
    width: width || 1,
    height: height || 1,
    depth: depth || 1
  };
  this.magFilter = NearestFilter;
  this.minFilter = NearestFilter;
  this.wrapR = ClampToEdgeWrapping;
  this.generateMipmaps = false;
  this.flipY = false;
  this.needsUpdate = true;
}

DataTexture3D.prototype = Object.create(Texture.prototype);
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;
/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

const emptyTexture = new Texture();
const emptyTexture2dArray = new DataTexture2DArray();
const emptyTexture3d = new DataTexture3D();
const emptyCubeTexture = new CubeTexture(); // --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)

const arrayCacheF32 = [];
const arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms

const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices

function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )
  // see http://jacksondunstan.com/articles/983

  const n = nBlocks * blockSize;
  let r = arrayCacheF32[n];

  if (r === undefined) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }

  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);

    for (let i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }

  return r;
}

function arraysEqual(a, b) {
  if (a.length !== b.length) return false;

  for (let i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i]) return false;
  }

  return true;
}

function copyArray(a, b) {
  for (let i = 0, l = b.length; i < l; i++) {
    a[i] = b[i];
  }
} // Texture unit allocation


function allocTexUnits(textures, n) {
  let r = arrayCacheI32[n];

  if (r === undefined) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }

  for (let i = 0; i !== n; ++i) {
    r[i] = textures.allocateTextureUnit();
  }

  return r;
} // --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar


function setValueV1f(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
} // Single float vector (from flat array or THREE.VectorN)


function setValueV2f(gl, v) {
  const cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}

function setValueV3f(gl, v) {
  const cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== undefined) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}

function setValueV4f(gl, v) {
  const cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
} // Single matrix (from flat array or MatrixN)


function setValueM2(gl, v) {
  const cache = this.cache;
  const elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}

function setValueM3(gl, v) {
  const cache = this.cache;
  const elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}

function setValueM4(gl, v) {
  const cache = this.cache;
  const elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
} // Single texture (2D / Cube)


function setValueT1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.safeSetTexture2D(v || emptyTexture, unit);
}

function setValueT2DArray1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.setTexture2DArray(v || emptyTexture2dArray, unit);
}

function setValueT3D1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.setTexture3D(v || emptyTexture3d, unit);
}

function setValueT6(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.safeSetTextureCube(v || emptyCubeTexture, unit);
} // Integer / Boolean vectors or arrays thereof (always flat arrays)


function setValueV1i(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
}

function setValueV2i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform2iv(this.addr, v);
  copyArray(cache, v);
}

function setValueV3i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform3iv(this.addr, v);
  copyArray(cache, v);
}

function setValueV4i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform4iv(this.addr, v);
  copyArray(cache, v);
} // uint


function setValueV1ui(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1ui(this.addr, v);
  cache[0] = v;
} // Helper to pick the right setter for the singular case


function getSingularSetter(type) {
  switch (type) {
    case 0x1406:
      return setValueV1f;
    // FLOAT

    case 0x8b50:
      return setValueV2f;
    // _VEC2

    case 0x8b51:
      return setValueV3f;
    // _VEC3

    case 0x8b52:
      return setValueV4f;
    // _VEC4

    case 0x8b5a:
      return setValueM2;
    // _MAT2

    case 0x8b5b:
      return setValueM3;
    // _MAT3

    case 0x8b5c:
      return setValueM4;
    // _MAT4

    case 0x1404:
    case 0x8b56:
      return setValueV1i;
    // INT, BOOL

    case 0x8b53:
    case 0x8b57:
      return setValueV2i;
    // _VEC2

    case 0x8b54:
    case 0x8b58:
      return setValueV3i;
    // _VEC3

    case 0x8b55:
    case 0x8b59:
      return setValueV4i;
    // _VEC4

    case 0x1405:
      return setValueV1ui;
    // UINT

    case 0x8b5e: // SAMPLER_2D

    case 0x8d66: // SAMPLER_EXTERNAL_OES

    case 0x8dca: // INT_SAMPLER_2D

    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

    case 0x8b62:
      // SAMPLER_2D_SHADOW
      return setValueT1;

    case 0x8b5f: // SAMPLER_3D

    case 0x8dcb: // INT_SAMPLER_3D

    case 0x8dd3:
      // UNSIGNED_INT_SAMPLER_3D
      return setValueT3D1;

    case 0x8b60: // SAMPLER_CUBE

    case 0x8dcc: // INT_SAMPLER_CUBE

    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

    case 0x8dc5:
      // SAMPLER_CUBE_SHADOW
      return setValueT6;

    case 0x8dc1: // SAMPLER_2D_ARRAY

    case 0x8dcf: // INT_SAMPLER_2D_ARRAY

    case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY

    case 0x8dc4:
      // SAMPLER_2D_ARRAY_SHADOW
      return setValueT2DArray1;
  }
} // Array of scalars


function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
} // Integer / Boolean vectors or arrays thereof (always flat arrays)


function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}

function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}

function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}

function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
} // Array of vectors (flat or from THREE classes)


function setValueV2fArray(gl, v) {
  const data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}

function setValueV3fArray(gl, v) {
  const data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}

function setValueV4fArray(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
} // Array of matrices (flat or from THREE clases)


function setValueM2Array(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}

function setValueM3Array(gl, v) {
  const data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}

function setValueM4Array(gl, v) {
  const data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
} // Array of textures (2D / Cube)


function setValueT1Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);

  for (let i = 0; i !== n; ++i) {
    textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
  }
}

function setValueT6Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);

  for (let i = 0; i !== n; ++i) {
    textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
} // Helper to pick the right setter for a pure (bottom-level) array


function getPureArraySetter(type) {
  switch (type) {
    case 0x1406:
      return setValueV1fArray;
    // FLOAT

    case 0x8b50:
      return setValueV2fArray;
    // _VEC2

    case 0x8b51:
      return setValueV3fArray;
    // _VEC3

    case 0x8b52:
      return setValueV4fArray;
    // _VEC4

    case 0x8b5a:
      return setValueM2Array;
    // _MAT2

    case 0x8b5b:
      return setValueM3Array;
    // _MAT3

    case 0x8b5c:
      return setValueM4Array;
    // _MAT4

    case 0x1404:
    case 0x8b56:
      return setValueV1iArray;
    // INT, BOOL

    case 0x8b53:
    case 0x8b57:
      return setValueV2iArray;
    // _VEC2

    case 0x8b54:
    case 0x8b58:
      return setValueV3iArray;
    // _VEC3

    case 0x8b55:
    case 0x8b59:
      return setValueV4iArray;
    // _VEC4

    case 0x8b5e: // SAMPLER_2D

    case 0x8d66: // SAMPLER_EXTERNAL_OES

    case 0x8dca: // INT_SAMPLER_2D

    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

    case 0x8b62:
      // SAMPLER_2D_SHADOW
      return setValueT1Array;

    case 0x8b60: // SAMPLER_CUBE

    case 0x8dcc: // INT_SAMPLER_CUBE

    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

    case 0x8dc5:
      // SAMPLER_CUBE_SHADOW
      return setValueT6Array;
  }
} // --- Uniform Classes ---


function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
}

function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
}

PureArrayUniform.prototype.updateCache = function (data) {
  const cache = this.cache;

  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }

  copyArray(cache, data);
};

function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}

StructuredUniform.prototype.setValue = function (gl, value, textures) {
  const seq = this.seq;

  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    u.setValue(gl, value[u.id], textures);
  }
}; // --- Top-level ---
// Parser - builds up the property tree from the path strings


const RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g; // extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}

function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name,
        pathLength = path.length; // reset RegExp object, because of the early exit of a previous run

  RePathPart.lastIndex = 0;

  while (true) {
    const match = RePathPart.exec(path),
          matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === ']',
          subscript = match[3];
    if (idIsIndex) id = id | 0; // convert to integer

    if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
      // bare name or "pure" bottom-level array "[0]" suffix
      addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      // step into inner node / create it in case it doesn't exist
      const map = container.map;
      let next = map[id];

      if (next === undefined) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }

      container = next;
    }
  }
} // Root Container


function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  const n = gl.getProgramParameter(program, 35718);

  for (let i = 0; i < n; ++i) {
    const info = gl.getActiveUniform(program, i),
          addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}

WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
  const u = this.map[name];
  if (u !== undefined) u.setValue(gl, value, textures);
};

WebGLUniforms.prototype.setOptional = function (gl, object, name) {
  const v = object[name];
  if (v !== undefined) this.setValue(gl, name, v);
}; // Static interface


WebGLUniforms.upload = function (gl, seq, values, textures) {
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i],
          v = values[u.id];

    if (v.needsUpdate !== false) {
      // note: always updating when .needsUpdate is undefined
      u.setValue(gl, v.value, textures);
    }
  }
};

WebGLUniforms.seqWithValue = function (seq, values) {
  const r = [];

  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    if (u.id in values) r.push(u);
  }

  return r;
};

function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}

let programIdCount = 0;

function addLineNumbers(string) {
  const lines = string.split('\n');

  for (let i = 0; i < lines.length; i++) {
    lines[i] = i + 1 + ': ' + lines[i];
  }

  return lines.join('\n');
}

function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ['Linear', '( value )'];

    case sRGBEncoding:
      return ['sRGB', '( value )'];

    case RGBEEncoding:
      return ['RGBE', '( value )'];

    case RGBM7Encoding:
      return ['RGBM', '( value, 7.0 )'];

    case RGBM16Encoding:
      return ['RGBM', '( value, 16.0 )'];

    case RGBDEncoding:
      return ['RGBD', '( value, 256.0 )'];

    case GammaEncoding:
      return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];

    case LogLuvEncoding:
      return ['LogLuv', '( value )'];

    default:
      console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
      return ['Linear', '( value )'];
  }
}

function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713);
  const log = gl.getShaderInfoLog(shader).trim();
  if (status && log === '') return ''; // --enable-privileged-webgl-extension
  // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

  const source = gl.getShaderSource(shader);
  return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
}

function getTexelDecodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
}

function getTexelEncodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}

function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;

  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = 'Linear';
      break;

    case ReinhardToneMapping:
      toneMappingName = 'Reinhard';
      break;

    case CineonToneMapping:
      toneMappingName = 'OptimizedCineon';
      break;

    case ACESFilmicToneMapping:
      toneMappingName = 'ACESFilmic';
      break;

    case CustomToneMapping:
      toneMappingName = 'Custom';
      break;

    default:
      console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
      toneMappingName = 'Linear';
  }

  return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}

function generateExtensions(parameters) {
  const chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
  return chunks.filter(filterEmptyLine).join('\n');
}

function generateDefines(defines) {
  const chunks = [];

  for (const name in defines) {
    const value = defines[name];
    if (value === false) continue;
    chunks.push('#define ' + name + ' ' + value);
  }

  return chunks.join('\n');
}

function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, 35721);

  for (let i = 0; i < n; i++) {
    const info = gl.getActiveAttrib(program, i);
    const name = info.name; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

    attributes[name] = gl.getAttribLocation(program, name);
  }

  return attributes;
}

function filterEmptyLine(string) {
  return string !== '';
}

function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}

function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
} // Resolve Includes


const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}

function includeReplacer(match, include) {
  const string = ShaderChunk[include];

  if (string === undefined) {
    throw new Error('Can not resolve #include <' + include + '>');
  }

  return resolveIncludes(string);
} // Unroll Loops


const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}

function deprecatedLoopReplacer(match, start, end, snippet) {
  console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
  return loopReplacer(match, start, end, snippet);
}

function loopReplacer(match, start, end, snippet) {
  let string = '';

  for (let i = parseInt(start); i < parseInt(end); i++) {
    string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);
  }

  return string;
} //


function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";

  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }

  return precisionstring;
}

function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
  }

  return shadowMapTypeDefine;
}

function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        break;

      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
        break;
    }
  }

  return envMapTypeDefine;
}

function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
        break;
    }
  }

  return envMapModeDefine;
}

function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        break;

      case MixOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
        break;

      case AddOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
        break;
    }
  }

  return envMapBlendingDefine;
}

function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;
  const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + "\n" : '';

  if (parameters.isRawShaderMaterial) {
    prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

    if (prefixVertex.length > 0) {
      prefixVertex += '\n';
    }

    prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');

    if (prefixFragment.length > 0) {
      prefixFragment += '\n';
    }
  } else {
    prefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '	attribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '	attribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
    prefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer
    '#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
    parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below
    parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '', getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
  }

  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);

  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    // GLSL 3.0 conversion for built-in materials and ShaderMaterial
    versionString = '#version 300 es\n';
    prefixVertex = ['#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
    prefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
  }

  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );
  // console.log( '*FRAGMENT*', fragmentGlsl );

  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.

  if (parameters.index0AttributeName !== undefined) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    // programs with morphTargets displace position out of attribute 0
    gl.bindAttribLocation(program, 0, 'position');
  }

  gl.linkProgram(program); // check for link errors

  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;

    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
      console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
    } else if (programLog !== '') {
      console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
    } else if (vertexLog === '' || fragmentLog === '') {
      haveDiagnostics = false;
    }

    if (haveDiagnostics) {
      this.diagnostics = {
        runnable: runnable,
        programLog: programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  } // Clean up
  // Crashes in iOS9 and iOS10. #18402
  // gl.detachShader( program, glVertexShader );
  // gl.detachShader( program, glFragmentShader );


  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader); // set up caching for uniform locations

  let cachedUniforms;

  this.getUniforms = function () {
    if (cachedUniforms === undefined) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }

    return cachedUniforms;
  }; // set up caching for attribute locations


  let cachedAttributes;

  this.getAttributes = function () {
    if (cachedAttributes === undefined) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }

    return cachedAttributes;
  }; // free resource


  this.destroy = function () {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = undefined;
  }; //


  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}

function WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'toon',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite'
  };
  const parameterNames = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights', "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];

  function getMaxBones(object) {
    const skeleton = object.skeleton;
    const bones = skeleton.bones;

    if (floatVertexTextures) {
      return 1024;
    } else {
      // default for when object is not specified
      // ( for example when prebuilding shader to be used with multiple objects )
      //
      //  - leave some extra space for other uniforms
      //  - limit here is ANGLE's 254 max uniform vectors
      //    (up to 54 should be safe)
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);

      if (maxBones < bones.length) {
        console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
        return 0;
      }

      return maxBones;
    }
  }

  function getTextureEncodingFromMap(map) {
    let encoding;

    if (!map) {
      encoding = LinearEncoding;
    } else if (map.isTexture) {
      encoding = map.encoding;
    } else if (map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    }

    return encoding;
  }

  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = cubemaps.get(material.envMap || environment);
    const shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene
    // (not to blow over maxLights budget)

    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;

    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);

      if (precision !== material.precision) {
        console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
      }
    }

    let vertexShader, fragmentShader;

    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
    }

    const currentRenderTarget = renderer.getRenderTarget();
    const parameters = {
      isWebGL2: isWebGL2,
      shaderID: shaderID,
      shaderName: material.type,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      defines: material.defines,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision: precision,
      instancing: object.isInstancedMesh === true,
      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap),
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(envMap),
      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      clearcoatMap: !!material.clearcoatMap,
      clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      sheen: !!material.sheen,
      transmissionMap: !!material.transmissionMap,
      combine: material.combine,
      vertexTangents: material.normalMap && material.vertexTangents,
      vertexColors: material.vertexColors,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: logarithmicDepthBuffer,
      skinning: material.skinning && maxBones > 0,
      maxBones: maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: renderer.maxMorphTargets,
      maxMorphNormals: renderer.maxMorphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }

  function getProgramCacheKey(parameters) {
    const array = [];

    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.fragmentShader);
      array.push(parameters.vertexShader);
    }

    if (parameters.defines !== undefined) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }

    if (parameters.isRawShaderMaterial === false) {
      for (let i = 0; i < parameterNames.length; i++) {
        array.push(parameters[parameterNames[i]]);
      }

      array.push(renderer.outputEncoding);
      array.push(renderer.gammaFactor);
    }

    array.push(parameters.customProgramCacheKey);
    return array.join();
  }

  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;

    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }

    return uniforms;
  }

  function acquireProgram(parameters, cacheKey) {
    let program; // Check if code has been already compiled

    for (let p = 0, pl = programs.length; p < pl; p++) {
      const preexistingProgram = programs[p];

      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }

    if (program === undefined) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }

    return program;
  }

  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      // Remove from unordered set
      const i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop(); // Free WebGL resources

      program.destroy();
    }
  }

  return {
    getParameters: getParameters,
    getProgramCacheKey: getProgramCacheKey,
    getUniforms: getUniforms,
    acquireProgram: acquireProgram,
    releaseProgram: releaseProgram,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: programs
  };
}

function WebGLProperties() {
  let properties = new WeakMap();

  function get(object) {
    let map = properties.get(object);

    if (map === undefined) {
      map = {};
      properties.set(object, map);
    }

    return map;
  }

  function remove(object) {
    properties.delete(object);
  }

  function update(object, key, value) {
    properties.get(object)[key] = value;
  }

  function dispose() {
    properties = new WeakMap();
  }

  return {
    get: get,
    remove: remove,
    update: update,
    dispose: dispose
  };
}

function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.program !== b.program) {
    return a.program.id - b.program.id;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}

function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}

function WebGLRenderList(properties) {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transparent = [];
  const defaultProgram = {
    id: -1
  };

  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transparent.length = 0;
  }

  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex];
    const materialProperties = properties.get(material);

    if (renderItem === undefined) {
      renderItem = {
        id: object.id,
        object: object,
        geometry: geometry,
        material: material,
        program: materialProperties.program || defaultProgram,
        groupOrder: groupOrder,
        renderOrder: object.renderOrder,
        z: z,
        group: group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = materialProperties.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }

    renderItemsIndex++;
    return renderItem;
  }

  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).push(renderItem);
  }

  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).unshift(renderItem);
  }

  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
  }

  function finish() {
    // Clear references from inactive renderItems in the list
    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
      const renderItem = renderItems[i];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.program = null;
      renderItem.group = null;
    }
  }

  return {
    opaque: opaque,
    transparent: transparent,
    init: init,
    push: push,
    unshift: unshift,
    finish: finish,
    sort: sort
  };
}

function WebGLRenderLists(properties) {
  let lists = new WeakMap();

  function get(scene, camera) {
    const cameras = lists.get(scene);
    let list;

    if (cameras === undefined) {
      list = new WebGLRenderList(properties);
      lists.set(scene, new WeakMap());
      lists.get(scene).set(camera, list);
    } else {
      list = cameras.get(camera);

      if (list === undefined) {
        list = new WebGLRenderList(properties);
        cameras.set(camera, list);
      }
    }

    return list;
  }

  function dispose() {
    lists = new WeakMap();
  }

  return {
    get: get,
    dispose: dispose
  };
}

function UniformsCache() {
  const lights = {};
  return {
    get: function (light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }

      let uniforms;

      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;

        case 'SpotLight':
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;

        case 'PointLight':
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;

        case 'HemisphereLight':
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;

        case 'RectAreaLight':
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }

      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}

function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function (light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }

      let uniforms;

      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;

        case 'SpotLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;

        case 'PointLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1000
          };
          break;
        // TODO (abelnation): set RectAreaLight shadow uniforms
      }

      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}

let nextVersion = 0;

function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}

function WebGLLights() {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };

  for (let i = 0; i < 9; i++) state.probe.push(new Vector3());

  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();

  function setup(lights, shadows, camera) {
    let r = 0,
        g = 0,
        b = 0;

    for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);

    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    const viewMatrix = camera.matrixWorldInverse;
    lights.sort(shadowCastingLightsFirst);

    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

      if (light.isAmbientLight) {
        r += color.r * intensity;
        g += color.g * intensity;
        b += color.b * intensity;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);

        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }

        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;

        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }

        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light); // (a) intensity is the total visible light emitted
        //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
        // (b) intensity is the brightness of the light

        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors

        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42); // TODO (abelnation): RectAreaLight distance?
        // uniforms.distance = distance;

        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;

        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }

        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }

    if (rectAreaLength > 0) {
      state.rectAreaLTC1 = UniformsLib.LTC_1;
      state.rectAreaLTC2 = UniformsLib.LTC_2;
    }

    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    const hash = state.hash;

    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }

  return {
    setup: setup,
    state: state
  };
}

function WebGLRenderState() {
  const lights = new WebGLLights();
  const lightsArray = [];
  const shadowsArray = [];

  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }

  function pushLight(light) {
    lightsArray.push(light);
  }

  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }

  function setupLights(camera) {
    lights.setup(lightsArray, shadowsArray, camera);
  }

  const state = {
    lightsArray: lightsArray,
    shadowsArray: shadowsArray,
    lights: lights
  };
  return {
    init: init,
    state: state,
    setupLights: setupLights,
    pushLight: pushLight,
    pushShadow: pushShadow
  };
}

function WebGLRenderStates() {
  let renderStates = new WeakMap();

  function get(scene, camera) {
    let renderState;

    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState();
      renderStates.set(scene, new WeakMap());
      renderStates.get(scene).set(camera, renderState);
    } else {
      if (renderStates.get(scene).has(camera) === false) {
        renderState = new WebGLRenderState();
        renderStates.get(scene).set(camera, renderState);
      } else {
        renderState = renderStates.get(scene).get(camera);
      }
    }

    return renderState;
  }

  function dispose() {
    renderStates = new WeakMap();
  }

  return {
    get: get,
    dispose: dispose
  };
}
/**
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */


function MeshDepthMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshDepthMaterial';
  this.depthPacking = BasicDepthPacking;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.setValues(parameters);
}

MeshDepthMaterial.prototype = Object.create(Material.prototype);
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

MeshDepthMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.depthPacking = source.depthPacking;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  return this;
};
/**
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */


function MeshDistanceMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshDistanceMaterial';
  this.referencePosition = new Vector3();
  this.nearDistance = 1;
  this.farDistance = 1000;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.fog = false;
  this.setValues(parameters);
}

MeshDistanceMaterial.prototype = Object.create(Material.prototype);
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

MeshDistanceMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.referencePosition.copy(source.referencePosition);
  this.nearDistance = source.nearDistance;
  this.farDistance = source.farDistance;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  return this;
};

var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
  let _frustum = new Frustum();

  const _shadowMapSize = new Vector2(),
        _viewportSize = new Vector2(),
        _viewport = new Vector4(),
        _depthMaterials = [],
        _distanceMaterials = [],
        _materialCache = {};

  const shadowSide = {
    0: BackSide,
    1: FrontSide,
    2: DoubleSide
  };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      SAMPLE_RATE: 2.0 / 8.0,
      HALF_SAMPLE_RATE: 1.0 / 8.0
    },
    uniforms: {
      shadow_pass: {
        value: null
      },
      resolution: {
        value: new Vector2()
      },
      radius: {
        value: 4.0
      }
    },
    vertexShader: vsm_vert,
    fragmentShader: vsm_frag
  });
  const shadowMaterialHorizonal = shadowMaterialVertical.clone();
  shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;

  this.render = function (lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;

    const currentRenderTarget = _renderer.getRenderTarget();

    const activeCubeFace = _renderer.getActiveCubeFace();

    const activeMipmapLevel = _renderer.getActiveMipmapLevel();

    const _state = _renderer.state; // Set GL state for depth map.

    _state.setBlending(NoBlending);

    _state.buffers.color.setClear(1, 1, 1, 1);

    _state.buffers.depth.setTest(true);

    _state.setScissorTest(false); // render depth map


    for (let i = 0, il = lights.length; i < il; i++) {
      const light = lights[i];
      const shadow = light.shadow;
      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;

      if (shadow === undefined) {
        console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
        continue;
      }

      _shadowMapSize.copy(shadow.mapSize);

      const shadowFrameExtents = shadow.getFrameExtents();

      _shadowMapSize.multiply(shadowFrameExtents);

      _viewportSize.copy(shadow.mapSize);

      if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
        if (_shadowMapSize.x > maxTextureSize) {
          _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }

        if (_shadowMapSize.y > maxTextureSize) {
          _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }

      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        const pars = {
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          format: RGBAFormat
        };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }

      if (shadow.map === null) {
        const pars = {
          minFilter: NearestFilter,
          magFilter: NearestFilter,
          format: RGBAFormat
        };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }

      _renderer.setRenderTarget(shadow.map);

      _renderer.clear();

      const viewportCount = shadow.getViewportCount();

      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);

        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);

        _state.viewport(_viewport);

        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      } // do blur pass for VSM


      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }

      shadow.needsUpdate = false;
    }

    scope.needsUpdate = false;

    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };

  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh); // vertical pass


    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;

    _renderer.setRenderTarget(shadow.mapPass);

    _renderer.clear();

    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizonal pass


    shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;

    _renderer.setRenderTarget(shadow.map);

    _renderer.clear();

    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null);
  }

  function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _depthMaterials[index];

    if (material === undefined) {
      material = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking,
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _depthMaterials[index] = material;
    }

    return material;
  }

  function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _distanceMaterials[index];

    if (material === undefined) {
      material = new MeshDistanceMaterial({
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _distanceMaterials[index] = material;
    }

    return material;
  }

  function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    let getMaterialVariant = getDepthMaterialVariant;
    let customMaterial = object.customDepthMaterial;

    if (light.isPointLight === true) {
      getMaterialVariant = getDistanceMaterialVariant;
      customMaterial = object.customDistanceMaterial;
    }

    if (customMaterial === undefined) {
      let useMorphing = false;

      if (material.morphTargets === true) {
        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
      }

      let useSkinning = false;

      if (object.isSkinnedMesh === true) {
        if (material.skinning === true) {
          useSkinning = true;
        } else {
          console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
        }
      }

      const useInstancing = object.isInstancedMesh === true;
      result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
    } else {
      result = customMaterial;
    }

    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      // in this case we need a unique material instance reflecting the
      // appropriate state
      const keyA = result.uuid,
            keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];

      if (materialsForVariant === undefined) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }

      let cachedMaterial = materialsForVariant[keyB];

      if (cachedMaterial === undefined) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }

      result = cachedMaterial;
    }

    result.visible = material.visible;
    result.wireframe = material.wireframe;

    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }

    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;

    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }

    return result;
  }

  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera.layers);

    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

        const geometry = _objects.update(object);

        const material = object.material;

        if (Array.isArray(material)) {
          const groups = geometry.groups;

          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group = groups[k];
            const groupMaterial = material[group.materialIndex];

            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);

              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);

          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }

    const children = object.children;

    for (let i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera, shadowCamera, light, type);
    }
  }
}

function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;

  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function (colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }

        color.set(r, g, b, a);

        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function () {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0); // set to invalid state
      }
    };
  }

  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function (depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function (depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function (depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;

              case AlwaysDepth:
                gl.depthFunc(519);
                break;

              case LessDepth:
                gl.depthFunc(513);
                break;

              case LessEqualDepth:
                gl.depthFunc(515);
                break;

              case EqualDepth:
                gl.depthFunc(514);
                break;

              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;

              case GreaterDepth:
                gl.depthFunc(516);
                break;

              case NotEqualDepth:
                gl.depthFunc(517);
                break;

              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }

          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function () {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }

  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function (stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function (stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function (stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function (stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function () {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  } //


  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let currentProgram = null;
  let currentBlendingEnabled = null;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(35661);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(7938);

  if (glVersion.indexOf('WebGL') !== -1) {
    version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1.0;
  } else if (glVersion.indexOf('OpenGL ES') !== -1) {
    version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2.0;
  }

  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const currentScissor = new Vector4();
  const currentViewport = new Vector4();

  function createTexture(type, target, count) {
    const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.

    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);

    for (let i = 0; i < count; i++) {
      gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }

    return texture;
  }

  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6); // init

  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending); //

  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }

  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }

  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }

    return false;
  }

  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };

  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions.get('EXT_blend_minmax');

    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }

  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };

  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled) {
        disable(3042);
        currentBlendingEnabled = false;
      }

      return;
    }

    if (!currentBlendingEnabled) {
      enable(3042);
      currentBlendingEnabled = true;
    }

    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }

        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;

            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;

            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 0, 769, 771);
              break;

            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;

            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;

            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;

            case SubtractiveBlending:
              gl.blendFunc(0, 769);
              break;

            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;

            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        }

        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }

      return;
    } // custom blending


    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;

    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }

    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }

    currentBlending = blending;
    currentPremultipledAlpha = null;
  }

  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);

    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }

    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
  } //


  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }

      currentFlipSided = flipSided;
    }
  }

  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);

      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }

    currentCullFace = cullFace;
  }

  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }

  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);

      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }

  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  } // texture


  function activeTexture(webglSlot) {
    if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;

    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }

  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }

    let boundTexture = currentBoundTextures[currentTextureSlot];

    if (boundTexture === undefined) {
      boundTexture = {
        type: undefined,
        texture: undefined
      };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }

    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }

  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];

    if (boundTexture !== undefined && boundTexture.type !== undefined) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = undefined;
      boundTexture.texture = undefined;
    }
  }

  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  } //


  function scissor(scissor) {
    if (currentScissor.equals(scissor) === false) {
      gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
      currentScissor.copy(scissor);
    }
  }

  function viewport(viewport) {
    if (currentViewport.equals(viewport) === false) {
      gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
      currentViewport.copy(viewport);
    }
  } //


  function reset() {
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentProgram = null;
    currentBlending = null;
    currentFlipSided = null;
    currentCullFace = null;
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }

  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable: enable,
    disable: disable,
    useProgram: useProgram,
    setBlending: setBlending,
    setMaterial: setMaterial,
    setFlipSided: setFlipSided,
    setCullFace: setCullFace,
    setLineWidth: setLineWidth,
    setPolygonOffset: setPolygonOffset,
    setScissorTest: setScissorTest,
    activeTexture: activeTexture,
    bindTexture: bindTexture,
    unbindTexture: unbindTexture,
    compressedTexImage2D: compressedTexImage2D,
    texImage2D: texImage2D,
    texImage3D: texImage3D,
    scissor: scissor,
    viewport: viewport,
    reset: reset
  };
}

function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;

  const _videoTextures = new WeakMap();

  let _canvas; // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
  // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
  // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).


  let useOffscreenCanvas = false;

  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {// Ignore any errors
  }

  function createCanvas(width, height) {
    // Use OffscreenCanvas when available. Specially needed in web workers
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
  }

  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1; // handle case if texture exceeds max size

    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    } // only perform resize if necessary


    if (scale < 1 || needsPowerOfTwo === true) {
      // only perform resize for certain image types
      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas

        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, width, height);
        console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
        return canvas;
      } else {
        if ('data' in image) {
          console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
        }

        return image;
      }
    }

    return image;
  }

  function isPowerOfTwo(image) {
    return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
  }

  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2) return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }

  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }

  function generateMipmap(target, texture, width, height) {
    _gl.generateMipmap(target);

    const textureProperties = properties.get(texture); // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11

    textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
  }

  function getInternalFormat(internalFormatName, glFormat, glType) {
    if (isWebGL2 === false) return glFormat;

    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
      console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
    }

    let internalFormat = glFormat;

    if (glFormat === 6403) {
      if (glType === 5126) internalFormat = 33326;
      if (glType === 5131) internalFormat = 33325;
      if (glType === 5121) internalFormat = 33321;
    }

    if (glFormat === 6407) {
      if (glType === 5126) internalFormat = 34837;
      if (glType === 5131) internalFormat = 34843;
      if (glType === 5121) internalFormat = 32849;
    }

    if (glFormat === 6408) {
      if (glType === 5126) internalFormat = 34836;
      if (glType === 5131) internalFormat = 34842;
      if (glType === 5121) internalFormat = 32856;
    }

    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get('EXT_color_buffer_float');
    }

    return internalFormat;
  } // Fallback filters for non-power-of-2 textures


  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
      return 9728;
    }

    return 9729;
  } //


  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    deallocateTexture(texture);

    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }

    info.memory.textures--;
  }

  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener('dispose', onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    info.memory.textures--;
  } //


  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === undefined) return;

    _gl.deleteTexture(textureProperties.__webglTexture);

    properties.remove(texture);
  }

  function deallocateRenderTarget(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(renderTarget.texture);
    if (!renderTarget) return;

    if (textureProperties.__webglTexture !== undefined) {
      _gl.deleteTexture(textureProperties.__webglTexture);
    }

    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }

    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);

        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);

      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }

    properties.remove(renderTarget.texture);
    properties.remove(renderTarget);
  } //


  let textureUnits = 0;

  function resetTextureUnits() {
    textureUnits = 0;
  }

  function allocateTextureUnit() {
    const textureUnit = textureUnits;

    if (textureUnit >= maxTextures) {
      console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
    }

    textureUnits += 1;
    return textureUnit;
  } //


  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;

      if (image === undefined) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
      } else if (image.complete === false) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }

  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }

  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }

  function setTextureCube(texture, slot) {
    if (texture.image.length !== 6) return;
    const textureProperties = properties.get(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      initTexture(textureProperties, texture);
      state.activeTexture(33984 + slot);
      state.bindTexture(34067, textureProperties.__webglTexture);

      _gl.pixelStorei(37440, texture.flipY);

      const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];

      for (let i = 0; i < 6; i++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
        } else {
          cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
        }
      }

      const image = cubeImage[0],
            supportsMips = isPowerOfTwo(image) || isWebGL2,
            glFormat = utils.convert(texture.format),
            glType = utils.convert(texture.type),
            glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
      setTextureParameters(34067, texture, supportsMips);
      let mipmaps;

      if (isCompressed) {
        for (let i = 0; i < 6; i++) {
          mipmaps = cubeImage[i].mipmaps;

          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];

            if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
              if (glFormat !== null) {
                state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              } else {
                console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
              }
            } else {
              state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        }

        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        mipmaps = texture.mipmaps;

        for (let i = 0; i < 6; i++) {
          if (isDataTexture) {
            state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);

            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              const mipmapImage = mipmap.image[i].image;
              state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
            }
          } else {
            state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);

            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
            }
          }
        }

        textureProperties.__maxMipLevel = mipmaps.length;
      }

      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        // We assume images for cube map have the same size.
        generateMipmap(34067, texture, image.width, image.height);
      }

      textureProperties.__version = texture.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    } else {
      state.activeTexture(33984 + slot);
      state.bindTexture(34067, textureProperties.__webglTexture);
    }
  }

  function setTextureCubeDynamic(texture, slot) {
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, properties.get(texture).__webglTexture);
  }

  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };

  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);

      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);

      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }

      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);

      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);

      _gl.texParameteri(textureType, 10243, 33071);

      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }

      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
      }

      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));

      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));

      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
      }
    }

    const extension = extensions.get('EXT_texture_filter_anisotropic');

    if (extension) {
      if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
      if (texture.type === HalfFloatType && (isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null) return;

      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));

        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }

  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === undefined) {
      textureProperties.__webglInit = true;
      texture.addEventListener('dispose', onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }

  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataTexture2DArray) textureType = 35866;
    if (texture.isDataTexture3D) textureType = 32879;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);

    _gl.pixelStorei(37440, texture.flipY);

    _gl.pixelStorei(37441, texture.premultiplyAlpha);

    _gl.pixelStorei(3317, texture.unpackAlignment);

    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
    const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
    const supportsMips = isPowerOfTwo(image) || isWebGL2,
          glFormat = utils.convert(texture.format);
    let glType = utils.convert(texture.type),
        glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(textureType, texture, supportsMips);
    let mipmap;
    const mipmaps = texture.mipmaps;

    if (texture.isDepthTexture) {
      // populate depth texture with dummy data
      glInternalFormat = 6402;

      if (isWebGL2) {
        if (texture.type === FloatType) {
          glInternalFormat = 36012;
        } else if (texture.type === UnsignedIntType) {
          glInternalFormat = 33190;
        } else if (texture.type === UnsignedInt248Type) {
          glInternalFormat = 35056;
        } else {
          glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D
        }
      } else {
        if (texture.type === FloatType) {
          console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
        }
      } // validation checks for WebGL 1


      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
        // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
          texture.type = UnsignedShortType;
          glType = utils.convert(texture.type);
        }
      }

      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
        // Depth stencil textures need the DEPTH_STENCIL internal format
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
        glInternalFormat = 34041; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
        // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)

        if (texture.type !== UnsignedInt248Type) {
          console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
          texture.type = UnsignedInt248Type;
          glType = utils.convert(texture.type);
        }
      } //


      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels
      if (mipmaps.length > 0 && supportsMips) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }

        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (let i = 0, il = mipmaps.length; i < il; i++) {
        mipmap = mipmaps[i];

        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (glFormat !== null) {
            state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
          }
        } else {
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }

      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      // regular Texture (image, video, canvas)
      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels
      if (mipmaps.length > 0 && supportsMips) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
        }

        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
        textureProperties.__maxMipLevel = 0;
      }
    }

    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(textureType, texture, image.width, image.height);
    }

    textureProperties.__version = texture.version;
    if (texture.onUpdate) texture.onUpdate(texture);
  } // Render targets
  // Setup storage for target texture and bind it to correct framebuffer


  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    const glFormat = utils.convert(renderTarget.texture.format);
    const glType = utils.convert(renderTarget.texture.type);
    const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
    state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);

    _gl.bindFramebuffer(36160, framebuffer);

    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);

    _gl.bindFramebuffer(36160, null);
  } // Setup storage for internal depth/stencil buffers and bind to correct framebuffer


  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);

    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;

      if (isMultisample) {
        const depthTexture = renderTarget.depthTexture;

        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }

        const samples = getRenderTargetSamples(renderTarget);

        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }

      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);

        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }

      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const glFormat = utils.convert(renderTarget.texture.format);
      const glType = utils.convert(renderTarget.texture.type);
      const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);

      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);

        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }

    _gl.bindRenderbuffer(36161, null);
  } // Setup resources for a Depth Texture for a FBO (needs an extension)


  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube) throw new Error('Depth Texture with cube render targets is not supported');

    _gl.bindFramebuffer(36160, framebuffer);

    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
    } // upload an empty depth texture with framebuffer size


    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }

    setTexture2D(renderTarget.depthTexture, 0);

    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
    } else {
      throw new Error('Unknown depthTexture format');
    }
  } // Setup GL resources for a non-texture depth buffer


  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;

    if (renderTarget.depthTexture) {
      if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];

        for (let i = 0; i < 6; i++) {
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);

          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
        }
      } else {
        _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);

        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }

    _gl.bindFramebuffer(36160, null);
  } // Set up GL resources for the render target


  function setupRenderTarget(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(renderTarget.texture);
    renderTarget.addEventListener('dispose', onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    info.memory.textures++;
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2; // Handles WebGL2 RGBFormat fallback - #18858

    if (isWebGL2 && renderTarget.texture.format === RGBFormat && (renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType)) {
      renderTarget.texture.format = RGBAFormat;
      console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');
    } // Setup framebuffer


    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];

      for (let i = 0; i < 6; i++) {
        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

      if (isMultisample) {
        if (isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);

          const glFormat = utils.convert(renderTarget.texture.format);
          const glType = utils.convert(renderTarget.texture.type);
          const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
          const samples = getRenderTargetSamples(renderTarget);

          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);

          _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);

          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);

          _gl.bindRenderbuffer(36161, null);

          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }

          _gl.bindFramebuffer(36160, null);
        } else {
          console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
        }
      }
    } // Setup color buffer


    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, renderTarget.texture, supportsMips);

      for (let i = 0; i < 6; i++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);
      }

      if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
        generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
      }

      state.bindTexture(34067, null);
    } else {
      state.bindTexture(3553, textureProperties.__webglTexture);
      setTextureParameters(3553, renderTarget.texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);

      if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
        generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
      }

      state.bindTexture(3553, null);
    } // Setup depth and stencil buffers


    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }

  function updateRenderTargetMipmap(renderTarget) {
    const texture = renderTarget.texture;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;

    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;

      const webglTexture = properties.get(texture).__webglTexture;

      state.bindTexture(target, webglTexture);
      generateMipmap(target, texture, renderTarget.width, renderTarget.height);
      state.bindTexture(target, null);
    }
  }

  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (isWebGL2) {
        const renderTargetProperties = properties.get(renderTarget);

        _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);

        _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);

        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = 16384;
        if (renderTarget.depthBuffer) mask |= 256;
        if (renderTarget.stencilBuffer) mask |= 1024;

        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);

        _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer); // see #18905

      } else {
        console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
      }
    }
  }

  function getRenderTargetSamples(renderTarget) {
    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
  }

  function updateVideoTexture(texture) {
    const frame = info.render.frame; // Check the last frame we updated the VideoTexture

    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);

      texture.update();
    }
  } // backwards compatibility


  let warnedTexture2D = false;
  let warnedTextureCube = false;

  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
        warnedTexture2D = true;
      }

      texture = texture.texture;
    }

    setTexture2D(texture, slot);
  }

  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLCubeRenderTarget) {
      if (warnedTextureCube === false) {
        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
        warnedTextureCube = true;
      }

      texture = texture.texture;
    } // currently relying on the fact that WebGLCubeRenderTarget.texture is a Texture and NOT a CubeTexture
    // TODO: unify these code paths


    if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
      // CompressedTexture can have Array in image :/
      // this function alone should take care of cube textures
      setTextureCube(texture, slot);
    } else {
      // assumed: texture property of THREE.WebGLCubeRenderTarget
      setTextureCubeDynamic(texture, slot);
    }
  } //


  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setTextureCubeDynamic = setTextureCubeDynamic;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}

function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;

  function convert(p) {
    let extension;
    if (p === UnsignedByteType) return 5121;
    if (p === UnsignedShort4444Type) return 32819;
    if (p === UnsignedShort5551Type) return 32820;
    if (p === UnsignedShort565Type) return 33635;
    if (p === ByteType) return 5120;
    if (p === ShortType) return 5122;
    if (p === UnsignedShortType) return 5123;
    if (p === IntType) return 5124;
    if (p === UnsignedIntType) return 5125;
    if (p === FloatType) return 5126;

    if (p === HalfFloatType) {
      if (isWebGL2) return 5131;
      extension = extensions.get('OES_texture_half_float');

      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }

    if (p === AlphaFormat) return 6406;
    if (p === RGBFormat) return 6407;
    if (p === RGBAFormat) return 6408;
    if (p === LuminanceFormat) return 6409;
    if (p === LuminanceAlphaFormat) return 6410;
    if (p === DepthFormat) return 6402;
    if (p === DepthStencilFormat) return 34041;
    if (p === RedFormat) return 6403; // WebGL2 formats.

    if (p === RedIntegerFormat) return 36244;
    if (p === RGFormat) return 33319;
    if (p === RGIntegerFormat) return 33320;
    if (p === RGBIntegerFormat) return 36248;
    if (p === RGBAIntegerFormat) return 36249;

    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get('WEBGL_compressed_texture_s3tc');

      if (extension !== null) {
        if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    }

    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get('WEBGL_compressed_texture_pvrtc');

      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }

    if (p === RGB_ETC1_Format) {
      extension = extensions.get('WEBGL_compressed_texture_etc1');

      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }

    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get('WEBGL_compressed_texture_etc');

      if (extension !== null) {
        if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
      }
    }

    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
      extension = extensions.get('WEBGL_compressed_texture_astc');

      if (extension !== null) {
        // TODO Complete?
        return p;
      } else {
        return null;
      }
    }

    if (p === RGBA_BPTC_Format) {
      extension = extensions.get('EXT_texture_compression_bptc');

      if (extension !== null) {
        // TODO Complete?
        return p;
      } else {
        return null;
      }
    }

    if (p === UnsignedInt248Type) {
      if (isWebGL2) return 34042;
      extension = extensions.get('WEBGL_depth_texture');

      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }

  return {
    convert: convert
  };
}

function ArrayCamera(array) {
  PerspectiveCamera.call(this);
  this.cameras = array || [];
}

ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
  constructor: ArrayCamera,
  isArrayCamera: true
});

function Group() {
  Object3D.call(this);
  this.type = 'Group';
}

Group.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Group,
  isGroup: true
});

function WebXRController() {
  this._targetRay = null;
  this._grip = null;
  this._hand = null;
}

Object.assign(WebXRController.prototype, {
  constructor: WebXRController,
  getHandSpace: function () {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = [];
      this._hand.inputState = {
        pinching: false
      };

      if (window.XRHand) {
        for (let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i++) {
          // The transform of this joint will be updated with the joint pose on each frame
          const joint = new Group();
          joint.matrixAutoUpdate = false;
          joint.visible = false;

          this._hand.joints.push(joint); // ??


          this._hand.add(joint);
        }
      }
    }

    return this._hand;
  },
  getTargetRaySpace: function () {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
    }

    return this._targetRay;
  },
  getGripSpace: function () {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
    }

    return this._grip;
  },
  dispatchEvent: function (event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }

    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }

    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }

    return this;
  },
  disconnect: function (inputSource) {
    this.dispatchEvent({
      type: 'disconnected',
      data: inputSource
    });

    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }

    if (this._grip !== null) {
      this._grip.visible = false;
    }

    if (this._hand !== null) {
      this._hand.visible = false;
    }

    return this;
  },
  update: function (inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;

    if (inputSource) {
      if (hand && inputSource.hand) {
        handPose = true;

        for (let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i++) {
          if (inputSource.hand[i]) {
            // Update the joints groups with the XRJoint poses
            const jointPose = frame.getJointPose(inputSource.hand[i], referenceSpace);
            const joint = hand.joints[i];

            if (jointPose !== null) {
              joint.matrix.fromArray(jointPose.transform.matrix);
              joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
              joint.jointRadius = jointPose.radius;
            }

            joint.visible = jointPose !== null; // Custom events
            // Check pinch

            const indexTip = hand.joints[window.XRHand.INDEX_PHALANX_TIP];
            const thumbTip = hand.joints[window.XRHand.THUMB_PHALANX_TIP];
            const distance = indexTip.position.distanceTo(thumbTip.position);
            const distanceToPinch = 0.02;
            const threshold = 0.005;

            if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
              hand.inputState.pinching = false;
              this.dispatchEvent({
                type: "pinchend",
                handedness: inputSource.handedness,
                target: this
              });
            } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
              hand.inputState.pinching = true;
              this.dispatchEvent({
                type: "pinchstart",
                handedness: inputSource.handedness,
                target: this
              });
            }
          }
        }
      } else {
        if (targetRay !== null) {
          inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

          if (inputPose !== null) {
            targetRay.matrix.fromArray(inputPose.transform.matrix);
            targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          }
        }

        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);

          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
          }
        }
      }
    }

    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }

    if (grip !== null) {
      grip.visible = gripPose !== null;
    }

    if (hand !== null) {
      hand.visible = handPose !== null;
    }

    return this;
  }
});

function WebXRManager(renderer, gl) {
  const scope = this;
  let session = null;
  let framebufferScaleFactor = 1.0;
  let referenceSpace = null;
  let referenceSpaceType = 'local-floor';
  let pose = null;
  const controllers = [];
  const inputSourcesMap = new Map(); //

  const cameraL = new PerspectiveCamera();
  cameraL.layers.enable(1);
  cameraL.viewport = new Vector4();
  const cameraR = new PerspectiveCamera();
  cameraR.layers.enable(2);
  cameraR.viewport = new Vector4();
  const cameras = [cameraL, cameraR];
  const cameraVR = new ArrayCamera();
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2);
  let _currentDepthNear = null;
  let _currentDepthFar = null; //

  this.enabled = false;
  this.isPresenting = false;

  this.getController = function (index) {
    let controller = controllers[index];

    if (controller === undefined) {
      controller = new WebXRController();
      controllers[index] = controller;
    }

    return controller.getTargetRaySpace();
  };

  this.getControllerGrip = function (index) {
    let controller = controllers[index];

    if (controller === undefined) {
      controller = new WebXRController();
      controllers[index] = controller;
    }

    return controller.getGripSpace();
  };

  this.getHand = function (index) {
    let controller = controllers[index];

    if (controller === undefined) {
      controller = new WebXRController();
      controllers[index] = controller;
    }

    return controller.getHandSpace();
  }; //


  function onSessionEvent(event) {
    const controller = inputSourcesMap.get(event.inputSource);

    if (controller) {
      controller.dispatchEvent({
        type: event.type
      });
    }
  }

  function onSessionEnd() {
    inputSourcesMap.forEach(function (controller, inputSource) {
      controller.disconnect(inputSource);
    });
    inputSourcesMap.clear(); //

    renderer.setFramebuffer(null);
    renderer.setRenderTarget(renderer.getRenderTarget()); // Hack #15830

    animation.stop();
    scope.isPresenting = false;
    scope.dispatchEvent({
      type: 'sessionend'
    });
  }

  function onRequestReferenceSpace(value) {
    referenceSpace = value;
    animation.setContext(session);
    animation.start();
    scope.isPresenting = true;
    scope.dispatchEvent({
      type: 'sessionstart'
    });
  }

  this.setFramebufferScaleFactor = function (value) {
    framebufferScaleFactor = value;

    if (scope.isPresenting === true) {
      console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
    }
  };

  this.setReferenceSpaceType = function (value) {
    referenceSpaceType = value;

    if (scope.isPresenting === true) {
      console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
    }
  };

  this.getReferenceSpace = function () {
    return referenceSpace;
  };

  this.getSession = function () {
    return session;
  };

  this.setSession = function (value) {
    session = value;

    if (session !== null) {
      session.addEventListener('select', onSessionEvent);
      session.addEventListener('selectstart', onSessionEvent);
      session.addEventListener('selectend', onSessionEvent);
      session.addEventListener('squeeze', onSessionEvent);
      session.addEventListener('squeezestart', onSessionEvent);
      session.addEventListener('squeezeend', onSessionEvent);
      session.addEventListener('end', onSessionEnd);
      const attributes = gl.getContextAttributes();

      if (attributes.xrCompatible !== true) {
        gl.makeXRCompatible();
      }

      const layerInit = {
        antialias: attributes.antialias,
        alpha: attributes.alpha,
        depth: attributes.depth,
        stencil: attributes.stencil,
        framebufferScaleFactor: framebufferScaleFactor
      }; // eslint-disable-next-line no-undef

      const baseLayer = new XRWebGLLayer(session, gl, layerInit);
      session.updateRenderState({
        baseLayer: baseLayer
      });
      session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace); //

      session.addEventListener('inputsourceschange', updateInputSources);
    }
  };

  function updateInputSources(event) {
    const inputSources = session.inputSources; // Assign inputSources to available controllers

    for (let i = 0; i < controllers.length; i++) {
      inputSourcesMap.set(inputSources[i], controllers[i]);
    } // Notify disconnected


    for (let i = 0; i < event.removed.length; i++) {
      const inputSource = event.removed[i];
      const controller = inputSourcesMap.get(inputSource);

      if (controller) {
        controller.dispatchEvent({
          type: 'disconnected',
          data: inputSource
        });
        inputSourcesMap.delete(inputSource);
      }
    } // Notify connected


    for (let i = 0; i < event.added.length; i++) {
      const inputSource = event.added[i];
      const controller = inputSourcesMap.get(inputSource);

      if (controller) {
        controller.dispatchEvent({
          type: 'connected',
          data: inputSource
        });
      }
    }
  } //


  const cameraLPos = new Vector3();
  const cameraRPos = new Vector3();
  /**
   * Assumes 2 cameras that are parallel and share an X-axis, and that
   * the cameras' projection and world matrices have already been set.
   * And that near and far planes are identical for both cameras.
   * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
   */

  function setProjectionFromUnion(camera, cameraL, cameraR) {
    cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
    cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
    const ipd = cameraLPos.distanceTo(cameraRPos);
    const projL = cameraL.projectionMatrix.elements;
    const projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and
    // most likely identical top and bottom frustum extents.
    // Use the left camera for these values.

    const near = projL[14] / (projL[10] - 1);
    const far = projL[14] / (projL[10] + 1);
    const topFov = (projL[9] + 1) / projL[5];
    const bottomFov = (projL[9] - 1) / projL[5];
    const leftFov = (projL[8] - 1) / projL[0];
    const rightFov = (projR[8] + 1) / projR[0];
    const left = near * leftFov;
    const right = near * rightFov; // Calculate the new camera's position offset from the
    // left camera. xOffset should be roughly half `ipd`.

    const zOffset = ipd / (-leftFov + rightFov);
    const xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?

    cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
    camera.translateX(xOffset);
    camera.translateZ(zOffset);
    camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
    camera.matrixWorldInverse.getInverse(camera.matrixWorld); // Find the union of the frustum values of the cameras and scale
    // the values so that the near plane's position does not change in world space,
    // although must now be relative to the new union camera.

    const near2 = near + zOffset;
    const far2 = far + zOffset;
    const left2 = left - xOffset;
    const right2 = right + (ipd - xOffset);
    const top2 = topFov * far / far2 * near2;
    const bottom2 = bottomFov * far / far2 * near2;
    camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
  }

  function updateCamera(camera, parent) {
    if (parent === null) {
      camera.matrixWorld.copy(camera.matrix);
    } else {
      camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
    }

    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
  }

  this.getCamera = function (camera) {
    cameraVR.near = cameraR.near = cameraL.near = camera.near;
    cameraVR.far = cameraR.far = cameraL.far = camera.far;

    if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
      // Note that the new renderState won't apply until the next frame. See #18320
      session.updateRenderState({
        depthNear: cameraVR.near,
        depthFar: cameraVR.far
      });
      _currentDepthNear = cameraVR.near;
      _currentDepthFar = cameraVR.far;
    }

    const parent = camera.parent;
    const cameras = cameraVR.cameras;
    updateCamera(cameraVR, parent);

    for (let i = 0; i < cameras.length; i++) {
      updateCamera(cameras[i], parent);
    } // update camera and its children


    camera.matrixWorld.copy(cameraVR.matrixWorld);
    const children = camera.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(true);
    } // update projection matrix for proper view frustum culling


    if (cameras.length === 2) {
      setProjectionFromUnion(cameraVR, cameraL, cameraR);
    } else {
      // assume single camera setup (AR)
      cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
    }

    return cameraVR;
  }; // Animation Loop


  let onAnimationFrameCallback = null;

  function onAnimationFrame(time, frame) {
    pose = frame.getViewerPose(referenceSpace);

    if (pose !== null) {
      const views = pose.views;
      const baseLayer = session.renderState.baseLayer;
      renderer.setFramebuffer(baseLayer.framebuffer);
      let cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list

      if (views.length !== cameraVR.cameras.length) {
        cameraVR.cameras.length = 0;
        cameraVRNeedsUpdate = true;
      }

      for (let i = 0; i < views.length; i++) {
        const view = views[i];
        const viewport = baseLayer.getViewport(view);
        const camera = cameras[i];
        camera.matrix.fromArray(view.transform.matrix);
        camera.projectionMatrix.fromArray(view.projectionMatrix);
        camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

        if (i === 0) {
          cameraVR.matrix.copy(camera.matrix);
        }

        if (cameraVRNeedsUpdate === true) {
          cameraVR.cameras.push(camera);
        }
      }
    } //


    const inputSources = session.inputSources;

    for (let i = 0; i < controllers.length; i++) {
      const controller = controllers[i];
      const inputSource = inputSources[i];
      controller.update(inputSource, frame, referenceSpace);
    }

    if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
  }

  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);

  this.setAnimationLoop = function (callback) {
    onAnimationFrameCallback = callback;
  };

  this.dispose = function () {};
}

Object.assign(WebXRManager.prototype, EventDispatcher.prototype);

function WebGLMaterials(properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);

    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }

  function refreshMaterialUniforms(uniforms, material, pixelRatio, height) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsLambert(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);

      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material);
      } else {
        refreshUniformsStandard(uniforms, material);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDepth(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsNormal(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);

      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false; // #15581
    }
  }

  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;

    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }

    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }

    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }

    const envMap = properties.get(material).envMap;

    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;

      const maxMipLevel = properties.get(envMap).__maxMipLevel;

      if (maxMipLevel !== undefined) {
        uniforms.maxMipLevel.value = maxMipLevel;
      }
    }

    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }

    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. specular map
    // 3. displacementMap map
    // 4. normal map
    // 5. bump map
    // 6. roughnessMap map
    // 7. metalnessMap map
    // 8. alphaMap map
    // 9. emissiveMap map
    // 10. clearcoat map
    // 11. clearcoat normal map
    // 12. clearcoat roughnessMap map


    let uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    }

    if (uvScaleMap !== undefined) {
      // backwards compatibility
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }

      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    } // uv repeat and offset setting priorities for uv2
    // 1. ao map
    // 2. light map


    let uv2ScaleMap;

    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }

    if (uv2ScaleMap !== undefined) {
      // backwards compatibility
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }

      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }

      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }

  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }

  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }

  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. alpha map


    let uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }

    if (uvScaleMap !== undefined) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }

  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. alpha map


    let uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }

    if (uvScaleMap !== undefined) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }

  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }

  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;

    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }

    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }

    const envMap = properties.get(material).envMap;

    if (envMap) {
      //uniforms.envMap.value = material.envMap; // part of uniforms common
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }

  function refreshUniformsPhysical(uniforms, material) {
    refreshUniformsStandard(uniforms, material);
    uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

    uniforms.clearcoat.value = material.clearcoat;
    uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
    if (material.sheen) uniforms.sheen.value.copy(material.sheen);

    if (material.clearcoatMap) {
      uniforms.clearcoatMap.value = material.clearcoatMap;
    }

    if (material.clearcoatRoughnessMap) {
      uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
    }

    if (material.clearcoatNormalMap) {
      uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
      uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

      if (material.side === BackSide) {
        uniforms.clearcoatNormalScale.value.negate();
      }
    }

    uniforms.transmission.value = material.transmission;

    if (material.transmissionMap) {
      uniforms.transmissionMap.value = material.transmissionMap;
    }
  }

  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }

    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }

  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  return {
    refreshFogUniforms: refreshFogUniforms,
    refreshMaterialUniforms: refreshMaterialUniforms
  };
}

function WebGLRenderer(parameters) {
  parameters = parameters || {};

  const _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
        _context = parameters.context !== undefined ? parameters.context : null,
        _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
        _depth = parameters.depth !== undefined ? parameters.depth : true,
        _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
        _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
        _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
        _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
        _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
        _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

  let currentRenderList = null;
  let currentRenderState = null; // public properties

  this.domElement = _canvas; // Debug configuration container

  this.debug = {
    /**
     * Enables error checking and reporting when shader programs are being compiled
     * @type {boolean}
     */
    checkShaderErrors: true
  }; // clearing

  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true; // scene graph

  this.sortObjects = true; // user-defined clipping

  this.clippingPlanes = [];
  this.localClippingEnabled = false; // physically based shading

  this.gammaFactor = 2.0; // for backwards compatibility

  this.outputEncoding = LinearEncoding; // physical lights

  this.physicallyCorrectLights = false; // tone mapping

  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1.0; // morphs

  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4; // internal properties

  const _this = this;

  let _isContextLost = false; // internal state cache

  let _framebuffer = null;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentFramebuffer = null;

  let _currentMaterialId = -1;

  let _currentCamera = null;
  let _currentArrayCamera = null;

  const _currentViewport = new Vector4();

  const _currentScissor = new Vector4();

  let _currentScissorTest = null; //

  let _width = _canvas.width;
  let _height = _canvas.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;

  const _viewport = new Vector4(0, 0, _width, _height);

  const _scissor = new Vector4(0, 0, _width, _height);

  let _scissorTest = false; // frustum

  const _frustum = new Frustum(); // clipping


  let _clippingEnabled = false;
  let _localClippingEnabled = false; // camera matrices cache

  const _projScreenMatrix = new Matrix4();

  const _vector3 = new Vector3();

  const _emptyScene = {
    background: null,
    fog: null,
    environment: null,
    overrideMaterial: null,
    isScene: true
  };

  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  } // initialize


  let _gl = _context;

  function getContext(contextNames, contextAttributes) {
    for (let i = 0; i < contextNames.length; i++) {
      const contextName = contextNames[i];

      const context = _canvas.getContext(contextName, contextAttributes);

      if (context !== null) return context;
    }

    return null;
  }

  try {
    const contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    }; // event listeners must be registered before WebGL context is created, see #12753

    _canvas.addEventListener('webglcontextlost', onContextLost, false);

    _canvas.addEventListener('webglcontextrestored', onContextRestore, false);

    if (_gl === null) {
      const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];

      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }

      _gl = getContext(contextNames, contextAttributes);

      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error('Error creating WebGL context with your selected attributes.');
        } else {
          throw new Error('Error creating WebGL context.');
        }
      }
    } // Some experimental-webgl implementations do not have getShaderPrecisionFormat


    if (_gl.getShaderPrecisionFormat === undefined) {
      _gl.getShaderPrecisionFormat = function () {
        return {
          'rangeMin': 1,
          'rangeMax': 1,
          'precision': 1
        };
      };
    }
  } catch (error) {
    console.error('THREE.WebGLRenderer: ' + error.message);
    throw error;
  }

  let extensions, capabilities, state, info;
  let properties, textures, cubemaps, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates, clipping;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils, bindingStates;

  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);

    if (capabilities.isWebGL2 === false) {
      extensions.get('WEBGL_depth_texture');
      extensions.get('OES_texture_float');
      extensions.get('OES_texture_half_float');
      extensions.get('OES_texture_half_float_linear');
      extensions.get('OES_standard_derivatives');
      extensions.get('OES_element_index_uint');
      extensions.get('OES_vertex_array_object');
      extensions.get('ANGLE_instanced_arrays');
    }

    extensions.get('OES_texture_float_linear');
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    cubemaps = new WebGLCubeMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(properties);
    renderLists = new WebGLRenderLists(properties);
    renderStates = new WebGLRenderStates();
    background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.state = state;
    _this.info = info;
  }

  initGLContext(); // xr

  const xr = new WebXRManager(_this, _gl);
  this.xr = xr; // shadow map

  const shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
  this.shadowMap = shadowMap; // API

  this.getContext = function () {
    return _gl;
  };

  this.getContextAttributes = function () {
    return _gl.getContextAttributes();
  };

  this.forceContextLoss = function () {
    const extension = extensions.get('WEBGL_lose_context');
    if (extension) extension.loseContext();
  };

  this.forceContextRestore = function () {
    const extension = extensions.get('WEBGL_lose_context');
    if (extension) extension.restoreContext();
  };

  this.getPixelRatio = function () {
    return _pixelRatio;
  };

  this.setPixelRatio = function (value) {
    if (value === undefined) return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };

  this.getSize = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');
      target = new Vector2();
    }

    return target.set(_width, _height);
  };

  this.setSize = function (width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
      return;
    }

    _width = width;
    _height = height;
    _canvas.width = Math.floor(width * _pixelRatio);
    _canvas.height = Math.floor(height * _pixelRatio);

    if (updateStyle !== false) {
      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';
    }

    this.setViewport(0, 0, width, height);
  };

  this.getDrawingBufferSize = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');
      target = new Vector2();
    }

    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };

  this.setDrawingBufferSize = function (width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas.width = Math.floor(width * pixelRatio);
    _canvas.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };

  this.getCurrentViewport = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');
      target = new Vector4();
    }

    return target.copy(_currentViewport);
  };

  this.getViewport = function (target) {
    return target.copy(_viewport);
  };

  this.setViewport = function (x, y, width, height) {
    if (x.isVector4) {
      _viewport.set(x.x, x.y, x.z, x.w);
    } else {
      _viewport.set(x, y, width, height);
    }

    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };

  this.getScissor = function (target) {
    return target.copy(_scissor);
  };

  this.setScissor = function (x, y, width, height) {
    if (x.isVector4) {
      _scissor.set(x.x, x.y, x.z, x.w);
    } else {
      _scissor.set(x, y, width, height);
    }

    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };

  this.getScissorTest = function () {
    return _scissorTest;
  };

  this.setScissorTest = function (boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };

  this.setOpaqueSort = function (method) {
    _opaqueSort = method;
  };

  this.setTransparentSort = function (method) {
    _transparentSort = method;
  }; // Clearing


  this.getClearColor = function () {
    return background.getClearColor();
  };

  this.setClearColor = function () {
    background.setClearColor.apply(background, arguments);
  };

  this.getClearAlpha = function () {
    return background.getClearAlpha();
  };

  this.setClearAlpha = function () {
    background.setClearAlpha.apply(background, arguments);
  };

  this.clear = function (color, depth, stencil) {
    let bits = 0;
    if (color === undefined || color) bits |= 16384;
    if (depth === undefined || depth) bits |= 256;
    if (stencil === undefined || stencil) bits |= 1024;

    _gl.clear(bits);
  };

  this.clearColor = function () {
    this.clear(true, false, false);
  };

  this.clearDepth = function () {
    this.clear(false, true, false);
  };

  this.clearStencil = function () {
    this.clear(false, false, true);
  }; //


  this.dispose = function () {
    _canvas.removeEventListener('webglcontextlost', onContextLost, false);

    _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    xr.dispose();
    animation.stop();
  }; // Events


  function onContextLost(event) {
    event.preventDefault();
    console.log('THREE.WebGLRenderer: Context Lost.');
    _isContextLost = true;
  }

  function onContextRestore()
  /* event */
  {
    console.log('THREE.WebGLRenderer: Context Restored.');
    _isContextLost = false;
    initGLContext();
  }

  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener('dispose', onMaterialDispose);
    deallocateMaterial(material);
  } // Buffer deallocation


  function deallocateMaterial(material) {
    releaseMaterialProgramReference(material);
    properties.remove(material);
  }

  function releaseMaterialProgramReference(material) {
    const programInfo = properties.get(material).program;

    if (programInfo !== undefined) {
      programCache.releaseProgram(programInfo);
    }
  } // Buffer rendering


  function renderObjectImmediate(object, program) {
    object.render(function (object) {
      _this.renderBufferImmediate(object, program);
    });
  }

  this.renderBufferImmediate = function (object, program) {
    bindingStates.initAttributes();
    const buffers = properties.get(object);
    if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
    const programAttributes = program.getAttributes();

    if (object.hasPositions) {
      _gl.bindBuffer(34962, buffers.position);

      _gl.bufferData(34962, object.positionArray, 35048);

      bindingStates.enableAttribute(programAttributes.position);

      _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
    }

    if (object.hasNormals) {
      _gl.bindBuffer(34962, buffers.normal);

      _gl.bufferData(34962, object.normalArray, 35048);

      bindingStates.enableAttribute(programAttributes.normal);

      _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
    }

    if (object.hasUvs) {
      _gl.bindBuffer(34962, buffers.uv);

      _gl.bufferData(34962, object.uvArray, 35048);

      bindingStates.enableAttribute(programAttributes.uv);

      _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
    }

    if (object.hasColors) {
      _gl.bindBuffer(34962, buffers.color);

      _gl.bufferData(34962, object.colorArray, 35048);

      bindingStates.enableAttribute(programAttributes.color);

      _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
    }

    bindingStates.disableUnusedAttributes();

    _gl.drawArrays(4, 0, object.count);

    object.count = 0;
  };

  this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
    if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    const program = setProgram(camera, scene, material, object);
    state.setMaterial(material, frontFaceCW); //

    let index = geometry.index;
    const position = geometry.attributes.position; //

    if (index === null) {
      if (position === undefined || position.count === 0) return;
    } else if (index.count === 0) {
      return;
    } //


    let rangeFactor = 1;

    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }

    if (material.morphTargets || material.morphNormals) {
      morphtargets.update(object, geometry, material, program);
    }

    bindingStates.setup(object, material, program, geometry, index);
    let attribute;
    let renderer = bufferRenderer;

    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    } //


    const dataCount = index !== null ? index.count : position.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0) return; //

    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        renderer.setMode(4);
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

      state.setLineWidth(lineWidth * getTargetPixelRatio());

      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }

    if (object.isInstancedMesh) {
      renderer.renderInstances(drawStart, drawCount, object.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  }; // Compile


  this.compile = function (scene, camera) {
    currentRenderState = renderStates.get(scene, camera);
    currentRenderState.init();
    scene.traverse(function (object) {
      if (object.isLight) {
        currentRenderState.pushLight(object);

        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights(camera);
    const compiled = new WeakMap();
    scene.traverse(function (object) {
      const material = object.material;

      if (material) {
        if (Array.isArray(material)) {
          for (let i = 0; i < material.length; i++) {
            const material2 = material[i];

            if (compiled.has(material2) === false) {
              initMaterial(material2, scene, object);
              compiled.set(material2);
            }
          }
        } else if (compiled.has(material) === false) {
          initMaterial(material, scene, object);
          compiled.set(material);
        }
      }
    });
  }; // Animation Loop


  let onAnimationFrameCallback = null;

  function onAnimationFrame(time) {
    if (xr.isPresenting) return;
    if (onAnimationFrameCallback) onAnimationFrameCallback(time);
  }

  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== 'undefined') animation.setContext(window);

  this.setAnimationLoop = function (callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  }; // Rendering


  this.render = function (scene, camera) {
    let renderTarget, forceClear;

    if (arguments[2] !== undefined) {
      console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
      renderTarget = arguments[2];
    }

    if (arguments[3] !== undefined) {
      console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
      forceClear = arguments[3];
    }

    if (camera !== undefined && camera.isCamera !== true) {
      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
      return;
    }

    if (_isContextLost === true) return; // reset caching for this frame

    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null; // update scene graph

    if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum

    if (camera.parent === null) camera.updateMatrixWorld();

    if (xr.enabled === true && xr.isPresenting === true) {
      camera = xr.getCamera(camera);
    } //


    if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
    currentRenderState = renderStates.get(scene, camera);
    currentRenderState.init();

    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

    _frustum.setFromProjectionMatrix(_projScreenMatrix);

    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, camera);
    currentRenderList.init();
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();

    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    } //


    if (_clippingEnabled === true) clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    currentRenderState.setupLights(camera);
    if (_clippingEnabled === true) clipping.endShadows(); //

    if (this.info.autoReset === true) this.info.reset();

    if (renderTarget !== undefined) {
      this.setRenderTarget(renderTarget);
    } //


    background.render(currentRenderList, scene, camera, forceClear); // render scene

    const opaqueObjects = currentRenderList.opaque;
    const transparentObjects = currentRenderList.transparent;
    if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
    if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera); //

    if (scene.isScene === true) scene.onAfterRender(_this, scene, camera); //

    if (_currentRenderTarget !== null) {
      // Generate mipmap if we're using any kind of mipmap filtering
      textures.updateRenderTargetMipmap(_currentRenderTarget); // resolve multisample renderbuffers to a single-sample texture if necessary

      textures.updateMultisampleRenderTarget(_currentRenderTarget);
    } // Ensure depth buffer writing is enabled so it can be cleared on next render


    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false); // _gl.finish();

    currentRenderList = null;
    currentRenderState = null;
  };

  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera.layers);

    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true) object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);

        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }

          const geometry = objects.update(object);
          const material = object.material;

          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
        }

        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          // update skeleton only once in a frame
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }

        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }

          const geometry = objects.update(object);
          const material = object.material;

          if (Array.isArray(material)) {
            const groups = geometry.groups;

            for (let i = 0, l = groups.length; i < l; i++) {
              const group = groups[i];
              const groupMaterial = material[group.materialIndex];

              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }

    const children = object.children;

    for (let i = 0, l = children.length; i < l; i++) {
      projectObject(children[i], camera, groupOrder, sortObjects);
    }
  }

  function renderObjects(renderList, scene, camera) {
    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

    for (let i = 0, l = renderList.length; i < l; i++) {
      const renderItem = renderList[i];
      const object = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;

      if (camera.isArrayCamera) {
        _currentArrayCamera = camera;
        const cameras = camera.cameras;

        for (let j = 0, jl = cameras.length; j < jl; j++) {
          const camera2 = cameras[j];

          if (object.layers.test(camera2.layers)) {
            state.viewport(_currentViewport.copy(camera2.viewport));
            currentRenderState.setupLights(camera2);
            renderObject(object, scene, camera2, geometry, material, group);
          }
        }
      } else {
        _currentArrayCamera = null;
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }

  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

    if (object.isImmediateRenderObject) {
      const program = setProgram(camera, scene, material, object);
      state.setMaterial(material);
      bindingStates.reset();
      renderObjectImmediate(object, program);
    } else {
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
    }

    object.onAfterRender(_this, scene, camera, geometry, material, group);
    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
  }

  function initMaterial(material, scene, object) {
    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
    const programCacheKey = programCache.getProgramCacheKey(parameters);
    let program = materialProperties.program;
    let programChange = true;

    if (program === undefined) {
      // new material
      material.addEventListener('dispose', onMaterialDispose);
    } else if (program.cacheKey !== programCacheKey) {
      // changed glsl or parameters
      releaseMaterialProgramReference(material);
    } else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
      programChange = false;
    } else if (parameters.shaderID !== undefined) {
      // same glsl and uniform list, envMap still needs the update here to avoid a frame-late effect
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      materialProperties.envMap = cubemaps.get(material.envMap || environment);
      return;
    } else {
      // only rebuild uniform list
      programChange = false;
    }

    if (programChange) {
      parameters.uniforms = programCache.getUniforms(material);
      material.onBeforeCompile(parameters, _this);
      program = programCache.acquireProgram(parameters, programCacheKey);
      materialProperties.program = program;
      materialProperties.uniforms = parameters.uniforms;
      materialProperties.outputEncoding = parameters.outputEncoding;
    }

    const uniforms = materialProperties.uniforms;

    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      materialProperties.numClippingPlanes = clipping.numPlanes;
      materialProperties.numIntersection = clipping.numIntersection;
      uniforms.clippingPlanes = clipping.uniform;
    }

    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog;
    materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment); // store the light setup it was created for

    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;

    if (materialProperties.needsLights) {
      // wire up the material to this renderer's lighting state
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms
    }

    const progUniforms = materialProperties.program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.uniformsList = uniformsList;
  }

  function setProgram(camera, scene, material, object) {
    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

    textures.resetTextureUnits();
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
    const envMap = cubemaps.get(material.envMap || environment);
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;

    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup
        // object instead of the material, once it becomes feasible
        // (#8465, #8379)

        clipping.setState(material, camera, useCache);
      }
    }

    if (material.version === materialProperties.__version) {
      if (material.fog && materialProperties.fog !== fog) {
        initMaterial(material, scene, object);
      } else if (materialProperties.environment !== environment) {
        initMaterial(material, scene, object);
      } else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        initMaterial(material, scene, object);
      } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        initMaterial(material, scene, object);
      } else if (materialProperties.outputEncoding !== encoding) {
        initMaterial(material, scene, object);
      } else if (materialProperties.envMap !== envMap) {
        initMaterial(material, scene, object);
      }
    } else {
      initMaterial(material, scene, object);
      materialProperties.__version = material.version;
    }

    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const program = materialProperties.program,
          p_uniforms = program.getUniforms(),
          m_uniforms = materialProperties.uniforms;

    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }

    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }

    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
      }

      if (_currentCamera !== camera) {
        _currentCamera = camera; // lighting uniforms depend on the camera so enforce an update
        // now, in case this material supports lights - or later, when
        // the next material that does gets activated:

        refreshMaterial = true; // set to true on material change

        refreshLights = true; // remains set until update done
      } // load material specific uniforms
      // (shader material also gets them for the sake of genericity)


      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;

        if (uCamPos !== undefined) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }

      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
      }

      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) {
        p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
      }
    } // skinning uniforms must be set even if material didn't change
    // auto-setting of texture unit for bone texture must go before other textures
    // otherwise textures used for skinning can take over texture units reserved for other material textures


    if (material.skinning) {
      p_uniforms.setOptional(_gl, object, 'bindMatrix');
      p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
      const skeleton = object.skeleton;

      if (skeleton) {
        const bones = skeleton.bones;

        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === undefined) {
            // layout (1 matrix = 4 pixels)
            //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
            //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
            //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
            //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
            //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
            let size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix

            size = MathUtils.ceilPowerOfTwo(size);
            size = Math.max(size, 4);
            const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel

            boneMatrices.set(skeleton.boneMatrices); // copy current values

            const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
            skeleton.boneMatrices = boneMatrices;
            skeleton.boneTexture = boneTexture;
            skeleton.boneTextureSize = size;
          }

          p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
        }
      }
    }

    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
    }

    if (refreshMaterial) {
      p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);

      if (materialProperties.needsLights) {
        // the current material requires lighting info
        // note: all lighting uniforms are always set correctly
        // they simply reference the renderer's state for their
        // values
        //
        // use the current material's .needsUpdate flags to set
        // the GL state when required
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      } // refresh uniforms common to several materials


      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }

      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }

    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }

    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, 'center', object.center);
    } // common matrices


    p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
    p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
    p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
    return program;
  } // If uniforms are marked as clean, they don't need to be loaded to the GPU.


  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }

  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  } //


  this.setFramebuffer = function (value) {
    if (_framebuffer !== value && _currentRenderTarget === null) _gl.bindFramebuffer(36160, value);
    _framebuffer = value;
  };

  this.getActiveCubeFace = function () {
    return _currentActiveCubeFace;
  };

  this.getActiveMipmapLevel = function () {
    return _currentActiveMipmapLevel;
  };

  this.getRenderList = function () {
    return currentRenderList;
  };

  this.setRenderList = function (renderList) {
    currentRenderList = renderList;
  };

  this.getRenderState = function () {
    return currentRenderState;
  };

  this.setRenderState = function (renderState) {
    currentRenderState = renderState;
  };

  this.getRenderTarget = function () {
    return _currentRenderTarget;
  };

  this.setRenderTarget = function (renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;

    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
      textures.setupRenderTarget(renderTarget);
    }

    let framebuffer = _framebuffer;
    let isCube = false;

    if (renderTarget) {
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }

      _currentViewport.copy(renderTarget.viewport);

      _currentScissor.copy(renderTarget.scissor);

      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();

      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();

      _currentScissorTest = _scissorTest;
    }

    if (_currentFramebuffer !== framebuffer) {
      _gl.bindFramebuffer(36160, framebuffer);

      _currentFramebuffer = framebuffer;
    }

    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);

    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);

      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    }
  };

  this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
      return;
    }

    let framebuffer = properties.get(renderTarget).__webglFramebuffer;

    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }

    if (framebuffer) {
      let restore = false;

      if (framebuffer !== _currentFramebuffer) {
        _gl.bindFramebuffer(36160, framebuffer);

        restore = true;
      }

      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;

        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
          return;
        }

        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && // IE11, Edge and Chrome Mac < 52 (#9513)
        !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
        !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get('EXT_color_buffer_float') : extensions.get('EXT_color_buffer_half_float')))) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
          return;
        }

        if (_gl.checkFramebufferStatus(36160) === 36053) {
          // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
          if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } else {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
        }
      } finally {
        if (restore) {
          _gl.bindFramebuffer(36160, _currentFramebuffer);
        }
      }
    }
  };

  this.copyFramebufferToTexture = function (position, texture, level) {
    if (level === undefined) level = 0;
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    const glFormat = utils.convert(texture.format);
    textures.setTexture2D(texture, 0);

    _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);

    state.unbindTexture();
  };

  this.copyTextureToTexture = function (position, srcTexture, dstTexture, level) {
    if (level === undefined) level = 0;
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0); // As another texture upload may have changed pixelStorei
    // parameters, make sure they are correct for the dstTexture

    _gl.pixelStorei(37440, dstTexture.flipY);

    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);

    _gl.pixelStorei(3317, dstTexture.unpackAlignment);

    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    } // Generate mipmaps only when copying level 0


    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553);
    state.unbindTexture();
  };

  this.initTexture = function (texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };

  if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
      detail: this
    })); // eslint-disable-line no-undef

  }
}

function WebGL1Renderer(parameters) {
  WebGLRenderer.call(this, parameters);
}

WebGL1Renderer.prototype = Object.assign(Object.create(WebGLRenderer.prototype), {
  constructor: WebGL1Renderer,
  isWebGL1Renderer: true
});

class FogExp2 {
  constructor(color, density) {
    Object.defineProperty(this, 'isFogExp2', {
      value: true
    });
    this.name = '';
    this.color = new Color(color);
    this.density = density !== undefined ? density : 0.00025;
  }

  clone() {
    return new FogExp2(this.color, this.density);
  }

  toJSON()
  /* meta */
  {
    return {
      type: 'FogExp2',
      color: this.color.getHex(),
      density: this.density
    };
  }

}

exports.FogExp2 = FogExp2;

class Fog {
  constructor(color, near, far) {
    Object.defineProperty(this, 'isFog', {
      value: true
    });
    this.name = '';
    this.color = new Color(color);
    this.near = near !== undefined ? near : 1;
    this.far = far !== undefined ? far : 1000;
  }

  clone() {
    return new Fog(this.color, this.near, this.far);
  }

  toJSON()
  /* meta */
  {
    return {
      type: 'Fog',
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }

}

exports.Fog = Fog;

class Scene extends Object3D {
  constructor() {
    super();
    Object.defineProperty(this, 'isScene', {
      value: true
    });
    this.type = 'Scene';
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true; // checked by the renderer

    if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
        detail: this
      })); // eslint-disable-line no-undef

    }
  }

  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.environment !== null) this.environment = source.environment.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }

  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.background !== null) data.object.background = this.background.toJSON(meta);
    if (this.environment !== null) data.object.environment = this.environment.toJSON(meta);
    if (this.fog !== null) data.object.fog = this.fog.toJSON();
    return data;
  }

}

exports.Scene = Scene;

function InterleavedBuffer(array, stride) {
  this.array = array;
  this.stride = stride;
  this.count = array !== undefined ? array.length / stride : 0;
  this.usage = StaticDrawUsage;
  this.updateRange = {
    offset: 0,
    count: -1
  };
  this.version = 0;
  this.uuid = MathUtils.generateUUID();
}

Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {
  set: function (value) {
    if (value === true) this.version++;
  }
});
Object.assign(InterleavedBuffer.prototype, {
  isInterleavedBuffer: true,
  onUploadCallback: function () {},
  setUsage: function (value) {
    this.usage = value;
    return this;
  },
  copy: function (source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  },
  copyAt: function (index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;

    for (let i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }

    return this;
  },
  set: function (value, offset) {
    if (offset === undefined) offset = 0;
    this.array.set(value, offset);
    return this;
  },
  clone: function (data) {
    if (data.arrayBuffers === undefined) {
      data.arrayBuffers = {};
    }

    if (this.array.buffer._uuid === undefined) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }

    if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }

    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new InterleavedBuffer(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  },
  onUpload: function (callback) {
    this.onUploadCallback = callback;
    return this;
  },
  toJSON: function (data) {
    if (data.arrayBuffers === undefined) {
      data.arrayBuffers = {};
    } // generate UUID for array buffer if necessary


    if (this.array.buffer._uuid === undefined) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }

    if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
    } //


    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
});

const _vector$6 = new Vector3();

function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
  this.name = '';
  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset;
  this.normalized = normalized === true;
}

Object.defineProperties(InterleavedBufferAttribute.prototype, {
  count: {
    get: function () {
      return this.data.count;
    }
  },
  array: {
    get: function () {
      return this.data.array;
    }
  },
  needsUpdate: {
    set: function (value) {
      this.data.needsUpdate = value;
    }
  }
});
Object.assign(InterleavedBufferAttribute.prototype, {
  isInterleavedBufferAttribute: true,
  applyMatrix4: function (m) {
    for (let i = 0, l = this.data.count; i < l; i++) {
      _vector$6.x = this.getX(i);
      _vector$6.y = this.getY(i);
      _vector$6.z = this.getZ(i);

      _vector$6.applyMatrix4(m);

      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }

    return this;
  },
  setX: function (index, x) {
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  },
  setY: function (index, y) {
    this.data.array[index * this.data.stride + this.offset + 1] = y;
    return this;
  },
  setZ: function (index, z) {
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  },
  setW: function (index, w) {
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  },
  getX: function (index) {
    return this.data.array[index * this.data.stride + this.offset];
  },
  getY: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  },
  getZ: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  },
  getW: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  },
  setXY: function (index, x, y) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    return this;
  },
  setXYZ: function (index, x, y, z) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    return this;
  },
  setXYZW: function (index, x, y, z, w) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  },
  clone: function (data) {
    if (data === undefined) {
      console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
      const array = [];

      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;

        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }

      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === undefined) {
        data.interleavedBuffers = {};
      }

      if (data.interleavedBuffers[this.data.uuid] === undefined) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }

      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  },
  toJSON: function (data) {
    if (data === undefined) {
      console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
      const array = [];

      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;

        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      } // deinterleave data and save it as an ordinary buffer attribute for now


      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: array,
        normalized: this.normalized
      };
    } else {
      // save as true interlaved attribtue
      if (data.interleavedBuffers === undefined) {
        data.interleavedBuffers = {};
      }

      if (data.interleavedBuffers[this.data.uuid] === undefined) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }

      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
});
/**
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

function SpriteMaterial(parameters) {
  Material.call(this);
  this.type = 'SpriteMaterial';
  this.color = new Color(0xffffff);
  this.map = null;
  this.alphaMap = null;
  this.rotation = 0;
  this.sizeAttenuation = true;
  this.transparent = true;
  this.setValues(parameters);
}

SpriteMaterial.prototype = Object.create(Material.prototype);
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;

SpriteMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.rotation = source.rotation;
  this.sizeAttenuation = source.sizeAttenuation;
  return this;
};

let _geometry;

const _intersectPoint = new Vector3();

const _worldScale = new Vector3();

const _mvPosition = new Vector3();

const _alignedPosition = new Vector2();

const _rotatedPosition = new Vector2();

const _viewWorldMatrix = new Matrix4();

const _vA$1 = new Vector3();

const _vB$1 = new Vector3();

const _vC$1 = new Vector3();

const _uvA$1 = new Vector2();

const _uvB$1 = new Vector2();

const _uvC$1 = new Vector2();

function Sprite(material) {
  Object3D.call(this);
  this.type = 'Sprite';

  if (_geometry === undefined) {
    _geometry = new BufferGeometry();
    const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
    const interleavedBuffer = new InterleavedBuffer(float32Array, 5);

    _geometry.setIndex([0, 1, 2, 0, 2, 3]);

    _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));

    _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
  }

  this.geometry = _geometry;
  this.material = material !== undefined ? material : new SpriteMaterial();
  this.center = new Vector2(0.5, 0.5);
}

Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Sprite,
  isSprite: true,
  raycast: function (raycaster, intersects) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }

    _worldScale.setFromMatrixScale(this.matrixWorld);

    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);

    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);

    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);

    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }

    const rotation = this.material.rotation;
    let sin, cos;

    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }

    const center = this.center;
    transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

    _uvA$1.set(0, 0);

    _uvB$1.set(1, 0);

    _uvC$1.set(1, 1); // check first triangle


    let intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);

    if (intersect === null) {
      // check second triangle
      transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

      _uvB$1.set(0, 1);

      intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);

      if (intersect === null) {
        return;
      }
    }

    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects.push({
      distance: distance,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
      face: null,
      object: this
    });
  },
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    if (source.center !== undefined) this.center.copy(source.center);
    this.material = source.material;
    return this;
  }
});

function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  // compute position in camera space
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero


  if (sin !== undefined) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }

  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y; // transform to world space

  vertexPosition.applyMatrix4(_viewWorldMatrix);
}

const _v1$4 = new Vector3();

const _v2$2 = new Vector3();

function LOD() {
  Object3D.call(this);
  this._currentLevel = 0;
  this.type = 'LOD';
  Object.defineProperties(this, {
    levels: {
      enumerable: true,
      value: []
    }
  });
  this.autoUpdate = true;
}

LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: LOD,
  isLOD: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source, false);
    const levels = source.levels;

    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      this.addLevel(level.object.clone(), level.distance);
    }

    this.autoUpdate = source.autoUpdate;
    return this;
  },
  addLevel: function (object, distance) {
    if (distance === undefined) distance = 0;
    distance = Math.abs(distance);
    const levels = this.levels;
    let l;

    for (l = 0; l < levels.length; l++) {
      if (distance < levels[l].distance) {
        break;
      }
    }

    levels.splice(l, 0, {
      distance: distance,
      object: object
    });
    this.add(object);
    return this;
  },
  getCurrentLevel: function () {
    return this._currentLevel;
  },
  getObjectForDistance: function (distance) {
    const levels = this.levels;

    if (levels.length > 0) {
      let i, l;

      for (i = 1, l = levels.length; i < l; i++) {
        if (distance < levels[i].distance) {
          break;
        }
      }

      return levels[i - 1].object;
    }

    return null;
  },
  raycast: function (raycaster, intersects) {
    const levels = this.levels;

    if (levels.length > 0) {
      _v1$4.setFromMatrixPosition(this.matrixWorld);

      const distance = raycaster.ray.origin.distanceTo(_v1$4);
      this.getObjectForDistance(distance).raycast(raycaster, intersects);
    }
  },
  update: function (camera) {
    const levels = this.levels;

    if (levels.length > 1) {
      _v1$4.setFromMatrixPosition(camera.matrixWorld);

      _v2$2.setFromMatrixPosition(this.matrixWorld);

      const distance = _v1$4.distanceTo(_v2$2) / camera.zoom;
      levels[0].object.visible = true;
      let i, l;

      for (i = 1, l = levels.length; i < l; i++) {
        if (distance >= levels[i].distance) {
          levels[i - 1].object.visible = false;
          levels[i].object.visible = true;
        } else {
          break;
        }
      }

      this._currentLevel = i - 1;

      for (; i < l; i++) {
        levels[i].object.visible = false;
      }
    }
  },
  toJSON: function (meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    if (this.autoUpdate === false) data.object.autoUpdate = false;
    data.object.levels = [];
    const levels = this.levels;

    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance
      });
    }

    return data;
  }
});

function SkinnedMesh(geometry, material) {
  if (geometry && geometry.isGeometry) {
    console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
  }

  Mesh.call(this, geometry, material);
  this.type = 'SkinnedMesh';
  this.bindMode = 'attached';
  this.bindMatrix = new Matrix4();
  this.bindMatrixInverse = new Matrix4();
}

SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: SkinnedMesh,
  isSkinnedMesh: true,
  copy: function (source) {
    Mesh.prototype.copy.call(this, source);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    return this;
  },
  bind: function (skeleton, bindMatrix) {
    this.skeleton = skeleton;

    if (bindMatrix === undefined) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }

    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.getInverse(bindMatrix);
  },
  pose: function () {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function () {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;

    for (let i = 0, l = skinWeight.count; i < l; i++) {
      vector.x = skinWeight.getX(i);
      vector.y = skinWeight.getY(i);
      vector.z = skinWeight.getZ(i);
      vector.w = skinWeight.getW(i);
      const scale = 1.0 / vector.manhattanLength();

      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0); // do something reasonable
      }

      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
    }
  },
  updateMatrixWorld: function (force) {
    Mesh.prototype.updateMatrixWorld.call(this, force);

    if (this.bindMode === 'attached') {
      this.bindMatrixInverse.getInverse(this.matrixWorld);
    } else if (this.bindMode === 'detached') {
      this.bindMatrixInverse.getInverse(this.bindMatrix);
    } else {
      console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
    }
  },
  boneTransform: function () {
    const basePosition = new Vector3();
    const skinIndex = new Vector4();
    const skinWeight = new Vector4();
    const vector = new Vector3();
    const matrix = new Matrix4();
    return function (index, target) {
      const skeleton = this.skeleton;
      const geometry = this.geometry;
      skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
      skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
      basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
      target.set(0, 0, 0);

      for (let i = 0; i < 4; i++) {
        const weight = skinWeight.getComponent(i);

        if (weight !== 0) {
          const boneIndex = skinIndex.getComponent(i);
          matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
          target.addScaledVector(vector.copy(basePosition).applyMatrix4(matrix), weight);
        }
      }

      return target.applyMatrix4(this.bindMatrixInverse);
    };
  }()
});

const _offsetMatrix = new Matrix4();

const _identityMatrix = new Matrix4();

function Skeleton(bones, boneInverses) {
  // copy the bone array
  bones = bones || [];
  this.bones = bones.slice(0);
  this.boneMatrices = new Float32Array(this.bones.length * 16);
  this.frame = -1; // use the supplied bone inverses or calculate the inverses

  if (boneInverses === undefined) {
    this.calculateInverses();
  } else {
    if (this.bones.length === boneInverses.length) {
      this.boneInverses = boneInverses.slice(0);
    } else {
      console.warn('THREE.Skeleton boneInverses is the wrong length.');
      this.boneInverses = [];

      for (let i = 0, il = this.bones.length; i < il; i++) {
        this.boneInverses.push(new Matrix4());
      }
    }
  }
}

Object.assign(Skeleton.prototype, {
  calculateInverses: function () {
    this.boneInverses = [];

    for (let i = 0, il = this.bones.length; i < il; i++) {
      const inverse = new Matrix4();

      if (this.bones[i]) {
        inverse.getInverse(this.bones[i].matrixWorld);
      }

      this.boneInverses.push(inverse);
    }
  },
  pose: function () {
    // recover the bind-time world matrices
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];

      if (bone) {
        bone.matrixWorld.getInverse(this.boneInverses[i]);
      }
    } // compute the local matrices, positions, rotations and scales


    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];

      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.getInverse(bone.parent.matrixWorld);
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }

        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  },
  update: function () {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture; // flatten bone matrices to array

    for (let i = 0, il = bones.length; i < il; i++) {
      // compute the offset between the current and the original transform
      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;

      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);

      _offsetMatrix.toArray(boneMatrices, i * 16);
    }

    if (boneTexture !== undefined) {
      boneTexture.needsUpdate = true;
    }
  },
  clone: function () {
    return new Skeleton(this.bones, this.boneInverses);
  },
  getBoneByName: function (name) {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];

      if (bone.name === name) {
        return bone;
      }
    }

    return undefined;
  },
  dispose: function () {
    if (this.boneTexture) {
      this.boneTexture.dispose();
      this.boneTexture = undefined;
    }
  }
});

function Bone() {
  Object3D.call(this);
  this.type = 'Bone';
}

Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Bone,
  isBone: true
});

const _instanceLocalMatrix = new Matrix4();

const _instanceWorldMatrix = new Matrix4();

const _instanceIntersects = [];

const _mesh = new Mesh();

function InstancedMesh(geometry, material, count) {
  Mesh.call(this, geometry, material);
  this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
  this.instanceColor = null;
  this.count = count;
  this.frustumCulled = false;
}

InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: InstancedMesh,
  isInstancedMesh: true,
  copy: function (source) {
    Mesh.prototype.copy.call(this, source);
    this.instanceMatrix.copy(source.instanceMatrix);
    this.count = source.count;
    return this;
  },
  setColorAt: function (index, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);
    }

    color.toArray(this.instanceColor.array, index * 3);
  },
  getMatrixAt: function (index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  },
  raycast: function (raycaster, intersects) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === undefined) return;

    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      // calculate the world matrix for each instance
      this.getMatrixAt(instanceId, _instanceLocalMatrix);

      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance


      _mesh.matrixWorld = _instanceWorldMatrix;

      _mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast


      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
        const intersect = _instanceIntersects[i];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects.push(intersect);
      }

      _instanceIntersects.length = 0;
    }
  },
  setMatrixAt: function (index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  },
  updateMorphTargets: function () {}
});
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

function LineBasicMaterial(parameters) {
  Material.call(this);
  this.type = 'LineBasicMaterial';
  this.color = new Color(0xffffff);
  this.linewidth = 1;
  this.linecap = 'round';
  this.linejoin = 'round';
  this.morphTargets = false;
  this.setValues(parameters);
}

LineBasicMaterial.prototype = Object.create(Material.prototype);
LineBasicMaterial.prototype.constructor = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = true;

LineBasicMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.linewidth = source.linewidth;
  this.linecap = source.linecap;
  this.linejoin = source.linejoin;
  this.morphTargets = source.morphTargets;
  return this;
};

const _start = new Vector3();

const _end = new Vector3();

const _inverseMatrix$1 = new Matrix4();

const _ray$1 = new Ray();

const _sphere$2 = new Sphere();

function Line(geometry, material, mode) {
  if (mode === 1) {
    console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');
  }

  Object3D.call(this);
  this.type = 'Line';
  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  this.material = material !== undefined ? material : new LineBasicMaterial();
  this.updateMorphTargets();
}

Line.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Line,
  isLine: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  computeLineDistances: function () {
    const geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      // we assume non-indexed geometry
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [0];

        for (let i = 1, l = positionAttribute.count; i < l; i++) {
          _start.fromBufferAttribute(positionAttribute, i - 1);

          _end.fromBufferAttribute(positionAttribute, i);

          lineDistances[i] = lineDistances[i - 1];
          lineDistances[i] += _start.distanceTo(_end);
        }

        geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
      }
    } else if (geometry.isGeometry) {
      const vertices = geometry.vertices;
      const lineDistances = geometry.lineDistances;
      lineDistances[0] = 0;

      for (let i = 1, l = vertices.length; i < l; i++) {
        lineDistances[i] = lineDistances[i - 1];
        lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);
      }
    }

    return this;
  },
  raycast: function (raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold; // Checking boundingSphere distance to ray

    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

    _sphere$2.copy(geometry.boundingSphere);

    _sphere$2.applyMatrix4(matrixWorld);

    _sphere$2.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$2) === false) return; //

    _inverseMatrix$1.getInverse(matrixWorld);

    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);

    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step = this && this.isLineSegments ? 2 : 1;

    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positions = attributes.position.array;

      if (index !== null) {
        const indices = index.array;

        for (let i = 0, l = indices.length - 1; i < l; i += step) {
          const a = indices[i];
          const b = indices[i + 1];
          vStart.fromArray(positions, a * 3);
          vEnd.fromArray(positions, b * 3);

          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

          if (distSq > localThresholdSq) continue;
          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far) continue;
          intersects.push({
            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        for (let i = 0, l = positions.length / 3 - 1; i < l; i += step) {
          vStart.fromArray(positions, 3 * i);
          vEnd.fromArray(positions, 3 * i + 3);

          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

          if (distSq > localThresholdSq) continue;
          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far) continue;
          intersects.push({
            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry.isGeometry) {
      const vertices = geometry.vertices;
      const nbVertices = vertices.length;

      for (let i = 0; i < nbVertices - 1; i += step) {
        const distSq = _ray$1.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);

        if (distSq > localThresholdSq) continue;
        interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

        const distance = raycaster.ray.origin.distanceTo(interRay);
        if (distance < raycaster.near || distance > raycaster.far) continue;
        intersects.push({
          distance: distance,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: interSegment.clone().applyMatrix4(this.matrixWorld),
          index: i,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  },
  updateMorphTargets: function () {
    const geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);

      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];

        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};

          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;

      if (morphTargets !== undefined && morphTargets.length > 0) {
        console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  }
});

const _start$1 = new Vector3();

const _end$1 = new Vector3();

function LineSegments(geometry, material) {
  Line.call(this, geometry, material);
  this.type = 'LineSegments';
}

LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineSegments,
  isLineSegments: true,
  computeLineDistances: function () {
    const geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      // we assume non-indexed geometry
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [];

        for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
          _start$1.fromBufferAttribute(positionAttribute, i);

          _end$1.fromBufferAttribute(positionAttribute, i + 1);

          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
          lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
        }

        geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
      }
    } else if (geometry.isGeometry) {
      const vertices = geometry.vertices;
      const lineDistances = geometry.lineDistances;

      for (let i = 0, l = vertices.length; i < l; i += 2) {
        _start$1.copy(vertices[i]);

        _end$1.copy(vertices[i + 1]);

        lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
        lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
      }
    }

    return this;
  }
});

function LineLoop(geometry, material) {
  Line.call(this, geometry, material);
  this.type = 'LineLoop';
}

LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineLoop,
  isLineLoop: true
});
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */

function PointsMaterial(parameters) {
  Material.call(this);
  this.type = 'PointsMaterial';
  this.color = new Color(0xffffff);
  this.map = null;
  this.alphaMap = null;
  this.size = 1;
  this.sizeAttenuation = true;
  this.morphTargets = false;
  this.setValues(parameters);
}

PointsMaterial.prototype = Object.create(Material.prototype);
PointsMaterial.prototype.constructor = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;

PointsMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.size = source.size;
  this.sizeAttenuation = source.sizeAttenuation;
  this.morphTargets = source.morphTargets;
  return this;
};

const _inverseMatrix$2 = new Matrix4();

const _ray$2 = new Ray();

const _sphere$3 = new Sphere();

const _position$1 = new Vector3();

function Points(geometry, material) {
  Object3D.call(this);
  this.type = 'Points';
  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  this.material = material !== undefined ? material : new PointsMaterial();
  this.updateMorphTargets();
}

Points.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Points,
  isPoints: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  raycast: function (raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold; // Checking boundingSphere distance to ray

    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

    _sphere$3.copy(geometry.boundingSphere);

    _sphere$3.applyMatrix4(matrixWorld);

    _sphere$3.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$3) === false) return; //

    _inverseMatrix$2.getInverse(matrixWorld);

    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);

    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;

    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positions = attributes.position.array;

      if (index !== null) {
        const indices = index.array;

        for (let i = 0, il = indices.length; i < il; i++) {
          const a = indices[i];

          _position$1.fromArray(positions, a * 3);

          testPoint(_position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      } else {
        for (let i = 0, l = positions.length / 3; i < l; i++) {
          _position$1.fromArray(positions, i * 3);

          testPoint(_position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      }
    } else {
      const vertices = geometry.vertices;

      for (let i = 0, l = vertices.length; i < l; i++) {
        testPoint(vertices[i], i, localThresholdSq, matrixWorld, raycaster, intersects, this);
      }
    }
  },
  updateMorphTargets: function () {
    const geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);

      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];

        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};

          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;

      if (morphTargets !== undefined && morphTargets.length > 0) {
        console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  }
});

function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
  const rayPointDistanceSq = _ray$2.distanceSqToPoint(point);

  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();

    _ray$2.closestPointToPoint(point, intersectPoint);

    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects.push({
      distance: distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index: index,
      face: null,
      object: object
    });
  }
}

function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.format = format !== undefined ? format : RGBFormat;
  this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
  this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
  this.generateMipmaps = false;
  const scope = this;

  function updateVideo() {
    scope.needsUpdate = true;
    video.requestVideoFrameCallback(updateVideo);
  }

  if ('requestVideoFrameCallback' in video) {
    video.requestVideoFrameCallback(updateVideo);
  }
}

VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
  constructor: VideoTexture,
  isVideoTexture: true,
  update: function () {
    const video = this.image;
    const hasVideoFrameCallback = ('requestVideoFrameCallback' in video);

    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
});

function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.image = {
    width: width,
    height: height
  };
  this.mipmaps = mipmaps; // no flipping for cube textures
  // (also flipping doesn't work for compressed textures )

  this.flipY = false; // can't generate mipmaps for compressed textures
  // mips must be embedded in DDS files

  this.generateMipmaps = false;
}

CompressedTexture.prototype = Object.create(Texture.prototype);
CompressedTexture.prototype.constructor = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = true;

function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.needsUpdate = true;
}

CanvasTexture.prototype = Object.create(Texture.prototype);
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;

function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
  format = format !== undefined ? format : DepthFormat;

  if (format !== DepthFormat && format !== DepthStencilFormat) {
    throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
  }

  if (type === undefined && format === DepthFormat) type = UnsignedShortType;
  if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.image = {
    width: width,
    height: height
  };
  this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
  this.flipY = false;
  this.generateMipmaps = false;
}

DepthTexture.prototype = Object.create(Texture.prototype);
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;

class WireframeGeometry extends BufferGeometry {
  constructor(geometry) {
    super();
    this.type = 'WireframeGeometry'; // buffer

    const vertices = []; // helper variables

    const edge = [0, 0],
          edges = {};
    const keys = ['a', 'b', 'c']; // different logic for Geometry and BufferGeometry

    if (geometry && geometry.isGeometry) {
      // create a data structure that contains all edges without duplicates
      const faces = geometry.faces;

      for (let i = 0, l = faces.length; i < l; i++) {
        const face = faces[i];

        for (let j = 0; j < 3; j++) {
          const edge1 = face[keys[j]];
          const edge2 = face[keys[(j + 1) % 3]];
          edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates

          edge[1] = Math.max(edge1, edge2);
          const key = edge[0] + ',' + edge[1];

          if (edges[key] === undefined) {
            edges[key] = {
              index1: edge[0],
              index2: edge[1]
            };
          }
        }
      } // generate vertices


      for (const key in edges) {
        const e = edges[key];
        let vertex = geometry.vertices[e.index1];
        vertices.push(vertex.x, vertex.y, vertex.z);
        vertex = geometry.vertices[e.index2];
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    } else if (geometry && geometry.isBufferGeometry) {
      const vertex = new Vector3();

      if (geometry.index !== null) {
        // indexed BufferGeometry
        const position = geometry.attributes.position;
        const indices = geometry.index;
        let groups = geometry.groups;

        if (groups.length === 0) {
          groups = [{
            start: 0,
            count: indices.count,
            materialIndex: 0
          }];
        } // create a data structure that contains all eges without duplicates


        for (let o = 0, ol = groups.length; o < ol; ++o) {
          const group = groups[o];
          const start = group.start;
          const count = group.count;

          for (let i = start, l = start + count; i < l; i += 3) {
            for (let j = 0; j < 3; j++) {
              const edge1 = indices.getX(i + j);
              const edge2 = indices.getX(i + (j + 1) % 3);
              edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates

              edge[1] = Math.max(edge1, edge2);
              const key = edge[0] + ',' + edge[1];

              if (edges[key] === undefined) {
                edges[key] = {
                  index1: edge[0],
                  index2: edge[1]
                };
              }
            }
          }
        } // generate vertices


        for (const key in edges) {
          const e = edges[key];
          vertex.fromBufferAttribute(position, e.index1);
          vertices.push(vertex.x, vertex.y, vertex.z);
          vertex.fromBufferAttribute(position, e.index2);
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      } else {
        // non-indexed BufferGeometry
        const position = geometry.attributes.position;

        for (let i = 0, l = position.count / 3; i < l; i++) {
          for (let j = 0; j < 3; j++) {
            // three edges per triangle, an edge is represented as (index1, index2)
            // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
            const index1 = 3 * i + j;
            vertex.fromBufferAttribute(position, index1);
            vertices.push(vertex.x, vertex.y, vertex.z);
            const index2 = 3 * i + (j + 1) % 3;
            vertex.fromBufferAttribute(position, index2);
            vertices.push(vertex.x, vertex.y, vertex.z);
          }
        }
      }
    } // build geometry


    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  }

}
/**
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */
// ParametricGeometry


exports.WireframeGeometry = WireframeGeometry;

function ParametricGeometry(func, slices, stacks) {
  Geometry.call(this);
  this.type = 'ParametricGeometry';
  this.parameters = {
    func: func,
    slices: slices,
    stacks: stacks
  };
  this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
  this.mergeVertices();
}

ParametricGeometry.prototype = Object.create(Geometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry; // ParametricBufferGeometry

function ParametricBufferGeometry(func, slices, stacks) {
  BufferGeometry.call(this);
  this.type = 'ParametricBufferGeometry';
  this.parameters = {
    func: func,
    slices: slices,
    stacks: stacks
  }; // buffers

  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  const EPS = 0.00001;
  const normal = new Vector3();
  const p0 = new Vector3(),
        p1 = new Vector3();
  const pu = new Vector3(),
        pv = new Vector3();

  if (func.length < 3) {
    console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
  } // generate vertices, normals and uvs


  const sliceCount = slices + 1;

  for (let i = 0; i <= stacks; i++) {
    const v = i / stacks;

    for (let j = 0; j <= slices; j++) {
      const u = j / slices; // vertex

      func(u, v, p0);
      vertices.push(p0.x, p0.y, p0.z); // normal
      // approximate tangent vectors via finite differences

      if (u - EPS >= 0) {
        func(u - EPS, v, p1);
        pu.subVectors(p0, p1);
      } else {
        func(u + EPS, v, p1);
        pu.subVectors(p1, p0);
      }

      if (v - EPS >= 0) {
        func(u, v - EPS, p1);
        pv.subVectors(p0, p1);
      } else {
        func(u, v + EPS, p1);
        pv.subVectors(p1, p0);
      } // cross product of tangent vectors returns surface normal


      normal.crossVectors(pu, pv).normalize();
      normals.push(normal.x, normal.y, normal.z); // uv

      uvs.push(u, v);
    }
  } // generate indices


  for (let i = 0; i < stacks; i++) {
    for (let j = 0; j < slices; j++) {
      const a = i * sliceCount + j;
      const b = i * sliceCount + j + 1;
      const c = (i + 1) * sliceCount + j + 1;
      const d = (i + 1) * sliceCount + j; // faces one and two

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry; // PolyhedronGeometry

class PolyhedronGeometry extends Geometry {
  constructor(vertices, indices, radius, detail) {
    super();
    this.type = 'PolyhedronGeometry';
    this.parameters = {
      vertices: vertices,
      indices: indices,
      radius: radius,
      detail: detail
    };
    this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
    this.mergeVertices();
  }

} // PolyhedronBufferGeometry


exports.PolyhedronGeometry = PolyhedronGeometry;

class PolyhedronBufferGeometry extends BufferGeometry {
  constructor(vertices, indices, radius, detail) {
    super();
    this.type = 'PolyhedronBufferGeometry';
    this.parameters = {
      vertices: vertices,
      indices: indices,
      radius: radius,
      detail: detail
    };
    radius = radius || 1;
    detail = detail || 0; // default buffer data

    const vertexBuffer = [];
    const uvBuffer = []; // the subdivision creates the vertex buffer data

    subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius

    applyRadius(radius); // finally, create the uv data

    generateUVs(); // build non-indexed geometry

    this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));

    if (detail === 0) {
      this.computeVertexNormals(); // flat normals
    } else {
      this.normalizeNormals(); // smooth normals
    } // helper functions


    function subdivide(detail) {
      const a = new Vector3();
      const b = new Vector3();
      const c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value

      for (let i = 0; i < indices.length; i += 3) {
        // get the vertices of the face
        getVertexByIndex(indices[i + 0], a);
        getVertexByIndex(indices[i + 1], b);
        getVertexByIndex(indices[i + 2], c); // perform subdivision

        subdivideFace(a, b, c, detail);
      }
    }

    function subdivideFace(a, b, c, detail) {
      const cols = Math.pow(2, detail); // we use this multidimensional array as a data structure for creating the subdivision

      const v = []; // construct all of the vertices for this subdivision

      for (let i = 0; i <= cols; i++) {
        v[i] = [];
        const aj = a.clone().lerp(c, i / cols);
        const bj = b.clone().lerp(c, i / cols);
        const rows = cols - i;

        for (let j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      } // construct all of the faces


      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < 2 * (cols - i) - 1; j++) {
          const k = Math.floor(j / 2);

          if (j % 2 === 0) {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k]);
            pushVertex(v[i][k]);
          } else {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k + 1]);
            pushVertex(v[i + 1][k]);
          }
        }
      }
    }

    function applyRadius(radius) {
      const vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex

      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        vertex.normalize().multiplyScalar(radius);
        vertexBuffer[i + 0] = vertex.x;
        vertexBuffer[i + 1] = vertex.y;
        vertexBuffer[i + 2] = vertex.z;
      }
    }

    function generateUVs() {
      const vertex = new Vector3();

      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        const u = azimuth(vertex) / 2 / Math.PI + 0.5;
        const v = inclination(vertex) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }

      correctUVs();
      correctSeam();
    }

    function correctSeam() {
      // handle case when face straddles the seam, see #3269
      for (let i = 0; i < uvBuffer.length; i += 6) {
        // uv data of a single face
        const x0 = uvBuffer[i + 0];
        const x1 = uvBuffer[i + 2];
        const x2 = uvBuffer[i + 4];
        const max = Math.max(x0, x1, x2);
        const min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary

        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2) uvBuffer[i + 0] += 1;
          if (x1 < 0.2) uvBuffer[i + 2] += 1;
          if (x2 < 0.2) uvBuffer[i + 4] += 1;
        }
      }
    }

    function pushVertex(vertex) {
      vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }

    function getVertexByIndex(index, vertex) {
      const stride = index * 3;
      vertex.x = vertices[stride + 0];
      vertex.y = vertices[stride + 1];
      vertex.z = vertices[stride + 2];
    }

    function correctUVs() {
      const a = new Vector3();
      const b = new Vector3();
      const c = new Vector3();
      const centroid = new Vector3();
      const uvA = new Vector2();
      const uvB = new Vector2();
      const uvC = new Vector2();

      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a).add(b).add(c).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j + 0, a, azi);
        correctUV(uvB, j + 2, b, azi);
        correctUV(uvC, j + 4, c, azi);
      }
    }

    function correctUV(uv, stride, vector, azimuth) {
      if (azimuth < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }

      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
      }
    } // Angle around the Y axis, counter-clockwise when looking from above.


    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    } // Angle above the XZ plane.


    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }

} // TetrahedronGeometry


exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;

class TetrahedronGeometry extends Geometry {
  constructor(radius, detail) {
    super();
    this.type = 'TetrahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
    this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
    this.mergeVertices();
  }

} // TetrahedronBufferGeometry


exports.TetrahedronGeometry = TetrahedronGeometry;

class TetrahedronBufferGeometry extends PolyhedronBufferGeometry {
  constructor(radius, detail) {
    const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
    const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(vertices, indices, radius, detail);
    this.type = 'TetrahedronBufferGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

} // OctahedronGeometry


exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;

class OctahedronGeometry extends Geometry {
  constructor(radius, detail) {
    super();
    this.type = 'OctahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
    this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
    this.mergeVertices();
  }

} // OctahedronBufferGeometry


exports.OctahedronGeometry = OctahedronGeometry;

class OctahedronBufferGeometry extends PolyhedronBufferGeometry {
  constructor(radius, detail) {
    const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
    const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
    super(vertices, indices, radius, detail);
    this.type = 'OctahedronBufferGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

} // IcosahedronGeometry


exports.OctahedronBufferGeometry = OctahedronBufferGeometry;

class IcosahedronGeometry extends Geometry {
  constructor(radius, detail) {
    super();
    this.type = 'IcosahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
    this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
    this.mergeVertices();
  }

} // IcosahedronBufferGeometry


exports.IcosahedronGeometry = IcosahedronGeometry;

class IcosahedronBufferGeometry extends PolyhedronBufferGeometry {
  constructor(radius, detail) {
    const t = (1 + Math.sqrt(5)) / 2;
    const vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
    const indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
    super(vertices, indices, radius, detail);
    this.type = 'IcosahedronBufferGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

} // DodecahedronGeometry


exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;

class DodecahedronGeometry extends Geometry {
  constructor(radius, detail) {
    super();
    this.type = 'DodecahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
    this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
    this.mergeVertices();
  }

} // DodecahedronBufferGeometry


exports.DodecahedronGeometry = DodecahedronGeometry;

class DodecahedronBufferGeometry extends PolyhedronBufferGeometry {
  constructor(radius, detail) {
    const t = (1 + Math.sqrt(5)) / 2;
    const r = 1 / t;
    const vertices = [// (±1, ±1, ±1)
    -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, ±1/φ, ±φ)
    0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (±1/φ, ±φ, 0)
    -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (±φ, 0, ±1/φ)
    -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
    const indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
    super(vertices, indices, radius, detail);
    this.type = 'DodecahedronBufferGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

} // TubeGeometry


exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;

class TubeGeometry extends Geometry {
  constructor(path, tubularSegments, radius, radialSegments, closed, taper) {
    super();
    this.type = 'TubeGeometry';
    this.parameters = {
      path: path,
      tubularSegments: tubularSegments,
      radius: radius,
      radialSegments: radialSegments,
      closed: closed
    };
    if (taper !== undefined) console.warn('THREE.TubeGeometry: taper has been removed.');
    const bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed); // expose internals

    this.tangents = bufferGeometry.tangents;
    this.normals = bufferGeometry.normals;
    this.binormals = bufferGeometry.binormals; // create geometry

    this.fromBufferGeometry(bufferGeometry);
    this.mergeVertices();
  }

} // TubeBufferGeometry


exports.TubeGeometry = TubeGeometry;

class TubeBufferGeometry extends BufferGeometry {
  constructor(path, tubularSegments, radius, radialSegments, closed) {
    super();
    this.type = 'TubeBufferGeometry';
    this.parameters = {
      path: path,
      tubularSegments: tubularSegments,
      radius: radius,
      radialSegments: radialSegments,
      closed: closed
    };
    tubularSegments = tubularSegments || 64;
    radius = radius || 1;
    radialSegments = radialSegments || 8;
    closed = closed || false;
    const frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals

    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals; // helper variables

    const vertex = new Vector3();
    const normal = new Vector3();
    const uv = new Vector2();
    let P = new Vector3(); // buffer

    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = []; // create buffer data

    generateBufferData(); // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions

    function generateBufferData() {
      for (let i = 0; i < tubularSegments; i++) {
        generateSegment(i);
      } // if the geometry is not closed, generate the last row of vertices and normals
      // at the regular position on the given path
      //
      // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)


      generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.
      // this makes it easy compute correct values for closed geometries

      generateUVs(); // finally create faces

      generateIndices();
    }

    function generateSegment(i) {
      // we use getPointAt to sample evenly distributed points from the given path
      P = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal

      const N = frames.normals[i];
      const B = frames.binormals[i]; // generate normals and vertices for the current segment

      for (let j = 0; j <= radialSegments; j++) {
        const v = j / radialSegments * Math.PI * 2;
        const sin = Math.sin(v);
        const cos = -Math.cos(v); // normal

        normal.x = cos * N.x + sin * B.x;
        normal.y = cos * N.y + sin * B.y;
        normal.z = cos * N.z + sin * B.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z); // vertex

        vertex.x = P.x + radius * normal.x;
        vertex.y = P.y + radius * normal.y;
        vertex.z = P.z + radius * normal.z;
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    }

    function generateIndices() {
      for (let j = 1; j <= tubularSegments; j++) {
        for (let i = 1; i <= radialSegments; i++) {
          const a = (radialSegments + 1) * (j - 1) + (i - 1);
          const b = (radialSegments + 1) * j + (i - 1);
          const c = (radialSegments + 1) * j + i;
          const d = (radialSegments + 1) * (j - 1) + i; // faces

          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
    }

    function generateUVs() {
      for (let i = 0; i <= tubularSegments; i++) {
        for (let j = 0; j <= radialSegments; j++) {
          uv.x = i / tubularSegments;
          uv.y = j / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }

  toJSON() {
    const data = BufferGeometry.prototype.toJSON.call(this);
    data.path = this.parameters.path.toJSON();
    return data;
  }

} // TorusKnotGeometry


exports.TubeBufferGeometry = TubeBufferGeometry;

class TorusKnotGeometry extends Geometry {
  constructor(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
    super();
    this.type = 'TorusKnotGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      tubularSegments: tubularSegments,
      radialSegments: radialSegments,
      p: p,
      q: q
    };
    if (heightScale !== undefined) console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');
    this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
    this.mergeVertices();
  }

} // TorusKnotBufferGeometry


exports.TorusKnotGeometry = TorusKnotGeometry;

class TorusKnotBufferGeometry extends BufferGeometry {
  constructor(radius, tube, tubularSegments, radialSegments, p, q) {
    super();
    this.type = 'TorusKnotBufferGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      tubularSegments: tubularSegments,
      radialSegments: radialSegments,
      p: p,
      q: q
    };
    radius = radius || 1;
    tube = tube || 0.4;
    tubularSegments = Math.floor(tubularSegments) || 64;
    radialSegments = Math.floor(radialSegments) || 8;
    p = p || 2;
    q = q || 3; // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    const vertex = new Vector3();
    const normal = new Vector3();
    const P1 = new Vector3();
    const P2 = new Vector3();
    const B = new Vector3();
    const T = new Vector3();
    const N = new Vector3(); // generate vertices, normals and uvs

    for (let i = 0; i <= tubularSegments; ++i) {
      // the radian "u" is used to calculate the position on the torus curve of the current tubular segement
      const u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
      // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

      calculatePositionOnCurve(u, p, q, radius, P1);
      calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis

      T.subVectors(P2, P1);
      N.addVectors(P2, P1);
      B.crossVectors(T, N);
      N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it

      B.normalize();
      N.normalize();

      for (let j = 0; j <= radialSegments; ++j) {
        // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
        // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
        const v = j / radialSegments * Math.PI * 2;
        const cx = -tube * Math.cos(v);
        const cy = tube * Math.sin(v); // now calculate the final vertex position.
        // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

        vertex.x = P1.x + (cx * N.x + cy * B.x);
        vertex.y = P1.y + (cx * N.y + cy * B.y);
        vertex.z = P1.z + (cx * N.z + cy * B.z);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

        normal.subVectors(vertex, P1).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    } // generate indices


    for (let j = 1; j <= tubularSegments; j++) {
      for (let i = 1; i <= radialSegments; i++) {
        // indices
        const a = (radialSegments + 1) * (j - 1) + (i - 1);
        const b = (radialSegments + 1) * j + (i - 1);
        const c = (radialSegments + 1) * j + i;
        const d = (radialSegments + 1) * (j - 1) + i; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve

    function calculatePositionOnCurve(u, p, q, radius, position) {
      const cu = Math.cos(u);
      const su = Math.sin(u);
      const quOverP = q / p * u;
      const cs = Math.cos(quOverP);
      position.x = radius * (2 + cs) * 0.5 * cu;
      position.y = radius * (2 + cs) * su * 0.5;
      position.z = radius * Math.sin(quOverP) * 0.5;
    }
  }

} // TorusGeometry


exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;

class TorusGeometry extends Geometry {
  constructor(radius, tube, radialSegments, tubularSegments, arc) {
    super();
    this.type = 'TorusGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      radialSegments: radialSegments,
      tubularSegments: tubularSegments,
      arc: arc
    };
    this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
    this.mergeVertices();
  }

} // TorusBufferGeometry


exports.TorusGeometry = TorusGeometry;

class TorusBufferGeometry extends BufferGeometry {
  constructor(radius, tube, radialSegments, tubularSegments, arc) {
    super();
    this.type = 'TorusBufferGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      radialSegments: radialSegments,
      tubularSegments: tubularSegments,
      arc: arc
    };
    radius = radius || 1;
    tube = tube || 0.4;
    radialSegments = Math.floor(radialSegments) || 8;
    tubularSegments = Math.floor(tubularSegments) || 6;
    arc = arc || Math.PI * 2; // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    const center = new Vector3();
    const vertex = new Vector3();
    const normal = new Vector3(); // generate vertices, normals and uvs

    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const u = i / tubularSegments * arc;
        const v = j / radialSegments * Math.PI * 2; // vertex

        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex.z = tube * Math.sin(v);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex, center).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    } // generate indices


    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        // indices
        const a = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c = (tubularSegments + 1) * (j - 1) + i;
        const d = (tubularSegments + 1) * j + i; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }

}
/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */


exports.TorusBufferGeometry = TorusBufferGeometry;
const Earcut = {
  triangulate: function (data, holeIndices, dim) {
    dim = dim || 2;
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];

      for (let i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      } // minX, minY and invSize are later used to transform coords into integers for z-order calculation


      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
}; // create a circular doubly linked list from polygon points in the specified winding order

function linkedList(data, start, end, dim, clockwise) {
  let i, last;

  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }

  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }

  return last;
} // eliminate colinear or duplicate points


function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p = start,
      again;

  do {
    again = false;

    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);

  return end;
} // main ear slicing loop which triangulates a polygon (given as a linked list)


function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return; // interlink polygon nodes in z-order

  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear,
      prev,
      next; // iterate through ears, slicing them one by one

  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;

    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      // cut off the triangle
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear); // skipping the next vertex leads to less sliver triangles

      ear = next.next;
      stop = next.next;
      continue;
    }

    ear = next; // if we looped through the whole remaining polygon and can't find any more ears

    if (ear === stop) {
      // try filtering points and slicing again
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }

      break;
    }
  }
} // check whether a polygon node forms a valid ear with adjacent nodes


function isEar(ear) {
  const a = ear.prev,
        b = ear,
        c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // now make sure we don't have other points inside the potential ear

  let p = ear.next.next;

  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }

  return true;
}

function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev,
        b = ear,
        c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // triangle bbox; min & max are calculated like this for speed

  const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
        minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
        maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
        maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;

  const minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p = ear.prevZ,
      n = ear.nextZ; // look for points inside the triangle in both directions

  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  } // look for remaining points in decreasing z-order


  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  } // look for remaining points in increasing z-order


  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }

  return true;
} // go through all polygon nodes and cure small local self-intersections


function cureLocalIntersections(start, triangles, dim) {
  let p = start;

  do {
    const a = p.prev,
          b = p.next.next;

    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim); // remove two nodes involved

      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }

    p = p.next;
  } while (p !== start);

  return filterPoints(p);
} // try splitting polygon into two and triangulate them independently


function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  // look for a valid diagonal that divides the polygon into two
  let a = start;

  do {
    let b = a.next.next;

    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        // split the polygon in two by the diagonal
        let c = splitPolygon(a, b); // filter colinear points around the cuts

        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next); // run earcut on each half

        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }

      b = b.next;
    }

    a = a.next;
  } while (a !== start);
} // link every hole into the outer loop, producing a single-ring polygon without holes


function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i, len, start, end, list;

  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }

  queue.sort(compareX); // process holes from left to right

  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }

  return outerNode;
}

function compareX(a, b) {
  return a.x - b.x;
} // find a bridge between vertices that connects hole with an outer ring and and link it


function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);

  if (outerNode) {
    const b = splitPolygon(outerNode, hole); // filter collinear points around the cuts

    filterPoints(outerNode, outerNode.next);
    filterPoints(b, b.next);
  }
} // David Eberly's algorithm for finding a bridge between hole and outer polygon


function findHoleBridge(hole, outerNode) {
  let p = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity,
      m; // find a segment intersected by a ray from the hole's leftmost point to the left;
  // segment's endpoint with lesser x will be potential connection point

  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

      if (x <= hx && x > qx) {
        qx = x;

        if (x === hx) {
          if (hy === p.y) return p;
          if (hy === p.next.y) return p.next;
        }

        m = p.x < p.next.x ? p : p.next;
      }
    }

    p = p.next;
  } while (p !== outerNode);

  if (!m) return null;
  if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
  // look for points inside the triangle of hole point, segment intersection and endpoint;
  // if there are no points found, we have a valid connection;
  // otherwise choose the point of the minimum angle with the ray as connection point

  const stop = m,
        mx = m.x,
        my = m.y;
  let tanMin = Infinity,
      tan;
  p = m;

  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }

    p = p.next;
  } while (p !== stop);

  return m;
} // whether sector in vertex m contains sector in vertex p in the same coordinates


function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
} // interlink polygon nodes in z-order


function indexCurve(start, minX, minY, invSize) {
  let p = start;

  do {
    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);

  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
} // Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


function sortLinked(list) {
  let i,
      p,
      q,
      e,
      tail,
      numMerges,
      pSize,
      qSize,
      inSize = 1;

  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;

    while (p) {
      numMerges++;
      q = p;
      pSize = 0;

      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }

      qSize = inSize;

      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }

        if (tail) tail.nextZ = e;else list = e;
        e.prevZ = tail;
        tail = e;
      }

      p = q;
    }

    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);

  return list;
} // z-order of a point given coords and inverse of the longer side of data bbox


function zOrder(x, y, minX, minY, invSize) {
  // coords are transformed into non-negative 15-bit integer range
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 0x00FF00FF;
  x = (x | x << 4) & 0x0F0F0F0F;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y = (y | y << 8) & 0x00FF00FF;
  y = (y | y << 4) & 0x0F0F0F0F;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
} // find the leftmost node of a polygon ring


function getLeftmost(start) {
  let p = start,
      leftmost = start;

  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);

  return leftmost;
} // check if a point lies within a convex triangle


function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges
  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible
  area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
} // signed area of a triangle


function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
} // check if two points are equal


function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
} // check if two segments intersect


function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true; // general case

  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1

  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1

  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2

  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

  return false;
} // for collinear points p, q, r, check if point q lies on segment pr


function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
} // check if a polygon diagonal intersects any polygon segments


function intersectsPolygon(a, b) {
  let p = a;

  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);

  return false;
} // check if a polygon diagonal is locally inside the polygon


function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
} // check if the middle point of a polygon diagonal is inside the polygon


function middleInside(a, b) {
  let p = a,
      inside = false;
  const px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;

  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
    p = p.next;
  } while (p !== a);

  return inside;
} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring


function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
} // create a node and optionally link it with previous one (in a circular doubly linked list)


function insertNode(i, x, y, last) {
  const p = new Node(i, x, y);

  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }

  return p;
}

function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
  // vertex index in coordinates array
  this.i = i; // vertex coordinates

  this.x = x;
  this.y = y; // previous and next vertex nodes in a polygon ring

  this.prev = null;
  this.next = null; // z-order curve value

  this.z = null; // previous and next nodes in z-order

  this.prevZ = null;
  this.nextZ = null; // indicates whether this is a steiner point

  this.steiner = false;
}

function signedArea(data, start, end, dim) {
  let sum = 0;

  for (let i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }

  return sum;
}

const ShapeUtils = {
  // calculate area of the contour polygon
  area: function (contour) {
    const n = contour.length;
    let a = 0.0;

    for (let p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }

    return a * 0.5;
  },
  isClockWise: function (pts) {
    return ShapeUtils.area(pts) < 0;
  },
  triangulateShape: function (contour, holes) {
    const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]

    const holeIndices = []; // array of hole indices

    const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

    removeDupEndPts(contour);
    addContour(vertices, contour); //

    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);

    for (let i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    } //


    const triangles = Earcut.triangulate(vertices, holeIndices); //

    for (let i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }

    return faces;
  }
};
exports.ShapeUtils = ShapeUtils;

function removeDupEndPts(points) {
  const l = points.length;

  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}

function addContour(vertices, contour) {
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}
/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */
// ExtrudeGeometry


class ExtrudeGeometry extends Geometry {
  constructor(shapes, options) {
    super();
    this.type = 'ExtrudeGeometry';
    this.parameters = {
      shapes: shapes,
      options: options
    };
    this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
    this.mergeVertices();
  }

  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON(shapes, options, data);
  }

} // ExtrudeBufferGeometry


exports.ExtrudeGeometry = ExtrudeGeometry;

class ExtrudeBufferGeometry extends BufferGeometry {
  constructor(shapes, options) {
    super();
    this.type = 'ExtrudeBufferGeometry';
    this.parameters = {
      shapes: shapes,
      options: options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];

    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      addShape(shape);
    } // build geometry


    this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals(); // functions

    function addShape(shape) {
      const placeholder = []; // options

      const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
      const steps = options.steps !== undefined ? options.steps : 1;
      let depth = options.depth !== undefined ? options.depth : 100;
      let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
      let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
      let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
      let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
      let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
      const extrudePath = options.extrudePath;
      const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options

      if (options.amount !== undefined) {
        console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
        depth = options.amount;
      } //


      let extrudePts,
          extrudeByPath = false;
      let splineTube, binormal, normal, position2;

      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false; // bevels not supported for path extrusion
        // SETUP TNB variables
        // TODO1 - have a .isClosed in spline?

        splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      } // Safeguards if bevels are not enabled


      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      } // Variables initialization


      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);

      if (reverse) {
        vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...

        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];

          if (ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }

      const faces = ShapeUtils.triangulateShape(vertices, holes);
      /* Vertices */

      const contour = vertices; // vertices has all points but contour has only points of circumference

      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        vertices = vertices.concat(ahole);
      }

      function scalePt2(pt, vec, size) {
        if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size).add(pt);
      }

      const vlen = vertices.length,
            flen = faces.length; // Find directions for point movement

      function getBevelVec(inPt, inPrev, inNext) {
        // computes for inPt the corresponding point inPt' on a new contour
        //   shifted by 1 unit (length of normalized vector) to the left
        // if we walk along contour clockwise, this new contour is outside the old one
        //
        // inPt' is the intersection of the two lines parallel to the two
        //  adjacent edges of inPt at a distance of 1 unit on the left side.
        let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
        // good reading for geometry algorithms (here: line-line intersection)
        // http://geomalgorithms.com/a05-_intersect-1.html

        const v_prev_x = inPt.x - inPrev.x,
              v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x,
              v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges

        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

        if (Math.abs(collinear0) > Number.EPSILON) {
          // not collinear
          // length of vectors for normalizing
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left

          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point

          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point

          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly
          //  but prevent crazy spikes

          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;

          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          // handle special case of collinear edges
          let direction_eq = false; // assumes: opposite

          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }

          if (direction_eq) {
            // console.log("Warning: lines are a straight sequence");
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            // console.log("Warning: lines are a straight spike");
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }

        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }

      const contourMovements = [];

      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il) j = 0;
        if (k === il) k = 0; //  (j)---(i)---(k)
        // console.log('i,j,k', i, j , k)

        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }

      const holesMovements = [];
      let oneHoleMovements,
          verticesMovements = contourMovements.concat();

      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = [];

        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il) j = 0;
          if (k === il) k = 0; //  (j)---(i)---(k)

          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }

        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      } // Loop bevelSegments, 1 for the front, 1 for the back


      for (let b = 0; b < bevelSegments; b++) {
        //for ( b = bevelSegments; b > 0; b -- ) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, -z);
        } // expand holes


        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];

          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
            v(vert.x, vert.y, -z);
          }
        }
      }

      const bs = bevelSize + bevelOffset; // Back facing vertices

      for (let i = 0; i < vlen; i++) {
        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      } // Add stepped vertices...
      // Including front facing vertices


      for (let s = 1; s <= steps; s++) {
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

          if (!extrudeByPath) {
            v(vert.x, vert.y, depth / steps * s);
          } else {
            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      } // Add bevel segments planes
      //for ( b = 1; b <= bevelSegments; b ++ ) {


      for (let b = bevelSegments - 1; b >= 0; b--) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, depth + z);
        } // expand holes


        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];

          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

            if (!extrudeByPath) {
              v(vert.x, vert.y, depth + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }
      /* Faces */
      // Top and bottom faces


      buildLidFaces(); // Sides faces

      buildSideFaces(); /////  Internal functions

      function buildLidFaces() {
        const start = verticesArray.length / 3;

        if (bevelEnabled) {
          let layer = 0; // steps + 1

          let offset = vlen * layer; // Bottom faces

          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }

          layer = steps + bevelSegments * 2;
          offset = vlen * layer; // Top faces

          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          // Bottom faces
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2], face[1], face[0]);
          } // Top faces


          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }

        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      } // Create faces for the z-sides of the shape


      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;

        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          sidewalls(ahole, layeroffset); //, true

          layeroffset += ahole.length;
        }

        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }

      function sidewalls(contour, layeroffset) {
        let i = contour.length;

        while (--i >= 0) {
          const j = i;
          let k = i - 1;
          if (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);

          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
            const slen1 = vlen * s;
            const slen2 = vlen * (s + 1);
            const a = layeroffset + j + slen1,
                  b = layeroffset + k + slen1,
                  c = layeroffset + k + slen2,
                  d = layeroffset + j + slen2;
            f4(a, b, c, d);
          }
        }
      }

      function v(x, y, z) {
        placeholder.push(x);
        placeholder.push(y);
        placeholder.push(z);
      }

      function f3(a, b, c) {
        addVertex(a);
        addVertex(b);
        addVertex(c);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }

      function f4(a, b, c, d) {
        addVertex(a);
        addVertex(b);
        addVertex(d);
        addVertex(b);
        addVertex(c);
        addVertex(d);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }

      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }

      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }

  toJSON() {
    const data = BufferGeometry.prototype.toJSON.call(this);
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON(shapes, options, data);
  }

}

exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
const WorldUVGenerator = {
  generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
  },
  generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];

    if (Math.abs(a_y - b_y) < 0.01) {
      return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
    } else {
      return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
    }
  }
};

function toJSON(shapes, options, data) {
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }

  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
/**
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */
// TextGeometry


class TextGeometry extends Geometry {
  constructor(text, parameters) {
    super();
    this.type = 'TextGeometry';
    this.parameters = {
      text: text,
      parameters: parameters
    };
    this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
    this.mergeVertices();
  }

} // TextBufferGeometry


exports.TextGeometry = TextGeometry;

class TextBufferGeometry extends ExtrudeBufferGeometry {
  constructor(text, parameters) {
    parameters = parameters || {};
    const font = parameters.font;

    if (!(font && font.isFont)) {
      console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
      return new Geometry();
    }

    const shapes = font.generateShapes(text, parameters.size); // translate parameters to ExtrudeGeometry API

    parameters.depth = parameters.height !== undefined ? parameters.height : 50; // defaults

    if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
    if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
    if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
    super(shapes, parameters);
    this.type = 'TextBufferGeometry';
  }

} // SphereGeometry


exports.TextBufferGeometry = TextBufferGeometry;

class SphereGeometry extends Geometry {
  constructor(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
    super();
    this.type = 'SphereGeometry';
    this.parameters = {
      radius: radius,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      phiStart: phiStart,
      phiLength: phiLength,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
    this.mergeVertices();
  }

} // SphereBufferGeometry


exports.SphereGeometry = SphereGeometry;

class SphereBufferGeometry extends BufferGeometry {
  constructor(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
    super();
    this.type = 'SphereBufferGeometry';
    this.parameters = {
      radius: radius,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      phiStart: phiStart,
      phiLength: phiLength,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    radius = radius || 1;
    widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
    heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
    phiStart = phiStart !== undefined ? phiStart : 0;
    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex = new Vector3();
    const normal = new Vector3(); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // generate vertices, normals and uvs

    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments; // special case for the poles

      let uOffset = 0;

      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }

      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments; // vertex

        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }

      grid.push(verticesRow);
    } // indices


    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }

} // RingGeometry


exports.SphereBufferGeometry = SphereBufferGeometry;

class RingGeometry extends Geometry {
  constructor(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
    super();
    this.type = 'RingGeometry';
    this.parameters = {
      innerRadius: innerRadius,
      outerRadius: outerRadius,
      thetaSegments: thetaSegments,
      phiSegments: phiSegments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
    this.mergeVertices();
  }

} // RingBufferGeometry


exports.RingGeometry = RingGeometry;

class RingBufferGeometry extends BufferGeometry {
  constructor(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
    super();
    this.type = 'RingBufferGeometry';
    this.parameters = {
      innerRadius: innerRadius,
      outerRadius: outerRadius,
      thetaSegments: thetaSegments,
      phiSegments: phiSegments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    innerRadius = innerRadius || 0.5;
    outerRadius = outerRadius || 1;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
    phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1; // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // some helper variables

    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex = new Vector3();
    const uv = new Vector2(); // generate vertices, normals and uvs

    for (let j = 0; j <= phiSegments; j++) {
      for (let i = 0; i <= thetaSegments; i++) {
        // values are generate from the inside of the ring to the outside
        const segment = thetaStart + i / thetaSegments * thetaLength; // vertex

        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normals.push(0, 0, 1); // uv

        uv.x = (vertex.x / outerRadius + 1) / 2;
        uv.y = (vertex.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      } // increase the radius for next row of vertices


      radius += radiusStep;
    } // indices


    for (let j = 0; j < phiSegments; j++) {
      const thetaSegmentLevel = j * (thetaSegments + 1);

      for (let i = 0; i < thetaSegments; i++) {
        const segment = i + thetaSegmentLevel;
        const a = segment;
        const b = segment + thetaSegments + 1;
        const c = segment + thetaSegments + 2;
        const d = segment + 1; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }

} // LatheGeometry


exports.RingBufferGeometry = RingBufferGeometry;

class LatheGeometry extends Geometry {
  constructor(points, segments, phiStart, phiLength) {
    super();
    this.type = 'LatheGeometry';
    this.parameters = {
      points: points,
      segments: segments,
      phiStart: phiStart,
      phiLength: phiLength
    };
    this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
    this.mergeVertices();
  }

} // LatheBufferGeometry


exports.LatheGeometry = LatheGeometry;

class LatheBufferGeometry extends BufferGeometry {
  constructor(points, segments, phiStart, phiLength) {
    super();
    this.type = 'LatheBufferGeometry';
    this.parameters = {
      points: points,
      segments: segments,
      phiStart: phiStart,
      phiLength: phiLength
    };
    segments = Math.floor(segments) || 12;
    phiStart = phiStart || 0;
    phiLength = phiLength || Math.PI * 2; // clamp phiLength so it's in range of [ 0, 2PI ]

    phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2); // buffers

    const indices = [];
    const vertices = [];
    const uvs = []; // helper variables

    const inverseSegments = 1.0 / segments;
    const vertex = new Vector3();
    const uv = new Vector2(); // generate vertices and uvs

    for (let i = 0; i <= segments; i++) {
      const phi = phiStart + i * inverseSegments * phiLength;
      const sin = Math.sin(phi);
      const cos = Math.cos(phi);

      for (let j = 0; j <= points.length - 1; j++) {
        // vertex
        vertex.x = points[j].x * sin;
        vertex.y = points[j].y;
        vertex.z = points[j].x * cos;
        vertices.push(vertex.x, vertex.y, vertex.z); // uv

        uv.x = i / segments;
        uv.y = j / (points.length - 1);
        uvs.push(uv.x, uv.y);
      }
    } // indices


    for (let i = 0; i < segments; i++) {
      for (let j = 0; j < points.length - 1; j++) {
        const base = j + i * points.length;
        const a = base;
        const b = base + points.length;
        const c = base + points.length + 1;
        const d = base + 1; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals

    this.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.
    // because the corresponding vertices are identical (but still have different UVs).

    if (phiLength === Math.PI * 2) {
      const normals = this.attributes.normal.array;
      const n1 = new Vector3();
      const n2 = new Vector3();
      const n = new Vector3(); // this is the buffer offset for the last line of vertices

      const base = segments * points.length * 3;

      for (let i = 0, j = 0; i < points.length; i++, j += 3) {
        // select the normal of the vertex in the first line
        n1.x = normals[j + 0];
        n1.y = normals[j + 1];
        n1.z = normals[j + 2]; // select the normal of the vertex in the last line

        n2.x = normals[base + j + 0];
        n2.y = normals[base + j + 1];
        n2.z = normals[base + j + 2]; // average normals

        n.addVectors(n1, n2).normalize(); // assign the new values to both normals

        normals[j + 0] = normals[base + j + 0] = n.x;
        normals[j + 1] = normals[base + j + 1] = n.y;
        normals[j + 2] = normals[base + j + 2] = n.z;
      }
    }
  }

} // ShapeGeometry


exports.LatheBufferGeometry = LatheBufferGeometry;

class ShapeGeometry extends Geometry {
  constructor(shapes, curveSegments) {
    super();
    this.type = 'ShapeGeometry';

    if (typeof curveSegments === 'object') {
      console.warn('THREE.ShapeGeometry: Options parameter has been removed.');
      curveSegments = curveSegments.curveSegments;
    }

    this.parameters = {
      shapes: shapes,
      curveSegments: curveSegments
    };
    this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
    this.mergeVertices();
  }

  toJSON() {
    const data = Geometry.prototype.toJSON.call(this);
    const shapes = this.parameters.shapes;
    return toJSON$1(shapes, data);
  }

} // ShapeBufferGeometry


exports.ShapeGeometry = ShapeGeometry;

class ShapeBufferGeometry extends BufferGeometry {
  constructor(shapes, curveSegments) {
    super();
    this.type = 'ShapeBufferGeometry';
    this.parameters = {
      shapes: shapes,
      curveSegments: curveSegments
    };
    curveSegments = curveSegments || 12; // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    let groupStart = 0;
    let groupCount = 0; // allow single and array values for "shapes" parameter

    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);
        this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

        groupStart += groupCount;
        groupCount = 0;
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions

    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes; // check direction of vertices

      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }

      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];

        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i] = shapeHole.reverse();
        }
      }

      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array

      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        shapeVertices = shapeVertices.concat(shapeHole);
      } // vertices, normals, uvs


      for (let i = 0, l = shapeVertices.length; i < l; i++) {
        const vertex = shapeVertices[i];
        vertices.push(vertex.x, vertex.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex.x, vertex.y); // world uvs
      } // incides


      for (let i = 0, l = faces.length; i < l; i++) {
        const face = faces[i];
        const a = face[0] + indexOffset;
        const b = face[1] + indexOffset;
        const c = face[2] + indexOffset;
        indices.push(a, b, c);
        groupCount += 3;
      }
    }
  }

  toJSON() {
    const data = BufferGeometry.prototype.toJSON.call(this);
    const shapes = this.parameters.shapes;
    return toJSON$1(shapes, data);
  }

} //


exports.ShapeBufferGeometry = ShapeBufferGeometry;

function toJSON$1(shapes, data) {
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }

  return data;
}

class EdgesGeometry extends BufferGeometry {
  constructor(geometry, thresholdAngle) {
    super();
    this.type = 'EdgesGeometry';
    this.parameters = {
      thresholdAngle: thresholdAngle
    };
    thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1; // buffer

    const vertices = []; // helper variables

    const thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
    const edge = [0, 0],
          edges = {};
    let edge1, edge2, key;
    const keys = ['a', 'b', 'c']; // prepare source geometry

    let geometry2;

    if (geometry.isBufferGeometry) {
      geometry2 = new Geometry();
      geometry2.fromBufferGeometry(geometry);
    } else {
      geometry2 = geometry.clone();
    }

    geometry2.mergeVertices();
    geometry2.computeFaceNormals();
    const sourceVertices = geometry2.vertices;
    const faces = geometry2.faces; // now create a data structure where each entry represents an edge with its adjoining faces

    for (let i = 0, l = faces.length; i < l; i++) {
      const face = faces[i];

      for (let j = 0; j < 3; j++) {
        edge1 = face[keys[j]];
        edge2 = face[keys[(j + 1) % 3]];
        edge[0] = Math.min(edge1, edge2);
        edge[1] = Math.max(edge1, edge2);
        key = edge[0] + ',' + edge[1];

        if (edges[key] === undefined) {
          edges[key] = {
            index1: edge[0],
            index2: edge[1],
            face1: i,
            face2: undefined
          };
        } else {
          edges[key].face2 = i;
        }
      }
    } // generate vertices


    for (key in edges) {
      const e = edges[key]; // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

      if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
        let vertex = sourceVertices[e.index1];
        vertices.push(vertex.x, vertex.y, vertex.z);
        vertex = sourceVertices[e.index2];
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    } // build geometry


    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  }

} // CylinderGeometry


exports.EdgesGeometry = EdgesGeometry;

class CylinderGeometry extends Geometry {
  constructor(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    super();
    this.type = 'CylinderGeometry';
    this.parameters = {
      radiusTop: radiusTop,
      radiusBottom: radiusBottom,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
    this.mergeVertices();
  }

} // CylinderBufferGeometry


exports.CylinderGeometry = CylinderGeometry;

class CylinderBufferGeometry extends BufferGeometry {
  constructor(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    super();
    this.type = 'CylinderBufferGeometry';
    this.parameters = {
      radiusTop: radiusTop,
      radiusBottom: radiusBottom,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    const scope = this;
    radiusTop = radiusTop !== undefined ? radiusTop : 1;
    radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
    height = height || 1;
    radialSegments = Math.floor(radialSegments) || 8;
    heightSegments = Math.floor(heightSegments) || 1;
    openEnded = openEnded !== undefined ? openEnded : false;
    thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2; // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0; // generate geometry

    generateTorso();

    if (openEnded === false) {
      if (radiusTop > 0) generateCap(true);
      if (radiusBottom > 0) generateCap(false);
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    function generateTorso() {
      const normal = new Vector3();
      const vertex = new Vector3();
      let groupCount = 0; // this will be used to calculate the normal

      const slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs

      for (let y = 0; y <= heightSegments; y++) {
        const indexRow = [];
        const v = y / heightSegments; // calculate the radius of the current row

        const radius = v * (radiusBottom - radiusTop) + radiusTop;

        for (let x = 0; x <= radialSegments; x++) {
          const u = x / radialSegments;
          const theta = u * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta); // vertex

          vertex.x = radius * sinTheta;
          vertex.y = -v * height + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z); // normal

          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z); // uv

          uvs.push(u, 1 - v); // save index of vertex in respective row

          indexRow.push(index++);
        } // now save vertices of the row in our index array


        indexArray.push(indexRow);
      } // generate indices


      for (let x = 0; x < radialSegments; x++) {
        for (let y = 0; y < heightSegments; y++) {
          // we use the index array to access the correct indices
          const a = indexArray[y][x];
          const b = indexArray[y + 1][x];
          const c = indexArray[y + 1][x + 1];
          const d = indexArray[y][x + 1]; // faces

          indices.push(a, b, d);
          indices.push(b, c, d); // update group counter

          groupCount += 6;
        }
      } // add a group to the geometry. this will ensure multi material support


      scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups

      groupStart += groupCount;
    }

    function generateCap(top) {
      // save the index of the first center vertex
      const centerIndexStart = index;
      const uv = new Vector2();
      const vertex = new Vector3();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.
      // because the geometry needs one set of uvs per face,
      // we must generate a center vertex per face/segment

      for (let x = 1; x <= radialSegments; x++) {
        // vertex
        vertices.push(0, halfHeight * sign, 0); // normal

        normals.push(0, sign, 0); // uv

        uvs.push(0.5, 0.5); // increase index

        index++;
      } // save the index of the last center vertex


      const centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs

      for (let x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta); // vertex

        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normals.push(0, sign, 0); // uv

        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign + 0.5;
        uvs.push(uv.x, uv.y); // increase index

        index++;
      } // generate indices


      for (let x = 0; x < radialSegments; x++) {
        const c = centerIndexStart + x;
        const i = centerIndexEnd + x;

        if (top === true) {
          // face top
          indices.push(i, i + 1, c);
        } else {
          // face bottom
          indices.push(i + 1, i, c);
        }

        groupCount += 3;
      } // add a group to the geometry. this will ensure multi material support


      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups

      groupStart += groupCount;
    }
  }

} // ConeGeometry


exports.CylinderBufferGeometry = CylinderBufferGeometry;

class ConeGeometry extends CylinderGeometry {
  constructor(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = 'ConeGeometry';
    this.parameters = {
      radius: radius,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
  }

} // ConeBufferGeometry


exports.ConeGeometry = ConeGeometry;

class ConeBufferGeometry extends CylinderBufferGeometry {
  constructor(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = 'ConeBufferGeometry';
    this.parameters = {
      radius: radius,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
  }

} // CircleGeometry


exports.ConeBufferGeometry = ConeBufferGeometry;

class CircleGeometry extends Geometry {
  constructor(radius, segments, thetaStart, thetaLength) {
    super();
    this.type = 'CircleGeometry';
    this.parameters = {
      radius: radius,
      segments: segments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
    this.mergeVertices();
  }

} // CircleBufferGeometry


exports.CircleGeometry = CircleGeometry;

class CircleBufferGeometry extends BufferGeometry {
  constructor(radius, segments, thetaStart, thetaLength) {
    super();
    this.type = 'CircleBufferGeometry';
    this.parameters = {
      radius: radius,
      segments: segments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    radius = radius || 1;
    segments = segments !== undefined ? Math.max(3, segments) : 8;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2; // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    const vertex = new Vector3();
    const uv = new Vector2(); // center point

    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);

    for (let s = 0, i = 3; s <= segments; s++, i += 3) {
      const segment = thetaStart + s / segments * thetaLength; // vertex

      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      normals.push(0, 0, 1); // uvs

      uv.x = (vertices[i] / radius + 1) / 2;
      uv.y = (vertices[i + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    } // indices


    for (let i = 1; i <= segments; i++) {
      indices.push(i, i + 1, 0);
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }

}

exports.CircleBufferGeometry = CircleBufferGeometry;
var Geometries = /*#__PURE__*/Object.freeze({
  __proto__: null,
  WireframeGeometry: WireframeGeometry,
  ParametricGeometry: ParametricGeometry,
  ParametricBufferGeometry: ParametricBufferGeometry,
  TetrahedronGeometry: TetrahedronGeometry,
  TetrahedronBufferGeometry: TetrahedronBufferGeometry,
  OctahedronGeometry: OctahedronGeometry,
  OctahedronBufferGeometry: OctahedronBufferGeometry,
  IcosahedronGeometry: IcosahedronGeometry,
  IcosahedronBufferGeometry: IcosahedronBufferGeometry,
  DodecahedronGeometry: DodecahedronGeometry,
  DodecahedronBufferGeometry: DodecahedronBufferGeometry,
  PolyhedronGeometry: PolyhedronGeometry,
  PolyhedronBufferGeometry: PolyhedronBufferGeometry,
  TubeGeometry: TubeGeometry,
  TubeBufferGeometry: TubeBufferGeometry,
  TorusKnotGeometry: TorusKnotGeometry,
  TorusKnotBufferGeometry: TorusKnotBufferGeometry,
  TorusGeometry: TorusGeometry,
  TorusBufferGeometry: TorusBufferGeometry,
  TextGeometry: TextGeometry,
  TextBufferGeometry: TextBufferGeometry,
  SphereGeometry: SphereGeometry,
  SphereBufferGeometry: SphereBufferGeometry,
  RingGeometry: RingGeometry,
  RingBufferGeometry: RingBufferGeometry,
  PlaneGeometry: PlaneGeometry,
  PlaneBufferGeometry: PlaneBufferGeometry,
  LatheGeometry: LatheGeometry,
  LatheBufferGeometry: LatheBufferGeometry,
  ShapeGeometry: ShapeGeometry,
  ShapeBufferGeometry: ShapeBufferGeometry,
  ExtrudeGeometry: ExtrudeGeometry,
  ExtrudeBufferGeometry: ExtrudeBufferGeometry,
  EdgesGeometry: EdgesGeometry,
  ConeGeometry: ConeGeometry,
  ConeBufferGeometry: ConeBufferGeometry,
  CylinderGeometry: CylinderGeometry,
  CylinderBufferGeometry: CylinderBufferGeometry,
  CircleGeometry: CircleGeometry,
  CircleBufferGeometry: CircleBufferGeometry,
  BoxGeometry: BoxGeometry,
  BoxBufferGeometry: BoxBufferGeometry
});
/**
 * parameters = {
 *  color: <THREE.Color>
 * }
 */

function ShadowMaterial(parameters) {
  Material.call(this);
  this.type = 'ShadowMaterial';
  this.color = new Color(0x000000);
  this.transparent = true;
  this.setValues(parameters);
}

ShadowMaterial.prototype = Object.create(Material.prototype);
ShadowMaterial.prototype.constructor = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = true;

ShadowMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  return this;
};

function RawShaderMaterial(parameters) {
  ShaderMaterial.call(this, parameters);
  this.type = 'RawShaderMaterial';
}

RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
RawShaderMaterial.prototype.constructor = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshStandardMaterial(parameters) {
  Material.call(this);
  this.defines = {
    'STANDARD': ''
  };
  this.type = 'MeshStandardMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.roughness = 1.0;
  this.metalness = 0.0;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.roughnessMap = null;
  this.metalnessMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.envMapIntensity = 1.0;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.vertexTangents = false;
  this.setValues(parameters);
}

MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

MeshStandardMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.defines = {
    'STANDARD': ''
  };
  this.color.copy(source.color);
  this.roughness = source.roughness;
  this.metalness = source.metalness;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.roughnessMap = source.roughnessMap;
  this.metalnessMap = source.metalnessMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.envMapIntensity = source.envMapIntensity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.vertexTangents = source.vertexTangents;
  return this;
};
/**
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *
 *  sheen: <Color>,
 *
 *  transmission: <float>,
 *  transmissionMap: new THREE.Texture( <Image> )
 * }
 */


function MeshPhysicalMaterial(parameters) {
  MeshStandardMaterial.call(this);
  this.defines = {
    'STANDARD': '',
    'PHYSICAL': ''
  };
  this.type = 'MeshPhysicalMaterial';
  this.clearcoat = 0.0;
  this.clearcoatMap = null;
  this.clearcoatRoughness = 0.0;
  this.clearcoatRoughnessMap = null;
  this.clearcoatNormalScale = new Vector2(1, 1);
  this.clearcoatNormalMap = null;
  this.reflectivity = 0.5; // maps to F0 = 0.04

  this.sheen = null; // null will disable sheen bsdf

  this.transmission = 0.0;
  this.transmissionMap = null;
  this.setValues(parameters);
}

MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

MeshPhysicalMaterial.prototype.copy = function (source) {
  MeshStandardMaterial.prototype.copy.call(this, source);
  this.defines = {
    'STANDARD': '',
    'PHYSICAL': ''
  };
  this.clearcoat = source.clearcoat;
  this.clearcoatMap = source.clearcoatMap;
  this.clearcoatRoughness = source.clearcoatRoughness;
  this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
  this.clearcoatNormalMap = source.clearcoatNormalMap;
  this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
  this.reflectivity = source.reflectivity;

  if (source.sheen) {
    this.sheen = (this.sheen || new Color()).copy(source.sheen);
  } else {
    this.sheen = null;
  }

  this.transmission = source.transmission;
  this.transmissionMap = source.transmissionMap;
  return this;
};
/**
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshPhongMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshPhongMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.specular = new Color(0x111111);
  this.shininess = 30;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshPhongMaterial.prototype = Object.create(Material.prototype);
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

MeshPhongMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.specular.copy(source.specular);
  this.shininess = source.shininess;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * parameters = {
 *  color: <hex>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshToonMaterial(parameters) {
  Material.call(this);
  this.defines = {
    'TOON': ''
  };
  this.type = 'MeshToonMaterial';
  this.color = new Color(0xffffff);
  this.map = null;
  this.gradientMap = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.alphaMap = null;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshToonMaterial.prototype = Object.create(Material.prototype);
MeshToonMaterial.prototype.constructor = MeshToonMaterial;
MeshToonMaterial.prototype.isMeshToonMaterial = true;

MeshToonMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.gradientMap = source.gradientMap;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.alphaMap = source.alphaMap;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshNormalMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshNormalMaterial';
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshNormalMaterial.prototype = Object.create(Material.prototype);
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

MeshNormalMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshLambertMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshLambertMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshLambertMaterial.prototype = Object.create(Material.prototype);
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

MeshLambertMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshMatcapMaterial(parameters) {
  Material.call(this);
  this.defines = {
    'MATCAP': ''
  };
  this.type = 'MeshMatcapMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.matcap = null;
  this.map = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.alphaMap = null;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshMatcapMaterial.prototype = Object.create(Material.prototype);
MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

MeshMatcapMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.defines = {
    'MATCAP': ''
  };
  this.color.copy(source.color);
  this.matcap = source.matcap;
  this.map = source.map;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.alphaMap = source.alphaMap;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */


function LineDashedMaterial(parameters) {
  LineBasicMaterial.call(this);
  this.type = 'LineDashedMaterial';
  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.setValues(parameters);
}

LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
LineDashedMaterial.prototype.constructor = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;

LineDashedMaterial.prototype.copy = function (source) {
  LineBasicMaterial.prototype.copy.call(this, source);
  this.scale = source.scale;
  this.dashSize = source.dashSize;
  this.gapSize = source.gapSize;
  return this;
};

var Materials = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ShadowMaterial: ShadowMaterial,
  SpriteMaterial: SpriteMaterial,
  RawShaderMaterial: RawShaderMaterial,
  ShaderMaterial: ShaderMaterial,
  PointsMaterial: PointsMaterial,
  MeshPhysicalMaterial: MeshPhysicalMaterial,
  MeshStandardMaterial: MeshStandardMaterial,
  MeshPhongMaterial: MeshPhongMaterial,
  MeshToonMaterial: MeshToonMaterial,
  MeshNormalMaterial: MeshNormalMaterial,
  MeshLambertMaterial: MeshLambertMaterial,
  MeshDepthMaterial: MeshDepthMaterial,
  MeshDistanceMaterial: MeshDistanceMaterial,
  MeshBasicMaterial: MeshBasicMaterial,
  MeshMatcapMaterial: MeshMatcapMaterial,
  LineDashedMaterial: LineDashedMaterial,
  LineBasicMaterial: LineBasicMaterial,
  Material: Material
});
const AnimationUtils = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function (array, from, to) {
    if (AnimationUtils.isTypedArray(array)) {
      // in ios9 array.subarray(from, undefined) will return empty array
      // but array.subarray(from) or array.subarray(from, len) is correct
      return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
    }

    return array.slice(from, to);
  },
  // converts an array to a specific type
  convertArray: function (array, type, forceClone) {
    if (!array || // let 'undefined' and 'null' pass
    !forceClone && array.constructor === type) return array;

    if (typeof type.BYTES_PER_ELEMENT === 'number') {
      return new type(array); // create typed array
    }

    return Array.prototype.slice.call(array); // create Array
  },
  isTypedArray: function (object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function (times) {
    function compareTime(i, j) {
      return times[i] - times[j];
    }

    const n = times.length;
    const result = new Array(n);

    for (let i = 0; i !== n; ++i) result[i] = i;

    result.sort(compareTime);
    return result;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function (values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);

    for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
      const srcOffset = order[i] * stride;

      for (let j = 0; j !== stride; ++j) {
        result[dstOffset++] = values[srcOffset + j];
      }
    }

    return result;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function (jsonKeys, times, values, valuePropertyName) {
    let i = 1,
        key = jsonKeys[0];

    while (key !== undefined && key[valuePropertyName] === undefined) {
      key = jsonKeys[i++];
    }

    if (key === undefined) return; // no data

    let value = key[valuePropertyName];
    if (value === undefined) return; // no data

    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          values.push.apply(values, value); // push all elements
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    } else if (value.toArray !== undefined) {
      // ...assume THREE.Math-ish
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          value.toArray(values, values.length);
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    } else {
      // otherwise push as-is
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          values.push(value);
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    }
  },
  subclip: function (sourceClip, name, startFrame, endFrame, fps) {
    fps = fps || 30;
    const clip = sourceClip.clone();
    clip.name = name;
    const tracks = [];

    for (let i = 0; i < clip.tracks.length; ++i) {
      const track = clip.tracks[i];
      const valueSize = track.getValueSize();
      const times = [];
      const values = [];

      for (let j = 0; j < track.times.length; ++j) {
        const frame = track.times[j] * fps;
        if (frame < startFrame || frame >= endFrame) continue;
        times.push(track.times[j]);

        for (let k = 0; k < valueSize; ++k) {
          values.push(track.values[j * valueSize + k]);
        }
      }

      if (times.length === 0) continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }

    clip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip

    let minStartTime = Infinity;

    for (let i = 0; i < clip.tracks.length; ++i) {
      if (minStartTime > clip.tracks[i].times[0]) {
        minStartTime = clip.tracks[i].times[0];
      }
    } // shift all tracks such that clip begins at t=0


    for (let i = 0; i < clip.tracks.length; ++i) {
      clip.tracks[i].shift(-1 * minStartTime);
    }

    clip.resetDuration();
    return clip;
  },
  makeClipAdditive: function (targetClip, referenceFrame, referenceClip, fps) {
    if (referenceFrame === undefined) referenceFrame = 0;
    if (referenceClip === undefined) referenceClip = targetClip;
    if (fps === undefined || fps <= 0) fps = 30;
    const numTracks = targetClip.tracks.length;
    const referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame

    for (let i = 0; i < numTracks; ++i) {
      const referenceTrack = referenceClip.tracks[i];
      const referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric

      if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue; // Find the track in the target clip whose name and type matches the reference track

      const targetTrack = targetClip.tracks.find(function (track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === undefined) continue;
      let referenceOffset = 0;
      const referenceValueSize = referenceTrack.getValueSize();

      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }

      let targetOffset = 0;
      const targetValueSize = targetTrack.getValueSize();

      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }

      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue; // Find the value to subtract out of the track

      if (referenceTime <= referenceTrack.times[0]) {
        // Reference frame is earlier than the first keyframe, so just use the first keyframe
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        // Reference frame is after the last keyframe, so just use the last keyframe
        const startIndex = lastIndex * referenceValueSize + referenceOffset;
        const endIndex = startIndex + referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else {
        // Interpolate to the reference value
        const interpolant = referenceTrack.createInterpolant();
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
      } // Conjugate the quaternion


      if (referenceTrackType === 'quaternion') {
        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      } // Subtract the reference value from all of the track values


      const numTimes = targetTrack.times.length;

      for (let j = 0; j < numTimes; ++j) {
        const valueStart = j * targetValueSize + targetOffset;

        if (referenceTrackType === 'quaternion') {
          // Multiply the conjugate for quaternion track types
          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
        } else {
          const valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types

          for (let k = 0; k < valueEnd; ++k) {
            targetTrack.values[valueStart + k] -= referenceValue[k];
          }
        }
      }
    }

    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};
/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */

exports.AnimationUtils = AnimationUtils;

function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  this.parameterPositions = parameterPositions;
  this._cachedIndex = 0;
  this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
  this.sampleValues = sampleValues;
  this.valueSize = sampleSize;
}

Object.assign(Interpolant.prototype, {
  evaluate: function (t) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex,
        t1 = pp[i1],
        t0 = pp[i1 - 1];

    validate_interval: {
      seek: {
        let right;

        linear_scan: {
          //- See http://jsperf.com/comparison-to-undefined/3
          //- slower code:
          //-
          //- 				if ( t >= t1 || t1 === undefined ) {
          forward_scan: if (!(t < t1)) {
            for (let giveUpAt = i1 + 2;;) {
              if (t1 === undefined) {
                if (t < t0) break forward_scan; // after end

                i1 = pp.length;
                this._cachedIndex = i1;
                return this.afterEnd_(i1 - 1, t, t0);
              }

              if (i1 === giveUpAt) break; // this loop

              t0 = t1;
              t1 = pp[++i1];

              if (t < t1) {
                // we have arrived at the sought interval
                break seek;
              }
            } // prepare binary search on the right side of the index


            right = pp.length;
            break linear_scan;
          } //- slower code:
          //-					if ( t < t0 || t0 === undefined ) {


          if (!(t >= t0)) {
            // looping?
            const t1global = pp[1];

            if (t < t1global) {
              i1 = 2; // + 1, using the scan for the details

              t0 = t1global;
            } // linear reverse scan


            for (let giveUpAt = i1 - 2;;) {
              if (t0 === undefined) {
                // before start
                this._cachedIndex = 0;
                return this.beforeStart_(0, t, t1);
              }

              if (i1 === giveUpAt) break; // this loop

              t1 = t0;
              t0 = pp[--i1 - 1];

              if (t >= t0) {
                // we have arrived at the sought interval
                break seek;
              }
            } // prepare binary search on the left side of the index


            right = i1;
            i1 = 0;
            break linear_scan;
          } // the interval is valid


          break validate_interval;
        } // linear scan
        // binary search


        while (i1 < right) {
          const mid = i1 + right >>> 1;

          if (t < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }

        t1 = pp[i1];
        t0 = pp[i1 - 1]; // check boundary cases, again

        if (t0 === undefined) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t, t1);
        }

        if (t1 === undefined) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t);
        }
      } // seek


      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    } // validate_interval


    return this.interpolate_(i1, t0, t, t1);
  },
  settings: null,
  // optional, subclass-specific settings structure
  // Note: The indirection allows central control of many interpolants.
  // --- Protected interface
  DefaultSettings_: {},
  getSettings_: function () {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function (index) {
    // copies a sample value to the result buffer
    const result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          offset = index * stride;

    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset + i];
    }

    return result;
  },
  // Template methods for derived classes:
  interpolate_: function ()
  /* i1, t0, t, t1 */
  {
    throw new Error('call to abstract method'); // implementations shall return this.resultBuffer
  },
  intervalChanged_: function ()
  /* i1, t0, t1 */
  {// empty
  }
}); // DECLARE ALIAS AFTER assign prototype

Object.assign(Interpolant.prototype, {
  //( 0, t, t0 ), returns this.resultBuffer
  beforeStart_: Interpolant.prototype.copySampleValue_,
  //( N-1, tN-1, t ), returns this.resultBuffer
  afterEnd_: Interpolant.prototype.copySampleValue_
});
/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  this._weightPrev = -0;
  this._offsetPrev = -0;
  this._weightNext = -0;
  this._offsetNext = -0;
}

CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: CubicInterpolant,
  DefaultSettings_: {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  },
  intervalChanged_: function (i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2,
        iNext = i1 + 1,
        tPrev = pp[iPrev],
        tNext = pp[iNext];

    if (tPrev === undefined) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          // f'(t0) = 0
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;

        case WrapAroundEnding:
          // use the other end of the curve
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;

        default:
          // ZeroCurvatureEnding
          // f''(t0) = 0 a.k.a. Natural Spline
          iPrev = i1;
          tPrev = t1;
      }
    }

    if (tNext === undefined) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          // f'(tN) = 0
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;

        case WrapAroundEnding:
          // use the other end of the curve
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;

        default:
          // ZeroCurvatureEnding
          // f''(tN) = 0, a.k.a. Natural Spline
          iNext = i1 - 1;
          tNext = t0;
      }
    }

    const halfDt = (t1 - t0) * 0.5,
          stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  },
  interpolate_: function (i1, t0, t, t1) {
    const result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          o1 = i1 * stride,
          o0 = o1 - stride,
          oP = this._offsetPrev,
          oN = this._offsetNext,
          wP = this._weightPrev,
          wN = this._weightNext,
          p = (t - t0) / (t1 - t0),
          pp = p * p,
          ppp = pp * p; // evaluate polynomials

    const sP = -wP * ppp + 2 * wP * pp - wP * p;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    const sN = wN * ppp - wN * pp; // combine data linearly

    for (let i = 0; i !== stride; ++i) {
      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
    }

    return result;
  }
});

function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}

LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: LinearInterpolant,
  interpolate_: function (i1, t0, t, t1) {
    const result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          offset1 = i1 * stride,
          offset0 = offset1 - stride,
          weight1 = (t - t0) / (t1 - t0),
          weight0 = 1 - weight1;

    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }

    return result;
  }
});
/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 */

function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}

DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: DiscreteInterpolant,
  interpolate_: function (i1
  /*, t0, t, t1 */
  ) {
    return this.copySampleValue_(i1 - 1);
  }
});

function KeyframeTrack(name, times, values, interpolation) {
  if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
  if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
  this.name = name;
  this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
  this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
  this.setInterpolation(interpolation || this.DefaultInterpolation);
} // Static methods


Object.assign(KeyframeTrack, {
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  toJSON: function (track) {
    const trackType = track.constructor;
    let json; // derived classes can define a static toJSON method

    if (trackType.toJSON !== undefined) {
      json = trackType.toJSON(track);
    } else {
      // by default, we assume the data can be serialized as-is
      json = {
        'name': track.name,
        'times': AnimationUtils.convertArray(track.times, Array),
        'values': AnimationUtils.convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();

      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }

    json.type = track.ValueTypeName; // mandatory

    return json;
  }
});
Object.assign(KeyframeTrack.prototype, {
  constructor: KeyframeTrack,
  TimeBufferType: Float32Array,
  ValueBufferType: Float32Array,
  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodDiscrete: function (result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodLinear: function (result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodSmooth: function (result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  setInterpolation: function (interpolation) {
    let factoryMethod;

    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;

      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;

      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }

    if (factoryMethod === undefined) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;

      if (this.createInterpolant === undefined) {
        // fall back to default, unless the default itself is messed up
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message); // fatal, in this case
        }
      }

      console.warn('THREE.KeyframeTrack:', message);
      return this;
    }

    this.createInterpolant = factoryMethod;
    return this;
  },
  getInterpolation: function () {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;

      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;

      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  },
  getValueSize: function () {
    return this.values.length / this.times.length;
  },
  // move all keyframes either forwards or backwards in time
  shift: function (timeOffset) {
    if (timeOffset !== 0.0) {
      const times = this.times;

      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
      }
    }

    return this;
  },
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale: function (timeScale) {
    if (timeScale !== 1.0) {
      const times = this.times;

      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
      }
    }

    return this;
  },
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim: function (startTime, endTime) {
    const times = this.times,
          nKeys = times.length;
    let from = 0,
        to = nKeys - 1;

    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }

    while (to !== -1 && times[to] > endTime) {
      --to;
    }

    ++to; // inclusive -> exclusive bound

    if (from !== 0 || to !== nKeys) {
      // empty tracks are forbidden, so keep at least one keyframe
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }

      const stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
    }

    return this;
  },
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate: function () {
    let valid = true;
    const valueSize = this.getValueSize();

    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
      valid = false;
    }

    const times = this.times,
          values = this.values,
          nKeys = times.length;

    if (nKeys === 0) {
      console.error('THREE.KeyframeTrack: Track is empty.', this);
      valid = false;
    }

    let prevTime = null;

    for (let i = 0; i !== nKeys; i++) {
      const currTime = times[i];

      if (typeof currTime === 'number' && isNaN(currTime)) {
        console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
        valid = false;
        break;
      }

      if (prevTime !== null && prevTime > currTime) {
        console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
        valid = false;
        break;
      }

      prevTime = currTime;
    }

    if (values !== undefined) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i = 0, n = values.length; i !== n; ++i) {
          const value = values[i];

          if (isNaN(value)) {
            console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
            valid = false;
            break;
          }
        }
      }
    }

    return valid;
  },
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize: function () {
    // times or values may be shared with other tracks, so overwriting is unsafe
    const times = AnimationUtils.arraySlice(this.times),
          values = AnimationUtils.arraySlice(this.values),
          stride = this.getValueSize(),
          smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
          lastIndex = times.length - 1;
    let writeIndex = 1;

    for (let i = 1; i < lastIndex; ++i) {
      let keep = false;
      const time = times[i];
      const timeNext = times[i + 1]; // remove adjacent keyframes scheduled at the same time

      if (time !== timeNext && (i !== 1 || time !== time[0])) {
        if (!smoothInterpolation) {
          // remove unnecessary keyframes same as their neighbors
          const offset = i * stride,
                offsetP = offset - stride,
                offsetN = offset + stride;

          for (let j = 0; j !== stride; ++j) {
            const value = values[offset + j];

            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      } // in-place compaction


      if (keep) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          const readOffset = i * stride,
                writeOffset = writeIndex * stride;

          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }

        ++writeIndex;
      }
    } // flush last keyframe (compaction looks ahead)


    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];

      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }

      ++writeIndex;
    }

    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }

    return this;
  },
  clone: function () {
    const times = AnimationUtils.arraySlice(this.times, 0);
    const values = AnimationUtils.arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.

    track.createInterpolant = this.createInterpolant;
    return track;
  }
});
/**
 * A Track of Boolean keyframe values.
 */

function BooleanKeyframeTrack(name, times, values) {
  KeyframeTrack.call(this, name, times, values);
}

BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: BooleanKeyframeTrack,
  ValueTypeName: 'bool',
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: undefined,
  InterpolantFactoryMethodSmooth: undefined // Note: Actually this track could have a optimized / compressed
  // representation of a single value and a custom interpolant that
  // computes "firstValue ^ isOdd( index )".

});
/**
 * A Track of keyframe values that represent color.
 */

function ColorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: ColorKeyframeTrack,
  ValueTypeName: 'color' // ValueBufferType is inherited
  // DefaultInterpolation is inherited
  // Note: Very basic implementation and nothing special yet.
  // However, this is the place for color space parameterization.

});
/**
 * A Track of numeric keyframe values.
 */

function NumberKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: NumberKeyframeTrack,
  ValueTypeName: 'number' // ValueBufferType is inherited
  // DefaultInterpolation is inherited

});
/**
 * Spherical linear unit quaternion interpolant.
 */

function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}

QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: QuaternionLinearInterpolant,
  interpolate_: function (i1, t0, t, t1) {
    const result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          alpha = (t - t0) / (t1 - t0);
    let offset = i1 * stride;

    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }

    return result;
  }
});
/**
 * A Track of quaternion keyframe values.
 */

function QuaternionKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: QuaternionKeyframeTrack,
  ValueTypeName: 'quaternion',
  // ValueBufferType is inherited
  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodLinear: function (result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodSmooth: undefined // not yet implemented

});
/**
 * A Track that interpolates Strings
 */

function StringKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: StringKeyframeTrack,
  ValueTypeName: 'string',
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: undefined,
  InterpolantFactoryMethodSmooth: undefined
});
/**
 * A Track of vectored keyframe values.
 */

function VectorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: VectorKeyframeTrack,
  ValueTypeName: 'vector' // ValueBufferType is inherited
  // DefaultInterpolation is inherited

});

function AnimationClip(name, duration, tracks, blendMode) {
  this.name = name;
  this.tracks = tracks;
  this.duration = duration !== undefined ? duration : -1;
  this.blendMode = blendMode !== undefined ? blendMode : NormalAnimationBlendMode;
  this.uuid = MathUtils.generateUUID(); // this means it should figure out its duration by scanning the tracks

  if (this.duration < 0) {
    this.resetDuration();
  }
}

function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case 'scalar':
    case 'double':
    case 'float':
    case 'number':
    case 'integer':
      return NumberKeyframeTrack;

    case 'vector':
    case 'vector2':
    case 'vector3':
    case 'vector4':
      return VectorKeyframeTrack;

    case 'color':
      return ColorKeyframeTrack;

    case 'quaternion':
      return QuaternionKeyframeTrack;

    case 'bool':
    case 'boolean':
      return BooleanKeyframeTrack;

    case 'string':
      return StringKeyframeTrack;
  }

  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
}

function parseKeyframeTrack(json) {
  if (json.type === undefined) {
    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
  }

  const trackType = getTrackTypeForValueTypeName(json.type);

  if (json.times === undefined) {
    const times = [],
          values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, 'value');
    json.times = times;
    json.values = values;
  } // derived classes can define a static parse method


  if (trackType.parse !== undefined) {
    return trackType.parse(json);
  } else {
    // by default, we assume a constructor compatible with the base
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}

Object.assign(AnimationClip, {
  parse: function (json) {
    const tracks = [],
          jsonTracks = json.tracks,
          frameTime = 1.0 / (json.fps || 1.0);

    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
    }

    return new AnimationClip(json.name, json.duration, tracks, json.blendMode);
  },
  toJSON: function (clip) {
    const tracks = [],
          clipTracks = clip.tracks;
    const json = {
      'name': clip.name,
      'duration': clip.duration,
      'tracks': tracks,
      'uuid': clip.uuid,
      'blendMode': clip.blendMode
    };

    for (let i = 0, n = clipTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
    }

    return json;
  },
  CreateFromMorphTargetSequence: function (name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];

    for (let i = 0; i < numMorphTargets; i++) {
      let times = [];
      let values = [];
      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
      values.push(0, 1, 0);
      const order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the
      // last frame as well for perfect loop.

      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }

      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
    }

    return new AnimationClip(name, -1, tracks);
  },
  findByName: function (objectOrClipArray, name) {
    let clipArray = objectOrClipArray;

    if (!Array.isArray(objectOrClipArray)) {
      const o = objectOrClipArray;
      clipArray = o.geometry && o.geometry.animations || o.animations;
    }

    for (let i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name) {
        return clipArray[i];
      }
    }

    return null;
  },
  CreateClipsFromMorphTargetSequences: function (morphTargets, fps, noLoop) {
    const animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences
    // such flamingo_flyA_003, flamingo_run1_003, crdeath0059

    const pattern = /^([\w-]*?)([\d]+)$/; // sort morph target names into animation groups based
    // patterns like Walk_001, Walk_002, Run_001, Run_002

    for (let i = 0, il = morphTargets.length; i < il; i++) {
      const morphTarget = morphTargets[i];
      const parts = morphTarget.name.match(pattern);

      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];

        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }

        animationMorphTargets.push(morphTarget);
      }
    }

    const clips = [];

    for (const name in animationToMorphTargets) {
      clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }

    return clips;
  },
  // parse the animation.hierarchy format
  parseAnimation: function (animation, bones) {
    if (!animation) {
      console.error('THREE.AnimationClip: No animation in JSONLoader data.');
      return null;
    }

    const addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
      // only return track if there are actually keys.
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again

        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };

    const tracks = [];
    const clipName = animation.name || 'default';
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode; // automatic length determination in AnimationClip.

    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];

    for (let h = 0; h < hierarchyTracks.length; h++) {
      const animationKeys = hierarchyTracks[h].keys; // skip empty tracks

      if (!animationKeys || animationKeys.length === 0) continue; // process morph targets

      if (animationKeys[0].morphTargets) {
        // figure out all morph targets used in this track
        const morphTargetNames = {};
        let k;

        for (k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
            }
          }
        } // create a track for each morph target with all zero
        // morphTargetInfluences except for the keys in which
        // the morphTarget is named.


        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];

          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
            const animationKey = animationKeys[k];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }

          tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
        }

        duration = morphTargetNames.length * (fps || 1.0);
      } else {
        // ...assume skeletal animation
        const boneName = '.bones[' + bones[h].name + ']';
        addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
      }
    }

    if (tracks.length === 0) {
      return null;
    }

    const clip = new AnimationClip(clipName, duration, tracks, blendMode);
    return clip;
  }
});
Object.assign(AnimationClip.prototype, {
  resetDuration: function () {
    const tracks = this.tracks;
    let duration = 0;

    for (let i = 0, n = tracks.length; i !== n; ++i) {
      const track = this.tracks[i];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }

    this.duration = duration;
    return this;
  },
  trim: function () {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].trim(0, this.duration);
    }

    return this;
  },
  validate: function () {
    let valid = true;

    for (let i = 0; i < this.tracks.length; i++) {
      valid = valid && this.tracks[i].validate();
    }

    return valid;
  },
  optimize: function () {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].optimize();
    }

    return this;
  },
  clone: function () {
    const tracks = [];

    for (let i = 0; i < this.tracks.length; i++) {
      tracks.push(this.tracks[i].clone());
    }

    return new AnimationClip(this.name, this.duration, tracks, this.blendMode);
  }
});
const Cache = {
  enabled: false,
  files: {},
  add: function (key, file) {
    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );

    this.files[key] = file;
  },
  get: function (key) {
    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );

    return this.files[key];
  },
  remove: function (key) {
    delete this.files[key];
  },
  clear: function () {
    this.files = {};
  }
};
exports.Cache = Cache;

function LoadingManager(onLoad, onProgress, onError) {
  const scope = this;
  let isLoading = false;
  let itemsLoaded = 0;
  let itemsTotal = 0;
  let urlModifier = undefined;
  const handlers = []; // Refer to #5689 for the reason why we don't set .onStart
  // in the constructor

  this.onStart = undefined;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;

  this.itemStart = function (url) {
    itemsTotal++;

    if (isLoading === false) {
      if (scope.onStart !== undefined) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }

    isLoading = true;
  };

  this.itemEnd = function (url) {
    itemsLoaded++;

    if (scope.onProgress !== undefined) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }

    if (itemsLoaded === itemsTotal) {
      isLoading = false;

      if (scope.onLoad !== undefined) {
        scope.onLoad();
      }
    }
  };

  this.itemError = function (url) {
    if (scope.onError !== undefined) {
      scope.onError(url);
    }
  };

  this.resolveURL = function (url) {
    if (urlModifier) {
      return urlModifier(url);
    }

    return url;
  };

  this.setURLModifier = function (transform) {
    urlModifier = transform;
    return this;
  };

  this.addHandler = function (regex, loader) {
    handlers.push(regex, loader);
    return this;
  };

  this.removeHandler = function (regex) {
    const index = handlers.indexOf(regex);

    if (index !== -1) {
      handlers.splice(index, 2);
    }

    return this;
  };

  this.getHandler = function (file) {
    for (let i = 0, l = handlers.length; i < l; i += 2) {
      const regex = handlers[i];
      const loader = handlers[i + 1];
      if (regex.global) regex.lastIndex = 0; // see #17920

      if (regex.test(file)) {
        return loader;
      }
    }

    return null;
  };
}

const DefaultLoadingManager = new LoadingManager();
exports.DefaultLoadingManager = DefaultLoadingManager;

function Loader(manager) {
  this.manager = manager !== undefined ? manager : DefaultLoadingManager;
  this.crossOrigin = 'anonymous';
  this.path = '';
  this.resourcePath = '';
  this.requestHeader = {};
}

Object.assign(Loader.prototype, {
  load: function ()
  /* url, onLoad, onProgress, onError */
  {},
  loadAsync: function (url, onProgress) {
    const scope = this;
    return new Promise(function (resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  },
  parse: function ()
  /* data */
  {},
  setCrossOrigin: function (crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  },
  setPath: function (path) {
    this.path = path;
    return this;
  },
  setResourcePath: function (resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  },
  setRequestHeader: function (requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
});
const loading = {};

function FileLoader(manager) {
  Loader.call(this, manager);
}

FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: FileLoader,
  load: function (url, onLoad, onProgress, onError) {
    if (url === undefined) url = '';
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);

    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    } // Check if request is duplicate


    if (loading[url] !== undefined) {
      loading[url].push({
        onLoad: onLoad,
        onProgress: onProgress,
        onError: onError
      });
      return;
    } // Check for data: URI


    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    const dataUriRegexResult = url.match(dataUriRegex);
    let request; // Safari can not handle Data URIs through XMLHttpRequest so process manually

    if (dataUriRegexResult) {
      const mimeType = dataUriRegexResult[1];
      const isBase64 = !!dataUriRegexResult[2];
      let data = dataUriRegexResult[3];
      data = decodeURIComponent(data);
      if (isBase64) data = atob(data);

      try {
        let response;
        const responseType = (this.responseType || '').toLowerCase();

        switch (responseType) {
          case 'arraybuffer':
          case 'blob':
            const view = new Uint8Array(data.length);

            for (let i = 0; i < data.length; i++) {
              view[i] = data.charCodeAt(i);
            }

            if (responseType === 'blob') {
              response = new Blob([view.buffer], {
                type: mimeType
              });
            } else {
              response = view.buffer;
            }

            break;

          case 'document':
            const parser = new DOMParser();
            response = parser.parseFromString(data, mimeType);
            break;

          case 'json':
            response = JSON.parse(data);
            break;

          default:
            // 'text' or other
            response = data;
            break;
        } // Wait for next browser tick like standard XMLHttpRequest event dispatching does


        setTimeout(function () {
          if (onLoad) onLoad(response);
          scope.manager.itemEnd(url);
        }, 0);
      } catch (error) {
        // Wait for next browser tick like standard XMLHttpRequest event dispatching does
        setTimeout(function () {
          if (onError) onError(error);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, 0);
      }
    } else {
      // Initialise array for duplicate requests
      loading[url] = [];
      loading[url].push({
        onLoad: onLoad,
        onProgress: onProgress,
        onError: onError
      });
      request = new XMLHttpRequest();
      request.open('GET', url, true);
      request.addEventListener('load', function (event) {
        const response = this.response;
        const callbacks = loading[url];
        delete loading[url];

        if (this.status === 200 || this.status === 0) {
          // Some browsers return HTTP Status 0 when using non-http protocol
          // e.g. 'file://' or 'data://'. Handle as success.
          if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.'); // Add to cache only on HTTP success, so that we do not cache
          // error response bodies as proper responses to requests.

          Cache.add(url, response);

          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onLoad) callback.onLoad(response);
          }

          scope.manager.itemEnd(url);
        } else {
          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onError) callback.onError(event);
          }

          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
      }, false);
      request.addEventListener('progress', function (event) {
        const callbacks = loading[url];

        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onProgress) callback.onProgress(event);
        }
      }, false);
      request.addEventListener('error', function (event) {
        const callbacks = loading[url];
        delete loading[url];

        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onError) callback.onError(event);
        }

        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      request.addEventListener('abort', function (event) {
        const callbacks = loading[url];
        delete loading[url];

        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onError) callback.onError(event);
        }

        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      if (this.responseType !== undefined) request.responseType = this.responseType;
      if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
      if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

      for (const header in this.requestHeader) {
        request.setRequestHeader(header, this.requestHeader[header]);
      }

      request.send(null);
    }

    scope.manager.itemStart(url);
    return request;
  },
  setResponseType: function (value) {
    this.responseType = value;
    return this;
  },
  setWithCredentials: function (value) {
    this.withCredentials = value;
    return this;
  },
  setMimeType: function (value) {
    this.mimeType = value;
    return this;
  }
});

function AnimationLoader(manager) {
  Loader.call(this, manager);
}

AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: AnimationLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.load(url, function (text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }

        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  },
  parse: function (json) {
    const animations = [];

    for (let i = 0; i < json.length; i++) {
      const clip = AnimationClip.parse(json[i]);
      animations.push(clip);
    }

    return animations;
  }
});
/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function CompressedTextureLoader(manager) {
  Loader.call(this, manager);
}

CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: CompressedTextureLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const images = [];
    const texture = new CompressedTexture();
    texture.image = images;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType('arraybuffer');
    loader.setRequestHeader(this.requestHeader);
    let loaded = 0;

    function loadTexture(i) {
      loader.load(url[i], function (buffer) {
        const texDatas = scope.parse(buffer, true);
        images[i] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;

        if (loaded === 6) {
          if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, onProgress, onError);
    }

    if (Array.isArray(url)) {
      for (let i = 0, il = url.length; i < il; ++i) {
        loadTexture(i);
      }
    } else {
      // compressed cubemap texture stored in a single DDS file
      loader.load(url, function (buffer) {
        const texDatas = scope.parse(buffer, true);

        if (texDatas.isCubemap) {
          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

          for (let f = 0; f < faces; f++) {
            images[f] = {
              mipmaps: []
            };

            for (let i = 0; i < texDatas.mipmapCount; i++) {
              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
              images[f].format = texDatas.format;
              images[f].width = texDatas.width;
              images[f].height = texDatas.height;
            }
          }
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }

        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }

        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad) onLoad(texture);
      }, onProgress, onError);
    }

    return texture;
  }
});

function ImageLoader(manager) {
  Loader.call(this, manager);
}

ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ImageLoader,
  load: function (url, onLoad, onProgress, onError) {
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);

    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }

    const image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');

    function onImageLoad() {
      image.removeEventListener('load', onImageLoad, false);
      image.removeEventListener('error', onImageError, false);
      Cache.add(url, this);
      if (onLoad) onLoad(this);
      scope.manager.itemEnd(url);
    }

    function onImageError(event) {
      image.removeEventListener('load', onImageLoad, false);
      image.removeEventListener('error', onImageError, false);
      if (onError) onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }

    image.addEventListener('load', onImageLoad, false);
    image.addEventListener('error', onImageError, false);

    if (url.substr(0, 5) !== 'data:') {
      if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
    }

    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
});

function CubeTextureLoader(manager) {
  Loader.call(this, manager);
}

CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: CubeTextureLoader,
  load: function (urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;

    function loadTexture(i) {
      loader.load(urls[i], function (image) {
        texture.images[i] = image;
        loaded++;

        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, undefined, onError);
    }

    for (let i = 0; i < urls.length; ++i) {
      loadTexture(i);
    }

    return texture;
  }
});
/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function DataTextureLoader(manager) {
  Loader.call(this, manager);
}

DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: DataTextureLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const texture = new DataTexture();
    const loader = new FileLoader(this.manager);
    loader.setResponseType('arraybuffer');
    loader.setRequestHeader(this.requestHeader);
    loader.setPath(this.path);
    loader.load(url, function (buffer) {
      const texData = scope.parse(buffer);
      if (!texData) return;

      if (texData.image !== undefined) {
        texture.image = texData.image;
      } else if (texData.data !== undefined) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }

      texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
      texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

      if (texData.format !== undefined) {
        texture.format = texData.format;
      }

      if (texData.type !== undefined) {
        texture.type = texData.type;
      }

      if (texData.mipmaps !== undefined) {
        texture.mipmaps = texData.mipmaps;
        texture.minFilter = LinearMipmapLinearFilter; // presumably...
      }

      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }

      texture.needsUpdate = true;
      if (onLoad) onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  }
});

function TextureLoader(manager) {
  Loader.call(this, manager);
}

TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: TextureLoader,
  load: function (url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function (image) {
      texture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.

      const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? RGBFormat : RGBAFormat;
      texture.needsUpdate = true;

      if (onLoad !== undefined) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
});
/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

function Curve() {
  this.type = 'Curve';
  this.arcLengthDivisions = 200;
}

Object.assign(Curve.prototype, {
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint: function ()
  /* t, optionalTarget */
  {
    console.warn('THREE.Curve: .getPoint() not implemented.');
    return null;
  },
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt: function (u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  },
  // Get sequence of points using getPoint( t )
  getPoints: function (divisions) {
    if (divisions === undefined) divisions = 5;
    const points = [];

    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }

    return points;
  },
  // Get sequence of points using getPointAt( u )
  getSpacedPoints: function (divisions) {
    if (divisions === undefined) divisions = 5;
    const points = [];

    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }

    return points;
  },
  // Get total curve arc length
  getLength: function () {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  },
  // Get list of cumulative segment lengths
  getLengths: function (divisions) {
    if (divisions === undefined) divisions = this.arcLengthDivisions;

    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }

    this.needsUpdate = false;
    const cache = [];
    let current,
        last = this.getPoint(0);
    let sum = 0;
    cache.push(0);

    for (let p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }

    this.cacheArcLengths = cache;
    return cache; // { sums: cache, sum: sum }; Sum is in the last element.
  },
  updateArcLengths: function () {
    this.needsUpdate = true;
    this.getLengths();
  },
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping: function (u, distance) {
    const arcLengths = this.getLengths();
    let i = 0;
    const il = arcLengths.length;
    let targetArcLength; // The targeted u distance value to get

    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    } // binary search for the index with largest value smaller than target u distance


    let low = 0,
        high = il - 1,
        comparison;

    while (low <= high) {
      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

      comparison = arcLengths[i] - targetArcLength;

      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break; // DONE
      }
    }

    i = high;

    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    } // we could get finer grain at lengths, or use simple interpolation between two points


    const lengthBefore = arcLengths[i];
    const lengthAfter = arcLengths[i + 1];
    const segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points

    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t

    const t = (i + segmentFraction) / (il - 1);
    return t;
  },
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent: function (t, optionalTarget) {
    const delta = 0.0001;
    let t1 = t - delta;
    let t2 = t + delta; // Capping in case of danger

    if (t1 < 0) t1 = 0;
    if (t2 > 1) t2 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t2);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  },
  getTangentAt: function (u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getTangent(t, optionalTarget);
  },
  computeFrenetFrames: function (segments, closed) {
    // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4(); // compute the tangent vectors for each segment on the curve

    for (let i = 0; i <= segments; i++) {
      const u = i / segments;
      tangents[i] = this.getTangentAt(u, new Vector3());
      tangents[i].normalize();
    } // select an initial normal vector perpendicular to the first tangent vector,
    // and in the direction of the minimum tangent xyz component


    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);

    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }

    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }

    if (tz <= min) {
      normal.set(0, 0, 1);
    }

    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve

    for (let i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);

      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(MathUtils.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }

      binormals[i].crossVectors(tangents[i], normals[i]);
    } // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same


    if (closed === true) {
      let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;

      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }

      for (let i = 1; i <= segments; i++) {
        // twist a little...
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }

    return {
      tangents: tangents,
      normals: normals,
      binormals: binormals
    };
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  },
  toJSON: function () {
    const data = {
      metadata: {
        version: 4.5,
        type: 'Curve',
        generator: 'Curve.toJSON'
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  },
  fromJSON: function (json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
});

function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
  Curve.call(this);
  this.type = 'EllipseCurve';
  this.aX = aX || 0;
  this.aY = aY || 0;
  this.xRadius = xRadius || 1;
  this.yRadius = yRadius || 1;
  this.aStartAngle = aStartAngle || 0;
  this.aEndAngle = aEndAngle || 2 * Math.PI;
  this.aClockwise = aClockwise || false;
  this.aRotation = aRotation || 0;
}

EllipseCurve.prototype = Object.create(Curve.prototype);
EllipseCurve.prototype.constructor = EllipseCurve;
EllipseCurve.prototype.isEllipseCurve = true;

EllipseCurve.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector2();
  const twoPi = Math.PI * 2;
  let deltaAngle = this.aEndAngle - this.aStartAngle;
  const samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI

  while (deltaAngle < 0) deltaAngle += twoPi;

  while (deltaAngle > twoPi) deltaAngle -= twoPi;

  if (deltaAngle < Number.EPSILON) {
    if (samePoints) {
      deltaAngle = 0;
    } else {
      deltaAngle = twoPi;
    }
  }

  if (this.aClockwise === true && !samePoints) {
    if (deltaAngle === twoPi) {
      deltaAngle = -twoPi;
    } else {
      deltaAngle = deltaAngle - twoPi;
    }
  }

  const angle = this.aStartAngle + t * deltaAngle;
  let x = this.aX + this.xRadius * Math.cos(angle);
  let y = this.aY + this.yRadius * Math.sin(angle);

  if (this.aRotation !== 0) {
    const cos = Math.cos(this.aRotation);
    const sin = Math.sin(this.aRotation);
    const tx = x - this.aX;
    const ty = y - this.aY; // Rotate the point about the center of the ellipse.

    x = tx * cos - ty * sin + this.aX;
    y = tx * sin + ty * cos + this.aY;
  }

  return point.set(x, y);
};

EllipseCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.aX = source.aX;
  this.aY = source.aY;
  this.xRadius = source.xRadius;
  this.yRadius = source.yRadius;
  this.aStartAngle = source.aStartAngle;
  this.aEndAngle = source.aEndAngle;
  this.aClockwise = source.aClockwise;
  this.aRotation = source.aRotation;
  return this;
};

EllipseCurve.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.aX = this.aX;
  data.aY = this.aY;
  data.xRadius = this.xRadius;
  data.yRadius = this.yRadius;
  data.aStartAngle = this.aStartAngle;
  data.aEndAngle = this.aEndAngle;
  data.aClockwise = this.aClockwise;
  data.aRotation = this.aRotation;
  return data;
};

EllipseCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.aX = json.aX;
  this.aY = json.aY;
  this.xRadius = json.xRadius;
  this.yRadius = json.yRadius;
  this.aStartAngle = json.aStartAngle;
  this.aEndAngle = json.aEndAngle;
  this.aClockwise = json.aClockwise;
  this.aRotation = json.aRotation;
  return this;
};

function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
  EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
  this.type = 'ArcCurve';
}

ArcCurve.prototype = Object.create(EllipseCurve.prototype);
ArcCurve.prototype.constructor = ArcCurve;
ArcCurve.prototype.isArcCurve = true;
/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {
  let c0 = 0,
      c1 = 0,
      c2 = 0,
      c3 = 0;
  /*
   * Compute coefficients for a cubic polynomial
   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
   * such that
   *   p(0) = x0, p(1) = x1
   *  and
   *   p'(0) = t0, p'(1) = t1.
   */

  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }

  return {
    initCatmullRom: function (x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
      // compute tangents when parameterized in [t1,t2]
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]

      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function (t) {
      const t2 = t * t;
      const t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
} //


const tmp = new Vector3();
const px = new CubicPoly(),
      py = new CubicPoly(),
      pz = new CubicPoly();

function CatmullRomCurve3(points, closed, curveType, tension) {
  Curve.call(this);
  this.type = 'CatmullRomCurve3';
  this.points = points || [];
  this.closed = closed || false;
  this.curveType = curveType || 'centripetal';
  this.tension = tension !== undefined ? tension : 0.5;
}

CatmullRomCurve3.prototype = Object.create(Curve.prototype);
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

CatmullRomCurve3.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector3();
  const points = this.points;
  const l = points.length;
  const p = (l - (this.closed ? 0 : 1)) * t;
  let intPoint = Math.floor(p);
  let weight = p - intPoint;

  if (this.closed) {
    intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
  } else if (weight === 0 && intPoint === l - 1) {
    intPoint = l - 2;
    weight = 1;
  }

  let p0, p3; // 4 points (p1 & p2 defined below)

  if (this.closed || intPoint > 0) {
    p0 = points[(intPoint - 1) % l];
  } else {
    // extrapolate first point
    tmp.subVectors(points[0], points[1]).add(points[0]);
    p0 = tmp;
  }

  const p1 = points[intPoint % l];
  const p2 = points[(intPoint + 1) % l];

  if (this.closed || intPoint + 2 < l) {
    p3 = points[(intPoint + 2) % l];
  } else {
    // extrapolate last point
    tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
    p3 = tmp;
  }

  if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
    // init Centripetal / Chordal Catmull-Rom
    const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
    let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
    let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
    let dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points

    if (dt1 < 1e-4) dt1 = 1.0;
    if (dt0 < 1e-4) dt0 = dt1;
    if (dt2 < 1e-4) dt2 = dt1;
    px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
    py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
    pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
  } else if (this.curveType === 'catmullrom') {
    px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
    py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
    pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
  }

  point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
  return point;
};

CatmullRomCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.points = [];

  for (let i = 0, l = source.points.length; i < l; i++) {
    const point = source.points[i];
    this.points.push(point.clone());
  }

  this.closed = source.closed;
  this.curveType = source.curveType;
  this.tension = source.tension;
  return this;
};

CatmullRomCurve3.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.points = [];

  for (let i = 0, l = this.points.length; i < l; i++) {
    const point = this.points[i];
    data.points.push(point.toArray());
  }

  data.closed = this.closed;
  data.curveType = this.curveType;
  data.tension = this.tension;
  return data;
};

CatmullRomCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.points = [];

  for (let i = 0, l = json.points.length; i < l; i++) {
    const point = json.points[i];
    this.points.push(new Vector3().fromArray(point));
  }

  this.closed = json.closed;
  this.curveType = json.curveType;
  this.tension = json.tension;
  return this;
};
/**
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bézier_curve
 */


function CatmullRom(t, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t2 = t * t;
  const t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
} //


function QuadraticBezierP0(t, p) {
  const k = 1 - t;
  return k * k * p;
}

function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}

function QuadraticBezierP2(t, p) {
  return t * t * p;
}

function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
} //


function CubicBezierP0(t, p) {
  const k = 1 - t;
  return k * k * k * p;
}

function CubicBezierP1(t, p) {
  const k = 1 - t;
  return 3 * k * k * t * p;
}

function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}

function CubicBezierP3(t, p) {
  return t * t * t * p;
}

function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}

function CubicBezierCurve(v0, v1, v2, v3) {
  Curve.call(this);
  this.type = 'CubicBezierCurve';
  this.v0 = v0 || new Vector2();
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
  this.v3 = v3 || new Vector2();
}

CubicBezierCurve.prototype = Object.create(Curve.prototype);
CubicBezierCurve.prototype.constructor = CubicBezierCurve;
CubicBezierCurve.prototype.isCubicBezierCurve = true;

CubicBezierCurve.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector2();
  const v0 = this.v0,
        v1 = this.v1,
        v2 = this.v2,
        v3 = this.v3;
  point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
  return point;
};

CubicBezierCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  this.v3.copy(source.v3);
  return this;
};

CubicBezierCurve.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  data.v3 = this.v3.toArray();
  return data;
};

CubicBezierCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  this.v3.fromArray(json.v3);
  return this;
};

function CubicBezierCurve3(v0, v1, v2, v3) {
  Curve.call(this);
  this.type = 'CubicBezierCurve3';
  this.v0 = v0 || new Vector3();
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
  this.v3 = v3 || new Vector3();
}

CubicBezierCurve3.prototype = Object.create(Curve.prototype);
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

CubicBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector3();
  const v0 = this.v0,
        v1 = this.v1,
        v2 = this.v2,
        v3 = this.v3;
  point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
  return point;
};

CubicBezierCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  this.v3.copy(source.v3);
  return this;
};

CubicBezierCurve3.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  data.v3 = this.v3.toArray();
  return data;
};

CubicBezierCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  this.v3.fromArray(json.v3);
  return this;
};

function LineCurve(v1, v2) {
  Curve.call(this);
  this.type = 'LineCurve';
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
}

LineCurve.prototype = Object.create(Curve.prototype);
LineCurve.prototype.constructor = LineCurve;
LineCurve.prototype.isLineCurve = true;

LineCurve.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector2();

  if (t === 1) {
    point.copy(this.v2);
  } else {
    point.copy(this.v2).sub(this.v1);
    point.multiplyScalar(t).add(this.v1);
  }

  return point;
}; // Line curve is linear, so we can overwrite default getPointAt


LineCurve.prototype.getPointAt = function (u, optionalTarget) {
  return this.getPoint(u, optionalTarget);
};

LineCurve.prototype.getTangent = function (t, optionalTarget) {
  const tangent = optionalTarget || new Vector2();
  tangent.copy(this.v2).sub(this.v1).normalize();
  return tangent;
};

LineCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};

LineCurve.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};

LineCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};

function LineCurve3(v1, v2) {
  Curve.call(this);
  this.type = 'LineCurve3';
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
}

LineCurve3.prototype = Object.create(Curve.prototype);
LineCurve3.prototype.constructor = LineCurve3;
LineCurve3.prototype.isLineCurve3 = true;

LineCurve3.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector3();

  if (t === 1) {
    point.copy(this.v2);
  } else {
    point.copy(this.v2).sub(this.v1);
    point.multiplyScalar(t).add(this.v1);
  }

  return point;
}; // Line curve is linear, so we can overwrite default getPointAt


LineCurve3.prototype.getPointAt = function (u, optionalTarget) {
  return this.getPoint(u, optionalTarget);
};

LineCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};

LineCurve3.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};

LineCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};

function QuadraticBezierCurve(v0, v1, v2) {
  Curve.call(this);
  this.type = 'QuadraticBezierCurve';
  this.v0 = v0 || new Vector2();
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
}

QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

QuadraticBezierCurve.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector2();
  const v0 = this.v0,
        v1 = this.v1,
        v2 = this.v2;
  point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
  return point;
};

QuadraticBezierCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};

QuadraticBezierCurve.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};

QuadraticBezierCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};

function QuadraticBezierCurve3(v0, v1, v2) {
  Curve.call(this);
  this.type = 'QuadraticBezierCurve3';
  this.v0 = v0 || new Vector3();
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
}

QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

QuadraticBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector3();
  const v0 = this.v0,
        v1 = this.v1,
        v2 = this.v2;
  point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
  return point;
};

QuadraticBezierCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};

QuadraticBezierCurve3.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};

QuadraticBezierCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};

function SplineCurve(points) {
  Curve.call(this);
  this.type = 'SplineCurve';
  this.points = points || [];
}

SplineCurve.prototype = Object.create(Curve.prototype);
SplineCurve.prototype.constructor = SplineCurve;
SplineCurve.prototype.isSplineCurve = true;

SplineCurve.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector2();
  const points = this.points;
  const p = (points.length - 1) * t;
  const intPoint = Math.floor(p);
  const weight = p - intPoint;
  const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
  const p1 = points[intPoint];
  const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
  const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
  point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
  return point;
};

SplineCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.points = [];

  for (let i = 0, l = source.points.length; i < l; i++) {
    const point = source.points[i];
    this.points.push(point.clone());
  }

  return this;
};

SplineCurve.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.points = [];

  for (let i = 0, l = this.points.length; i < l; i++) {
    const point = this.points[i];
    data.points.push(point.toArray());
  }

  return data;
};

SplineCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.points = [];

  for (let i = 0, l = json.points.length; i < l; i++) {
    const point = json.points[i];
    this.points.push(new Vector2().fromArray(point));
  }

  return this;
};

var Curves = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ArcCurve: ArcCurve,
  CatmullRomCurve3: CatmullRomCurve3,
  CubicBezierCurve: CubicBezierCurve,
  CubicBezierCurve3: CubicBezierCurve3,
  EllipseCurve: EllipseCurve,
  LineCurve: LineCurve,
  LineCurve3: LineCurve3,
  QuadraticBezierCurve: QuadraticBezierCurve,
  QuadraticBezierCurve3: QuadraticBezierCurve3,
  SplineCurve: SplineCurve
});
/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

function CurvePath() {
  Curve.call(this);
  this.type = 'CurvePath';
  this.curves = [];
  this.autoClose = false; // Automatically closes the path
}

CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
  constructor: CurvePath,
  add: function (curve) {
    this.curves.push(curve);
  },
  closePath: function () {
    // Add a line curve if start and end of lines are not connected
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);

    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  },
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint: function (t) {
    const d = t * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i = 0; // To think about boundaries points.

    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        const diff = curveLengths[i] - d;
        const curve = this.curves[i];
        const segmentLength = curve.getLength();
        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u);
      }

      i++;
    }

    return null; // loop where sum != 0, sum > d , sum+1 <d
  },
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength: function () {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  },
  // cacheLengths must be recalculated.
  updateArcLengths: function () {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  },
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths: function () {
    // We use cache values if curves and cache array are same length
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    } // Get length of sub-curve
    // Push sums into cached array


    const lengths = [];
    let sums = 0;

    for (let i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }

    this.cacheLengths = lengths;
    return lengths;
  },
  getSpacedPoints: function (divisions) {
    if (divisions === undefined) divisions = 40;
    const points = [];

    for (let i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }

    if (this.autoClose) {
      points.push(points[0]);
    }

    return points;
  },
  getPoints: function (divisions) {
    divisions = divisions || 12;
    const points = [];
    let last;

    for (let i = 0, curves = this.curves; i < curves.length; i++) {
      const curve = curves[i];
      const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);

      for (let j = 0; j < pts.length; j++) {
        const point = pts[j];
        if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

        points.push(point);
        last = point;
      }
    }

    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }

    return points;
  },
  copy: function (source) {
    Curve.prototype.copy.call(this, source);
    this.curves = [];

    for (let i = 0, l = source.curves.length; i < l; i++) {
      const curve = source.curves[i];
      this.curves.push(curve.clone());
    }

    this.autoClose = source.autoClose;
    return this;
  },
  toJSON: function () {
    const data = Curve.prototype.toJSON.call(this);
    data.autoClose = this.autoClose;
    data.curves = [];

    for (let i = 0, l = this.curves.length; i < l; i++) {
      const curve = this.curves[i];
      data.curves.push(curve.toJSON());
    }

    return data;
  },
  fromJSON: function (json) {
    Curve.prototype.fromJSON.call(this, json);
    this.autoClose = json.autoClose;
    this.curves = [];

    for (let i = 0, l = json.curves.length; i < l; i++) {
      const curve = json.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }

    return this;
  }
});

function Path(points) {
  CurvePath.call(this);
  this.type = 'Path';
  this.currentPoint = new Vector2();

  if (points) {
    this.setFromPoints(points);
  }
}

Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
  constructor: Path,
  setFromPoints: function (points) {
    this.moveTo(points[0].x, points[0].y);

    for (let i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y);
    }

    return this;
  },
  moveTo: function (x, y) {
    this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

    return this;
  },
  lineTo: function (x, y) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
    this.curves.push(curve);
    this.currentPoint.set(x, y);
    return this;
  },
  quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  },
  bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  },
  splineThru: function (pts
  /*Array of Vector*/
  ) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  },
  arc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  },
  absarc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  },
  ellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  },
  absellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

    if (this.curves.length > 0) {
      // if a previous curve is present, attempt to join
      const firstPoint = curve.getPoint(0);

      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }

    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  },
  copy: function (source) {
    CurvePath.prototype.copy.call(this, source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  },
  toJSON: function () {
    const data = CurvePath.prototype.toJSON.call(this);
    data.currentPoint = this.currentPoint.toArray();
    return data;
  },
  fromJSON: function (json) {
    CurvePath.prototype.fromJSON.call(this, json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
});

function Shape(points) {
  Path.call(this, points);
  this.uuid = MathUtils.generateUUID();
  this.type = 'Shape';
  this.holes = [];
}

Shape.prototype = Object.assign(Object.create(Path.prototype), {
  constructor: Shape,
  getPointsHoles: function (divisions) {
    const holesPts = [];

    for (let i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }

    return holesPts;
  },
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints: function (divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  },
  copy: function (source) {
    Path.prototype.copy.call(this, source);
    this.holes = [];

    for (let i = 0, l = source.holes.length; i < l; i++) {
      const hole = source.holes[i];
      this.holes.push(hole.clone());
    }

    return this;
  },
  toJSON: function () {
    const data = Path.prototype.toJSON.call(this);
    data.uuid = this.uuid;
    data.holes = [];

    for (let i = 0, l = this.holes.length; i < l; i++) {
      const hole = this.holes[i];
      data.holes.push(hole.toJSON());
    }

    return data;
  },
  fromJSON: function (json) {
    Path.prototype.fromJSON.call(this, json);
    this.uuid = json.uuid;
    this.holes = [];

    for (let i = 0, l = json.holes.length; i < l; i++) {
      const hole = json.holes[i];
      this.holes.push(new Path().fromJSON(hole));
    }

    return this;
  }
});

function Light(color, intensity) {
  Object3D.call(this);
  this.type = 'Light';
  this.color = new Color(color);
  this.intensity = intensity !== undefined ? intensity : 1;
  this.receiveShadow = undefined;
}

Light.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Light,
  isLight: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  },
  toJSON: function (meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== undefined) data.object.distance = this.distance;
    if (this.angle !== undefined) data.object.angle = this.angle;
    if (this.decay !== undefined) data.object.decay = this.decay;
    if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
    if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
    return data;
  }
});

function HemisphereLight(skyColor, groundColor, intensity) {
  Light.call(this, skyColor, intensity);
  this.type = 'HemisphereLight';
  this.castShadow = undefined;
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.groundColor = new Color(groundColor);
}

HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: HemisphereLight,
  isHemisphereLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }
});

function LightShadow(camera) {
  this.camera = camera;
  this.bias = 0;
  this.normalBias = 0;
  this.radius = 1;
  this.mapSize = new Vector2(512, 512);
  this.map = null;
  this.mapPass = null;
  this.matrix = new Matrix4();
  this.autoUpdate = true;
  this.needsUpdate = false;
  this._frustum = new Frustum();
  this._frameExtents = new Vector2(1, 1);
  this._viewportCount = 1;
  this._viewports = [new Vector4(0, 0, 1, 1)];
}

Object.assign(LightShadow.prototype, {
  _projScreenMatrix: new Matrix4(),
  _lightPositionWorld: new Vector3(),
  _lookTarget: new Vector3(),
  getViewportCount: function () {
    return this._viewportCount;
  },
  getFrustum: function () {
    return this._frustum;
  },
  updateMatrices: function (light) {
    const shadowCamera = this.camera,
          shadowMatrix = this.matrix,
          projScreenMatrix = this._projScreenMatrix,
          lookTarget = this._lookTarget,
          lightPositionWorld = this._lightPositionWorld;
    lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(lightPositionWorld);
    lookTarget.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(lookTarget);
    shadowCamera.updateMatrixWorld();
    projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);

    this._frustum.setFromProjectionMatrix(projScreenMatrix);

    shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  },
  getViewport: function (viewportIndex) {
    return this._viewports[viewportIndex];
  },
  getFrameExtents: function () {
    return this._frameExtents;
  },
  copy: function (source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  toJSON: function () {
    const object = {};
    if (this.bias !== 0) object.bias = this.bias;
    if (this.normalBias !== 0) object.normalBias = this.normalBias;
    if (this.radius !== 1) object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
});

function SpotLightShadow() {
  LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
}

SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: SpotLightShadow,
  isSpotLightShadow: true,
  updateMatrices: function (light) {
    const camera = this.camera;
    const fov = MathUtils.RAD2DEG * 2 * light.angle;
    const aspect = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;

    if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
      camera.fov = fov;
      camera.aspect = aspect;
      camera.far = far;
      camera.updateProjectionMatrix();
    }

    LightShadow.prototype.updateMatrices.call(this, light);
  }
});

function SpotLight(color, intensity, distance, angle, penumbra, decay) {
  Light.call(this, color, intensity);
  this.type = 'SpotLight';
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  Object.defineProperty(this, 'power', {
    get: function () {
      // intensity = power per solid angle.
      // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      return this.intensity * Math.PI;
    },
    set: function (power) {
      // intensity = power per solid angle.
      // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      this.intensity = power / Math.PI;
    }
  });
  this.distance = distance !== undefined ? distance : 0;
  this.angle = angle !== undefined ? angle : Math.PI / 3;
  this.penumbra = penumbra !== undefined ? penumbra : 0;
  this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.

  this.shadow = new SpotLightShadow();
}

SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: SpotLight,
  isSpotLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
});

function PointLightShadow() {
  LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
  this._frameExtents = new Vector2(4, 2);
  this._viewportCount = 6;
  this._viewports = [// These viewports map a cube-map onto a 2D texture with the
  // following orientation:
  //
  //  xzXZ
  //   y Y
  //
  // X - Positive x direction
  // x - Negative x direction
  // Y - Positive y direction
  // y - Negative y direction
  // Z - Positive z direction
  // z - Negative z direction
  // positive X
  new Vector4(2, 1, 1, 1), // negative X
  new Vector4(0, 1, 1, 1), // positive Z
  new Vector4(3, 1, 1, 1), // negative Z
  new Vector4(1, 1, 1, 1), // positive Y
  new Vector4(3, 0, 1, 1), // negative Y
  new Vector4(1, 0, 1, 1)];
  this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
  this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
}

PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: PointLightShadow,
  isPointLightShadow: true,
  updateMatrices: function (light, viewportIndex) {
    if (viewportIndex === undefined) viewportIndex = 0;
    const camera = this.camera,
          shadowMatrix = this.matrix,
          lightPositionWorld = this._lightPositionWorld,
          lookTarget = this._lookTarget,
          projScreenMatrix = this._projScreenMatrix;
    lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(lightPositionWorld);
    lookTarget.copy(camera.position);
    lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);
    projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

    this._frustum.setFromProjectionMatrix(projScreenMatrix);
  }
});

function PointLight(color, intensity, distance, decay) {
  Light.call(this, color, intensity);
  this.type = 'PointLight';
  Object.defineProperty(this, 'power', {
    get: function () {
      // intensity = power per solid angle.
      // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      return this.intensity * 4 * Math.PI;
    },
    set: function (power) {
      // intensity = power per solid angle.
      // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      this.intensity = power / (4 * Math.PI);
    }
  });
  this.distance = distance !== undefined ? distance : 0;
  this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.

  this.shadow = new PointLightShadow();
}

PointLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: PointLight,
  isPointLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
});

function OrthographicCamera(left, right, top, bottom, near, far) {
  Camera.call(this);
  this.type = 'OrthographicCamera';
  this.zoom = 1;
  this.view = null;
  this.left = left !== undefined ? left : -1;
  this.right = right !== undefined ? right : 1;
  this.top = top !== undefined ? top : 1;
  this.bottom = bottom !== undefined ? bottom : -1;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;
  this.updateProjectionMatrix();
}

OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: OrthographicCamera,
  isOrthographicCamera: true,
  copy: function (source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  },
  setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }

    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function () {
    if (this.view !== null) {
      this.view.enabled = false;
    }

    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function () {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;

    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }

    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function (meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }
});

function DirectionalLightShadow() {
  LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
}

DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: DirectionalLightShadow,
  isDirectionalLightShadow: true,
  updateMatrices: function (light) {
    LightShadow.prototype.updateMatrices.call(this, light);
  }
});

function DirectionalLight(color, intensity) {
  Light.call(this, color, intensity);
  this.type = 'DirectionalLight';
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  this.shadow = new DirectionalLightShadow();
}

DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: DirectionalLight,
  isDirectionalLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
});

function AmbientLight(color, intensity) {
  Light.call(this, color, intensity);
  this.type = 'AmbientLight';
  this.castShadow = undefined;
}

AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: AmbientLight,
  isAmbientLight: true
});

function RectAreaLight(color, intensity, width, height) {
  Light.call(this, color, intensity);
  this.type = 'RectAreaLight';
  this.width = width !== undefined ? width : 10;
  this.height = height !== undefined ? height : 10;
}

RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: RectAreaLight,
  isRectAreaLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.width = source.width;
    this.height = source.height;
    return this;
  },
  toJSON: function (meta) {
    const data = Light.prototype.toJSON.call(this, meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
});
/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */
// 3-band SH defined by 9 coefficients

class SphericalHarmonics3 {
  constructor() {
    Object.defineProperty(this, 'isSphericalHarmonics3', {
      value: true
    });
    this.coefficients = [];

    for (let i = 0; i < 9; i++) {
      this.coefficients.push(new Vector3());
    }
  }

  set(coefficients) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].copy(coefficients[i]);
    }

    return this;
  }

  zero() {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].set(0, 0, 0);
    }

    return this;
  } // get the radiance in the direction of the normal
  // target is a Vector3


  getAt(normal, target) {
    // normal is assumed to be unit length
    const x = normal.x,
          y = normal.y,
          z = normal.z;
    const coeff = this.coefficients; // band 0

    target.copy(coeff[0]).multiplyScalar(0.282095); // band 1

    target.addScaledVector(coeff[1], 0.488603 * y);
    target.addScaledVector(coeff[2], 0.488603 * z);
    target.addScaledVector(coeff[3], 0.488603 * x); // band 2

    target.addScaledVector(coeff[4], 1.092548 * (x * y));
    target.addScaledVector(coeff[5], 1.092548 * (y * z));
    target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
    target.addScaledVector(coeff[7], 1.092548 * (x * z));
    target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
    return target;
  } // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf


  getIrradianceAt(normal, target) {
    // normal is assumed to be unit length
    const x = normal.x,
          y = normal.y,
          z = normal.z;
    const coeff = this.coefficients; // band 0

    target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095
    // band 1

    target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603

    target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
    target.addScaledVector(coeff[3], 2.0 * 0.511664 * x); // band 2

    target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548

    target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3

    target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
    target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274

    return target;
  }

  add(sh) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].add(sh.coefficients[i]);
    }

    return this;
  }

  addScaledSH(sh, s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].addScaledVector(sh.coefficients[i], s);
    }

    return this;
  }

  scale(s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].multiplyScalar(s);
    }

    return this;
  }

  lerp(sh, alpha) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].lerp(sh.coefficients[i], alpha);
    }

    return this;
  }

  equals(sh) {
    for (let i = 0; i < 9; i++) {
      if (!this.coefficients[i].equals(sh.coefficients[i])) {
        return false;
      }
    }

    return true;
  }

  copy(sh) {
    return this.set(sh.coefficients);
  }

  clone() {
    return new this.constructor().copy(this);
  }

  fromArray(array, offset) {
    if (offset === undefined) offset = 0;
    const coefficients = this.coefficients;

    for (let i = 0; i < 9; i++) {
      coefficients[i].fromArray(array, offset + i * 3);
    }

    return this;
  }

  toArray(array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    const coefficients = this.coefficients;

    for (let i = 0; i < 9; i++) {
      coefficients[i].toArray(array, offset + i * 3);
    }

    return array;
  } // evaluate the basis functions
  // shBasis is an Array[ 9 ]


  static getBasisAt(normal, shBasis) {
    // normal is assumed to be unit length
    const x = normal.x,
          y = normal.y,
          z = normal.z; // band 0

    shBasis[0] = 0.282095; // band 1

    shBasis[1] = 0.488603 * y;
    shBasis[2] = 0.488603 * z;
    shBasis[3] = 0.488603 * x; // band 2

    shBasis[4] = 1.092548 * x * y;
    shBasis[5] = 1.092548 * y * z;
    shBasis[6] = 0.315392 * (3 * z * z - 1);
    shBasis[7] = 1.092548 * x * z;
    shBasis[8] = 0.546274 * (x * x - y * y);
  }

}

exports.SphericalHarmonics3 = SphericalHarmonics3;

function LightProbe(sh, intensity) {
  Light.call(this, undefined, intensity);
  this.type = 'LightProbe';
  this.sh = sh !== undefined ? sh : new SphericalHarmonics3();
}

LightProbe.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: LightProbe,
  isLightProbe: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.sh.copy(source.sh);
    return this;
  },
  fromJSON: function (json) {
    this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();

    this.sh.fromArray(json.sh);
    return this;
  },
  toJSON: function (meta) {
    const data = Light.prototype.toJSON.call(this, meta);
    data.object.sh = this.sh.toArray();
    return data;
  }
});

function MaterialLoader(manager) {
  Loader.call(this, manager);
  this.textures = {};
}

MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: MaterialLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.load(url, function (text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }

        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  },
  parse: function (json) {
    const textures = this.textures;

    function getTexture(name) {
      if (textures[name] === undefined) {
        console.warn('THREE.MaterialLoader: Undefined texture', name);
      }

      return textures[name];
    }

    const material = new Materials[json.type]();
    if (json.uuid !== undefined) material.uuid = json.uuid;
    if (json.name !== undefined) material.name = json.name;
    if (json.color !== undefined) material.color.setHex(json.color);
    if (json.roughness !== undefined) material.roughness = json.roughness;
    if (json.metalness !== undefined) material.metalness = json.metalness;
    if (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen);
    if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
    if (json.specular !== undefined) material.specular.setHex(json.specular);
    if (json.shininess !== undefined) material.shininess = json.shininess;
    if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
    if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
    if (json.fog !== undefined) material.fog = json.fog;
    if (json.flatShading !== undefined) material.flatShading = json.flatShading;
    if (json.blending !== undefined) material.blending = json.blending;
    if (json.combine !== undefined) material.combine = json.combine;
    if (json.side !== undefined) material.side = json.side;
    if (json.opacity !== undefined) material.opacity = json.opacity;
    if (json.transparent !== undefined) material.transparent = json.transparent;
    if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
    if (json.depthTest !== undefined) material.depthTest = json.depthTest;
    if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
    if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
    if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
    if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
    if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
    if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
    if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
    if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
    if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
    if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
    if (json.wireframe !== undefined) material.wireframe = json.wireframe;
    if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
    if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
    if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
    if (json.rotation !== undefined) material.rotation = json.rotation;
    if (json.linewidth !== 1) material.linewidth = json.linewidth;
    if (json.dashSize !== undefined) material.dashSize = json.dashSize;
    if (json.gapSize !== undefined) material.gapSize = json.gapSize;
    if (json.scale !== undefined) material.scale = json.scale;
    if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
    if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
    if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
    if (json.skinning !== undefined) material.skinning = json.skinning;
    if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
    if (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;
    if (json.dithering !== undefined) material.dithering = json.dithering;
    if (json.vertexTangents !== undefined) material.vertexTangents = json.vertexTangents;
    if (json.visible !== undefined) material.visible = json.visible;
    if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
    if (json.userData !== undefined) material.userData = json.userData;

    if (json.vertexColors !== undefined) {
      if (typeof json.vertexColors === 'number') {
        material.vertexColors = json.vertexColors > 0 ? true : false;
      } else {
        material.vertexColors = json.vertexColors;
      }
    } // Shader Material


    if (json.uniforms !== undefined) {
      for (const name in json.uniforms) {
        const uniform = json.uniforms[name];
        material.uniforms[name] = {};

        switch (uniform.type) {
          case 't':
            material.uniforms[name].value = getTexture(uniform.value);
            break;

          case 'c':
            material.uniforms[name].value = new Color().setHex(uniform.value);
            break;

          case 'v2':
            material.uniforms[name].value = new Vector2().fromArray(uniform.value);
            break;

          case 'v3':
            material.uniforms[name].value = new Vector3().fromArray(uniform.value);
            break;

          case 'v4':
            material.uniforms[name].value = new Vector4().fromArray(uniform.value);
            break;

          case 'm3':
            material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
            break;

          case 'm4':
            material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
            break;

          default:
            material.uniforms[name].value = uniform.value;
        }
      }
    }

    if (json.defines !== undefined) material.defines = json.defines;
    if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
    if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;

    if (json.extensions !== undefined) {
      for (const key in json.extensions) {
        material.extensions[key] = json.extensions[key];
      }
    } // Deprecated


    if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
    // for PointsMaterial

    if (json.size !== undefined) material.size = json.size;
    if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps

    if (json.map !== undefined) material.map = getTexture(json.map);
    if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
    if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
    if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
    if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
    if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
    if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;

    if (json.normalScale !== undefined) {
      let normalScale = json.normalScale;

      if (Array.isArray(normalScale) === false) {
        // Blender exporter used to export a scalar. See #7459
        normalScale = [normalScale, normalScale];
      }

      material.normalScale = new Vector2().fromArray(normalScale);
    }

    if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
    if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
    if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
    if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
    if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
    if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
    if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
    if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
    if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
    if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
    if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
    if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
    if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
    if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
    if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
    if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
    if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
    if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
    if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
    if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
    if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
    if (json.transmission !== undefined) material.transmission = json.transmission;
    if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
    return material;
  },
  setTextures: function (value) {
    this.textures = value;
    return this;
  }
});
const LoaderUtils = {
  decodeText: function (array) {
    if (typeof TextDecoder !== 'undefined') {
      return new TextDecoder().decode(array);
    } // Avoid the String.fromCharCode.apply(null, array) shortcut, which
    // throws a "maximum call stack size exceeded" error for large arrays.


    let s = '';

    for (let i = 0, il = array.length; i < il; i++) {
      // Implicitly assumes little-endian.
      s += String.fromCharCode(array[i]);
    }

    try {
      // merges multi-byte utf-8 characters.
      return decodeURIComponent(escape(s));
    } catch (e) {
      // see #16358
      return s;
    }
  },
  extractUrlBase: function (url) {
    const index = url.lastIndexOf('/');
    if (index === -1) return './';
    return url.substr(0, index + 1);
  }
};
exports.LoaderUtils = LoaderUtils;

function InstancedBufferGeometry() {
  BufferGeometry.call(this);
  this.type = 'InstancedBufferGeometry';
  this.instanceCount = Infinity;
}

InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
  constructor: InstancedBufferGeometry,
  isInstancedBufferGeometry: true,
  copy: function (source) {
    BufferGeometry.prototype.copy.call(this, source);
    this.instanceCount = source.instanceCount;
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  toJSON: function () {
    const data = BufferGeometry.prototype.toJSON.call(this);
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
});

function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
  if (typeof normalized === 'number') {
    meshPerAttribute = normalized;
    normalized = false;
    console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
  }

  BufferAttribute.call(this, array, itemSize, normalized);
  this.meshPerAttribute = meshPerAttribute || 1;
}

InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
  constructor: InstancedBufferAttribute,
  isInstancedBufferAttribute: true,
  copy: function (source) {
    BufferAttribute.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  toJSON: function () {
    const data = BufferAttribute.prototype.toJSON.call(this);
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
});

function BufferGeometryLoader(manager) {
  Loader.call(this, manager);
}

BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: BufferGeometryLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.load(url, function (text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }

        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  },
  parse: function (json) {
    const interleavedBufferMap = {};
    const arrayBufferMap = {};

    function getInterleavedBuffer(json, uuid) {
      if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
      const interleavedBuffers = json.interleavedBuffers;
      const interleavedBuffer = interleavedBuffers[uuid];
      const buffer = getArrayBuffer(json, interleavedBuffer.buffer);
      const array = new TYPED_ARRAYS[interleavedBuffer.type](buffer);
      const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
      ib.uuid = interleavedBuffer.uuid;
      interleavedBufferMap[uuid] = ib;
      return ib;
    }

    function getArrayBuffer(json, uuid) {
      if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
      const arrayBuffers = json.arrayBuffers;
      const arrayBuffer = arrayBuffers[uuid];
      const ab = new Uint32Array(arrayBuffer).buffer;
      arrayBufferMap[uuid] = ab;
      return ab;
    }

    const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
    const index = json.data.index;

    if (index !== undefined) {
      const typedArray = new TYPED_ARRAYS[index.type](index.array);
      geometry.setIndex(new BufferAttribute(typedArray, 1));
    }

    const attributes = json.data.attributes;

    for (const key in attributes) {
      const attribute = attributes[key];
      let bufferAttribute;

      if (attribute.isInterleavedBufferAttribute) {
        const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
        bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
      } else {
        const typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
        const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
        bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
      }

      if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
      geometry.setAttribute(key, bufferAttribute);
    }

    const morphAttributes = json.data.morphAttributes;

    if (morphAttributes) {
      for (const key in morphAttributes) {
        const attributeArray = morphAttributes[key];
        const array = [];

        for (let i = 0, il = attributeArray.length; i < il; i++) {
          const attribute = attributeArray[i];
          let bufferAttribute;

          if (attribute.isInterleavedBufferAttribute) {
            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
          } else {
            const typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
            bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
          }

          if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
          array.push(bufferAttribute);
        }

        geometry.morphAttributes[key] = array;
      }
    }

    const morphTargetsRelative = json.data.morphTargetsRelative;

    if (morphTargetsRelative) {
      geometry.morphTargetsRelative = true;
    }

    const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

    if (groups !== undefined) {
      for (let i = 0, n = groups.length; i !== n; ++i) {
        const group = groups[i];
        geometry.addGroup(group.start, group.count, group.materialIndex);
      }
    }

    const boundingSphere = json.data.boundingSphere;

    if (boundingSphere !== undefined) {
      const center = new Vector3();

      if (boundingSphere.center !== undefined) {
        center.fromArray(boundingSphere.center);
      }

      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
    }

    if (json.name) geometry.name = json.name;
    if (json.userData) geometry.userData = json.userData;
    return geometry;
  }
});
const TYPED_ARRAYS = {
  Int8Array: Int8Array,
  Uint8Array: Uint8Array,
  // Workaround for IE11 pre KB2929437. See #11440
  Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
  Int16Array: Int16Array,
  Uint16Array: Uint16Array,
  Int32Array: Int32Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array
};

function ObjectLoader(manager) {
  Loader.call(this, manager);
}

ObjectLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ObjectLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(scope.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.load(url, function (text) {
      let json = null;

      try {
        json = JSON.parse(text);
      } catch (error) {
        if (onError !== undefined) onError(error);
        console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
        return;
      }

      const metadata = json.metadata;

      if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
        console.error('THREE.ObjectLoader: Can\'t load ' + url);
        return;
      }

      scope.parse(json, onLoad);
    }, onProgress, onError);
  },
  parse: function (json, onLoad) {
    const shapes = this.parseShape(json.shapes);
    const geometries = this.parseGeometries(json.geometries, shapes);
    const images = this.parseImages(json.images, function () {
      if (onLoad !== undefined) onLoad(object);
    });
    const textures = this.parseTextures(json.textures, images);
    const materials = this.parseMaterials(json.materials, textures);
    const object = this.parseObject(json.object, geometries, materials);

    if (json.animations) {
      object.animations = this.parseAnimations(json.animations);
    }

    if (json.images === undefined || json.images.length === 0) {
      if (onLoad !== undefined) onLoad(object);
    }

    return object;
  },
  parseShape: function (json) {
    const shapes = {};

    if (json !== undefined) {
      for (let i = 0, l = json.length; i < l; i++) {
        const shape = new Shape().fromJSON(json[i]);
        shapes[shape.uuid] = shape;
      }
    }

    return shapes;
  },
  parseGeometries: function (json, shapes) {
    const geometries = {};
    let geometryShapes;

    if (json !== undefined) {
      const bufferGeometryLoader = new BufferGeometryLoader();

      for (let i = 0, l = json.length; i < l; i++) {
        let geometry;
        const data = json[i];

        switch (data.type) {
          case 'PlaneGeometry':
          case 'PlaneBufferGeometry':
            geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
            break;

          case 'BoxGeometry':
          case 'BoxBufferGeometry':
          case 'CubeGeometry':
            // backwards compatible
            geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
            break;

          case 'CircleGeometry':
          case 'CircleBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
            break;

          case 'CylinderGeometry':
          case 'CylinderBufferGeometry':
            geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;

          case 'ConeGeometry':
          case 'ConeBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;

          case 'SphereGeometry':
          case 'SphereBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
            break;

          case 'DodecahedronGeometry':
          case 'DodecahedronBufferGeometry':
          case 'IcosahedronGeometry':
          case 'IcosahedronBufferGeometry':
          case 'OctahedronGeometry':
          case 'OctahedronBufferGeometry':
          case 'TetrahedronGeometry':
          case 'TetrahedronBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.detail);
            break;

          case 'RingGeometry':
          case 'RingBufferGeometry':
            geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
            break;

          case 'TorusGeometry':
          case 'TorusBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
            break;

          case 'TorusKnotGeometry':
          case 'TorusKnotBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
            break;

          case 'TubeGeometry':
          case 'TubeBufferGeometry':
            // This only works for built-in curves (e.g. CatmullRomCurve3).
            // User defined curves or instances of CurvePath will not be deserialized.
            geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
            break;

          case 'LatheGeometry':
          case 'LatheBufferGeometry':
            geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
            break;

          case 'PolyhedronGeometry':
          case 'PolyhedronBufferGeometry':
            geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
            break;

          case 'ShapeGeometry':
          case 'ShapeBufferGeometry':
            geometryShapes = [];

            for (let j = 0, jl = data.shapes.length; j < jl; j++) {
              const shape = shapes[data.shapes[j]];
              geometryShapes.push(shape);
            }

            geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
            break;

          case 'ExtrudeGeometry':
          case 'ExtrudeBufferGeometry':
            geometryShapes = [];

            for (let j = 0, jl = data.shapes.length; j < jl; j++) {
              const shape = shapes[data.shapes[j]];
              geometryShapes.push(shape);
            }

            const extrudePath = data.options.extrudePath;

            if (extrudePath !== undefined) {
              data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
            }

            geometry = new Geometries[data.type](geometryShapes, data.options);
            break;

          case 'BufferGeometry':
          case 'InstancedBufferGeometry':
            geometry = bufferGeometryLoader.parse(data);
            break;

          case 'Geometry':
            console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
            break;

          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
            continue;
        }

        geometry.uuid = data.uuid;
        if (data.name !== undefined) geometry.name = data.name;
        if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
        geometries[data.uuid] = geometry;
      }
    }

    return geometries;
  },
  parseMaterials: function (json, textures) {
    const cache = {}; // MultiMaterial

    const materials = {};

    if (json !== undefined) {
      const loader = new MaterialLoader();
      loader.setTextures(textures);

      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];

        if (data.type === 'MultiMaterial') {
          // Deprecated
          const array = [];

          for (let j = 0; j < data.materials.length; j++) {
            const material = data.materials[j];

            if (cache[material.uuid] === undefined) {
              cache[material.uuid] = loader.parse(material);
            }

            array.push(cache[material.uuid]);
          }

          materials[data.uuid] = array;
        } else {
          if (cache[data.uuid] === undefined) {
            cache[data.uuid] = loader.parse(data);
          }

          materials[data.uuid] = cache[data.uuid];
        }
      }
    }

    return materials;
  },
  parseAnimations: function (json) {
    const animations = [];

    for (let i = 0; i < json.length; i++) {
      const data = json[i];
      const clip = AnimationClip.parse(data);
      if (data.uuid !== undefined) clip.uuid = data.uuid;
      animations.push(clip);
    }

    return animations;
  },
  parseImages: function (json, onLoad) {
    const scope = this;
    const images = {};
    let loader;

    function loadImage(url) {
      scope.manager.itemStart(url);
      return loader.load(url, function () {
        scope.manager.itemEnd(url);
      }, undefined, function () {
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
    }

    if (json !== undefined && json.length > 0) {
      const manager = new LoadingManager(onLoad);
      loader = new ImageLoader(manager);
      loader.setCrossOrigin(this.crossOrigin);

      for (let i = 0, il = json.length; i < il; i++) {
        const image = json[i];
        const url = image.url;

        if (Array.isArray(url)) {
          // load array of images e.g CubeTexture
          images[image.uuid] = [];

          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j];
            const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;
            images[image.uuid].push(loadImage(path));
          }
        } else {
          // load single image
          const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.resourcePath + image.url;
          images[image.uuid] = loadImage(path);
        }
      }
    }

    return images;
  },
  parseTextures: function (json, images) {
    function parseConstant(value, type) {
      if (typeof value === 'number') return value;
      console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
      return type[value];
    }

    const textures = {};

    if (json !== undefined) {
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];

        if (data.image === undefined) {
          console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
        }

        if (images[data.image] === undefined) {
          console.warn('THREE.ObjectLoader: Undefined image', data.image);
        }

        let texture;

        if (Array.isArray(images[data.image])) {
          texture = new CubeTexture(images[data.image]);
        } else {
          texture = new Texture(images[data.image]);
        }

        texture.needsUpdate = true;
        texture.uuid = data.uuid;
        if (data.name !== undefined) texture.name = data.name;
        if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
        if (data.offset !== undefined) texture.offset.fromArray(data.offset);
        if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
        if (data.center !== undefined) texture.center.fromArray(data.center);
        if (data.rotation !== undefined) texture.rotation = data.rotation;

        if (data.wrap !== undefined) {
          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
        }

        if (data.format !== undefined) texture.format = data.format;
        if (data.type !== undefined) texture.type = data.type;
        if (data.encoding !== undefined) texture.encoding = data.encoding;
        if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
        if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
        if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
        if (data.flipY !== undefined) texture.flipY = data.flipY;
        if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
        if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
        textures[data.uuid] = texture;
      }
    }

    return textures;
  },
  parseObject: function (data, geometries, materials) {
    let object;

    function getGeometry(name) {
      if (geometries[name] === undefined) {
        console.warn('THREE.ObjectLoader: Undefined geometry', name);
      }

      return geometries[name];
    }

    function getMaterial(name) {
      if (name === undefined) return undefined;

      if (Array.isArray(name)) {
        const array = [];

        for (let i = 0, l = name.length; i < l; i++) {
          const uuid = name[i];

          if (materials[uuid] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined material', uuid);
          }

          array.push(materials[uuid]);
        }

        return array;
      }

      if (materials[name] === undefined) {
        console.warn('THREE.ObjectLoader: Undefined material', name);
      }

      return materials[name];
    }

    let geometry, material;

    switch (data.type) {
      case 'Scene':
        object = new Scene();

        if (data.background !== undefined) {
          if (Number.isInteger(data.background)) {
            object.background = new Color(data.background);
          }
        }

        if (data.fog !== undefined) {
          if (data.fog.type === 'Fog') {
            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
          } else if (data.fog.type === 'FogExp2') {
            object.fog = new FogExp2(data.fog.color, data.fog.density);
          }
        }

        break;

      case 'PerspectiveCamera':
        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
        if (data.focus !== undefined) object.focus = data.focus;
        if (data.zoom !== undefined) object.zoom = data.zoom;
        if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
        if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
        if (data.view !== undefined) object.view = Object.assign({}, data.view);
        break;

      case 'OrthographicCamera':
        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
        if (data.zoom !== undefined) object.zoom = data.zoom;
        if (data.view !== undefined) object.view = Object.assign({}, data.view);
        break;

      case 'AmbientLight':
        object = new AmbientLight(data.color, data.intensity);
        break;

      case 'DirectionalLight':
        object = new DirectionalLight(data.color, data.intensity);
        break;

      case 'PointLight':
        object = new PointLight(data.color, data.intensity, data.distance, data.decay);
        break;

      case 'RectAreaLight':
        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
        break;

      case 'SpotLight':
        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
        break;

      case 'HemisphereLight':
        object = new HemisphereLight(data.color, data.groundColor, data.intensity);
        break;

      case 'LightProbe':
        object = new LightProbe().fromJSON(data);
        break;

      case 'SkinnedMesh':
        console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');

      case 'Mesh':
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new Mesh(geometry, material);
        break;

      case 'InstancedMesh':
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        const count = data.count;
        const instanceMatrix = data.instanceMatrix;
        object = new InstancedMesh(geometry, material, count);
        object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
        break;

      case 'LOD':
        object = new LOD();
        break;

      case 'Line':
        object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
        break;

      case 'LineLoop':
        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
        break;

      case 'LineSegments':
        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
        break;

      case 'PointCloud':
      case 'Points':
        object = new Points(getGeometry(data.geometry), getMaterial(data.material));
        break;

      case 'Sprite':
        object = new Sprite(getMaterial(data.material));
        break;

      case 'Group':
        object = new Group();
        break;

      default:
        object = new Object3D();
    }

    object.uuid = data.uuid;
    if (data.name !== undefined) object.name = data.name;

    if (data.matrix !== undefined) {
      object.matrix.fromArray(data.matrix);
      if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
      if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
    } else {
      if (data.position !== undefined) object.position.fromArray(data.position);
      if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
      if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
      if (data.scale !== undefined) object.scale.fromArray(data.scale);
    }

    if (data.castShadow !== undefined) object.castShadow = data.castShadow;
    if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

    if (data.shadow) {
      if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
      if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
      if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
      if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
      if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
    }

    if (data.visible !== undefined) object.visible = data.visible;
    if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
    if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
    if (data.userData !== undefined) object.userData = data.userData;
    if (data.layers !== undefined) object.layers.mask = data.layers;

    if (data.children !== undefined) {
      const children = data.children;

      for (let i = 0; i < children.length; i++) {
        object.add(this.parseObject(children[i], geometries, materials));
      }
    }

    if (data.type === 'LOD') {
      if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
      const levels = data.levels;

      for (let l = 0; l < levels.length; l++) {
        const level = levels[l];
        const child = object.getObjectByProperty('uuid', level.object);

        if (child !== undefined) {
          object.addLevel(child, level.distance);
        }
      }
    }

    return object;
  }
});
const TEXTURE_MAPPING = {
  UVMapping: UVMapping,
  CubeReflectionMapping: CubeReflectionMapping,
  CubeRefractionMapping: CubeRefractionMapping,
  EquirectangularReflectionMapping: EquirectangularReflectionMapping,
  EquirectangularRefractionMapping: EquirectangularRefractionMapping,
  CubeUVReflectionMapping: CubeUVReflectionMapping,
  CubeUVRefractionMapping: CubeUVRefractionMapping
};
const TEXTURE_WRAPPING = {
  RepeatWrapping: RepeatWrapping,
  ClampToEdgeWrapping: ClampToEdgeWrapping,
  MirroredRepeatWrapping: MirroredRepeatWrapping
};
const TEXTURE_FILTER = {
  NearestFilter: NearestFilter,
  NearestMipmapNearestFilter: NearestMipmapNearestFilter,
  NearestMipmapLinearFilter: NearestMipmapLinearFilter,
  LinearFilter: LinearFilter,
  LinearMipmapNearestFilter: LinearMipmapNearestFilter,
  LinearMipmapLinearFilter: LinearMipmapLinearFilter
};

function ImageBitmapLoader(manager) {
  if (typeof createImageBitmap === 'undefined') {
    console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
  }

  if (typeof fetch === 'undefined') {
    console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
  }

  Loader.call(this, manager);
  this.options = {
    premultiplyAlpha: 'none'
  };
}

ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ImageBitmapLoader,
  isImageBitmapLoader: true,
  setOptions: function setOptions(options) {
    this.options = options;
    return this;
  },
  load: function (url, onLoad, onProgress, onError) {
    if (url === undefined) url = '';
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);

    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }

    fetch(url).then(function (res) {
      return res.blob();
    }).then(function (blob) {
      return createImageBitmap(blob, scope.options);
    }).then(function (imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad) onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function (e) {
      if (onError) onError(e);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
});

function ShapePath() {
  this.type = 'ShapePath';
  this.color = new Color();
  this.subPaths = [];
  this.currentPath = null;
}

Object.assign(ShapePath.prototype, {
  moveTo: function (x, y) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x, y);
    return this;
  },
  lineTo: function (x, y) {
    this.currentPath.lineTo(x, y);
    return this;
  },
  quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
    return this;
  },
  bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
    return this;
  },
  splineThru: function (pts) {
    this.currentPath.splineThru(pts);
    return this;
  },
  toShapes: function (isCCW, noHoles) {
    function toShapesNoHoles(inSubpaths) {
      const shapes = [];

      for (let i = 0, l = inSubpaths.length; i < l; i++) {
        const tmpPath = inSubpaths[i];
        const tmpShape = new Shape();
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
      }

      return shapes;
    }

    function isPointInsidePolygon(inPt, inPolygon) {
      const polyLen = inPolygon.length; // inPt on polygon contour => immediate success    or
      // toggling of inside/outside at every single! intersection point of an edge
      //  with the horizontal line through inPt, left of inPt
      //  not counting lowerY endpoints of edges and whole edges on that line

      let inside = false;

      for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
        let edgeLowPt = inPolygon[p];
        let edgeHighPt = inPolygon[q];
        let edgeDx = edgeHighPt.x - edgeLowPt.x;
        let edgeDy = edgeHighPt.y - edgeLowPt.y;

        if (Math.abs(edgeDy) > Number.EPSILON) {
          // not parallel
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p];
            edgeDy = -edgeDy;
          }

          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;

          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
            // continue;				// no intersection or edgeLowPt => doesn't count !!!
          } else {
            const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0) return true; // inPt is on contour ?

            if (perpEdge < 0) continue;
            inside = !inside; // true intersection left of inPt
          }
        } else {
          // parallel or collinear
          if (inPt.y !== edgeLowPt.y) continue; // parallel
          // edge lies on the same horizontal line as inPt

          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
          // continue;
        }
      }

      return inside;
    }

    const isClockWise = ShapeUtils.isClockWise;
    const subPaths = this.subPaths;
    if (subPaths.length === 0) return [];
    if (noHoles === true) return toShapesNoHoles(subPaths);
    let solid, tmpPath, tmpShape;
    const shapes = [];

    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }

    let holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst; // console.log("Holes first", holesFirst);

    const betterShapeHoles = [];
    const newShapes = [];
    let newShapeHoles = [];
    let mainIdx = 0;
    let tmpPoints;
    newShapes[mainIdx] = undefined;
    newShapeHoles[mainIdx] = [];

    for (let i = 0, l = subPaths.length; i < l; i++) {
      tmpPath = subPaths[i];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;

      if (solid) {
        if (!holesFirst && newShapes[mainIdx]) mainIdx++;
        newShapes[mainIdx] = {
          s: new Shape(),
          p: tmpPoints
        };
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst) mainIdx++;
        newShapeHoles[mainIdx] = []; //console.log('cw', i);
      } else {
        newShapeHoles[mainIdx].push({
          h: tmpPath,
          p: tmpPoints[0]
        }); //console.log('ccw', i);
      }
    } // only Holes? -> probably all Shapes with wrong orientation


    if (!newShapes[0]) return toShapesNoHoles(subPaths);

    if (newShapes.length > 1) {
      let ambiguous = false;
      const toChange = [];

      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }

      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        const sho = newShapeHoles[sIdx];

        for (let hIdx = 0; hIdx < sho.length; hIdx++) {
          const ho = sho[hIdx];
          let hole_unassigned = true;

          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx) toChange.push({
                froms: sIdx,
                tos: s2Idx,
                hole: hIdx
              });

              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }

          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      } // console.log("ambiguous: ", ambiguous);


      if (toChange.length > 0) {
        // console.log("to change: ", toChange);
        if (!ambiguous) newShapeHoles = betterShapeHoles;
      }
    }

    let tmpHoles;

    for (let i = 0, il = newShapes.length; i < il; i++) {
      tmpShape = newShapes[i].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i];

      for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h);
      }
    } //console.log("shape", shapes);


    return shapes;
  }
});

function Font(data) {
  this.type = 'Font';
  this.data = data;
}

Object.assign(Font.prototype, {
  isFont: true,
  generateShapes: function (text, size) {
    if (size === undefined) size = 100;
    const shapes = [];
    const paths = createPaths(text, size, this.data);

    for (let p = 0, pl = paths.length; p < pl; p++) {
      Array.prototype.push.apply(shapes, paths[p].toShapes());
    }

    return shapes;
  }
});

function createPaths(text, size, data) {
  const chars = Array.from ? Array.from(text) : String(text).split(''); // workaround for IE11, see #13988

  const scale = size / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0,
      offsetY = 0;

  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];

    if (char === '\n') {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }

  return paths;
}

function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs['?'];

  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
    return;
  }

  const path = new ShapePath();
  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

    for (let i = 0, l = outline.length; i < l;) {
      const action = outline[i++];

      switch (action) {
        case 'm':
          // moveTo
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.moveTo(x, y);
          break;

        case 'l':
          // lineTo
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.lineTo(x, y);
          break;

        case 'q':
          // quadraticCurveTo
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;

        case 'b':
          // bezierCurveTo
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          cpx2 = outline[i++] * scale + offsetX;
          cpy2 = outline[i++] * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }

  return {
    offsetX: glyph.ha * scale,
    path: path
  };
}

function FontLoader(manager) {
  Loader.call(this, manager);
}

FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: FontLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.load(url, function (text) {
      let json;

      try {
        json = JSON.parse(text);
      } catch (e) {
        console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
        json = JSON.parse(text.substring(65, text.length - 2));
      }

      const font = scope.parse(json);
      if (onLoad) onLoad(font);
    }, onProgress, onError);
  },
  parse: function (json) {
    return new Font(json);
  }
});

let _context;

const AudioContext = {
  getContext: function () {
    if (_context === undefined) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }

    return _context;
  },
  setContext: function (value) {
    _context = value;
  }
};
exports.AudioContext = AudioContext;

function AudioLoader(manager) {
  Loader.call(this, manager);
}

AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: AudioLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setResponseType('arraybuffer');
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.load(url, function (buffer) {
      try {
        // Create a copy of the buffer. The `decodeAudioData` method
        // detaches the buffer when complete, preventing reuse.
        const bufferCopy = buffer.slice(0);
        const context = AudioContext.getContext();
        context.decodeAudioData(bufferCopy, function (audioBuffer) {
          onLoad(audioBuffer);
        });
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }

        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
});

function HemisphereLightProbe(skyColor, groundColor, intensity) {
  LightProbe.call(this, undefined, intensity);
  const color1 = new Color().set(skyColor);
  const color2 = new Color().set(groundColor);
  const sky = new Vector3(color1.r, color1.g, color1.b);
  const ground = new Vector3(color2.r, color2.g, color2.b); // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );

  const c0 = Math.sqrt(Math.PI);
  const c1 = c0 * Math.sqrt(0.75);
  this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
  this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
}

HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
  constructor: HemisphereLightProbe,
  isHemisphereLightProbe: true,
  copy: function (source) {
    // modifying colors not currently supported
    LightProbe.prototype.copy.call(this, source);
    return this;
  },
  toJSON: function (meta) {
    const data = LightProbe.prototype.toJSON.call(this, meta); // data.sh = this.sh.toArray(); // todo

    return data;
  }
});

function AmbientLightProbe(color, intensity) {
  LightProbe.call(this, undefined, intensity);
  const color1 = new Color().set(color); // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );

  this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
}

AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
  constructor: AmbientLightProbe,
  isAmbientLightProbe: true,
  copy: function (source) {
    // modifying color not currently supported
    LightProbe.prototype.copy.call(this, source);
    return this;
  },
  toJSON: function (meta) {
    const data = LightProbe.prototype.toJSON.call(this, meta); // data.sh = this.sh.toArray(); // todo

    return data;
  }
});

const _eyeRight = new Matrix4();

const _eyeLeft = new Matrix4();

function StereoCamera() {
  this.type = 'StereoCamera';
  this.aspect = 1;
  this.eyeSep = 0.064;
  this.cameraL = new PerspectiveCamera();
  this.cameraL.layers.enable(1);
  this.cameraL.matrixAutoUpdate = false;
  this.cameraR = new PerspectiveCamera();
  this.cameraR.layers.enable(2);
  this.cameraR.matrixAutoUpdate = false;
  this._cache = {
    focus: null,
    fov: null,
    aspect: null,
    near: null,
    far: null,
    zoom: null,
    eyeSep: null
  };
}

Object.assign(StereoCamera.prototype, {
  update: function (camera) {
    const cache = this._cache;
    const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

    if (needsUpdate) {
      cache.focus = camera.focus;
      cache.fov = camera.fov;
      cache.aspect = camera.aspect * this.aspect;
      cache.near = camera.near;
      cache.far = camera.far;
      cache.zoom = camera.zoom;
      cache.eyeSep = this.eyeSep; // Off-axis stereoscopic effect based on
      // http://paulbourke.net/stereographics/stereorender/

      const projectionMatrix = camera.projectionMatrix.clone();
      const eyeSepHalf = cache.eyeSep / 2;
      const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
      const ymax = cache.near * Math.tan(MathUtils.DEG2RAD * cache.fov * 0.5) / cache.zoom;
      let xmin, xmax; // translate xOffset

      _eyeLeft.elements[12] = -eyeSepHalf;
      _eyeRight.elements[12] = eyeSepHalf; // for left eye

      xmin = -ymax * cache.aspect + eyeSepOnProjection;
      xmax = ymax * cache.aspect + eyeSepOnProjection;
      projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraL.projectionMatrix.copy(projectionMatrix); // for right eye

      xmin = -ymax * cache.aspect - eyeSepOnProjection;
      xmax = ymax * cache.aspect - eyeSepOnProjection;
      projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraR.projectionMatrix.copy(projectionMatrix);
    }

    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
  }
});

class Clock {
  constructor(autoStart) {
    this.autoStart = autoStart !== undefined ? autoStart : true;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }

  start() {
    this.startTime = (typeof performance === 'undefined' ? Date : performance).now(); // see #10732

    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }

  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }

  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }

  getDelta() {
    let diff = 0;

    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }

    if (this.running) {
      const newTime = (typeof performance === 'undefined' ? Date : performance).now();
      diff = (newTime - this.oldTime) / 1000;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }

    return diff;
  }

}

exports.Clock = Clock;

const _position$2 = new Vector3();

const _quaternion$3 = new Quaternion();

const _scale$1 = new Vector3();

const _orientation = new Vector3();

class AudioListener extends Object3D {
  constructor() {
    super();
    this.type = 'AudioListener';
    this.context = AudioContext.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0; // private

    this._clock = new Clock();
  }

  getInput() {
    return this.gain;
  }

  removeFilter() {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
      this.gain.connect(this.context.destination);
      this.filter = null;
    }

    return this;
  }

  getFilter() {
    return this.filter;
  }

  setFilter(value) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
    } else {
      this.gain.disconnect(this.context.destination);
    }

    this.filter = value;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  }

  getMasterVolume() {
    return this.gain.gain.value;
  }

  setMasterVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }

  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    const listener = this.context.listener;
    const up = this.up;
    this.timeDelta = this._clock.getDelta();
    this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1);

    _orientation.set(0, 0, -1).applyQuaternion(_quaternion$3);

    if (listener.positionX) {
      // code path for Chrome (see #14393)
      const endTime = this.context.currentTime + this.timeDelta;
      listener.positionX.linearRampToValueAtTime(_position$2.x, endTime);
      listener.positionY.linearRampToValueAtTime(_position$2.y, endTime);
      listener.positionZ.linearRampToValueAtTime(_position$2.z, endTime);
      listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
      listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
      listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
      listener.upX.linearRampToValueAtTime(up.x, endTime);
      listener.upY.linearRampToValueAtTime(up.y, endTime);
      listener.upZ.linearRampToValueAtTime(up.z, endTime);
    } else {
      listener.setPosition(_position$2.x, _position$2.y, _position$2.z);
      listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
    }
  }

}

exports.AudioListener = AudioListener;

class Audio extends Object3D {
  constructor(listener) {
    super();
    this.type = 'Audio';
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = undefined;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = 'empty';
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }

  getOutput() {
    return this.gain;
  }

  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = 'audioNode';
    this.source = audioNode;
    this.connect();
    return this;
  }

  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = 'mediaNode';
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }

  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = 'mediaStreamNode';
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }

  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = 'buffer';
    if (this.autoplay) this.play();
    return this;
  }

  play(delay) {
    if (delay === undefined) delay = 0;

    if (this.isPlaying === true) {
      console.warn('THREE.Audio: Audio is already playing.');
      return;
    }

    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this._startedAt = this.context.currentTime + delay;
    const source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.loopStart = this.loopStart;
    source.loopEnd = this.loopEnd;
    source.onended = this.onEnded.bind(this);
    source.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }

  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    if (this.isPlaying === true) {
      // update current progress
      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;

      if (this.loop === true) {
        // ensure _progress does not exceed duration with looped audios
        this._progress = this._progress % (this.duration || this.buffer.duration);
      }

      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }

    return this;
  }

  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this._progress = 0;
    this.source.stop();
    this.source.onended = null;
    this.isPlaying = false;
    return this;
  }

  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);

      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].connect(this.filters[i]);
      }

      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }

    this._connected = true;
    return this;
  }

  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);

      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].disconnect(this.filters[i]);
      }

      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }

    this._connected = false;
    return this;
  }

  getFilters() {
    return this.filters;
  }

  setFilters(value) {
    if (!value) value = [];

    if (this._connected === true) {
      this.disconnect();
      this.filters = value;
      this.connect();
    } else {
      this.filters = value;
    }

    return this;
  }

  setDetune(value) {
    this.detune = value;
    if (this.source.detune === undefined) return; // only set detune when available

    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }

    return this;
  }

  getDetune() {
    return this.detune;
  }

  getFilter() {
    return this.getFilters()[0];
  }

  setFilter(filter) {
    return this.setFilters(filter ? [filter] : []);
  }

  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this.playbackRate = value;

    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }

    return this;
  }

  getPlaybackRate() {
    return this.playbackRate;
  }

  onEnded() {
    this.isPlaying = false;
  }

  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return false;
    }

    return this.loop;
  }

  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this.loop = value;

    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }

    return this;
  }

  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }

  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }

  getVolume() {
    return this.gain.gain.value;
  }

  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }

}

exports.Audio = Audio;

const _position$3 = new Vector3();

const _quaternion$4 = new Quaternion();

const _scale$2 = new Vector3();

const _orientation$1 = new Vector3();

class PositionalAudio extends Audio {
  constructor(listener) {
    super(listener);
    this.panner = this.context.createPanner();
    this.panner.panningModel = 'HRTF';
    this.panner.connect(this.gain);
  }

  getOutput() {
    return this.panner;
  }

  getRefDistance() {
    return this.panner.refDistance;
  }

  setRefDistance(value) {
    this.panner.refDistance = value;
    return this;
  }

  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }

  setRolloffFactor(value) {
    this.panner.rolloffFactor = value;
    return this;
  }

  getDistanceModel() {
    return this.panner.distanceModel;
  }

  setDistanceModel(value) {
    this.panner.distanceModel = value;
    return this;
  }

  getMaxDistance() {
    return this.panner.maxDistance;
  }

  setMaxDistance(value) {
    this.panner.maxDistance = value;
    return this;
  }

  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.panner.coneInnerAngle = coneInnerAngle;
    this.panner.coneOuterAngle = coneOuterAngle;
    this.panner.coneOuterGain = coneOuterGain;
    return this;
  }

  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.hasPlaybackControl === true && this.isPlaying === false) return;
    this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2);

    _orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);

    const panner = this.panner;

    if (panner.positionX) {
      // code path for Chrome and Firefox (see #14393)
      const endTime = this.context.currentTime + this.listener.timeDelta;
      panner.positionX.linearRampToValueAtTime(_position$3.x, endTime);
      panner.positionY.linearRampToValueAtTime(_position$3.y, endTime);
      panner.positionZ.linearRampToValueAtTime(_position$3.z, endTime);
      panner.orientationX.linearRampToValueAtTime(_orientation$1.x, endTime);
      panner.orientationY.linearRampToValueAtTime(_orientation$1.y, endTime);
      panner.orientationZ.linearRampToValueAtTime(_orientation$1.z, endTime);
    } else {
      panner.setPosition(_position$3.x, _position$3.y, _position$3.z);
      panner.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);
    }
  }

}

exports.PositionalAudio = PositionalAudio;

class AudioAnalyser {
  constructor(audio, fftSize) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }

  getFrequencyData() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }

  getAverageFrequency() {
    let value = 0;
    const data = this.getFrequencyData();

    for (let i = 0; i < data.length; i++) {
      value += data[i];
    }

    return value / data.length;
  }

}

exports.AudioAnalyser = AudioAnalyser;

function PropertyMixer(binding, typeName, valueSize) {
  this.binding = binding;
  this.valueSize = valueSize;
  let mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
  //
  // interpolators can use .buffer as their .result
  // the data then goes to 'incoming'
  //
  // 'accu0' and 'accu1' are used frame-interleaved for
  // the cumulative result and are compared to detect
  // changes
  //
  // 'orig' stores the original state of the property
  //
  // 'add' is used for additive cumulative results
  //
  // 'work' is optional and is only present for quaternion types. It is used
  // to store intermediate quaternion multiplication results

  switch (typeName) {
    case 'quaternion':
      mixFunction = this._slerp;
      mixFunctionAdditive = this._slerpAdditive;
      setIdentity = this._setAdditiveIdentityQuaternion;
      this.buffer = new Float64Array(valueSize * 6);
      this._workIndex = 5;
      break;

    case 'string':
    case 'bool':
      mixFunction = this._select; // Use the regular mix function and for additive on these types,
      // additive is not relevant for non-numeric types

      mixFunctionAdditive = this._select;
      setIdentity = this._setAdditiveIdentityOther;
      this.buffer = new Array(valueSize * 5);
      break;

    default:
      mixFunction = this._lerp;
      mixFunctionAdditive = this._lerpAdditive;
      setIdentity = this._setAdditiveIdentityNumeric;
      this.buffer = new Float64Array(valueSize * 5);
  }

  this._mixBufferRegion = mixFunction;
  this._mixBufferRegionAdditive = mixFunctionAdditive;
  this._setIdentity = setIdentity;
  this._origIndex = 3;
  this._addIndex = 4;
  this.cumulativeWeight = 0;
  this.cumulativeWeightAdditive = 0;
  this.useCount = 0;
  this.referenceCount = 0;
}

Object.assign(PropertyMixer.prototype, {
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate: function (accuIndex, weight) {
    // note: happily accumulating nothing when weight = 0, the caller knows
    // the weight and shouldn't have made the call in the first place
    const buffer = this.buffer,
          stride = this.valueSize,
          offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;

    if (currentWeight === 0) {
      // accuN := incoming * weight
      for (let i = 0; i !== stride; ++i) {
        buffer[offset + i] = buffer[i];
      }

      currentWeight = weight;
    } else {
      // accuN := accuN + incoming * weight
      currentWeight += weight;
      const mix = weight / currentWeight;

      this._mixBufferRegion(buffer, offset, 0, mix, stride);
    }

    this.cumulativeWeight = currentWeight;
  },
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive: function (weight) {
    const buffer = this.buffer,
          stride = this.valueSize,
          offset = stride * this._addIndex;

    if (this.cumulativeWeightAdditive === 0) {
      // add = identity
      this._setIdentity();
    } // add := add + incoming * weight


    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);

    this.cumulativeWeightAdditive += weight;
  },
  // apply the state of 'accu<i>' to the binding when accus differ
  apply: function (accuIndex) {
    const stride = this.valueSize,
          buffer = this.buffer,
          offset = accuIndex * stride + stride,
          weight = this.cumulativeWeight,
          weightAdditive = this.cumulativeWeightAdditive,
          binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;

    if (weight < 1) {
      // accuN := accuN + original * ( 1 - cumulativeWeight )
      const originalValueOffset = stride * this._origIndex;

      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
    }

    if (weightAdditive > 0) {
      // accuN := accuN + additive accuN
      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
    }

    for (let i = stride, e = stride + stride; i !== e; ++i) {
      if (buffer[i] !== buffer[i + stride]) {
        // value has changed -> update scene graph
        binding.setValue(buffer, offset);
        break;
      }
    }
  },
  // remember the state of the bound property and copy it to both accus
  saveOriginalState: function () {
    const binding = this.binding;
    const buffer = this.buffer,
          stride = this.valueSize,
          originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original

    for (let i = stride, e = originalValueOffset; i !== e; ++i) {
      buffer[i] = buffer[originalValueOffset + i % stride];
    } // Add to identity for additive


    this._setIdentity();

    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  },
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState: function () {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  },
  _setAdditiveIdentityNumeric: function () {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;

    for (let i = startIndex; i < endIndex; i++) {
      this.buffer[i] = 0;
    }
  },
  _setAdditiveIdentityQuaternion: function () {
    this._setAdditiveIdentityNumeric();

    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  },
  _setAdditiveIdentityOther: function () {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;

    for (let i = 0; i < this.valueSize; i++) {
      this.buffer[targetIndex + i] = this.buffer[startIndex + i];
    }
  },
  // mix functions
  _select: function (buffer, dstOffset, srcOffset, t, stride) {
    if (t >= 0.5) {
      for (let i = 0; i !== stride; ++i) {
        buffer[dstOffset + i] = buffer[srcOffset + i];
      }
    }
  },
  _slerp: function (buffer, dstOffset, srcOffset, t) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
  },
  _slerpAdditive: function (buffer, dstOffset, srcOffset, t, stride) {
    const workOffset = this._workIndex * stride; // Store result in intermediate buffer offset

    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result

    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
  },
  _lerp: function (buffer, dstOffset, srcOffset, t, stride) {
    const s = 1 - t;

    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
    }
  },
  _lerpAdditive: function (buffer, dstOffset, srcOffset, t, stride) {
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
    }
  }
}); // Characters [].:/ are reserved for track binding syntax.

const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.


const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';

const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.


const _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.


const _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.


const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.


const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);

const _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');

const _supportedObjectNames = ['material', 'materials', 'bones'];

function Composite(targetGroup, path, optionalParsedPath) {
  const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
  this._targetGroup = targetGroup;
  this._bindings = targetGroup.subscribe_(path, parsedPath);
}

Object.assign(Composite.prototype, {
  getValue: function (array, offset) {
    this.bind(); // bind all binding

    const firstValidIndex = this._targetGroup.nCachedObjects_,
          binding = this._bindings[firstValidIndex]; // and only call .getValue on the first

    if (binding !== undefined) binding.getValue(array, offset);
  },
  setValue: function (array, offset) {
    const bindings = this._bindings;

    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].setValue(array, offset);
    }
  },
  bind: function () {
    const bindings = this._bindings;

    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].bind();
    }
  },
  unbind: function () {
    const bindings = this._bindings;

    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].unbind();
    }
  }
});

function PropertyBinding(rootNode, path, parsedPath) {
  this.path = path;
  this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
  this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
  this.rootNode = rootNode;
}

Object.assign(PropertyBinding, {
  Composite: Composite,
  create: function (root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  },

  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  sanitizeNodeName: function (name) {
    return name.replace(/\s/g, '_').replace(_reservedRe, '');
  },
  parseTrackName: function (trackName) {
    const matches = _trackRe.exec(trackName);

    if (!matches) {
      throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
    }

    const results = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      // required
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

    if (lastDot !== undefined && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there
      // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
      // 'bar' could be the objectName, or part of a nodeName (which can
      // include '.' characters).

      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }

    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
    }

    return results;
  },
  findNode: function (root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    } // search into skeleton bones.


    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);

      if (bone !== undefined) {
        return bone;
      }
    } // search into node subtree.


    if (root.children) {
      const searchNodeSubtree = function (children) {
        for (let i = 0; i < children.length; i++) {
          const childNode = children[i];

          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }

          const result = searchNodeSubtree(childNode.children);
          if (result) return result;
        }

        return null;
      };

      const subTreeNode = searchNodeSubtree(root.children);

      if (subTreeNode) {
        return subTreeNode;
      }
    }

    return null;
  }
});
Object.assign(PropertyBinding.prototype, {
  // prototype, continued
  // these are used to "bind" a nonexistent property
  _getValue_unavailable: function () {},
  _setValue_unavailable: function () {},
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [function getValue_direct(buffer, offset) {
    buffer[offset] = this.node[this.propertyName];
  }, function getValue_array(buffer, offset) {
    const source = this.resolvedProperty;

    for (let i = 0, n = source.length; i !== n; ++i) {
      buffer[offset++] = source[i];
    }
  }, function getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex];
  }, function getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset);
  }],
  SetterByBindingTypeAndVersioning: [[// Direct
  function setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
  }, function setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }, function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [// EntireArray
  function setValue_array(buffer, offset) {
    const dest = this.resolvedProperty;

    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
  }, function setValue_array_setNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;

    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }

    this.targetObject.needsUpdate = true;
  }, function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;

    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }

    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [// ArrayElement
  function setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
  }, function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }, function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [// HasToFromArray
  function setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
  }, function setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.needsUpdate = true;
  }, function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }]],
  getValue: function getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset); // Note: This class uses a State pattern on a per-method basis:
    // 'bind' sets 'this.getValue' / 'setValue' and shadows the
    // prototype version of these methods with one that represents
    // the bound state. When the property is not found, the methods
    // become no-ops.
  },
  setValue: function getValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  },
  // create getter / setter pair for a property in the scene graph
  bind: function () {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;

    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    } // set fail state so we can just 'return' on error


    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable; // ensure there is a value node

    if (!targetObject) {
      console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
      return;
    }

    if (objectName) {
      let objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....

      switch (objectName) {
        case 'materials':
          if (!targetObject.material) {
            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
            return;
          }

          if (!targetObject.material.materials) {
            console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
            return;
          }

          targetObject = targetObject.material.materials;
          break;

        case 'bones':
          if (!targetObject.skeleton) {
            console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
            return;
          } // potential future optimization: skip this if propertyIndex is already an integer
          // and convert the integer string to a true integer.


          targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.

          for (let i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i;
              break;
            }
          }

          break;

        default:
          if (targetObject[objectName] === undefined) {
            console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
            return;
          }

          targetObject = targetObject[objectName];
      }

      if (objectIndex !== undefined) {
        if (targetObject[objectIndex] === undefined) {
          console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
          return;
        }

        targetObject = targetObject[objectIndex];
      }
    } // resolve property


    const nodeProperty = targetObject[propertyName];

    if (nodeProperty === undefined) {
      const nodeName = parsedPath.nodeName;
      console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
      return;
    } // determine versioning scheme


    let versioning = this.Versioning.None;
    this.targetObject = targetObject;

    if (targetObject.needsUpdate !== undefined) {
      // material
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
      // node transform
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    } // determine how the property gets bound


    let bindingType = this.BindingType.Direct;

    if (propertyIndex !== undefined) {
      // access a sub element of the property array (only primitives are supported right now)
      if (propertyName === "morphTargetInfluences") {
        // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
        // support resolving morphTarget names into indices.
        if (!targetObject.geometry) {
          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
          return;
        }

        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
            return;
          }

          if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        } else {
          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
          return;
        }
      }

      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
      // must use copy for Object3D.Euler/Quaternion
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    } // select getter / setter


    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  },
  unbind: function () {
    this.node = null; // back to the prototype version of getValue / setValue
    // note: avoiding to mutate the shape of 'this' via 'delete'

    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
}); // DECLARE ALIAS AFTER assign prototype

Object.assign(PropertyBinding.prototype, {
  // initial state of these methods that calls 'bind'
  _getValue_unbound: PropertyBinding.prototype.getValue,
  _setValue_unbound: PropertyBinding.prototype.setValue
});
/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */

function AnimationObjectGroup() {
  this.uuid = MathUtils.generateUUID(); // cached objects followed by the active ones

  this._objects = Array.prototype.slice.call(arguments);
  this.nCachedObjects_ = 0; // threshold
  // note: read by PropertyBinding.Composite

  const indices = {};
  this._indicesByUUID = indices; // for bookkeeping

  for (let i = 0, n = arguments.length; i !== n; ++i) {
    indices[arguments[i].uuid] = i;
  }

  this._paths = []; // inside: string

  this._parsedPaths = []; // inside: { we don't care, here }

  this._bindings = []; // inside: Array< PropertyBinding >

  this._bindingsIndicesByPath = {}; // inside: indices in these arrays

  const scope = this;
  this.stats = {
    objects: {
      get total() {
        return scope._objects.length;
      },

      get inUse() {
        return this.total - scope.nCachedObjects_;
      }

    },

    get bindingsPerObject() {
      return scope._bindings.length;
    }

  };
}

Object.assign(AnimationObjectGroup.prototype, {
  isAnimationObjectGroup: true,
  add: function () {
    const objects = this._objects,
          indicesByUUID = this._indicesByUUID,
          paths = this._paths,
          parsedPaths = this._parsedPaths,
          bindings = this._bindings,
          nBindings = bindings.length;
    let knownObject = undefined,
        nObjects = objects.length,
        nCachedObjects = this.nCachedObjects_;

    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
            uuid = object.uuid;
      let index = indicesByUUID[uuid];

      if (index === undefined) {
        // unknown object -> add it to the ACTIVE region
        index = nObjects++;
        indicesByUUID[uuid] = index;
        objects.push(object); // accounting is done, now do the same for all bindings

        for (let j = 0, m = nBindings; j !== m; ++j) {
          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
        }
      } else if (index < nCachedObjects) {
        knownObject = objects[index]; // move existing object to the ACTIVE region

        const firstActiveIndex = --nCachedObjects,
              lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index;
        objects[index] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings

        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j],
                lastCached = bindingsForPath[firstActiveIndex];
          let binding = bindingsForPath[index];
          bindingsForPath[index] = lastCached;

          if (binding === undefined) {
            // since we do not bother to create new bindings
            // for objects that are cached, the binding may
            // or may not exist
            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
          }

          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index] !== knownObject) {
        console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
      } // else the object is already where we want it to be

    } // for arguments


    this.nCachedObjects_ = nCachedObjects;
  },
  remove: function () {
    const objects = this._objects,
          indicesByUUID = this._indicesByUUID,
          bindings = this._bindings,
          nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_;

    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
            uuid = object.uuid,
            index = indicesByUUID[uuid];

      if (index !== undefined && index >= nCachedObjects) {
        // move existing object into the CACHED region
        const lastCachedIndex = nCachedObjects++,
              firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index;
        objects[index] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings

        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j],
                firstActive = bindingsForPath[lastCachedIndex],
                binding = bindingsForPath[index];
          bindingsForPath[index] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    } // for arguments


    this.nCachedObjects_ = nCachedObjects;
  },
  // remove & forget
  uncache: function () {
    const objects = this._objects,
          indicesByUUID = this._indicesByUUID,
          bindings = this._bindings,
          nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_,
        nObjects = objects.length;

    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
            uuid = object.uuid,
            index = indicesByUUID[uuid];

      if (index !== undefined) {
        delete indicesByUUID[uuid];

        if (index < nCachedObjects) {
          // object is cached, shrink the CACHED region
          const firstActiveIndex = --nCachedObjects,
                lastCachedObject = objects[firstActiveIndex],
                lastIndex = --nObjects,
                lastObject = objects[lastIndex]; // last cached object takes this object's place

          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject; // last object goes to the activated slot and pop

          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop(); // accounting is done, now do the same for all bindings

          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j],
                  lastCached = bindingsForPath[firstActiveIndex],
                  last = bindingsForPath[lastIndex];
            bindingsForPath[index] = lastCached;
            bindingsForPath[firstActiveIndex] = last;
            bindingsForPath.pop();
          }
        } else {
          // object is active, just swap with the last and pop
          const lastIndex = --nObjects,
                lastObject = objects[lastIndex];
          indicesByUUID[lastObject.uuid] = index;
          objects[index] = lastObject;
          objects.pop(); // accounting is done, now do the same for all bindings

          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j];
            bindingsForPath[index] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        } // cached or active

      } // if object is known

    } // for arguments


    this.nCachedObjects_ = nCachedObjects;
  },
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_: function (path, parsedPath) {
    // returns an array of bindings for the given path that is changed
    // according to the contained objects in the group
    const indicesByPath = this._bindingsIndicesByPath;
    let index = indicesByPath[path];
    const bindings = this._bindings;
    if (index !== undefined) return bindings[index];
    const paths = this._paths,
          parsedPaths = this._parsedPaths,
          objects = this._objects,
          nObjects = objects.length,
          nCachedObjects = this.nCachedObjects_,
          bindingsForPath = new Array(nObjects);
    index = bindings.length;
    indicesByPath[path] = index;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);

    for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
      const object = objects[i];
      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
    }

    return bindingsForPath;
  },
  unsubscribe_: function (path) {
    // tells the group to forget about a property path and no longer
    // update the array previously obtained with 'subscribe_'
    const indicesByPath = this._bindingsIndicesByPath,
          index = indicesByPath[path];

    if (index !== undefined) {
      const paths = this._paths,
            parsedPaths = this._parsedPaths,
            bindings = this._bindings,
            lastBindingsIndex = bindings.length - 1,
            lastBindings = bindings[lastBindingsIndex],
            lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index;
      bindings[index] = lastBindings;
      bindings.pop();
      parsedPaths[index] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
});

class AnimationAction {
  constructor(mixer, clip, localRoot, blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot || null;
    this.blendMode = blendMode || clip.blendMode;
    const tracks = clip.tracks,
          nTracks = tracks.length,
          interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };

    for (let i = 0; i !== nTracks; ++i) {
      const interpolant = tracks[i].createInterpolant(null);
      interpolants[i] = interpolant;
      interpolant.settings = interpolantSettings;
    }

    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants; // bound by the mixer
    // inside: PropertyMixer (managed by the mixer)

    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null; // for the memory manager

    this._byClipCacheIndex = null; // for the memory manager

    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1; // global mixer time when the action is to be started
    // it's set back to 'null' upon start of the action

    this._startTime = null; // scaled local time of the action
    // gets clamped or wrapped to 0..clip.duration according to loop

    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity; // no. of repetitions when looping

    this.paused = false; // true -> zero effective time scale

    this.enabled = true; // false -> zero effective weight

    this.clampWhenFinished = false; // keep feeding the last frame?

    this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate

    this.zeroSlopeAtEnd = true; // clips for start, loop and end
  } // State & Scheduling


  play() {
    this._mixer._activateAction(this);

    return this;
  }

  stop() {
    this._mixer._deactivateAction(this);

    return this.reset();
  }

  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0; // restart clip

    this._loopCount = -1; // forget previous loops

    this._startTime = null; // forget scheduling

    return this.stopFading().stopWarping();
  }

  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  } // return true when play has been called


  isScheduled() {
    return this._mixer._isActiveAction(this);
  }

  startAt(time) {
    this._startTime = time;
    return this;
  }

  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  } // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing


  setEffectiveWeight(weight) {
    this.weight = weight; // note: same logic as when updated at runtime

    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  } // return the weight considering fading and .enabled


  getEffectiveWeight() {
    return this._effectiveWeight;
  }

  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }

  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }

  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);

    if (warp) {
      const fadeInDuration = this._clip.duration,
            fadeOutDuration = fadeOutAction._clip.duration,
            startEndRatio = fadeOutDuration / fadeInDuration,
            endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1.0, startEndRatio, duration);
      this.warp(endStartRatio, 1.0, duration);
    }

    return this;
  }

  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }

  stopFading() {
    const weightInterpolant = this._weightInterpolant;

    if (weightInterpolant !== null) {
      this._weightInterpolant = null;

      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }

    return this;
  } // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing


  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  } // return the time scale considering warping and .paused


  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }

  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }

  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }

  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }

  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer,
          now = mixer.time,
          timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;

    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }

    const times = interpolant.parameterPositions,
          values = interpolant.sampleValues;
    times[0] = now;
    times[1] = now + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }

  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;

    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;

      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }

    return this;
  } // Object Accessors


  getMixer() {
    return this._mixer;
  }

  getClip() {
    return this._clip;
  }

  getRoot() {
    return this._localRoot || this._mixer._root;
  } // Interna


  _update(time, deltaTime, timeDirection, accuIndex) {
    // called by the mixer
    if (!this.enabled) {
      // call ._updateWeight() to update ._effectiveWeight
      this._updateWeight(time);

      return;
    }

    const startTime = this._startTime;

    if (startTime !== null) {
      // check for scheduled start of action
      const timeRunning = (time - startTime) * timeDirection;

      if (timeRunning < 0 || timeDirection === 0) {
        return; // yet to come / don't decide when delta = 0
      } // start


      this._startTime = null; // unschedule

      deltaTime = timeDirection * timeRunning;
    } // apply time scale and advance time


    deltaTime *= this._updateTimeScale(time);

    const clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in
    // an effective weight of 0


    const weight = this._updateWeight(time);

    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;

      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulateAdditive(weight);
          }

          break;

        case NormalAnimationBlendMode:
        default:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulate(accuIndex, weight);
          }

      }
    }
  }

  _updateWeight(time) {
    let weight = 0;

    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;

      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;

        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();

          if (interpolantValue === 0) {
            // faded out, disable
            this.enabled = false;
          }
        }
      }
    }

    this._effectiveWeight = weight;
    return weight;
  }

  _updateTimeScale(time) {
    let timeScale = 0;

    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;

      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;

        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();

          if (timeScale === 0) {
            // motion has halted, pause
            this.paused = true;
          } else {
            // warp done - apply final time scale
            this.timeScale = timeScale;
          }
        }
      }
    }

    this._effectiveTimeScale = timeScale;
    return timeScale;
  }

  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;

    if (deltaTime === 0) {
      if (loopCount === -1) return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }

    if (loop === LoopOnce) {
      if (loopCount === -1) {
        // just started
        this._loopCount = 0;

        this._setEndings(true, true, false);
      }

      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }

        if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
        this.time = time;

        this._mixer.dispatchEvent({
          type: 'finished',
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      // repetitive Repeat or PingPong
      if (loopCount === -1) {
        // just started
        if (deltaTime >= 0) {
          loopCount = 0;

          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          // when looping in reverse direction, the initial
          // transition through zero counts as a repetition,
          // so leave loopCount at -1
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }

      if (time >= duration || time < 0) {
        // wrap around
        const loopDelta = Math.floor(time / duration); // signed

        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;

        if (pending <= 0) {
          // have to stop (switch state, clamp time, fire event)
          if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;

          this._mixer.dispatchEvent({
            type: 'finished',
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          // keep running
          if (pending === 1) {
            // entering the last round
            const atStart = deltaTime < 0;

            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }

          this._loopCount = loopCount;
          this.time = time;

          this._mixer.dispatchEvent({
            type: 'loop',
            action: this,
            loopDelta: loopDelta
          });
        }
      } else {
        this.time = time;
      }

      if (pingPong && (loopCount & 1) === 1) {
        // invert time for the "pong round"
        return duration - time;
      }
    }

    return time;
  }

  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;

    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      // assuming for LoopOnce atStart == atEnd == true
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }

      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }

  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer,
          now = mixer.time;
    let interpolant = this._weightInterpolant;

    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }

    const times = interpolant.parameterPositions,
          values = interpolant.sampleValues;
    times[0] = now;
    values[0] = weightNow;
    times[1] = now + duration;
    values[1] = weightThen;
    return this;
  }

}

function AnimationMixer(root) {
  this._root = root;

  this._initMemoryManager();

  this._accuIndex = 0;
  this.time = 0;
  this.timeScale = 1.0;
}

AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: AnimationMixer,
  _bindAction: function (action, prototypeAction) {
    const root = action._localRoot || this._root,
          tracks = action._clip.tracks,
          nTracks = tracks.length,
          bindings = action._propertyBindings,
          interpolants = action._interpolants,
          rootUuid = root.uuid,
          bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];

    if (bindingsByName === undefined) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }

    for (let i = 0; i !== nTracks; ++i) {
      const track = tracks[i],
            trackName = track.name;
      let binding = bindingsByName[trackName];

      if (binding !== undefined) {
        bindings[i] = binding;
      } else {
        binding = bindings[i];

        if (binding !== undefined) {
          // existing binding, make sure the cache knows
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;

            this._addInactiveBinding(binding, rootUuid, trackName);
          }

          continue;
        }

        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;

        this._addInactiveBinding(binding, rootUuid, trackName);

        bindings[i] = binding;
      }

      interpolants[i].resultBuffer = binding.buffer;
    }
  },
  _activateAction: function (action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        // this action has been forgotten by the cache, but the user
        // appears to be still using it -> rebind
        const rootUuid = (action._localRoot || this._root).uuid,
              clipUuid = action._clip.uuid,
              actionsForClip = this._actionsByClip[clipUuid];

        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);

        this._addInactiveAction(action, clipUuid, rootUuid);
      }

      const bindings = action._propertyBindings; // increment reference counts / sort out state

      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];

        if (binding.useCount++ === 0) {
          this._lendBinding(binding);

          binding.saveOriginalState();
        }
      }

      this._lendAction(action);
    }
  },
  _deactivateAction: function (action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings; // decrement reference counts / sort out state

      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];

        if (--binding.useCount === 0) {
          binding.restoreOriginalState();

          this._takeBackBinding(binding);
        }
      }

      this._takeBackAction(action);
    }
  },
  // Memory manager
  _initMemoryManager: function () {
    this._actions = []; // 'nActiveActions' followed by inactive ones

    this._nActiveActions = 0;
    this._actionsByClip = {}; // inside:
    // {
    // 	knownActions: Array< AnimationAction > - used as prototypes
    // 	actionByRoot: AnimationAction - lookup
    // }

    this._bindings = []; // 'nActiveBindings' followed by inactive ones

    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

    this._controlInterpolants = []; // same game as above

    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },

        get inUse() {
          return scope._nActiveActions;
        }

      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },

        get inUse() {
          return scope._nActiveBindings;
        }

      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },

        get inUse() {
          return scope._nActiveControlInterpolants;
        }

      }
    };
  },
  // Memory management for AnimationAction objects
  _isActiveAction: function (action) {
    const index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  },
  _addInactiveAction: function (action, clipUuid, rootUuid) {
    const actions = this._actions,
          actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];

    if (actionsForClip === undefined) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }

    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  },
  _removeInactiveAction: function (action) {
    const actions = this._actions,
          lastInactiveAction = actions[actions.length - 1],
          cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid,
          actionsByClip = this._actionsByClip,
          actionsForClip = actionsByClip[clipUuid],
          knownActionsForClip = actionsForClip.knownActions,
          lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
          byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot,
          rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];

    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }

    this._removeInactiveBindingsForAction(action);
  },
  _removeInactiveBindingsForAction: function (action) {
    const bindings = action._propertyBindings;

    for (let i = 0, n = bindings.length; i !== n; ++i) {
      const binding = bindings[i];

      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  },
  _lendAction: function (action) {
    // [ active actions |  inactive actions  ]
    // [  active actions >| inactive actions ]
    //                 s        a
    //                  <-swap->
    //                 a        s
    const actions = this._actions,
          prevIndex = action._cacheIndex,
          lastActiveIndex = this._nActiveActions++,
          firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  },
  _takeBackAction: function (action) {
    // [  active actions  | inactive actions ]
    // [ active actions |< inactive actions  ]
    //        a        s
    //         <-swap->
    //        s        a
    const actions = this._actions,
          prevIndex = action._cacheIndex,
          firstInactiveIndex = --this._nActiveActions,
          lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  },
  // Memory management for PropertyMixer objects
  _addInactiveBinding: function (binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName,
          bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];

    if (bindingByName === undefined) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }

    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  },
  _removeInactiveBinding: function (binding) {
    const bindings = this._bindings,
          propBinding = binding.binding,
          rootUuid = propBinding.rootNode.uuid,
          trackName = propBinding.path,
          bindingsByRoot = this._bindingsByRootAndName,
          bindingByName = bindingsByRoot[rootUuid],
          lastInactiveBinding = bindings[bindings.length - 1],
          cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];

    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  },
  _lendBinding: function (binding) {
    const bindings = this._bindings,
          prevIndex = binding._cacheIndex,
          lastActiveIndex = this._nActiveBindings++,
          firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  },
  _takeBackBinding: function (binding) {
    const bindings = this._bindings,
          prevIndex = binding._cacheIndex,
          firstInactiveIndex = --this._nActiveBindings,
          lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  },
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant: function () {
    const interpolants = this._controlInterpolants,
          lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];

    if (interpolant === undefined) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }

    return interpolant;
  },
  _takeBackControlInterpolant: function (interpolant) {
    const interpolants = this._controlInterpolants,
          prevIndex = interpolant.__cacheIndex,
          firstInactiveIndex = --this._nActiveControlInterpolants,
          lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  },
  _controlInterpolantsResultBuffer: new Float32Array(1),
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction: function (clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root,
          rootUuid = root.uuid;
    let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;

    if (blendMode === undefined) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }

    if (actionsForClip !== undefined) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];

      if (existingAction !== undefined && existingAction.blendMode === blendMode) {
        return existingAction;
      } // we know the clip, so we don't have to parse all
      // the bindings again but can just copy


      prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action

      if (clipObject === null) clipObject = prototypeAction._clip;
    } // clip must be known when specified via string


    if (clipObject === null) return null; // allocate all resources required to run it

    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);

    this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager


    this._addInactiveAction(newAction, clipUuid, rootUuid);

    return newAction;
  },
  // get an existing action
  existingAction: function (clip, optionalRoot) {
    const root = optionalRoot || this._root,
          rootUuid = root.uuid,
          clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
          clipUuid = clipObject ? clipObject.uuid : clip,
          actionsForClip = this._actionsByClip[clipUuid];

    if (actionsForClip !== undefined) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }

    return null;
  },
  // deactivates all previously scheduled actions
  stopAllAction: function () {
    const actions = this._actions,
          nActions = this._nActiveActions;

    for (let i = nActions - 1; i >= 0; --i) {
      actions[i].stop();
    }

    return this;
  },
  // advance the time and update apply the animation
  update: function (deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions,
          nActions = this._nActiveActions,
          time = this.time += deltaTime,
          timeDirection = Math.sign(deltaTime),
          accuIndex = this._accuIndex ^= 1; // run active actions

    for (let i = 0; i !== nActions; ++i) {
      const action = actions[i];

      action._update(time, deltaTime, timeDirection, accuIndex);
    } // update scene graph


    const bindings = this._bindings,
          nBindings = this._nActiveBindings;

    for (let i = 0; i !== nBindings; ++i) {
      bindings[i].apply(accuIndex);
    }

    return this;
  },
  // Allows you to seek to a specific time in an animation.
  setTime: function (timeInSeconds) {
    this.time = 0; // Zero out time attribute for AnimationMixer object;

    for (let i = 0; i < this._actions.length; i++) {
      this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
    }

    return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
  },
  // return this mixer's root target object
  getRoot: function () {
    return this._root;
  },
  // free all resources specific to a particular clip
  uncacheClip: function (clip) {
    const actions = this._actions,
          clipUuid = clip.uuid,
          actionsByClip = this._actionsByClip,
          actionsForClip = actionsByClip[clipUuid];

    if (actionsForClip !== undefined) {
      // note: just calling _removeInactiveAction would mess up the
      // iteration state and also require updating the state we can
      // just throw away
      const actionsToRemove = actionsForClip.knownActions;

      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
        const action = actionsToRemove[i];

        this._deactivateAction(action);

        const cacheIndex = action._cacheIndex,
              lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();

        this._removeInactiveBindingsForAction(action);
      }

      delete actionsByClip[clipUuid];
    }
  },
  // free all resources specific to a particular root target object
  uncacheRoot: function (root) {
    const rootUuid = root.uuid,
          actionsByClip = this._actionsByClip;

    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot,
            action = actionByRoot[rootUuid];

      if (action !== undefined) {
        this._deactivateAction(action);

        this._removeInactiveAction(action);
      }
    }

    const bindingsByRoot = this._bindingsByRootAndName,
          bindingByName = bindingsByRoot[rootUuid];

    if (bindingByName !== undefined) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();

        this._removeInactiveBinding(binding);
      }
    }
  },
  // remove a targeted clip from the cache
  uncacheAction: function (clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);

    if (action !== null) {
      this._deactivateAction(action);

      this._removeInactiveAction(action);
    }
  }
});

class Uniform {
  constructor(value) {
    if (typeof value === 'string') {
      console.warn('THREE.Uniform: Type parameter is no longer needed.');
      value = arguments[1];
    }

    this.value = value;
  }

  clone() {
    return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
  }

}

exports.Uniform = Uniform;

function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
  InterleavedBuffer.call(this, array, stride);
  this.meshPerAttribute = meshPerAttribute || 1;
}

InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
  constructor: InstancedInterleavedBuffer,
  isInstancedInterleavedBuffer: true,
  copy: function (source) {
    InterleavedBuffer.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  clone: function (data) {
    const ib = InterleavedBuffer.prototype.clone.call(this, data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  },
  toJSON: function (data) {
    const json = InterleavedBuffer.prototype.toJSON.call(this, data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
});
/**
 * @author raub / https://github.com/raub
 */

/**
 * Element size is one of:
 * 5126: 4
 * 5123: 2
 * 5122: 2
 * 5125: 4
 * 5124: 4
 * 5120: 1
 * 5121: 1
 */

function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
  this.buffer = buffer;
  this.type = type;
  this.itemSize = itemSize;
  this.elementSize = elementSize;
  this.count = count;
  this.version = 0;
}

Object.defineProperty(GLBufferAttribute.prototype, 'needsUpdate', {
  set: function (value) {
    if (value === true) this.version++;
  }
});
Object.assign(GLBufferAttribute.prototype, {
  isGLBufferAttribute: true,
  setBuffer: function (buffer) {
    this.buffer = buffer;
    return this;
  },
  setType: function (type, elementSize) {
    this.type = type;
    this.elementSize = elementSize;
    return this;
  },
  setItemSize: function (itemSize) {
    this.itemSize = itemSize;
    return this;
  },
  setCount: function (count) {
    this.count = count;
    return this;
  }
});

function Raycaster(origin, direction, near, far) {
  this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)

  this.near = near || 0;
  this.far = far || Infinity;
  this.camera = null;
  this.layers = new Layers();
  this.params = {
    Mesh: {},
    Line: {
      threshold: 1
    },
    LOD: {},
    Points: {
      threshold: 1
    },
    Sprite: {}
  };
  Object.defineProperties(this.params, {
    PointCloud: {
      get: function () {
        console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
        return this.Points;
      }
    }
  });
}

function ascSort(a, b) {
  return a.distance - b.distance;
}

function intersectObject(object, raycaster, intersects, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects);
  }

  if (recursive === true) {
    const children = object.children;

    for (let i = 0, l = children.length; i < l; i++) {
      intersectObject(children[i], raycaster, intersects, true);
    }
  }
}

Object.assign(Raycaster.prototype, {
  set: function (origin, direction) {
    // direction is assumed to be normalized (for accurate distance calculations)
    this.ray.set(origin, direction);
  },
  setFromCamera: function (coords, camera) {
    if (camera && camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera && camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera

      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error('THREE.Raycaster: Unsupported camera type.');
    }
  },
  intersectObject: function (object, recursive, optionalTarget) {
    const intersects = optionalTarget || [];
    intersectObject(object, this, intersects, recursive);
    intersects.sort(ascSort);
    return intersects;
  },
  intersectObjects: function (objects, recursive, optionalTarget) {
    const intersects = optionalTarget || [];

    if (Array.isArray(objects) === false) {
      console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
      return intersects;
    }

    for (let i = 0, l = objects.length; i < l; i++) {
      intersectObject(objects[i], this, intersects, recursive);
    }

    intersects.sort(ascSort);
    return intersects;
  }
});
/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */

class Spherical {
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius;
    this.phi = phi; // polar angle

    this.theta = theta; // azimuthal angle

    return this;
  }

  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  } // restrict phi to be betwee EPS and PI-EPS


  makeSafe() {
    const EPS = 0.000001;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  }

  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }

  setFromCartesianCoords(x, y, z) {
    this.radius = Math.sqrt(x * x + y * y + z * z);

    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x, z);
      this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));
    }

    return this;
  }

}
/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */


exports.Spherical = Spherical;

class Cylindrical {
  constructor(radius, theta, y) {
    this.radius = radius !== undefined ? radius : 1.0; // distance from the origin to a point in the x-z plane

    this.theta = theta !== undefined ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis

    this.y = y !== undefined ? y : 0; // height above the x-z plane

    return this;
  }

  set(radius, theta, y) {
    this.radius = radius;
    this.theta = theta;
    this.y = y;
    return this;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(other) {
    this.radius = other.radius;
    this.theta = other.theta;
    this.y = other.y;
    return this;
  }

  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }

  setFromCartesianCoords(x, y, z) {
    this.radius = Math.sqrt(x * x + z * z);
    this.theta = Math.atan2(x, z);
    this.y = y;
    return this;
  }

}

exports.Cylindrical = Cylindrical;

const _vector$7 = new Vector2();

class Box2 {
  constructor(min, max) {
    Object.defineProperty(this, 'isBox2', {
      value: true
    });
    this.min = min !== undefined ? min : new Vector2(+Infinity, +Infinity);
    this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);
  }

  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }

  setFromPoints(points) {
    this.makeEmpty();

    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }

    return this;
  }

  setFromCenterAndSize(center, size) {
    const halfSize = _vector$7.copy(size).multiplyScalar(0.5);

    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }

  makeEmpty() {
    this.min.x = this.min.y = +Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }

  isEmpty() {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }

  getCenter(target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .getCenter() target is now required');
      target = new Vector2();
    }

    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }

  getSize(target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .getSize() target is now required');
      target = new Vector2();
    }

    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
  }

  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }

  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }

  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }

  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
  }

  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  }

  getParameter(point, target) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.
    if (target === undefined) {
      console.warn('THREE.Box2: .getParameter() target is now required');
      target = new Vector2();
    }

    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
  }

  intersectsBox(box) {
    // using 4 splitting planes to rule out intersections
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
  }

  clampPoint(point, target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .clampPoint() target is now required');
      target = new Vector2();
    }

    return target.copy(point).clamp(this.min, this.max);
  }

  distanceToPoint(point) {
    const clampedPoint = _vector$7.copy(point).clamp(this.min, this.max);

    return clampedPoint.sub(point).length();
  }

  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  }

  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }

  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }

  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }

}

exports.Box2 = Box2;

const _startP = new Vector3();

const _startEnd = new Vector3();

class Line3 {
  constructor(start, end) {
    this.start = start !== undefined ? start : new Vector3();
    this.end = end !== undefined ? end : new Vector3();
  }

  set(start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  }

  getCenter(target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .getCenter() target is now required');
      target = new Vector3();
    }

    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  }

  delta(target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .delta() target is now required');
      target = new Vector3();
    }

    return target.subVectors(this.end, this.start);
  }

  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }

  distance() {
    return this.start.distanceTo(this.end);
  }

  at(t, target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .at() target is now required');
      target = new Vector3();
    }

    return this.delta(target).multiplyScalar(t).add(this.start);
  }

  closestPointToPointParameter(point, clampToLine) {
    _startP.subVectors(point, this.start);

    _startEnd.subVectors(this.end, this.start);

    const startEnd2 = _startEnd.dot(_startEnd);

    const startEnd_startP = _startEnd.dot(_startP);

    let t = startEnd_startP / startEnd2;

    if (clampToLine) {
      t = MathUtils.clamp(t, 0, 1);
    }

    return t;
  }

  closestPointToPoint(point, clampToLine, target) {
    const t = this.closestPointToPointParameter(point, clampToLine);

    if (target === undefined) {
      console.warn('THREE.Line3: .closestPointToPoint() target is now required');
      target = new Vector3();
    }

    return this.delta(target).multiplyScalar(t).add(this.start);
  }

  applyMatrix4(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  }

  equals(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }

}

exports.Line3 = Line3;

function ImmediateRenderObject(material) {
  Object3D.call(this);
  this.material = material;

  this.render = function ()
  /* renderCallback */
  {};

  this.hasPositions = false;
  this.hasNormals = false;
  this.hasColors = false;
  this.hasUvs = false;
  this.positionArray = null;
  this.normalArray = null;
  this.colorArray = null;
  this.uvArray = null;
  this.count = 0;
}

ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;

const _vector$8 = new Vector3();

class SpotLightHelper extends Object3D {
  constructor(light, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    const geometry = new BufferGeometry();
    const positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];

    for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
      const p1 = i / l * Math.PI * 2;
      const p2 = j / l * Math.PI * 2;
      positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
    }

    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    const material = new LineBasicMaterial({
      fog: false,
      toneMapped: false
    });
    this.cone = new LineSegments(geometry, material);
    this.add(this.cone);
    this.update();
  }

  dispose() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  }

  update() {
    this.light.updateMatrixWorld();
    const coneLength = this.light.distance ? this.light.distance : 1000;
    const coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);

    _vector$8.setFromMatrixPosition(this.light.target.matrixWorld);

    this.cone.lookAt(_vector$8);

    if (this.color !== undefined) {
      this.cone.material.color.set(this.color);
    } else {
      this.cone.material.color.copy(this.light.color);
    }
  }

}

exports.SpotLightHelper = SpotLightHelper;

const _vector$9 = new Vector3();

const _boneMatrix = new Matrix4();

const _matrixWorldInv = new Matrix4();

class SkeletonHelper extends LineSegments {
  constructor(object) {
    const bones = getBoneList(object);
    const geometry = new BufferGeometry();
    const vertices = [];
    const colors = [];
    const color1 = new Color(0, 0, 1);
    const color2 = new Color(0, 1, 0);

    for (let i = 0; i < bones.length; i++) {
      const bone = bones[i];

      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors.push(color1.r, color1.g, color1.b);
        colors.push(color2.r, color2.g, color2.b);
      }
    }

    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({
      vertexColors: true,
      depthTest: false,
      depthWrite: false,
      toneMapped: false,
      transparent: true
    });
    super(geometry, material);
    this.type = 'SkeletonHelper';
    this.isSkeletonHelper = true;
    this.root = object;
    this.bones = bones;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  }

  updateMatrixWorld(force) {
    const bones = this.bones;
    const geometry = this.geometry;
    const position = geometry.getAttribute('position');

    _matrixWorldInv.getInverse(this.root.matrixWorld);

    for (let i = 0, j = 0; i < bones.length; i++) {
      const bone = bones[i];

      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);

        _vector$9.setFromMatrixPosition(_boneMatrix);

        position.setXYZ(j, _vector$9.x, _vector$9.y, _vector$9.z);

        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);

        _vector$9.setFromMatrixPosition(_boneMatrix);

        position.setXYZ(j + 1, _vector$9.x, _vector$9.y, _vector$9.z);
        j += 2;
      }
    }

    geometry.getAttribute('position').needsUpdate = true;
    super.updateMatrixWorld(force);
  }

}

exports.SkeletonHelper = SkeletonHelper;

function getBoneList(object) {
  const boneList = [];

  if (object && object.isBone) {
    boneList.push(object);
  }

  for (let i = 0; i < object.children.length; i++) {
    boneList.push.apply(boneList, getBoneList(object.children[i]));
  }

  return boneList;
}

class PointLightHelper extends Mesh {
  constructor(light, sphereSize, color) {
    const geometry = new SphereBufferGeometry(sphereSize, 4, 2);
    const material = new MeshBasicMaterial({
      wireframe: true,
      fog: false,
      toneMapped: false
    });
    super(geometry, material);
    this.light = light;
    this.light.updateMatrixWorld();
    this.color = color;
    this.type = 'PointLightHelper';
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
    /*
    // TODO: delete this comment?
    const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
    const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
    this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
    this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
    const d = light.distance;
    if ( d === 0.0 ) {
    	this.lightDistance.visible = false;
    } else {
    	this.lightDistance.scale.set( d, d, d );
    }
    this.add( this.lightDistance );
    */
  }

  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }

  update() {
    if (this.color !== undefined) {
      this.material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color);
    }
    /*
    const d = this.light.distance;
    	if ( d === 0.0 ) {
    		this.lightDistance.visible = false;
    	} else {
    		this.lightDistance.visible = true;
    	this.lightDistance.scale.set( d, d, d );
    	}
    */

  }

}

exports.PointLightHelper = PointLightHelper;

const _vector$a = new Vector3();

const _color1 = new Color();

const _color2 = new Color();

class HemisphereLightHelper extends Object3D {
  constructor(light, size, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    const geometry = new OctahedronBufferGeometry(size);
    geometry.rotateY(Math.PI * 0.5);
    this.material = new MeshBasicMaterial({
      wireframe: true,
      fog: false,
      toneMapped: false
    });
    if (this.color === undefined) this.material.vertexColors = true;
    const position = geometry.getAttribute('position');
    const colors = new Float32Array(position.count * 3);
    geometry.setAttribute('color', new BufferAttribute(colors, 3));
    this.add(new Mesh(geometry, this.material));
    this.update();
  }

  dispose() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  }

  update() {
    const mesh = this.children[0];

    if (this.color !== undefined) {
      this.material.color.set(this.color);
    } else {
      const colors = mesh.geometry.getAttribute('color');

      _color1.copy(this.light.color);

      _color2.copy(this.light.groundColor);

      for (let i = 0, l = colors.count; i < l; i++) {
        const color = i < l / 2 ? _color1 : _color2;
        colors.setXYZ(i, color.r, color.g, color.b);
      }

      colors.needsUpdate = true;
    }

    mesh.lookAt(_vector$a.setFromMatrixPosition(this.light.matrixWorld).negate());
  }

}

exports.HemisphereLightHelper = HemisphereLightHelper;

class GridHelper extends LineSegments {
  constructor(size, divisions, color1, color2) {
    size = size || 10;
    divisions = divisions || 10;
    color1 = new Color(color1 !== undefined ? color1 : 0x444444);
    color2 = new Color(color2 !== undefined ? color2 : 0x888888);
    const center = divisions / 2;
    const step = size / divisions;
    const halfSize = size / 2;
    const vertices = [],
          colors = [];

    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
      vertices.push(-halfSize, 0, k, halfSize, 0, k);
      vertices.push(k, 0, -halfSize, k, 0, halfSize);
      const color = i === center ? color1 : color2;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
    }

    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false
    });
    super(geometry, material);
    this.type = 'GridHelper';
  }

}

exports.GridHelper = GridHelper;

class PolarGridHelper extends LineSegments {
  constructor(radius, radials, circles, divisions, color1, color2) {
    radius = radius || 10;
    radials = radials || 16;
    circles = circles || 8;
    divisions = divisions || 64;
    color1 = new Color(color1 !== undefined ? color1 : 0x444444);
    color2 = new Color(color2 !== undefined ? color2 : 0x888888);
    const vertices = [];
    const colors = []; // create the radials

    for (let i = 0; i <= radials; i++) {
      const v = i / radials * (Math.PI * 2);
      const x = Math.sin(v) * radius;
      const z = Math.cos(v) * radius;
      vertices.push(0, 0, 0);
      vertices.push(x, 0, z);
      const color = i & 1 ? color1 : color2;
      colors.push(color.r, color.g, color.b);
      colors.push(color.r, color.g, color.b);
    } // create the circles


    for (let i = 0; i <= circles; i++) {
      const color = i & 1 ? color1 : color2;
      const r = radius - radius / circles * i;

      for (let j = 0; j < divisions; j++) {
        // first vertex
        let v = j / divisions * (Math.PI * 2);
        let x = Math.sin(v) * r;
        let z = Math.cos(v) * r;
        vertices.push(x, 0, z);
        colors.push(color.r, color.g, color.b); // second vertex

        v = (j + 1) / divisions * (Math.PI * 2);
        x = Math.sin(v) * r;
        z = Math.cos(v) * r;
        vertices.push(x, 0, z);
        colors.push(color.r, color.g, color.b);
      }
    }

    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false
    });
    super(geometry, material);
    this.type = 'PolarGridHelper';
  }

}

exports.PolarGridHelper = PolarGridHelper;

const _v1$5 = new Vector3();

const _v2$3 = new Vector3();

const _v3$1 = new Vector3();

class DirectionalLightHelper extends Object3D {
  constructor(light, size, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    if (size === undefined) size = 1;
    let geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
    const material = new LineBasicMaterial({
      fog: false,
      toneMapped: false
    });
    this.lightPlane = new Line(geometry, material);
    this.add(this.lightPlane);
    geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
    this.targetLine = new Line(geometry, material);
    this.add(this.targetLine);
    this.update();
  }

  dispose() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  }

  update() {
    _v1$5.setFromMatrixPosition(this.light.matrixWorld);

    _v2$3.setFromMatrixPosition(this.light.target.matrixWorld);

    _v3$1.subVectors(_v2$3, _v1$5);

    this.lightPlane.lookAt(_v2$3);

    if (this.color !== undefined) {
      this.lightPlane.material.color.set(this.color);
      this.targetLine.material.color.set(this.color);
    } else {
      this.lightPlane.material.color.copy(this.light.color);
      this.targetLine.material.color.copy(this.light.color);
    }

    this.targetLine.lookAt(_v2$3);
    this.targetLine.scale.z = _v3$1.length();
  }

}

exports.DirectionalLightHelper = DirectionalLightHelper;

const _vector$b = new Vector3();

const _camera = new Camera();
/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */


class CameraHelper extends LineSegments {
  constructor(camera) {
    const geometry = new BufferGeometry();
    const material = new LineBasicMaterial({
      color: 0xffffff,
      vertexColors: true,
      toneMapped: false
    });
    const vertices = [];
    const colors = [];
    const pointMap = {}; // colors

    const colorFrustum = new Color(0xffaa00);
    const colorCone = new Color(0xff0000);
    const colorUp = new Color(0x00aaff);
    const colorTarget = new Color(0xffffff);
    const colorCross = new Color(0x333333); // near

    addLine('n1', 'n2', colorFrustum);
    addLine('n2', 'n4', colorFrustum);
    addLine('n4', 'n3', colorFrustum);
    addLine('n3', 'n1', colorFrustum); // far

    addLine('f1', 'f2', colorFrustum);
    addLine('f2', 'f4', colorFrustum);
    addLine('f4', 'f3', colorFrustum);
    addLine('f3', 'f1', colorFrustum); // sides

    addLine('n1', 'f1', colorFrustum);
    addLine('n2', 'f2', colorFrustum);
    addLine('n3', 'f3', colorFrustum);
    addLine('n4', 'f4', colorFrustum); // cone

    addLine('p', 'n1', colorCone);
    addLine('p', 'n2', colorCone);
    addLine('p', 'n3', colorCone);
    addLine('p', 'n4', colorCone); // up

    addLine('u1', 'u2', colorUp);
    addLine('u2', 'u3', colorUp);
    addLine('u3', 'u1', colorUp); // target

    addLine('c', 't', colorTarget);
    addLine('p', 'c', colorCross); // cross

    addLine('cn1', 'cn2', colorCross);
    addLine('cn3', 'cn4', colorCross);
    addLine('cf1', 'cf2', colorCross);
    addLine('cf3', 'cf4', colorCross);

    function addLine(a, b, color) {
      addPoint(a, color);
      addPoint(b, color);
    }

    function addPoint(id, color) {
      vertices.push(0, 0, 0);
      colors.push(color.r, color.g, color.b);

      if (pointMap[id] === undefined) {
        pointMap[id] = [];
      }

      pointMap[id].push(vertices.length / 3 - 1);
    }

    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    super(geometry, material);
    this.type = 'CameraHelper';
    this.camera = camera;
    if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
  }

  update() {
    const geometry = this.geometry;
    const pointMap = this.pointMap;
    const w = 1,
          h = 1; // we need just camera projection matrix inverse
    // world matrix must be identity

    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); // center / target


    setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
    setPoint('t', pointMap, geometry, _camera, 0, 0, 1); // near

    setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
    setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
    setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
    setPoint('n4', pointMap, geometry, _camera, w, h, -1); // far

    setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
    setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
    setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
    setPoint('f4', pointMap, geometry, _camera, w, h, 1); // up

    setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
    setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
    setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1); // cross

    setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
    setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
    setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
    setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
    setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
    setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
    setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
    setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
    geometry.getAttribute('position').needsUpdate = true;
  }

}

exports.CameraHelper = CameraHelper;

function setPoint(point, pointMap, geometry, camera, x, y, z) {
  _vector$b.set(x, y, z).unproject(camera);

  const points = pointMap[point];

  if (points !== undefined) {
    const position = geometry.getAttribute('position');

    for (let i = 0, l = points.length; i < l; i++) {
      position.setXYZ(points[i], _vector$b.x, _vector$b.y, _vector$b.z);
    }
  }
}

const _box$3 = new Box3();

class BoxHelper extends LineSegments {
  constructor(object, color = 0xffff00) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = new Float32Array(8 * 3);
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute('position', new BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    }));
    this.object = object;
    this.type = 'BoxHelper';
    this.matrixAutoUpdate = false;
    this.update();
  }

  update(object) {
    if (object !== undefined) {
      console.warn('THREE.BoxHelper: .update() has no longer arguments.');
    }

    if (this.object !== undefined) {
      _box$3.setFromObject(this.object);
    }

    if (_box$3.isEmpty()) return;
    const min = _box$3.min;
    const max = _box$3.max;
    /*
    	5____4
    1/___0/|
    | 6__|_7
    2/___3/
    	0: max.x, max.y, max.z
    1: min.x, max.y, max.z
    2: min.x, min.y, max.z
    3: max.x, min.y, max.z
    4: max.x, max.y, min.z
    5: min.x, max.y, min.z
    6: min.x, min.y, min.z
    7: max.x, min.y, min.z
    */

    const position = this.geometry.attributes.position;
    const array = position.array;
    array[0] = max.x;
    array[1] = max.y;
    array[2] = max.z;
    array[3] = min.x;
    array[4] = max.y;
    array[5] = max.z;
    array[6] = min.x;
    array[7] = min.y;
    array[8] = max.z;
    array[9] = max.x;
    array[10] = min.y;
    array[11] = max.z;
    array[12] = max.x;
    array[13] = max.y;
    array[14] = min.z;
    array[15] = min.x;
    array[16] = max.y;
    array[17] = min.z;
    array[18] = min.x;
    array[19] = min.y;
    array[20] = min.z;
    array[21] = max.x;
    array[22] = min.y;
    array[23] = min.z;
    position.needsUpdate = true;
    this.geometry.computeBoundingSphere();
  }

  setFromObject(object) {
    this.object = object;
    this.update();
    return this;
  }

  copy(source) {
    LineSegments.prototype.copy.call(this, source);
    this.object = source.object;
    return this;
  }

}

exports.BoxHelper = BoxHelper;

class Box3Helper extends LineSegments {
  constructor(box, color = 0xffff00) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    }));
    this.box = box;
    this.type = 'Box3Helper';
    this.geometry.computeBoundingSphere();
  }

  updateMatrixWorld(force) {
    const box = this.box;
    if (box.isEmpty()) return;
    box.getCenter(this.position);
    box.getSize(this.scale);
    this.scale.multiplyScalar(0.5);
    super.updateMatrixWorld(force);
  }

}

exports.Box3Helper = Box3Helper;

class PlaneHelper extends Line {
  constructor(plane, size, hex) {
    const color = hex !== undefined ? hex : 0xffff00;
    const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    super(geometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    }));
    this.type = 'PlaneHelper';
    this.plane = plane;
    this.size = size === undefined ? 1 : size;
    const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
    const geometry2 = new BufferGeometry();
    geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
    geometry2.computeBoundingSphere();
    this.add(new Mesh(geometry2, new MeshBasicMaterial({
      color: color,
      opacity: 0.2,
      transparent: true,
      depthWrite: false,
      toneMapped: false
    })));
  }

  updateMatrixWorld(force) {
    let scale = -this.plane.constant;
    if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter

    this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
    this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

    this.lookAt(this.plane.normal);
    super.updateMatrixWorld(force);
  }

}

exports.PlaneHelper = PlaneHelper;

const _axis = new Vector3();

let _lineGeometry, _coneGeometry;

class ArrowHelper extends Object3D {
  constructor(dir, origin, length, color, headLength, headWidth) {
    super(); // dir is assumed to be normalized

    this.type = 'ArrowHelper';
    if (dir === undefined) dir = new Vector3(0, 0, 1);
    if (origin === undefined) origin = new Vector3(0, 0, 0);
    if (length === undefined) length = 1;
    if (color === undefined) color = 0xffff00;
    if (headLength === undefined) headLength = 0.2 * length;
    if (headWidth === undefined) headWidth = 0.2 * headLength;

    if (_lineGeometry === undefined) {
      _lineGeometry = new BufferGeometry();

      _lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

      _coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);

      _coneGeometry.translate(0, -0.5, 0);
    }

    this.position.copy(origin);
    this.line = new Line(_lineGeometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    }));
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
      color: color,
      toneMapped: false
    }));
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(dir);
    this.setLength(length, headLength, headWidth);
  }

  setDirection(dir) {
    // dir is assumed to be normalized
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      _axis.set(dir.z, 0, -dir.x).normalize();

      const radians = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(_axis, radians);
    }
  }

  setLength(length, headLength, headWidth) {
    if (headLength === undefined) headLength = 0.2 * length;
    if (headWidth === undefined) headWidth = 0.2 * headLength;
    this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458

    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length;
    this.cone.updateMatrix();
  }

  setColor(color) {
    this.line.material.color.set(color);
    this.cone.material.color.set(color);
  }

  copy(source) {
    super.copy(source, false);
    this.line.copy(source.line);
    this.cone.copy(source.cone);
    return this;
  }

}

exports.ArrowHelper = ArrowHelper;

class AxesHelper extends LineSegments {
  constructor(size = 1) {
    const vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
    const colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false
    });
    super(geometry, material);
    this.type = 'AxesHelper';
  }

}

exports.AxesHelper = AxesHelper;
const LOD_MIN = 4;
const LOD_MAX = 8;
const SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.

const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.

const MAX_SAMPLES = 20;
const ENCODINGS = {
  [LinearEncoding]: 0,
  [sRGBEncoding]: 1,
  [RGBEEncoding]: 2,
  [RGBM7Encoding]: 3,
  [RGBM16Encoding]: 4,
  [RGBDEncoding]: 5,
  [GammaEncoding]: 6
};

const _flatCamera = new OrthographicCamera();

const {
  _lodPlanes,
  _sizeLods,
  _sigmas
} = _createPlanes();

let _oldTarget = null; // Golden Ratio

const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.

const _axisDirections = [new Vector3(1, 1, 1), new Vector3(-1, 1, 1), new Vector3(1, 1, -1), new Vector3(-1, 1, -1), new Vector3(0, PHI, INV_PHI), new Vector3(0, PHI, -INV_PHI), new Vector3(INV_PHI, 0, PHI), new Vector3(-INV_PHI, 0, PHI), new Vector3(PHI, INV_PHI, 0), new Vector3(-PHI, INV_PHI, 0)];
/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 */

class PMREMGenerator {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._blurMaterial = _getBlurShader(MAX_SAMPLES);
    this._equirectShader = null;
    this._cubemapShader = null;

    this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */


  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();

    const cubeUVRenderTarget = this._allocateTargets();

    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);

    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }

    this._applyPMREM(cubeUVRenderTarget);

    this._cleanup(cubeUVRenderTarget);

    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */


  fromEquirectangular(equirectangular) {
    return this._fromTexture(equirectangular);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */


  fromCubemap(cubemap) {
    return this._fromTexture(cubemap);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */


  compileCubemapShader() {
    if (this._cubemapShader === null) {
      this._cubemapShader = _getCubemapShader();

      this._compileMaterial(this._cubemapShader);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */


  compileEquirectangularShader() {
    if (this._equirectShader === null) {
      this._equirectShader = _getEquirectShader();

      this._compileMaterial(this._equirectShader);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */


  dispose() {
    this._blurMaterial.dispose();

    if (this._cubemapShader !== null) this._cubemapShader.dispose();
    if (this._equirectShader !== null) this._equirectShader.dispose();

    for (let i = 0; i < _lodPlanes.length; i++) {
      _lodPlanes[i].dispose();
    }
  } // private interface


  _cleanup(outputTarget) {
    this._pingPongRenderTarget.dispose();

    this._renderer.setRenderTarget(_oldTarget);

    outputTarget.scissorTest = false;

    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }

  _fromTexture(texture) {
    _oldTarget = this._renderer.getRenderTarget();

    const cubeUVRenderTarget = this._allocateTargets(texture);

    this._textureToCubeUV(texture, cubeUVRenderTarget);

    this._applyPMREM(cubeUVRenderTarget);

    this._cleanup(cubeUVRenderTarget);

    return cubeUVRenderTarget;
  }

  _allocateTargets(texture) {
    // warning: null texture is valid
    const params = {
      magFilter: NearestFilter,
      minFilter: NearestFilter,
      generateMipmaps: false,
      type: UnsignedByteType,
      format: RGBEFormat,
      encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
      depthBuffer: false
    };

    const cubeUVRenderTarget = _createRenderTarget(params);

    cubeUVRenderTarget.depthBuffer = texture ? false : true;
    this._pingPongRenderTarget = _createRenderTarget(params);
    return cubeUVRenderTarget;
  }

  _compileMaterial(material) {
    const tmpMesh = new Mesh(_lodPlanes[0], material);

    this._renderer.compile(tmpMesh, _flatCamera);
  }

  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov = 90;
    const aspect = 1;
    const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const outputEncoding = renderer.outputEncoding;
    const toneMapping = renderer.toneMapping;
    const clearColor = renderer.getClearColor();
    const clearAlpha = renderer.getClearAlpha();
    renderer.toneMapping = NoToneMapping;
    renderer.outputEncoding = LinearEncoding;
    let background = scene.background;

    if (background && background.isColor) {
      background.convertSRGBToLinear(); // Convert linear to RGBE

      const maxComponent = Math.max(background.r, background.g, background.b);
      const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);
      background = background.multiplyScalar(Math.pow(2.0, -fExp));
      const alpha = (fExp + 128.0) / 255.0;
      renderer.setClearColor(background, alpha);
      scene.background = null;
    }

    for (let i = 0; i < 6; i++) {
      const col = i % 3;

      if (col == 0) {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(forwardSign[i], 0, 0);
      } else if (col == 1) {
        cubeCamera.up.set(0, 0, upSign[i]);
        cubeCamera.lookAt(0, forwardSign[i], 0);
      } else {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i]);
      }

      _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);

      renderer.setRenderTarget(cubeUVRenderTarget);
      renderer.render(scene, cubeCamera);
    }

    renderer.toneMapping = toneMapping;
    renderer.outputEncoding = outputEncoding;
    renderer.setClearColor(clearColor, clearAlpha);
  }

  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;

    if (texture.isCubeTexture) {
      if (this._cubemapShader == null) {
        this._cubemapShader = _getCubemapShader();
      }
    } else {
      if (this._equirectShader == null) {
        this._equirectShader = _getEquirectShader();
      }
    }

    const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
    const mesh = new Mesh(_lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms['envMap'].value = texture;

    if (!texture.isCubeTexture) {
      uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);
    }

    uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];
    uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];

    _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);

    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }

  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;

    for (let i = 1; i < TOTAL_LODS; i++) {
      const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);
      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];

      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
    }

    renderer.autoClear = autoClear;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */


  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;

    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);

    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
  }

  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;

    if (direction !== 'latitudinal' && direction !== 'longitudinal') {
      console.error('blur direction must be either latitudinal or longitudinal!');
    } // Number of standard deviations at which to cut off the discrete approximation.


    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = _sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;

    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }

    const weights = [];
    let sum = 0;

    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x = i / sigmaPixels;
      const weight = Math.exp(-x * x / 2);
      weights.push(weight);

      if (i == 0) {
        sum += weight;
      } else if (i < samples) {
        sum += 2 * weight;
      }
    }

    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum;
    }

    blurUniforms['envMap'].value = targetIn.texture;
    blurUniforms['samples'].value = samples;
    blurUniforms['weights'].value = weights;
    blurUniforms['latitudinal'].value = direction === 'latitudinal';

    if (poleAxis) {
      blurUniforms['poleAxis'].value = poleAxis;
    }

    blurUniforms['dTheta'].value = radiansPerPixel;
    blurUniforms['mipInt'].value = LOD_MAX - lodIn;
    blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
    blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
    const outputSize = _sizeLods[lodOut];
    const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
    const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);

    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);

    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }

}

exports.PMREMGenerator = PMREMGenerator;

function _isLDR(texture) {
  if (texture === undefined || texture.type !== UnsignedByteType) return false;
  return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
}

function _createPlanes() {
  const _lodPlanes = [];
  const _sizeLods = [];
  const _sigmas = [];
  let lod = LOD_MAX;

  for (let i = 0; i < TOTAL_LODS; i++) {
    const sizeLod = Math.pow(2, lod);

    _sizeLods.push(sizeLod);

    let sigma = 1.0 / sizeLod;

    if (i > LOD_MAX - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];
    } else if (i == 0) {
      sigma = 0;
    }

    _sigmas.push(sigma);

    const texelSize = 1.0 / (sizeLod - 1);
    const min = -texelSize / 2;
    const max = 1 + texelSize / 2;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);

    for (let face = 0; face < cubeFaces; face++) {
      const x = face % 3 * 2 / 3 - 1;
      const y = face > 2 ? 0 : -1;
      const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }

    const planes = new BufferGeometry();
    planes.setAttribute('position', new BufferAttribute(position, positionSize));
    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
    planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));

    _lodPlanes.push(planes);

    if (lod > LOD_MIN) {
      lod--;
    }
  }

  return {
    _lodPlanes,
    _sizeLods,
    _sigmas
  };
}

function _createRenderTarget(params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}

function _setViewport(target, x, y, width, height) {
  target.viewport.set(x, y, width, height);
  target.scissor.set(x, y, width, height);
}

function _getBlurShader(maxSamples) {
  const weights = new Float32Array(maxSamples);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new RawShaderMaterial({
    name: 'SphericalGaussianBlur',
    defines: {
      'n': maxSamples
    },
    uniforms: {
      'envMap': {
        value: null
      },
      'samples': {
        value: 1
      },
      'weights': {
        value: weights
      },
      'latitudinal': {
        value: false
      },
      'dTheta': {
        value: 0
      },
      'mipInt': {
        value: 0
      },
      'poleAxis': {
        value: poleAxis
      },
      'inputEncoding': {
        value: ENCODINGS[LinearEncoding]
      },
      'outputEncoding': {
        value: ENCODINGS[LinearEncoding]
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader:
    /* glsl */
    `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}

function _getEquirectShader() {
  const texelSize = new Vector2(1, 1);
  const shaderMaterial = new RawShaderMaterial({
    name: 'EquirectangularToCubeUV',
    uniforms: {
      'envMap': {
        value: null
      },
      'texelSize': {
        value: texelSize
      },
      'inputEncoding': {
        value: ENCODINGS[LinearEncoding]
      },
      'outputEncoding': {
        value: ENCODINGS[LinearEncoding]
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader:
    /* glsl */
    `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}

function _getCubemapShader() {
  const shaderMaterial = new RawShaderMaterial({
    name: 'CubemapToCubeUV',
    uniforms: {
      'envMap': {
        value: null
      },
      'inputEncoding': {
        value: ENCODINGS[LinearEncoding]
      },
      'outputEncoding': {
        value: ENCODINGS[LinearEncoding]
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader:
    /* glsl */
    `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}

function _getCommonVertexShader() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}

function _getEncodings() {
  return (
    /* glsl */
    `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`
  );
}

function Face4(a, b, c, d, normal, color, materialIndex) {
  console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
  return new Face3(a, b, c, normal, color, materialIndex);
}

const LineStrip = 0;
exports.LineStrip = LineStrip;
const LinePieces = 1;
exports.LinePieces = LinePieces;
const NoColors = 0;
exports.NoColors = NoColors;
const FaceColors = 1;
exports.FaceColors = FaceColors;
const VertexColors = 2;
exports.VertexColors = VertexColors;

function MeshFaceMaterial(materials) {
  console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
  return materials;
}

function MultiMaterial(materials) {
  if (materials === undefined) materials = [];
  console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
  materials.isMultiMaterial = true;
  materials.materials = materials;

  materials.clone = function () {
    return materials.slice();
  };

  return materials;
}

function PointCloud(geometry, material) {
  console.warn('THREE.PointCloud has been renamed to THREE.Points.');
  return new Points(geometry, material);
}

function Particle(material) {
  console.warn('THREE.Particle has been renamed to THREE.Sprite.');
  return new Sprite(material);
}

function ParticleSystem(geometry, material) {
  console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
  return new Points(geometry, material);
}

function PointCloudMaterial(parameters) {
  console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}

function ParticleBasicMaterial(parameters) {
  console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}

function ParticleSystemMaterial(parameters) {
  console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}

function Vertex(x, y, z) {
  console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
  return new Vector3(x, y, z);
} //


function DynamicBufferAttribute(array, itemSize) {
  console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
  return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
}

function Int8Attribute(array, itemSize) {
  console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
  return new Int8BufferAttribute(array, itemSize);
}

function Uint8Attribute(array, itemSize) {
  console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
  return new Uint8BufferAttribute(array, itemSize);
}

function Uint8ClampedAttribute(array, itemSize) {
  console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
  return new Uint8ClampedBufferAttribute(array, itemSize);
}

function Int16Attribute(array, itemSize) {
  console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
  return new Int16BufferAttribute(array, itemSize);
}

function Uint16Attribute(array, itemSize) {
  console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
  return new Uint16BufferAttribute(array, itemSize);
}

function Int32Attribute(array, itemSize) {
  console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
  return new Int32BufferAttribute(array, itemSize);
}

function Uint32Attribute(array, itemSize) {
  console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
  return new Uint32BufferAttribute(array, itemSize);
}

function Float32Attribute(array, itemSize) {
  console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
  return new Float32BufferAttribute(array, itemSize);
}

function Float64Attribute(array, itemSize) {
  console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
  return new Float64BufferAttribute(array, itemSize);
} //


Curve.create = function (construct, getPoint) {
  console.log('THREE.Curve.create() has been deprecated');
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
}; //


Object.assign(CurvePath.prototype, {
  createPointsGeometry: function (divisions) {
    console.warn('THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.'); // generate geometry from path points (for Line or Points objects)

    const pts = this.getPoints(divisions);
    return this.createGeometry(pts);
  },
  createSpacedPointsGeometry: function (divisions) {
    console.warn('THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.'); // generate geometry from equidistant sampling along the path

    const pts = this.getSpacedPoints(divisions);
    return this.createGeometry(pts);
  },
  createGeometry: function (points) {
    console.warn('THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
    const geometry = new Geometry();

    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
    }

    return geometry;
  }
}); //

Object.assign(Path.prototype, {
  fromPoints: function (points) {
    console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
    return this.setFromPoints(points);
  }
}); //

function ClosedSplineCurve3(points) {
  console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
  CatmullRomCurve3.call(this, points);
  this.type = 'catmullrom';
  this.closed = true;
}

ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype); //

function SplineCurve3(points) {
  console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
  CatmullRomCurve3.call(this, points);
  this.type = 'catmullrom';
}

SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype); //

function Spline(points) {
  console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');
  CatmullRomCurve3.call(this, points);
  this.type = 'catmullrom';
}

Spline.prototype = Object.create(CatmullRomCurve3.prototype);
Object.assign(Spline.prototype, {
  initFromArray: function ()
  /* a */
  {
    console.error('THREE.Spline: .initFromArray() has been removed.');
  },
  getControlPointsArray: function ()
  /* optionalTarget */
  {
    console.error('THREE.Spline: .getControlPointsArray() has been removed.');
  },
  reparametrizeByArcLength: function ()
  /* samplingCoef */
  {
    console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
  }
}); //

function AxisHelper(size) {
  console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
  return new AxesHelper(size);
}

function BoundingBoxHelper(object, color) {
  console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
  return new BoxHelper(object, color);
}

function EdgesHelper(object, hex) {
  console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
  return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
    color: hex !== undefined ? hex : 0xffffff
  }));
}

GridHelper.prototype.setColors = function () {
  console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
};

SkeletonHelper.prototype.update = function () {
  console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
};

function WireframeHelper(object, hex) {
  console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
  return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
    color: hex !== undefined ? hex : 0xffffff
  }));
} //


Object.assign(Loader.prototype, {
  extractUrlBase: function (url) {
    console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
    return LoaderUtils.extractUrlBase(url);
  }
});
Loader.Handlers = {
  add: function ()
  /* regex, loader */
  {
    console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
  },
  get: function ()
  /* file */
  {
    console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
  }
};

function XHRLoader(manager) {
  console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
  return new FileLoader(manager);
}

function BinaryTextureLoader(manager) {
  console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
  return new DataTextureLoader(manager);
}

Object.assign(ObjectLoader.prototype, {
  setTexturePath: function (value) {
    console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
    return this.setResourcePath(value);
  }
}); //

Object.assign(Box2.prototype, {
  center: function (optionalTarget) {
    console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
  },
  empty: function () {
    console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
  },
  isIntersectionBox: function (box) {
    console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
  },
  size: function (optionalTarget) {
    console.warn('THREE.Box2: .size() has been renamed to .getSize().');
    return this.getSize(optionalTarget);
  }
});
Object.assign(Box3.prototype, {
  center: function (optionalTarget) {
    console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
  },
  empty: function () {
    console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
  },
  isIntersectionBox: function (box) {
    console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
  },
  isIntersectionSphere: function (sphere) {
    console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
    return this.intersectsSphere(sphere);
  },
  size: function (optionalTarget) {
    console.warn('THREE.Box3: .size() has been renamed to .getSize().');
    return this.getSize(optionalTarget);
  }
});
Object.assign(Sphere.prototype, {
  empty: function () {
    console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
  }
});

Frustum.prototype.setFromMatrix = function (m) {
  console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
  return this.setFromProjectionMatrix(m);
};

Line3.prototype.center = function (optionalTarget) {
  console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
  return this.getCenter(optionalTarget);
};

Object.assign(MathUtils, {
  random16: function () {
    console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');
    return Math.random();
  },
  nearestPowerOfTwo: function (value) {
    console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');
    return MathUtils.floorPowerOfTwo(value);
  },
  nextPowerOfTwo: function (value) {
    console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');
    return MathUtils.ceilPowerOfTwo(value);
  }
});
Object.assign(Matrix3.prototype, {
  flattenToArrayOffset: function (array, offset) {
    console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  },
  multiplyVector3: function (vector) {
    console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
    return vector.applyMatrix3(this);
  },
  multiplyVector3Array: function ()
  /* a */
  {
    console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
  },
  applyToBufferAttribute: function (attribute) {
    console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
    return attribute.applyMatrix3(this);
  },
  applyToVector3Array: function ()
  /* array, offset, length */
  {
    console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
  }
});
Object.assign(Matrix4.prototype, {
  extractPosition: function (m) {
    console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
    return this.copyPosition(m);
  },
  flattenToArrayOffset: function (array, offset) {
    console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  },
  getPosition: function () {
    console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
    return new Vector3().setFromMatrixColumn(this, 3);
  },
  setRotationFromQuaternion: function (q) {
    console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
    return this.makeRotationFromQuaternion(q);
  },
  multiplyToArray: function () {
    console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
  },
  multiplyVector3: function (vector) {
    console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  multiplyVector4: function (vector) {
    console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  multiplyVector3Array: function ()
  /* a */
  {
    console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
  },
  rotateAxis: function (v) {
    console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
    v.transformDirection(this);
  },
  crossVector: function (vector) {
    console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  translate: function () {
    console.error('THREE.Matrix4: .translate() has been removed.');
  },
  rotateX: function () {
    console.error('THREE.Matrix4: .rotateX() has been removed.');
  },
  rotateY: function () {
    console.error('THREE.Matrix4: .rotateY() has been removed.');
  },
  rotateZ: function () {
    console.error('THREE.Matrix4: .rotateZ() has been removed.');
  },
  rotateByAxis: function () {
    console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
  },
  applyToBufferAttribute: function (attribute) {
    console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
    return attribute.applyMatrix4(this);
  },
  applyToVector3Array: function ()
  /* array, offset, length */
  {
    console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
  },
  makeFrustum: function (left, right, bottom, top, near, far) {
    console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
    return this.makePerspective(left, right, top, bottom, near, far);
  }
});

Plane.prototype.isIntersectionLine = function (line) {
  console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
  return this.intersectsLine(line);
};

Quaternion.prototype.multiplyVector3 = function (vector) {
  console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
  return vector.applyQuaternion(this);
};

Object.assign(Ray.prototype, {
  isIntersectionBox: function (box) {
    console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
  },
  isIntersectionPlane: function (plane) {
    console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
    return this.intersectsPlane(plane);
  },
  isIntersectionSphere: function (sphere) {
    console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
    return this.intersectsSphere(sphere);
  }
});
Object.assign(Triangle.prototype, {
  area: function () {
    console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
    return this.getArea();
  },
  barycoordFromPoint: function (point, target) {
    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
    return this.getBarycoord(point, target);
  },
  midpoint: function (target) {
    console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
    return this.getMidpoint(target);
  },
  normal: function (target) {
    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
    return this.getNormal(target);
  },
  plane: function (target) {
    console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
    return this.getPlane(target);
  }
});
Object.assign(Triangle, {
  barycoordFromPoint: function (point, a, b, c, target) {
    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
    return Triangle.getBarycoord(point, a, b, c, target);
  },
  normal: function (a, b, c, target) {
    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
    return Triangle.getNormal(a, b, c, target);
  }
});
Object.assign(Shape.prototype, {
  extractAllPoints: function (divisions) {
    console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
    return this.extractPoints(divisions);
  },
  extrude: function (options) {
    console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
    return new ExtrudeGeometry(this, options);
  },
  makeGeometry: function (options) {
    console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
    return new ShapeGeometry(this, options);
  }
});
Object.assign(Vector2.prototype, {
  fromAttribute: function (attribute, index, offset) {
    console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
  },
  distanceToManhattan: function (v) {
    console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
    return this.manhattanDistanceTo(v);
  },
  lengthManhattan: function () {
    console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
  }
});
Object.assign(Vector3.prototype, {
  setEulerFromRotationMatrix: function () {
    console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
  },
  setEulerFromQuaternion: function () {
    console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
  },
  getPositionFromMatrix: function (m) {
    console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
    return this.setFromMatrixPosition(m);
  },
  getScaleFromMatrix: function (m) {
    console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
    return this.setFromMatrixScale(m);
  },
  getColumnFromMatrix: function (index, matrix) {
    console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
    return this.setFromMatrixColumn(matrix, index);
  },
  applyProjection: function (m) {
    console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
    return this.applyMatrix4(m);
  },
  fromAttribute: function (attribute, index, offset) {
    console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
  },
  distanceToManhattan: function (v) {
    console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
    return this.manhattanDistanceTo(v);
  },
  lengthManhattan: function () {
    console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
  }
});
Object.assign(Vector4.prototype, {
  fromAttribute: function (attribute, index, offset) {
    console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
  },
  lengthManhattan: function () {
    console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
  }
}); //

Object.assign(Geometry.prototype, {
  computeTangents: function () {
    console.error('THREE.Geometry: .computeTangents() has been removed.');
  },
  computeLineDistances: function () {
    console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');
  },
  applyMatrix: function (matrix) {
    console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');
    return this.applyMatrix4(matrix);
  }
});
Object.assign(Object3D.prototype, {
  getChildByName: function (name) {
    console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
    return this.getObjectByName(name);
  },
  renderDepth: function () {
    console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
  },
  translate: function (distance, axis) {
    console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
    return this.translateOnAxis(axis, distance);
  },
  getWorldRotation: function () {
    console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
  },
  applyMatrix: function (matrix) {
    console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
    return this.applyMatrix4(matrix);
  }
});
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function () {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      return this.rotation.order;
    },
    set: function (value) {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function () {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    },
    set: function () {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    }
  }
});
Object.assign(Mesh.prototype, {
  setDrawMode: function () {
    console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
  }
});
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function () {
      console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
      return TrianglesDrawMode;
    },
    set: function () {
      console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
    }
  }
});
Object.defineProperties(LOD.prototype, {
  objects: {
    get: function () {
      console.warn('THREE.LOD: .objects has been renamed to .levels.');
      return this.levels;
    }
  }
});
Object.defineProperty(Skeleton.prototype, 'useVertexTexture', {
  get: function () {
    console.warn('THREE.Skeleton: useVertexTexture has been removed.');
  },
  set: function () {
    console.warn('THREE.Skeleton: useVertexTexture has been removed.');
  }
});

SkinnedMesh.prototype.initBones = function () {
  console.error('THREE.SkinnedMesh: initBones() has been removed.');
};

Object.defineProperty(Curve.prototype, '__arcLengthDivisions', {
  get: function () {
    console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
    return this.arcLengthDivisions;
  },
  set: function (value) {
    console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
    this.arcLengthDivisions = value;
  }
}); //

PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. " + "Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== undefined) this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
}; //


Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function () {
      console.warn('THREE.Light: .onlyShadow has been removed.');
    }
  },
  shadowCameraFov: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function () {
      console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
    }
  },
  shadowBias: {
    set: function (value) {
      console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function () {
      console.warn('THREE.Light: .shadowDarkness has been removed.');
    }
  },
  shadowMapWidth: {
    set: function (value) {
      console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function (value) {
      console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
      this.shadow.mapSize.height = value;
    }
  }
}); //

Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function () {
      console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
      return this.array.length;
    }
  },
  dynamic: {
    get: function () {
      console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
      return this.usage === DynamicDrawUsage;
    },
    set: function ()
    /* value */
    {
      console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
      this.setUsage(DynamicDrawUsage);
    }
  }
});
Object.assign(BufferAttribute.prototype, {
  setDynamic: function (value) {
    console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
    return this;
  },
  copyIndicesArray: function ()
  /* indices */
  {
    console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
  },
  setArray: function ()
  /* array */
  {
    console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
  }
});
Object.assign(BufferGeometry.prototype, {
  addIndex: function (index) {
    console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
    this.setIndex(index);
  },
  addAttribute: function (name, attribute) {
    console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');

    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
      console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
      return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
    }

    if (name === 'index') {
      console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
      this.setIndex(attribute);
      return this;
    }

    return this.setAttribute(name, attribute);
  },
  addDrawCall: function (start, count, indexOffset) {
    if (indexOffset !== undefined) {
      console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
    }

    console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
    this.addGroup(start, count);
  },
  clearDrawCalls: function () {
    console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
    this.clearGroups();
  },
  computeTangents: function () {
    console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
  },
  computeOffsets: function () {
    console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
  },
  removeAttribute: function (name) {
    console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
    return this.deleteAttribute(name);
  },
  applyMatrix: function (matrix) {
    console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
    return this.applyMatrix4(matrix);
  }
});
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function () {
      console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
      return this.groups;
    }
  },
  offsets: {
    get: function () {
      console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
      return this.groups;
    }
  }
});
Object.defineProperties(InstancedBufferGeometry.prototype, {
  maxInstancedCount: {
    get: function () {
      console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.');
      return this.instanceCount;
    },
    set: function (value) {
      console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.');
      this.instanceCount = value;
    }
  }
});
Object.defineProperties(Raycaster.prototype, {
  linePrecision: {
    get: function () {
      console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');
      return this.params.Line.threshold;
    },
    set: function (value) {
      console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');
      this.params.Line.threshold = value;
    }
  }
});
Object.defineProperties(InterleavedBuffer.prototype, {
  dynamic: {
    get: function () {
      console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
      return this.usage === DynamicDrawUsage;
    },
    set: function (value) {
      console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
      this.setUsage(value);
    }
  }
});
Object.assign(InterleavedBuffer.prototype, {
  setDynamic: function (value) {
    console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
    return this;
  },
  setArray: function ()
  /* array */
  {
    console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
  }
}); //

Object.assign(ExtrudeBufferGeometry.prototype, {
  getArrays: function () {
    console.error('THREE.ExtrudeBufferGeometry: .getArrays() has been removed.');
  },
  addShapeList: function () {
    console.error('THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.');
  },
  addShape: function () {
    console.error('THREE.ExtrudeBufferGeometry: .addShape() has been removed.');
  }
}); //

Object.assign(Scene.prototype, {
  dispose: function () {
    console.error('THREE.Scene: .dispose() has been removed.');
  }
}); //

Object.defineProperties(Uniform.prototype, {
  dynamic: {
    set: function () {
      console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
    }
  },
  onUpdate: {
    value: function () {
      console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
      return this;
    }
  }
}); //

Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function () {
      console.warn('THREE.Material: .wrapAround has been removed.');
    },
    set: function () {
      console.warn('THREE.Material: .wrapAround has been removed.');
    }
  },
  overdraw: {
    get: function () {
      console.warn('THREE.Material: .overdraw has been removed.');
    },
    set: function () {
      console.warn('THREE.Material: .overdraw has been removed.');
    }
  },
  wrapRGB: {
    get: function () {
      console.warn('THREE.Material: .wrapRGB has been removed.');
      return new Color();
    }
  },
  shading: {
    get: function () {
      console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
    },
    set: function (value) {
      console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function () {
      console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
      return this.stencilFuncMask;
    },
    set: function (value) {
      console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
      this.stencilFuncMask = value;
    }
  }
});
Object.defineProperties(MeshPhongMaterial.prototype, {
  metal: {
    get: function () {
      console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
      return false;
    },
    set: function () {
      console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
    }
  }
});
Object.defineProperties(MeshPhysicalMaterial.prototype, {
  transparency: {
    get: function () {
      console.warn('THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.');
      return this.transmission;
    },
    set: function (value) {
      console.warn('THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.');
      this.transmission = value;
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function () {
      console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
      return this.extensions.derivatives;
    },
    set: function (value) {
      console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
      this.extensions.derivatives = value;
    }
  }
}); //

Object.assign(WebGLRenderer.prototype, {
  clearTarget: function (renderTarget, color, depth, stencil) {
    console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
    this.setRenderTarget(renderTarget);
    this.clear(color, depth, stencil);
  },
  animate: function (callback) {
    console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
    this.setAnimationLoop(callback);
  },
  getCurrentRenderTarget: function () {
    console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
    return this.getRenderTarget();
  },
  getMaxAnisotropy: function () {
    console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
    return this.capabilities.getMaxAnisotropy();
  },
  getPrecision: function () {
    console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
    return this.capabilities.precision;
  },
  resetGLState: function () {
    console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
    return this.state.reset();
  },
  supportsFloatTextures: function () {
    console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
    return this.extensions.get('OES_texture_float');
  },
  supportsHalfFloatTextures: function () {
    console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
    return this.extensions.get('OES_texture_half_float');
  },
  supportsStandardDerivatives: function () {
    console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
    return this.extensions.get('OES_standard_derivatives');
  },
  supportsCompressedTextureS3TC: function () {
    console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
    return this.extensions.get('WEBGL_compressed_texture_s3tc');
  },
  supportsCompressedTexturePVRTC: function () {
    console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
    return this.extensions.get('WEBGL_compressed_texture_pvrtc');
  },
  supportsBlendMinMax: function () {
    console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
    return this.extensions.get('EXT_blend_minmax');
  },
  supportsVertexTextures: function () {
    console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
    return this.capabilities.vertexTextures;
  },
  supportsInstancedArrays: function () {
    console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
    return this.extensions.get('ANGLE_instanced_arrays');
  },
  enableScissorTest: function (boolean) {
    console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
    this.setScissorTest(boolean);
  },
  initMaterial: function () {
    console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
  },
  addPrePlugin: function () {
    console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
  },
  addPostPlugin: function () {
    console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
  },
  updateShadowMap: function () {
    console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
  },
  setFaceCulling: function () {
    console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
  },
  allocTextureUnit: function () {
    console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
  },
  setTexture: function () {
    console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
  },
  setTexture2D: function () {
    console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
  },
  setTextureCube: function () {
    console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
  },
  getActiveMipMapLevel: function () {
    console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
    return this.getActiveMipmapLevel();
  }
});
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function () {
      return this.shadowMap.enabled;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function () {
      return this.shadowMap.type;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function ()
    /* value */
    {
      console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
    }
  },
  context: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
      return this.getContext();
    }
  },
  vr: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
      return this.xr;
    }
  },
  gammaInput: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
      return false;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
    }
  },
  gammaOutput: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
      return false;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
      return 1.0;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function ()
    /* cullFace */
    {
      console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
    }
  },
  renderReverseSided: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
    }
  },
  renderSingleSided: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
    }
  }
});

function WebGLRenderTargetCube(width, height, options) {
  console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
  return new WebGLCubeRenderTarget(width, options);
} //


Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      return this.texture.wrapS;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      return this.texture.wrapT;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      return this.texture.magFilter;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      return this.texture.minFilter;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      return this.texture.anisotropy;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      return this.texture.offset;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      return this.texture.repeat;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      this.texture.repeat = value;
    }
  },
  format: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      return this.texture.format;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      this.texture.format = value;
    }
  },
  type: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      return this.texture.type;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      return this.texture.generateMipmaps;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      this.texture.generateMipmaps = value;
    }
  }
}); //

Object.defineProperties(Audio.prototype, {
  load: {
    value: function (file) {
      console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
      const scope = this;
      const audioLoader = new AudioLoader();
      audioLoader.load(file, function (buffer) {
        scope.setBuffer(buffer);
      });
      return this;
    }
  },
  startTime: {
    set: function () {
      console.warn('THREE.Audio: .startTime is now .play( delay ).');
    }
  }
});

AudioAnalyser.prototype.getData = function () {
  console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
  return this.getFrequencyData();
}; //


CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
  console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
  return this.update(renderer, scene);
}; //


const GeometryUtils = {
  merge: function (geometry1, geometry2, materialIndexOffset) {
    console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
    let matrix;

    if (geometry2.isMesh) {
      geometry2.matrixAutoUpdate && geometry2.updateMatrix();
      matrix = geometry2.matrix;
      geometry2 = geometry2.geometry;
    }

    geometry1.merge(geometry2, matrix, materialIndexOffset);
  },
  center: function (geometry) {
    console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
    return geometry.center();
  }
};
exports.GeometryUtils = GeometryUtils;
ImageUtils.crossOrigin = undefined;

ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
  console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
  const loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(url, onLoad, undefined, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};

ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {
  console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
  const loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(urls, onLoad, undefined, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};

ImageUtils.loadCompressedTexture = function () {
  console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
};

ImageUtils.loadCompressedTextureCube = function () {
  console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
}; //


function CanvasRenderer() {
  console.error('THREE.CanvasRenderer has been removed');
} //


function JSONLoader() {
  console.error('THREE.JSONLoader has been removed.');
} //


const SceneUtils = {
  createMultiMaterialObject: function ()
  /* geometry, materials */
  {
    console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
  },
  detach: function ()
  /* child, parent, scene */
  {
    console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
  },
  attach: function ()
  /* child, scene, parent */
  {
    console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
  }
}; //

exports.SceneUtils = SceneUtils;

function LensFlare() {
  console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');
}

if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
  /* eslint-disable no-undef */
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
    detail: {
      revision: REVISION
    }
  }));
  /* eslint-enable no-undef */

}
},{}],"threechars.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCharGeometryAndWidth = getCharGeometryAndWidth;

var THREE = _interopRequireWildcard(require("three"));

var _globals = require("./globals");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// cache the geometry, not the mesh
// caching the mesh would mean that every char (A, B, etc.) would
// end up at the same position...
// key: char (letter)
// value: {geometry: ..., width: ...}
var geometryCache = {};

function getCharGeometryAndWidth(char) {
  var geometry = null;
  var width = null;

  if (Object.keys(geometryCache).includes(char)) {
    var cachedGeometryAndWidth = geometryCache[char];
    geometry = cachedGeometryAndWidth.geometry;
    width = cachedGeometryAndWidth.width;
  } else {
    geometry = new THREE.TextBufferGeometry(char, {
      font: _globals.GLOBALS.font,
      size: 4,
      curveSegments: 1,
      height: 0.1
    });
    geometry.computeBoundingBox();
    width = geometry.boundingBox.max.x; // just in case

    if (isNaN(width)) {
      width = 0;
    } // sometimes bounding box will be -Infinity (for space chars?)


    width = Math.max(width, 0);
    geometryCache[char] = {
      geometry: geometry,
      width: width
    };
  } // var materials = [
  //   new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff }),
  //   new THREE.MeshBasicMaterial({ color: 0x000000 })
  // ];
  // var mesh = new THREE.Mesh(geometry, materials);


  return {
    geometry: geometry,
    width: width
  };
}
},{"three":"node_modules/three/build/three.module.js","./globals":"globals.js"}],"lib/BufferGeometryUtils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var THREE = _interopRequireWildcard(require("three"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @author mrdoob / http://mrdoob.com/
 */
var _default = {
  computeTangents: function computeTangents(geometry) {
    var index = geometry.index;
    var attributes = geometry.attributes; // based on http://www.terathon.com/code/tangent.html
    // (per vertex tangents)

    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
      console.warn('THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()');
      return;
    }

    var indices = index.array;
    var positions = attributes.position.array;
    var normals = attributes.normal.array;
    var uvs = attributes.uv.array;
    var nVertices = positions.length / 3;

    if (attributes.tangent === undefined) {
      geometry.addAttribute('tangent', new THREE.BufferAttribute(new Float32Array(4 * nVertices), 4));
    }

    var tangents = attributes.tangent.array;
    var tan1 = [],
        tan2 = [];

    for (var i = 0; i < nVertices; i++) {
      tan1[i] = new THREE.Vector3();
      tan2[i] = new THREE.Vector3();
    }

    var vA = new THREE.Vector3(),
        vB = new THREE.Vector3(),
        vC = new THREE.Vector3(),
        uvA = new THREE.Vector2(),
        uvB = new THREE.Vector2(),
        uvC = new THREE.Vector2(),
        sdir = new THREE.Vector3(),
        tdir = new THREE.Vector3();

    function handleTriangle(a, b, c) {
      vA.fromArray(positions, a * 3);
      vB.fromArray(positions, b * 3);
      vC.fromArray(positions, c * 3);
      uvA.fromArray(uvs, a * 2);
      uvB.fromArray(uvs, b * 2);
      uvC.fromArray(uvs, c * 2);
      var x1 = vB.x - vA.x;
      var x2 = vC.x - vA.x;
      var y1 = vB.y - vA.y;
      var y2 = vC.y - vA.y;
      var z1 = vB.z - vA.z;
      var z2 = vC.z - vA.z;
      var s1 = uvB.x - uvA.x;
      var s2 = uvC.x - uvA.x;
      var t1 = uvB.y - uvA.y;
      var t2 = uvC.y - uvA.y;
      var r = 1.0 / (s1 * t2 - s2 * t1);
      sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
      tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }

    var groups = geometry.groups;

    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }

    for (var i = 0, il = groups.length; i < il; ++i) {
      var group = groups[i];
      var start = group.start;
      var count = group.count;

      for (var j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
      }
    }

    var tmp = new THREE.Vector3(),
        tmp2 = new THREE.Vector3();
    var n = new THREE.Vector3(),
        n2 = new THREE.Vector3();
    var w, t, test;

    function handleVertex(v) {
      n.fromArray(normals, v * 3);
      n2.copy(n);
      t = tan1[v]; // Gram-Schmidt orthogonalize

      tmp.copy(t);
      tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness

      tmp2.crossVectors(n2, t);
      test = tmp2.dot(tan2[v]);
      w = test < 0.0 ? -1.0 : 1.0;
      tangents[v * 4] = tmp.x;
      tangents[v * 4 + 1] = tmp.y;
      tangents[v * 4 + 2] = tmp.z;
      tangents[v * 4 + 3] = w;
    }

    for (var i = 0, il = groups.length; i < il; ++i) {
      var group = groups[i];
      var start = group.start;
      var count = group.count;

      for (var j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(indices[j + 0]);
        handleVertex(indices[j + 1]);
        handleVertex(indices[j + 2]);
      }
    }
  },

  /**
   * @param  {Array<THREE.BufferGeometry>} geometries
   * @param  {Boolean} useGroups
   * @return {THREE.BufferGeometry}
   */
  mergeBufferGeometries: function mergeBufferGeometries(geometries, useGroups) {
    // console.log('mergeBufferGeometries');
    var isIndexed = geometries[0].index !== null;
    var attributesUsed = new Set(Object.keys(geometries[0].attributes));
    var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes)); // console.log('attributesUsed', attributesUsed);

    var attributes = {};
    var morphAttributes = {};
    var mergedGeometry = new THREE.BufferGeometry(); // console.log('mergedGeometry', mergedGeometry);

    var offset = 0;

    for (var i = 0; i < geometries.length; ++i) {
      var geometry = geometries[i]; // ensure that all geometries are indexed, or none

      if (isIndexed !== (geometry.index !== null)) {
        console.error('ensure that all geometries are indexed, or none');
        return null;
      } // gather attributes, exit early if they're different


      for (var name in geometry.attributes) {
        // console.log('name', name);
        // console.log('geometry.attributes', geometry.attributes);
        // console.log('attributesUsed', attributesUsed);
        if (!attributesUsed.has(name)) {
          console.error('attributesUsed.has( name )');
          return null;
        }

        if (attributes[name] === undefined) attributes[name] = [];
        attributes[name].push(geometry.attributes[name]);
      } // gather morph attributes, exit early if they're different


      for (var name in geometry.morphAttributes) {
        if (!morphAttributesUsed.has(name)) {
          console.error('morphAttributesUsed.has( name ');
          return null;
        }

        if (morphAttributes[name] === undefined) morphAttributes[name] = [];
        morphAttributes[name].push(geometry.morphAttributes[name]);
      } // gather .userData


      mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];
      mergedGeometry.userData.mergedUserData.push(geometry.userData);

      if (useGroups) {
        var count;

        if (isIndexed) {
          count = geometry.index.count;
        } else if (geometry.attributes.position !== undefined) {
          count = geometry.attributes.position.count;
        } else {
          console.error('useGroups -> isIndexed');
          return null;
        }

        mergedGeometry.addGroup(offset, count, i);
        offset += count;
      }
    } // merge indices


    if (isIndexed) {
      var indexOffset = 0;
      var mergedIndex = [];

      for (var i = 0; i < geometries.length; ++i) {
        var index = geometries[i].index;

        for (var j = 0; j < index.count; ++j) {
          mergedIndex.push(index.getX(j) + indexOffset);
        }

        indexOffset += geometries[i].attributes.position.count;
      }

      mergedGeometry.setIndex(mergedIndex);
    } // merge attributes


    for (var name in attributes) {
      var mergedAttribute = this.mergeBufferAttributes(attributes[name]);
      if (!mergedAttribute) return null;
      mergedGeometry.setAttribute(name, mergedAttribute);
    } // merge morph attributes


    for (var name in morphAttributes) {
      var numMorphTargets = morphAttributes[name][0].length;
      if (numMorphTargets === 0) break;
      mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
      mergedGeometry.morphAttributes[name] = [];

      for (var i = 0; i < numMorphTargets; ++i) {
        var morphAttributesToMerge = [];

        for (var j = 0; j < morphAttributes[name].length; ++j) {
          morphAttributesToMerge.push(morphAttributes[name][j][i]);
        }

        var mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge);
        if (!mergedMorphAttribute) return null;
        mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
      }
    }

    return mergedGeometry;
  },

  /**
   * @param {Array<THREE.BufferAttribute>} attributes
   * @return {THREE.BufferAttribute}
   */
  mergeBufferAttributes: function mergeBufferAttributes(attributes) {
    var TypedArray;
    var itemSize;
    var normalized;
    var arrayLength = 0;

    for (var i = 0; i < attributes.length; ++i) {
      var attribute = attributes[i];
      if (attribute.isInterleavedBufferAttribute) return null;
      if (TypedArray === undefined) TypedArray = attribute.array.constructor;
      if (TypedArray !== attribute.array.constructor) return null;
      if (itemSize === undefined) itemSize = attribute.itemSize;
      if (itemSize !== attribute.itemSize) return null;
      if (normalized === undefined) normalized = attribute.normalized;
      if (normalized !== attribute.normalized) return null;
      arrayLength += attribute.array.length;
    }

    var array = new TypedArray(arrayLength);
    var offset = 0;

    for (var i = 0; i < attributes.length; ++i) {
      array.set(attributes[i].array, offset);
      offset += attributes[i].array.length;
    }

    return new THREE.BufferAttribute(array, itemSize, normalized);
  },

  /**
   * @param {Array<THREE.BufferAttribute>} attributes
   * @return {Array<THREE.InterleavedBufferAttribute>}
   */
  interleaveAttributes: function interleaveAttributes(attributes) {
    // Interleaves the provided attributes into an InterleavedBuffer and returns
    // a set of InterleavedBufferAttributes for each attribute
    var TypedArray;
    var arrayLength = 0;
    var stride = 0; // calculate the the length and type of the interleavedBuffer

    for (var i = 0, l = attributes.length; i < l; ++i) {
      var attribute = attributes[i];
      if (TypedArray === undefined) TypedArray = attribute.array.constructor;

      if (TypedArray !== attribute.array.constructor) {
        console.warn('AttributeBuffers of different types cannot be interleaved');
        return null;
      }

      arrayLength += attribute.array.length;
      stride += attribute.itemSize;
    } // Create the set of buffer attributes


    var interleavedBuffer = new THREE.InterleavedBuffer(new TypedArray(arrayLength), stride);
    var offset = 0;
    var res = [];
    var getters = ['getX', 'getY', 'getZ', 'getW'];
    var setters = ['setX', 'setY', 'setZ', 'setW'];

    for (var j = 0, l = attributes.length; j < l; j++) {
      var attribute = attributes[j];
      var itemSize = attribute.itemSize;
      var count = attribute.count;
      var iba = new THREE.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);
      res.push(iba);
      offset += itemSize; // Move the data for each attribute into the new interleavedBuffer
      // at the appropriate offset

      for (var c = 0; c < count; c++) {
        for (var k = 0; k < itemSize; k++) {
          iba[setters[k]](c, attribute[getters[k]](c));
        }
      }
    }

    return res;
  },

  /**
   * @param {Array<THREE.BufferGeometry>} geometry
   * @return {number}
   */
  estimateBytesUsed: function estimateBytesUsed(geometry) {
    // Return the estimated memory used by this geometry in bytes
    // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account
    // for InterleavedBufferAttributes.
    var mem = 0;

    for (var name in geometry.attributes) {
      var attr = geometry.getAttribute(name);
      mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;
    }

    var indices = geometry.getIndex();
    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;
    return mem;
  },

  /**
   * @param {THREE.BufferGeometry} geometry
   * @param {number} tolerance
   * @return {THREE.BufferGeometry>}
   */
  mergeVertices: function mergeVertices(geometry) {
    var tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;
    tolerance = Math.max(tolerance, Number.EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it
    // if it's already available.

    var hashToIndex = {};
    var indices = geometry.getIndex();
    var positions = geometry.getAttribute('position');
    var vertexCount = indices ? indices.count : positions.count; // next value for triangle indices

    var nextIndex = 0; // attributes and new attribute arrays

    var attributeNames = Object.keys(geometry.attributes);
    var attrArrays = {};
    var morphAttrsArrays = {};
    var newIndices = [];
    var getters = ['getX', 'getY', 'getZ', 'getW']; // initialize the arrays

    for (var i = 0, l = attributeNames.length; i < l; i++) {
      var name = attributeNames[i];
      attrArrays[name] = [];
      var morphAttr = geometry.morphAttributes[name];

      if (morphAttr) {
        morphAttrsArrays[name] = new Array(morphAttr.length).fill().map(function () {
          return [];
        });
      }
    } // convert the error tolerance to an amount of decimal places to truncate to


    var decimalShift = Math.log10(1 / tolerance);
    var shiftMultiplier = Math.pow(10, decimalShift);

    for (var i = 0; i < vertexCount; i++) {
      var index = indices ? indices.getX(i) : i; // Generate a hash for the vertex attributes at the current index 'i'

      var hash = '';

      for (var j = 0, l = attributeNames.length; j < l; j++) {
        var name = attributeNames[j];
        var attribute = geometry.getAttribute(name);
        var itemSize = attribute.itemSize;

        for (var k = 0; k < itemSize; k++) {
          // double tilde truncates the decimal value
          hash += "".concat(~~(attribute[getters[k]](index) * shiftMultiplier), ",");
        }
      } // Add another reference to the vertex if it's already
      // used by another index


      if (hash in hashToIndex) {
        newIndices.push(hashToIndex[hash]);
      } else {
        // copy data to the new index in the attribute arrays
        for (var j = 0, l = attributeNames.length; j < l; j++) {
          var name = attributeNames[j];
          var attribute = geometry.getAttribute(name);
          var morphAttr = geometry.morphAttributes[name];
          var itemSize = attribute.itemSize;
          var newarray = attrArrays[name];
          var newMorphArrays = morphAttrsArrays[name];

          for (var k = 0; k < itemSize; k++) {
            var getterFunc = getters[k];
            newarray.push(attribute[getterFunc](index));

            if (morphAttr) {
              for (var m = 0, ml = morphAttr.length; m < ml; m++) {
                newMorphArrays[m].push(morphAttr[m][getterFunc](index));
              }
            }
          }
        }

        hashToIndex[hash] = nextIndex;
        newIndices.push(nextIndex);
        nextIndex++;
      }
    } // Generate typed arrays from new attribute arrays and update
    // the attributeBuffers


    var result = geometry.clone();

    for (var i = 0, l = attributeNames.length; i < l; i++) {
      var name = attributeNames[i];
      var oldAttribute = geometry.getAttribute(name);
      var attribute;
      var buffer = new oldAttribute.array.constructor(attrArrays[name]);

      if (oldAttribute.isInterleavedBufferAttribute) {
        attribute = new THREE.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.itemSize);
      } else {
        attribute = geometry.getAttribute(name).clone();
        attribute.setArray(buffer);
      }

      result.addAttribute(name, attribute); // Update the attribute arrays

      if (name in morphAttrsArrays) {
        for (var j = 0; j < morphAttrsArrays[name].length; j++) {
          var morphAttribute = geometry.morphAttributes[name][j].clone();
          morphAttribute.setArray(new morphAttribute.array.constructor(morphAttrsArrays[name][j]));
          result.morphAttributes[name][j] = morphAttribute;
        }
      }
    } // Generate an index buffer typed array


    var cons = Uint8Array;
    if (newIndices.length >= Math.pow(2, 8)) cons = Uint16Array;
    if (newIndices.length >= Math.pow(2, 16)) cons = Uint32Array;
    var newIndexBuffer = new cons(newIndices);
    var newIndices = null;

    if (indices === null) {
      newIndices = new THREE.BufferAttribute(newIndexBuffer, 1);
    } else {
      newIndices = geometry.getIndex().clone();
      newIndices.setArray(newIndexBuffer);
    }

    result.setIndex(newIndices);
    return result;
  }
};
exports.default = _default;
},{"three":"node_modules/three/build/three.module.js"}],"leaf.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var THREE = _interopRequireWildcard(require("three"));

var _globals = require("./globals");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Leaf = /*#__PURE__*/function () {
  function Leaf(p5, index_, co) {
    _classCallCheck(this, Leaf);

    this.index = index_;
    this.ang_z = p5.random(p5.TWO_PI);
    this.ang_y = p5.radians(p5.random(-20, 20));
    this.co = p5.color(255, 0, 0);
    this.w = p5.random(7, 10);
    this.h = p5.random(3, 5);
    this.a = p5.color('#22424B');
    this.b = p5.color('#4E7367');
    this.fill = p5.lerpColor(this.a, this.b, p5.random(1.));
    var x = 0,
        y = 0;
    var shape = new THREE.Shape();
    shape.lineTo(0.1 * this.w, -0.25 * this.h);
    shape.lineTo(0.4 * this.w, -0.5 * this.h);
    shape.lineTo(0.6 * this.w, -0.35 * this.h);
    shape.lineTo(1 * this.w, 0 * this.h);
    shape.lineTo(0.6 * this.w, 0.35 * this.h);
    shape.lineTo(0.4 * this.w, 0.5 * this.h);
    shape.lineTo(0.1 * this.w, 0.25 * this.h);
    var geometry = new THREE.ShapeGeometry(shape); // geometry.translate(0 - 0.5 * this.w, 0, 0);

    var material = new THREE.MeshPhongMaterial({
      color: new THREE.Color(p5.red(this.fill) / 255, p5.green(this.fill) / 255, p5.blue(this.fill) / 255)
    });
    material.side = THREE.DoubleSide;
    this.threeObject = new THREE.Mesh(geometry, material);
  }

  _createClass(Leaf, [{
    key: "getObjectThree",
    value: function getObjectThree() {
      return this.threeObject;
    }
  }, {
    key: "render",
    value: function render() {
      this.threeObject.rotation.set(0, 0, 0);
      this.threeObject.rotateY(this.ang_z + _globals.GLOBALS.wind * 3);
      this.threeObject.rotateZ(this.ang_y + _globals.GLOBALS.wind); // this.threeObject.rotateY(this.ang_z + (GLOBALS.wind * 3));
      // this.threeObject.rotateX(this.ang_y + (GLOBALS.wind));

      return;
      push();
      rotateZ(this.ang_z + wind * 3);
      rotateY(this.ang_y + wind); //     disableStyle();

      this.drawLeaf();
      pop();
    }
  }, {
    key: "drawLeaf",
    value: function drawLeaf() {
      return;
      beginShape();
      fill(this.fill);
      noStroke();
      vertex(0, 0);
      vertex(0.1 * this.w, -0.25 * this.h);
      vertex(0.4 * this.w, -0.5 * this.h);
      vertex(0.6 * this.w, -0.35 * this.h);
      vertex(1 * this.w, 0 * this.h);
      vertex(0.6 * this.w, 0.35 * this.h);
      vertex(0.4 * this.w, 0.5 * this.h);
      vertex(0.1 * this.w, 0.25 * this.h);
      endShape(CLOSE);
    }
  }]);

  return Leaf;
}();

exports.default = Leaf;
},{"three":"node_modules/three/build/three.module.js","./globals":"globals.js"}],"flower.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var THREE = _interopRequireWildcard(require("three"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Flower = /*#__PURE__*/function () {
  function Flower(p5, index_) {
    _classCallCheck(this, Flower);

    this.p5 = p5;
    this.index = index_;
    this.ang_z = p5.random(p5.TWO_PI);
    this.ang_y = p5.radians(p5.random(-20, 20));
    this.color = p5.lerpColor(p5.color(252, 0, 92, 150), p5.color(255, 122, 33, 150), p5.random(1));
    this.radius = p5.random(2, 4);
    this.points = [];
    this.createPoints();
    var shape = new THREE.Shape();

    for (var i = 0; i < this.points.length; i++) {
      shape.lineTo(this.points[i].x, this.points[i].y);
    }

    shape.lineTo(this.points[0].x, this.points[0].y);
    var geometry = new THREE.ShapeGeometry(shape);
    var material = new THREE.MeshPhongMaterial({
      color: new THREE.Color(p5.red(this.color) / 255, p5.green(this.color) / 255, p5.blue(this.color) / 255)
    });
    material.side = THREE.DoubleSide;
    this.threeObject = new THREE.Mesh(geometry, material);
  }

  _createClass(Flower, [{
    key: "getObjectThree",
    value: function getObjectThree() {
      return this.threeObject;
    }
  }, {
    key: "render",
    value: function render() {
      this.threeObject.rotation.set(0, 0, 0);
      this.threeObject.rotateY(this.ang_z);
      this.threeObject.rotateZ(this.ang_y);
      return;
      push();
      rotateZ(this.ang_z);
      rotateY(this.ang_y); //     shape.disableStyle();

      this.drawFlower();
      pop();
    }
  }, {
    key: "createPoints",
    value: function createPoints() {
      var p5 = this.p5;
      var detail = 10;

      for (var i = 0; i < detail; i++) {
        var ang = p5.map(i, 0, detail, 0, p5.TWO_PI);
        var aux = this.radius + p5.random(-this.radius * .2, this.radius * .2);
        var x = p5.cos(ang) * aux;
        var y = p5.sin(ang) * aux;
        this.points.push(p5.createVector(x, y));
      }
    }
  }, {
    key: "drawFlower",
    value: function drawFlower() {
      beginShape();
      noStroke();
      fill(this.color);

      for (var i = 0; i < this.points.length; i++) {
        vertex(this.points[i].x, this.points[i].y);
      }

      endShape(CLOSE);
    }
  }]);

  return Flower;
}();

exports.default = Flower;
},{"three":"node_modules/three/build/three.module.js"}],"branch.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var THREE = _interopRequireWildcard(require("three"));

var _globals = require("./globals");

var _threechars = require("./threechars");

var _BufferGeometryUtils = _interopRequireDefault(require("./lib/BufferGeometryUtils"));

var _leaf = _interopRequireDefault(require("./leaf"));

var _flower = _interopRequireDefault(require("./flower"));

var _util = require("./util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var MAX_POINTS_THREE = 100;

var Branch = /*#__PURE__*/function () {
  function Branch(p5, index_, generation_, coeff_, text_, magic_, co_) {
    _classCallCheck(this, Branch);

    // needs to be created before createpoints is called
    // this.geometry = new THREE.BufferGeometry();
    // var positions = new Float32Array( MAX_POINTS_THREE * 3 ); // 3 vertices per point
    // this.geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
    // // no points yet, no range is empty
    // this.geometry.setDrawRange(0, 0);
    // // material
    // var material = new THREE.LineBasicMaterial( {
    //   color: 0xff0000,
    //   linewidth: 1000,
    // } );
    // line
    // this.line = new THREE.Line( this.geometry,  material );
    // empty object, replaces line
    var geometry = new THREE.BufferGeometry();
    this.threeObject = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
      color: 0x417057
    })); // we'll be adding moving-around letters into the group,
    // and then emptying and merging the group into the branch's geometry every time
    // changing switches to false

    this.unmergedLettersMeshIndices = [];
    this.unmergedLettersGroup = new THREE.Group();
    this.threeObject.add(this.unmergedLettersGroup); // will contain the char meshes placed along this branch
    // for text 'apple', short branch will contain 'ap',
    // very long will be 'appleapple'...
    // WE DON'T NEED TO KEEP TRACK OF THE GEOMS (and meshes don't exist)... just keep track of how many were placed

    this.placedCharMeshes = [];
    this.nmbPlacedCharGeometries = 0;
    this.p5 = p5;
    this.points = [];
    this.new_points = [];
    this.leaves = [];
    this.flowers = [];
    this.changing = false;
    this.change_time = p5.int(p5.random(10, 30));
    this.change_fire = 0;
    this.cycles = 0;
    this.leaf_prob = 30;
    this.flower_prob = 10;
    this.branch_prob = 60;
    this.ang_z = p5.radians(p5.random(-40, 0));
    ;
    this.ang_y = 0;
    this.ang_y = p5.random(p5.TWO_PI);
    this.max_branches = 60;
    this.max_generation = 2;
    this.max_cycles = 6;
    this.segment_length = p5.random(3, 5);
    this.variance = 2;
    this.branches = []; // list of points indices, one per existing branch

    this.pointIndexPerBranch = [];
    this.co = co_;
    this.coeff = coeff_;
    this.text = text_;
    this.index = index_;
    this.generation = generation_;
    this.createpoints(this.p5); //  co = color(p5.random(50, 255), p5.random(50, 255), p5.random(50, 255));
    // co = color(255);

    this.segment_length = p5.map(this.generation, 0, 5, 5, 2);
    this.segment_length = p5.random(this.segment_length * .5, this.segment_length * 1.5);
    this.max_cycles = 6 - this.generation;
    this.magic_number = magic_; // println(segment_length);

    this.mergeTimeout = null;
  }

  _createClass(Branch, [{
    key: "getObjectThree",
    value: function getObjectThree() {
      return this.threeObject;
    } // getLineThree() {
    //   return this.line;
    // }
    // not just point[0] to point[length-1]...!

  }, {
    key: "getTotalLineLength",
    value: function getTotalLineLength() {
      if (this.points.length < 2) {
        return 0;
      }

      ;
      var length = 0;

      for (var pointIdx = 0; pointIdx < this.points.length - 1; pointIdx++) {
        var pointA = this.points[pointIdx];
        var pointB = this.points[pointIdx + 1];
        pointA = new THREE.Vector3(pointA.x, pointA.y, pointA.z);
        pointB = new THREE.Vector3(pointB.x, pointB.y, pointB.z);
        length += pointA.distanceToSquared(pointB);
      }

      return length;
    }
  }, {
    key: "handleChangingBecomingFalse",
    value: function handleChangingBecomingFalse() {
      // are there any unmerged letters?
      if (this.unmergedLettersGroup.children.length < 2) {
        return;
      } // // clear any pending timeouts


      if (this.mergeTimeout !== null) {
        clearTimeout(this.mergeTimeout);
      }

      var branch = this;
      this.mergeTimeout = setTimeout(function () {
        branch.doMerge();
      }, 100);
    }
  }, {
    key: "doMerge",
    value: function doMerge() {
      var _this$unmergedLetters;

      var geometriesToMerge = this.unmergedLettersGroup.children.map(function (child) {
        var newGeometry = child.geometry.clone();
        newGeometry.translate(child.position.x, child.position.y, child.position.z);
        return newGeometry;
      });

      var newMergedGeometry = _BufferGeometryUtils.default.mergeBufferGeometries([].concat(_toConsumableArray(geometriesToMerge), [this.threeObject.geometry]));

      this.threeObject.geometry.copy(newMergedGeometry);

      (_this$unmergedLetters = this.unmergedLettersGroup).remove.apply(_this$unmergedLetters, _toConsumableArray(this.unmergedLettersGroup.children));

      this.unmergedLettersMeshIndices = [];
    }
  }, {
    key: "placeTextThree",
    value: function placeTextThree() {
      var p5 = this.p5; // will always increase, but % text.length === index (into the text)

      var meshIndex = 0; // index into the text, will be set to 0 after wrapping

      var index = 0;
      var over = 0; //  float w_acum;

      for (var i = 0; i < this.points.length - 1; i++) {
        var start = this.points[i];
        var end = this.points[i + 1];
        var l = p5.dist(start.x, start.y, start.z, end.x, end.y, end.z);
        var w_acum = over;

        while (w_acum < l) {
          var lerp = w_acum / l;
          var pos = new THREE.Vector3(start.x, start.y, start.z).lerp(new THREE.Vector3(end.x, end.y, end.z), lerp); // let pos = Vector.lerp(start, end, lerp);

          var char = this.text[index]; // var geometry = null;

          var geometryWidth = null;
          var charGeometryAndWidth = (0, _threechars.getCharGeometryAndWidth)(char);
          var geometryWidth = charGeometryAndWidth.width; // if length of placed meshes is equal to meshIndex, it means
          // we need to place a new mesh

          if (this.nmbPlacedCharGeometries == meshIndex) {
            var cachedGeometry = charGeometryAndWidth.geometry;
            var geometry = cachedGeometry.clone(); // var materials = [
            //   new THREE.MeshBasicMaterial({ color: 0xff0000 }),
            //   new THREE.MeshBasicMaterial({ color: 0x000000 })
            // ];

            var material = new THREE.MeshPhongMaterial({
              color: 0x417057
            });
            var mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(pos.x, pos.y, pos.z); // add own property to mesh
            // mesh.meshIndex = meshIndex;
            // temporarily add letter as movable mesh for now

            this.unmergedLettersMeshIndices.push(meshIndex);
            this.unmergedLettersGroup.add(mesh); // this.line.add(mesh);
            // this.threeObject.add(mesh);

            /*
            geometry.translate(pos.x, pos.y, pos.z);
            // merge it into object
            var newMergedGeometry = BufferGeometryUtils.mergeBufferGeometries([geometry, this.threeObject.geometry])
            this.threeObject.geometry.copy(newMergedGeometry);
            */
            // keep cloned mesh
            // this.placedCharMeshes.push(mesh);

            this.nmbPlacedCharGeometries++;
          } else {
            // WE DO NOT UPDATE ALREADY PLACED GEOMETRIES BECAUSE THEY'VE BEEN MERGED
            // mesh already exists
            // mesh = this.placedCharMeshes[meshIndex];
            // get the cached mesh for this char just to get its width
            var unmergedMeshIndex = this.unmergedLettersMeshIndices.indexOf(meshIndex);

            if (unmergedMeshIndex !== -1) {
              this.unmergedLettersGroup.children[unmergedMeshIndex].position.set(pos.x, pos.y, pos.z);
            }
          } // mesh.position.set(pos.x, pos.y, pos.z);
          // p5.push();
          // p5.translate(pos.x, pos.y, pos.z);
          // text(this.text.charAt(index), 0, 0);
          // p5.pop();
          // w_acum += textWidth(this.text.charAt(index));


          if (char === ' ') {
            geometryWidth = 3;
          }

          w_acum += geometryWidth;
          index++;

          if (index > this.text.length - 1) {
            index = 0;
            w_acum += 3;
          }

          meshIndex++;
        }

        over = w_acum - l;
      } // TODO
      // iterate over text
      // get text[i]'s mesh width
      // if accumulated width + mesh width > line length, bail
      // otherwise, check if mesh has already been placed, otherwise place it
      // update mesh position based on 

    } // always call after pushing to this.points

  }, {
    key: "addPointThree",
    value: function addPointThree(p5Vector) {
      // var positions = this.line.geometry.attributes.position.array;
      // var startIndex = (this.points.length - 1) * 3;
      // positions[startIndex] = p5Vector.x;
      // positions[startIndex + 1] = p5Vector.y;
      // positions[startIndex + 2] = p5Vector.z;
      // this.line.geometry.setDrawRange(0, this.points.length);
      // this.line.geometry.attributes.position.needsUpdate = true;
      this.placeTextThree();
    }
  }, {
    key: "updatePointThree",
    value: function updatePointThree(vector, index) {
      // var positions = this.line.geometry.attributes.position.array;
      // var startIndex = index * 3;
      // positions[startIndex] = vector.x;
      // positions[startIndex + 1] = vector.y;
      // positions[startIndex + 2] = vector.z;
      // this.line.geometry.attributes.position.needsUpdate = true;
      var point = this.points[index]; // does the point being updated related to an existing branch?

      if (this.pointIndexPerBranch.indexOf(index) !== -1) {
        var branchIdx = this.pointIndexPerBranch.indexOf(index);
        this.branches[branchIdx].threeObject.position.set(point.x, point.y, point.z);
      }

      this.placeTextThree();
    } // branch is added at the last point

  }, {
    key: "createBranchThree",
    value: function createBranchThree(branch, point) {
      // branch.line.position.set(point.x, point.y, point.z);
      branch.threeObject.position.set(point.x, point.y, point.z); // this.line.add(branch.line);

      this.threeObject.add(branch.threeObject);
    }
  }, {
    key: "setColor",
    value: function setColor(c) {
      this.co = c;
    } // FIXME remove
    // createThreeObject(originX, originY, originZ) {
    //   var material = new THREE.LineBasicMaterial({
    //     color: 0x0000ff
    //   });
    //   var points = [];
    //   for(var i = 0; i < this.points.length; i++) {
    //     points.push( new THREE.Vector3(
    //       this.points[i].x,
    //       this.points[i].y,
    //       this.points[i].z
    //       )
    //     );
    //   }
    //   var geometry = new THREE.BufferGeometry().setFromPoints( points );
    //   geometry.position.set(originX, originY, originZ)
    //   var line = new THREE.Line( geometry, material );
    //   return line;
    // }

  }, {
    key: "render",
    value: function render(full_mode) {
      var p5 = this.p5; // p5.rotateY(ang_y);
      // reset them puppies
      // this.line.rotation.set(0, 0, 0);

      this.threeObject.rotation.set(0, 0, 0); // this.line.rotateY(this.ang_z);

      this.threeObject.rotateY(this.ang_z); // var rotationY = this.line.rotation.y
      // var rotationYDelta = this.ang_z - rotationY;
      // // console.log('rotationYDelta', rotationYDelta);
      // this.line.rotateY(rotationYDelta);
      // rotationY += rotationYDelta

      if (this.generation > 0) {
        // p5.rotateZ(HALF_PI + radians(wind * map(generation,0,2,1,3))); // or p5.rotateY
        // this.line.rotateX(p5.HALF_PI);
        this.threeObject.rotateZ(p5.HALF_PI);
      } // var newRotationY = this.ang_y + (GLOBALS.wind * p5.map(this.generation, 0, 2, 1, 3))
      // rotationYDelta = newRotationY - rotationY;
      // // console.log('rotationYDelta', rotationYDelta);
      // console.log('BEFORE line.rotation.y', this.line.rotation.y, 'rotationYDelta', rotationYDelta)
      // this.line.rotateY(this.ang_y + (GLOBALS.wind * p5.map(this.generation, 0, 2, 1, 3)));


      this.threeObject.rotateY(this.ang_y + _globals.GLOBALS.wind * p5.map(this.generation, 0, 2, 1, 3)); // console.log('AFTER line.rotation.y', this.line.rotation.y)
      // this.line.rotateX(this.ang_z - this.line.rotation.z);

      this.threeObject.rotateZ(this.ang_z);

      for (var i = 0; i < this.leaves.length; i++) {
        var index = this.leaves[i].index;
        this.leaves[i].render();
      }

      for (var _i = 0; _i < this.flowers.length; _i++) {
        var _index = this.flowers[_i].index;

        this.flowers[_i].render();
      }

      for (var _i2 = 0; _i2 < this.branches.length; _i2++) {
        var _index2 = this.branches[_i2].index;

        this.branches[_i2].render(full_mode);
      }
    }
  }, {
    key: "update",
    value: function update() {
      var p5 = this.p5;

      for (var i = 0; i < this.branches.length; i++) {
        this.branches[i].update();
      }

      if (this.changing) {
        var curr_time = p5.frameCount - this.change_fire;
        var lerp_amt = p5.map(curr_time, 0, this.change_time, 0, 1);
        lerp_amt = p5.constrain(lerp_amt, 0, 1);

        for (var _i3 = 0; _i3 < this.points.length; _i3++) {
          this.points[_i3].lerp(this.new_points[_i3], lerp_amt);

          this.updatePointThree(this.points[_i3], _i3);
        }

        if (lerp_amt >= 1) {
          this.changing = false;
          this.handleChangingBecomingFalse();
        }
      }
    }
  }, {
    key: "createpoints",
    value: function createpoints(p5) {
      this.points = [];
      var aux = p5.createVector(0, 0, 0);
      this.points.push(aux);
      this.addPointThree(aux);
      var points_per_segment = 0;

      if (this.generation == 0) {
        points_per_segment = 9;
      } else {
        points_per_segment = 5 - p5.ceil(this.generation * p5.random(1, 1.2));
      }

      for (var i = 1; i < points_per_segment; i++) {
        aux = p5.createVector(i * this.segment_length, 0 + p5.random(-this.variance, this.variance), 0 + p5.random(-this.variance, this.variance));
        this.points.push(aux);
        this.addPointThree(aux);

        if (p5.random(100) < this.leaf_prob) {
          this.addLeaf(i, aux);
        }
      }
    }
  }, {
    key: "advance",
    value: function advance() {
      var p5 = this.p5;
      var something_changed = false;

      for (var i = 0; i < this.branches.length; i++) {
        if (this.branches[i].advance()) {
          something_changed = true;
        }
      }

      if (!this.changing && this.cycles < this.max_cycles) {
        this.new_points = [];
        something_changed = true;

        for (var _i4 = 0; _i4 < this.points.length * this.magic_number * this.coeff; _i4++) {
          var aux = p5.createVector(_i4 * this.segment_length, 0 + p5.random(-this.variance, this.variance), 0 + p5.random(-this.variance, this.variance));
          this.new_points.push(aux);
        } //  println(points.length);


        for (var _i5 = this.points.length; _i5 < this.new_points.length; _i5++) {
          var _aux = new p5.createVector(this.points[this.points.length - 1].x, this.points[this.points.length - 1].y, this.points[this.points.length - 1].z);

          this.points.push(_aux);
          this.addPointThree(_aux);

          if (p5.random(100) < this.leaf_prob) {
            this.addLeaf(_i5, _aux);
          }

          if (p5.random(100) < this.flower_prob && this.generation > 1) {
            this.addFlower(_i5, _aux);
            (0, _util.playFlowerSound)();
          }

          if (p5.random(100) < this.branch_prob && this.generation < this.max_generation && this.branches.length < this.max_branches) {
            var b = new Branch(p5, _i5, this.generation + 1, 1 - 0.01 * this.cycles, this.text, this.magic_number, this.co); // b.setColor(co);

            this.branches.push(b);
            this.createBranchThree(b, _aux);
            this.pointIndexPerBranch.push(this.points.length - 1);
          }
        } //println(points.length);


        this.changing = true;
        this.change_fire = p5.frameCount;
        this.cycles++;
      }

      return something_changed;
    }
  }, {
    key: "addLeaf",
    value: function addLeaf(index, point) {
      var leafObj = new _leaf.default(this.p5, index, this.co); // this.leaves.p5.push(aux);

      this.leaves.push(leafObj);
      var leafThreeObject = leafObj.getObjectThree();
      leafThreeObject.position.set(point.x, point.y, point.z);
      this.threeObject.add(leafThreeObject); // this.threeObject.add(cube);
      // this.threeObject.add(mesh);
    }
  }, {
    key: "addFlower",
    value: function addFlower(index, point) {
      var flowerObj = new _flower.default(this.p5, index);
      this.flowers.push(flowerObj);
      var flowerThreeObject = flowerObj.getObjectThree();
      flowerThreeObject.position.set(point.x, point.y, point.z);
      this.threeObject.add(flowerThreeObject);
    }
  }, {
    key: "setRotations",
    value: function setRotations(y, z) {
      this.ang_z = z;
      this.ang_y = y;
    }
  }, {
    key: "renderText",
    value: function renderText() {
      p5.push();
      textAlign(LEFT, CENTER);
      textFont(font, font_size); // fill(co);

      var index = 0;
      var over = 0; //  float w_acum;

      for (var i = 0; i < this.points.length - 1; i += 1) {
        var start = this.points[i];
        var end = this.points[i + 1];
        var l = dist(start.x, start.y, start.z, end.x, end.y, end.z);
        var w_acum = over;

        while (w_acum < l) {
          var lerp = w_acum / l;
          var pos = p5.Vector.lerp(start, end, lerp);
          p5.push();
          p5.translate(pos.x, pos.y, pos.z);
          text(this.text.charAt(index), 0, 0);
          p5.pop();
          w_acum += textWidth(this.text.charAt(index));
          index++;

          if (index > this.text.length - 1) {
            index = 0;
          }
        }

        over = w_acum - l;
      }

      p5.pop();
    }
  }, {
    key: "getBranchCount",
    value: function getBranchCount() {
      var count = 1;

      for (var i = 0; i < this.branches.length; i++) {
        count += this.branches[i].getBranchCount();
      }

      return count;
    }
  }]);

  return Branch;
}();

exports.default = Branch;
},{"three":"node_modules/three/build/three.module.js","./globals":"globals.js","./threechars":"threechars.js","./lib/BufferGeometryUtils":"lib/BufferGeometryUtils.js","./leaf":"leaf.js","./flower":"flower.js","./util":"util.js"}],"node_modules/three/examples/jsm/controls/OrbitControls.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MapControls = exports.OrbitControls = void 0;

var _threeModule = require("../../../build/three.module.js");

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move
var OrbitControls = function (object, domElement) {
  if (domElement === undefined) console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
  if (domElement === document) console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
  this.object = object;
  this.domElement = domElement; // Set to false to disable this control

  this.enabled = true; // "target" sets the location of focus, where the object orbits around

  this.target = new _threeModule.Vector3(); // How far you can dolly in and out ( PerspectiveCamera only )

  this.minDistance = 0;
  this.maxDistance = Infinity; // How far you can zoom in and out ( OrthographicCamera only )

  this.minZoom = 0;
  this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits.
  // Range is 0 to Math.PI radians.

  this.minPolarAngle = 0; // radians

  this.maxPolarAngle = Math.PI; // radians
  // How far you can orbit horizontally, upper and lower limits.
  // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )

  this.minAzimuthAngle = -Infinity; // radians

  this.maxAzimuthAngle = Infinity; // radians
  // Set to true to enable damping (inertia)
  // If damping is enabled, you must call controls.update() in your animation loop

  this.enableDamping = false;
  this.dampingFactor = 0.05; // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
  // Set to false to disable zooming

  this.enableZoom = true;
  this.zoomSpeed = 1.0; // Set to false to disable rotating

  this.enableRotate = true;
  this.rotateSpeed = 1.0; // Set to false to disable panning

  this.enablePan = true;
  this.panSpeed = 1.0;
  this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up

  this.keyPanSpeed = 7.0; // pixels moved per arrow key push
  // Set to true to automatically rotate around the target
  // If auto-rotate is enabled, you must call controls.update() in your animation loop

  this.autoRotate = false;
  this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60
  // Set to false to disable use of the keys

  this.enableKeys = true; // The four arrow keys

  this.keys = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    BOTTOM: 40
  }; // Mouse buttons

  this.mouseButtons = {
    LEFT: _threeModule.MOUSE.ROTATE,
    MIDDLE: _threeModule.MOUSE.DOLLY,
    RIGHT: _threeModule.MOUSE.PAN
  }; // Touch fingers

  this.touches = {
    ONE: _threeModule.TOUCH.ROTATE,
    TWO: _threeModule.TOUCH.DOLLY_PAN
  }; // for reset

  this.target0 = this.target.clone();
  this.position0 = this.object.position.clone();
  this.zoom0 = this.object.zoom; //
  // public methods
  //

  this.getPolarAngle = function () {
    return spherical.phi;
  };

  this.getAzimuthalAngle = function () {
    return spherical.theta;
  };

  this.saveState = function () {
    scope.target0.copy(scope.target);
    scope.position0.copy(scope.object.position);
    scope.zoom0 = scope.object.zoom;
  };

  this.reset = function () {
    scope.target.copy(scope.target0);
    scope.object.position.copy(scope.position0);
    scope.object.zoom = scope.zoom0;
    scope.object.updateProjectionMatrix();
    scope.dispatchEvent(changeEvent);
    scope.update();
    state = STATE.NONE;
  }; // this method is exposed, but perhaps it would be better if we can make it private...


  this.update = function () {
    var offset = new _threeModule.Vector3(); // so camera.up is the orbit axis

    var quat = new _threeModule.Quaternion().setFromUnitVectors(object.up, new _threeModule.Vector3(0, 1, 0));
    var quatInverse = quat.clone().inverse();
    var lastPosition = new _threeModule.Vector3();
    var lastQuaternion = new _threeModule.Quaternion();
    var twoPI = 2 * Math.PI;
    return function update() {
      var position = scope.object.position;
      offset.copy(position).sub(scope.target); // rotate offset to "y-axis-is-up" space

      offset.applyQuaternion(quat); // angle from z-axis around y-axis

      spherical.setFromVector3(offset);

      if (scope.autoRotate && state === STATE.NONE) {
        rotateLeft(getAutoRotationAngle());
      }

      if (scope.enableDamping) {
        spherical.theta += sphericalDelta.theta * scope.dampingFactor;
        spherical.phi += sphericalDelta.phi * scope.dampingFactor;
      } else {
        spherical.theta += sphericalDelta.theta;
        spherical.phi += sphericalDelta.phi;
      } // restrict theta to be between desired limits


      var min = scope.minAzimuthAngle;
      var max = scope.maxAzimuthAngle;

      if (isFinite(min) && isFinite(max)) {
        if (min < -Math.PI) min += twoPI;else if (min > Math.PI) min -= twoPI;
        if (max < -Math.PI) max += twoPI;else if (max > Math.PI) max -= twoPI;

        if (min < max) {
          spherical.theta = Math.max(min, Math.min(max, spherical.theta));
        } else {
          spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
        }
      } // restrict phi to be between desired limits


      spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
      spherical.makeSafe();
      spherical.radius *= scale; // restrict radius to be between desired limits

      spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius)); // move target to panned location

      if (scope.enableDamping === true) {
        scope.target.addScaledVector(panOffset, scope.dampingFactor);
      } else {
        scope.target.add(panOffset);
      }

      offset.setFromSpherical(spherical); // rotate offset back to "camera-up-vector-is-up" space

      offset.applyQuaternion(quatInverse);
      position.copy(scope.target).add(offset);
      scope.object.lookAt(scope.target);

      if (scope.enableDamping === true) {
        sphericalDelta.theta *= 1 - scope.dampingFactor;
        sphericalDelta.phi *= 1 - scope.dampingFactor;
        panOffset.multiplyScalar(1 - scope.dampingFactor);
      } else {
        sphericalDelta.set(0, 0, 0);
        panOffset.set(0, 0, 0);
      }

      scale = 1; // update condition is:
      // min(camera displacement, camera rotation in radians)^2 > EPS
      // using small-angle approximation cos(x/2) = 1 - x^2 / 8

      if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
        scope.dispatchEvent(changeEvent);
        lastPosition.copy(scope.object.position);
        lastQuaternion.copy(scope.object.quaternion);
        zoomChanged = false;
        return true;
      }

      return false;
    };
  }();

  this.dispose = function () {
    scope.domElement.removeEventListener('contextmenu', onContextMenu, false);
    scope.domElement.removeEventListener('pointerdown', onPointerDown, false);
    scope.domElement.removeEventListener('wheel', onMouseWheel, false);
    scope.domElement.removeEventListener('touchstart', onTouchStart, false);
    scope.domElement.removeEventListener('touchend', onTouchEnd, false);
    scope.domElement.removeEventListener('touchmove', onTouchMove, false);
    scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, false);
    scope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp, false);
    scope.domElement.removeEventListener('keydown', onKeyDown, false); //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
  }; //
  // internals
  //


  var scope = this;
  var changeEvent = {
    type: 'change'
  };
  var startEvent = {
    type: 'start'
  };
  var endEvent = {
    type: 'end'
  };
  var STATE = {
    NONE: -1,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_PAN: 4,
    TOUCH_DOLLY_PAN: 5,
    TOUCH_DOLLY_ROTATE: 6
  };
  var state = STATE.NONE;
  var EPS = 0.000001; // current position in spherical coordinates

  var spherical = new _threeModule.Spherical();
  var sphericalDelta = new _threeModule.Spherical();
  var scale = 1;
  var panOffset = new _threeModule.Vector3();
  var zoomChanged = false;
  var rotateStart = new _threeModule.Vector2();
  var rotateEnd = new _threeModule.Vector2();
  var rotateDelta = new _threeModule.Vector2();
  var panStart = new _threeModule.Vector2();
  var panEnd = new _threeModule.Vector2();
  var panDelta = new _threeModule.Vector2();
  var dollyStart = new _threeModule.Vector2();
  var dollyEnd = new _threeModule.Vector2();
  var dollyDelta = new _threeModule.Vector2();

  function getAutoRotationAngle() {
    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
  }

  function getZoomScale() {
    return Math.pow(0.95, scope.zoomSpeed);
  }

  function rotateLeft(angle) {
    sphericalDelta.theta -= angle;
  }

  function rotateUp(angle) {
    sphericalDelta.phi -= angle;
  }

  var panLeft = function () {
    var v = new _threeModule.Vector3();
    return function panLeft(distance, objectMatrix) {
      v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix

      v.multiplyScalar(-distance);
      panOffset.add(v);
    };
  }();

  var panUp = function () {
    var v = new _threeModule.Vector3();
    return function panUp(distance, objectMatrix) {
      if (scope.screenSpacePanning === true) {
        v.setFromMatrixColumn(objectMatrix, 1);
      } else {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.crossVectors(scope.object.up, v);
      }

      v.multiplyScalar(distance);
      panOffset.add(v);
    };
  }(); // deltaX and deltaY are in pixels; right and down are positive


  var pan = function () {
    var offset = new _threeModule.Vector3();
    return function pan(deltaX, deltaY) {
      var element = scope.domElement;

      if (scope.object.isPerspectiveCamera) {
        // perspective
        var position = scope.object.position;
        offset.copy(position).sub(scope.target);
        var targetDistance = offset.length(); // half of the fov is center to top of screen

        targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0); // we use only clientHeight here so aspect ratio does not distort speed

        panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
        panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
      } else if (scope.object.isOrthographicCamera) {
        // orthographic
        panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
        panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
      } else {
        // camera neither orthographic nor perspective
        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
        scope.enablePan = false;
      }
    };
  }();

  function dollyOut(dollyScale) {
    if (scope.object.isPerspectiveCamera) {
      scale /= dollyScale;
    } else if (scope.object.isOrthographicCamera) {
      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
      scope.object.updateProjectionMatrix();
      zoomChanged = true;
    } else {
      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
      scope.enableZoom = false;
    }
  }

  function dollyIn(dollyScale) {
    if (scope.object.isPerspectiveCamera) {
      scale *= dollyScale;
    } else if (scope.object.isOrthographicCamera) {
      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
      scope.object.updateProjectionMatrix();
      zoomChanged = true;
    } else {
      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
      scope.enableZoom = false;
    }
  } //
  // event callbacks - update the object state
  //


  function handleMouseDownRotate(event) {
    rotateStart.set(event.clientX, event.clientY);
  }

  function handleMouseDownDolly(event) {
    dollyStart.set(event.clientX, event.clientY);
  }

  function handleMouseDownPan(event) {
    panStart.set(event.clientX, event.clientY);
  }

  function handleMouseMoveRotate(event) {
    rotateEnd.set(event.clientX, event.clientY);
    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
    var element = scope.domElement;
    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
    rotateStart.copy(rotateEnd);
    scope.update();
  }

  function handleMouseMoveDolly(event) {
    dollyEnd.set(event.clientX, event.clientY);
    dollyDelta.subVectors(dollyEnd, dollyStart);

    if (dollyDelta.y > 0) {
      dollyOut(getZoomScale());
    } else if (dollyDelta.y < 0) {
      dollyIn(getZoomScale());
    }

    dollyStart.copy(dollyEnd);
    scope.update();
  }

  function handleMouseMovePan(event) {
    panEnd.set(event.clientX, event.clientY);
    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
    pan(panDelta.x, panDelta.y);
    panStart.copy(panEnd);
    scope.update();
  }

  function handleMouseUp()
  /*event*/
  {// no-op
  }

  function handleMouseWheel(event) {
    if (event.deltaY < 0) {
      dollyIn(getZoomScale());
    } else if (event.deltaY > 0) {
      dollyOut(getZoomScale());
    }

    scope.update();
  }

  function handleKeyDown(event) {
    var needsUpdate = false;

    switch (event.keyCode) {
      case scope.keys.UP:
        pan(0, scope.keyPanSpeed);
        needsUpdate = true;
        break;

      case scope.keys.BOTTOM:
        pan(0, -scope.keyPanSpeed);
        needsUpdate = true;
        break;

      case scope.keys.LEFT:
        pan(scope.keyPanSpeed, 0);
        needsUpdate = true;
        break;

      case scope.keys.RIGHT:
        pan(-scope.keyPanSpeed, 0);
        needsUpdate = true;
        break;
    }

    if (needsUpdate) {
      // prevent the browser from scrolling on cursor keys
      event.preventDefault();
      scope.update();
    }
  }

  function handleTouchStartRotate(event) {
    if (event.touches.length == 1) {
      rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
    } else {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      rotateStart.set(x, y);
    }
  }

  function handleTouchStartPan(event) {
    if (event.touches.length == 1) {
      panStart.set(event.touches[0].pageX, event.touches[0].pageY);
    } else {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      panStart.set(x, y);
    }
  }

  function handleTouchStartDolly(event) {
    var dx = event.touches[0].pageX - event.touches[1].pageX;
    var dy = event.touches[0].pageY - event.touches[1].pageY;
    var distance = Math.sqrt(dx * dx + dy * dy);
    dollyStart.set(0, distance);
  }

  function handleTouchStartDollyPan(event) {
    if (scope.enableZoom) handleTouchStartDolly(event);
    if (scope.enablePan) handleTouchStartPan(event);
  }

  function handleTouchStartDollyRotate(event) {
    if (scope.enableZoom) handleTouchStartDolly(event);
    if (scope.enableRotate) handleTouchStartRotate(event);
  }

  function handleTouchMoveRotate(event) {
    if (event.touches.length == 1) {
      rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
    } else {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      rotateEnd.set(x, y);
    }

    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
    var element = scope.domElement;
    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
    rotateStart.copy(rotateEnd);
  }

  function handleTouchMovePan(event) {
    if (event.touches.length == 1) {
      panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
    } else {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      panEnd.set(x, y);
    }

    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
    pan(panDelta.x, panDelta.y);
    panStart.copy(panEnd);
  }

  function handleTouchMoveDolly(event) {
    var dx = event.touches[0].pageX - event.touches[1].pageX;
    var dy = event.touches[0].pageY - event.touches[1].pageY;
    var distance = Math.sqrt(dx * dx + dy * dy);
    dollyEnd.set(0, distance);
    dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
    dollyOut(dollyDelta.y);
    dollyStart.copy(dollyEnd);
  }

  function handleTouchMoveDollyPan(event) {
    if (scope.enableZoom) handleTouchMoveDolly(event);
    if (scope.enablePan) handleTouchMovePan(event);
  }

  function handleTouchMoveDollyRotate(event) {
    if (scope.enableZoom) handleTouchMoveDolly(event);
    if (scope.enableRotate) handleTouchMoveRotate(event);
  }

  function handleTouchEnd()
  /*event*/
  {// no-op
  } //
  // event handlers - FSM: listen for events and reset state
  //


  function onPointerDown(event) {
    if (scope.enabled === false) return;

    switch (event.pointerType) {
      case 'mouse':
        onMouseDown(event);
        break;
      // TODO touch
    }
  }

  function onPointerMove(event) {
    if (scope.enabled === false) return;

    switch (event.pointerType) {
      case 'mouse':
        onMouseMove(event);
        break;
      // TODO touch
    }
  }

  function onPointerUp(event) {
    if (scope.enabled === false) return;

    switch (event.pointerType) {
      case 'mouse':
        onMouseUp(event);
        break;
      // TODO touch
    }
  }

  function onMouseDown(event) {
    // Prevent the browser from scrolling.
    event.preventDefault(); // Manually set the focus since calling preventDefault above
    // prevents the browser from setting it automatically.

    scope.domElement.focus ? scope.domElement.focus() : window.focus();
    var mouseAction;

    switch (event.button) {
      case 0:
        mouseAction = scope.mouseButtons.LEFT;
        break;

      case 1:
        mouseAction = scope.mouseButtons.MIDDLE;
        break;

      case 2:
        mouseAction = scope.mouseButtons.RIGHT;
        break;

      default:
        mouseAction = -1;
    }

    switch (mouseAction) {
      case _threeModule.MOUSE.DOLLY:
        if (scope.enableZoom === false) return;
        handleMouseDownDolly(event);
        state = STATE.DOLLY;
        break;

      case _threeModule.MOUSE.ROTATE:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (scope.enablePan === false) return;
          handleMouseDownPan(event);
          state = STATE.PAN;
        } else {
          if (scope.enableRotate === false) return;
          handleMouseDownRotate(event);
          state = STATE.ROTATE;
        }

        break;

      case _threeModule.MOUSE.PAN:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (scope.enableRotate === false) return;
          handleMouseDownRotate(event);
          state = STATE.ROTATE;
        } else {
          if (scope.enablePan === false) return;
          handleMouseDownPan(event);
          state = STATE.PAN;
        }

        break;

      default:
        state = STATE.NONE;
    }

    if (state !== STATE.NONE) {
      scope.domElement.ownerDocument.addEventListener('pointermove', onPointerMove, false);
      scope.domElement.ownerDocument.addEventListener('pointerup', onPointerUp, false);
      scope.dispatchEvent(startEvent);
    }
  }

  function onMouseMove(event) {
    if (scope.enabled === false) return;
    event.preventDefault();

    switch (state) {
      case STATE.ROTATE:
        if (scope.enableRotate === false) return;
        handleMouseMoveRotate(event);
        break;

      case STATE.DOLLY:
        if (scope.enableZoom === false) return;
        handleMouseMoveDolly(event);
        break;

      case STATE.PAN:
        if (scope.enablePan === false) return;
        handleMouseMovePan(event);
        break;
    }
  }

  function onMouseUp(event) {
    if (scope.enabled === false) return;
    handleMouseUp(event);
    scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, false);
    scope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp, false);
    scope.dispatchEvent(endEvent);
    state = STATE.NONE;
  }

  function onMouseWheel(event) {
    if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;
    event.preventDefault();
    event.stopPropagation();
    scope.dispatchEvent(startEvent);
    handleMouseWheel(event);
    scope.dispatchEvent(endEvent);
  }

  function onKeyDown(event) {
    if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;
    handleKeyDown(event);
  }

  function onTouchStart(event) {
    if (scope.enabled === false) return;
    event.preventDefault(); // prevent scrolling

    switch (event.touches.length) {
      case 1:
        switch (scope.touches.ONE) {
          case _threeModule.TOUCH.ROTATE:
            if (scope.enableRotate === false) return;
            handleTouchStartRotate(event);
            state = STATE.TOUCH_ROTATE;
            break;

          case _threeModule.TOUCH.PAN:
            if (scope.enablePan === false) return;
            handleTouchStartPan(event);
            state = STATE.TOUCH_PAN;
            break;

          default:
            state = STATE.NONE;
        }

        break;

      case 2:
        switch (scope.touches.TWO) {
          case _threeModule.TOUCH.DOLLY_PAN:
            if (scope.enableZoom === false && scope.enablePan === false) return;
            handleTouchStartDollyPan(event);
            state = STATE.TOUCH_DOLLY_PAN;
            break;

          case _threeModule.TOUCH.DOLLY_ROTATE:
            if (scope.enableZoom === false && scope.enableRotate === false) return;
            handleTouchStartDollyRotate(event);
            state = STATE.TOUCH_DOLLY_ROTATE;
            break;

          default:
            state = STATE.NONE;
        }

        break;

      default:
        state = STATE.NONE;
    }

    if (state !== STATE.NONE) {
      scope.dispatchEvent(startEvent);
    }
  }

  function onTouchMove(event) {
    if (scope.enabled === false) return;
    event.preventDefault(); // prevent scrolling

    event.stopPropagation();

    switch (state) {
      case STATE.TOUCH_ROTATE:
        if (scope.enableRotate === false) return;
        handleTouchMoveRotate(event);
        scope.update();
        break;

      case STATE.TOUCH_PAN:
        if (scope.enablePan === false) return;
        handleTouchMovePan(event);
        scope.update();
        break;

      case STATE.TOUCH_DOLLY_PAN:
        if (scope.enableZoom === false && scope.enablePan === false) return;
        handleTouchMoveDollyPan(event);
        scope.update();
        break;

      case STATE.TOUCH_DOLLY_ROTATE:
        if (scope.enableZoom === false && scope.enableRotate === false) return;
        handleTouchMoveDollyRotate(event);
        scope.update();
        break;

      default:
        state = STATE.NONE;
    }
  }

  function onTouchEnd(event) {
    if (scope.enabled === false) return;
    handleTouchEnd(event);
    scope.dispatchEvent(endEvent);
    state = STATE.NONE;
  }

  function onContextMenu(event) {
    if (scope.enabled === false) return;
    event.preventDefault();
  } //


  scope.domElement.addEventListener('contextmenu', onContextMenu, false);
  scope.domElement.addEventListener('pointerdown', onPointerDown, false);
  scope.domElement.addEventListener('wheel', onMouseWheel, false);
  scope.domElement.addEventListener('touchstart', onTouchStart, false);
  scope.domElement.addEventListener('touchend', onTouchEnd, false);
  scope.domElement.addEventListener('touchmove', onTouchMove, false);
  scope.domElement.addEventListener('keydown', onKeyDown, false); // make sure element can receive keys.

  if (scope.domElement.tabIndex === -1) {
    scope.domElement.tabIndex = 0;
  } // force an update at start


  this.update();
};

exports.OrbitControls = OrbitControls;
OrbitControls.prototype = Object.create(_threeModule.EventDispatcher.prototype);
OrbitControls.prototype.constructor = OrbitControls; // This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
// This is very similar to OrbitControls, another set of touch behavior
//
//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - left mouse, or arrow keys / touch: one-finger move

var MapControls = function (object, domElement) {
  OrbitControls.call(this, object, domElement);
  this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up

  this.mouseButtons.LEFT = _threeModule.MOUSE.PAN;
  this.mouseButtons.RIGHT = _threeModule.MOUSE.ROTATE;
  this.touches.ONE = _threeModule.TOUCH.PAN;
  this.touches.TWO = _threeModule.TOUCH.DOLLY_ROTATE;
};

exports.MapControls = MapControls;
MapControls.prototype = Object.create(_threeModule.EventDispatcher.prototype);
MapControls.prototype.constructor = MapControls;
},{"../../../build/three.module.js":"node_modules/three/build/three.module.js"}],"threeapp.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initThreeApp = initThreeApp;
exports.scene = void 0;

var THREE = _interopRequireWildcard(require("three"));

var _OrbitControls = require("three/examples/jsm/controls/OrbitControls");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var scene = null;
exports.scene = scene;

function initThreeApp() {
  exports.scene = scene = new THREE.Scene();
  scene.background = new THREE.Color(0x070B0D);
  var camera = new THREE.PerspectiveCamera(90, 1, 0.1, 2000);
  window.camera = camera;
  var renderer = new THREE.WebGLRenderer(); // renderer.setSize( 500, 500 );

  var controls = null;
  window.addEventListener('resize', onWindowResize, false);

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);

    if (controls !== null) {
      controls.update();
    }
  }

  onWindowResize();
  document.body.appendChild(renderer.domElement);
  controls = new _OrbitControls.OrbitControls(camera, renderer.domElement); // controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
  // controls.dampingFactor = 0.05;
  // setting this to `false` will pan on x/y
  // NOT setting this will pan this on x (or y?) AND z (up-down the tree)
  // controls.screenSpacePanning = false;
  // controls.minDistance = 100;

  controls.maxDistance = 1000;
  controls.maxPolarAngle = Math.PI / 2; //controls.update() must be called after any manual changes to the camera's transform

  camera.position.set(83.77917465778985, 139.9592525793484, 232.97176600291303);
  camera.rotation.set(-0.5409754064092211, 0.2990182278004841, 0.17515849639880574);
  controls.update();

  var animate = function animate() {
    requestAnimationFrame(animate); // cube.rotation.x += 0.01;
    // cube.rotation.y += 0.01;

    controls.update();
    renderer.render(scene, camera);
  };

  var coolWhiteColor = 0xD4FFF7;
  var ambientLight = new THREE.AmbientLight(coolWhiteColor, 0.3);
  scene.add(ambientLight);
  var whiteCenterLight = new THREE.PointLight(coolWhiteColor, 1);
  whiteCenterLight.position.set(0, 2, 0);
  scene.add(whiteCenterLight); // can be kinda useful!
  // var sphereSize = 10;
  // var pointLightHelper = new THREE.PointLightHelper( whiteCenterLight, sphereSize );
  // scene.add( pointLightHelper );

  var pinkColor = 0xff4573;
  var pinkOffCenterLight = new THREE.PointLight(pinkColor, 0.4);
  pinkOffCenterLight.position.set(0, 2, -200);
  scene.add(pinkOffCenterLight); // var sphereSize = 10;
  // var pointLightHelper = new THREE.PointLightHelper( pinkOffCenterLight, sphereSize );
  // scene.add( pointLightHelper );

  animate();
}
},{"three":"node_modules/three/build/three.module.js","three/examples/jsm/controls/OrbitControls":"node_modules/three/examples/jsm/controls/OrbitControls.js"}],"tree.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var THREE = _interopRequireWildcard(require("three"));

var _branch = _interopRequireDefault(require("./branch"));

var _threeapp = require("./threeapp");

var _util = require("./util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Tree = /*#__PURE__*/function () {
  function Tree(p5, x_, y_, hope) {
    _classCallCheck(this, Tree);

    this.p5 = p5;
    this.a = p5.color('#22424B');
    this.b = p5.color('#4E7367');
    this.fill = p5.lerpColor(this.a, this.b, p5.random(1.));
    this.trunk = new _branch.default(p5, 0, 0, 1, hope, p5.random(1.1, 1.4), this.fill);
    this.trunk.setRotations(0, 0);
    this.x = x_;
    this.y = y_;
    this.sway = 0;
    this.advance_freq = p5.int(p5.random(30, 70));
    this.lastAdvanceMillis = null;
    this.objectThree = null;
  }

  _createClass(Tree, [{
    key: "update",
    value: function update() {
      this.trunk.update();
    }
  }, {
    key: "render",
    value: function render(full_mode) {
      var p5 = this.p5; // p5.push();
      // p5.fill(this.fill);
      // p5.translate(this.x, this.y);
      // p5.rotateY(-p5.HALF_PI);
      //  renderAxis();

      this.trunk.render(full_mode); // p5.pop();

      if (this.objectThree === null) {
        var geometry = new THREE.BoxGeometry(10, 10, 10);
        var material = new THREE.MeshBasicMaterial({
          color: 0x00ff00
        });
        this.objectThree = new THREE.Object3D();
        this.objectThree.position.set(this.x, 0, this.y);
        this.objectThree.rotation.set(0, 0, Math.PI / 2);

        _threeapp.scene.add(this.objectThree);

        var object = this.trunk.getObjectThree();
        this.objectThree.add(object);
      }
    }
  }, {
    key: "setSway",
    value: function setSway(s) {
      this.sway = s;
    }
  }, {
    key: "advance",
    value: function advance() {
      var now = new Date().getTime();
      var timeSinceLastAdvance = null;

      if (this.lastAdvanceMillis !== null) {
        timeSinceLastAdvance = now - this.lastAdvanceMillis;
      }

      if (timeSinceLastAdvance === null || timeSinceLastAdvance > this.advance_freq * 200) {
        if (this.trunk.advance()) {
          (0, _util.playGrowthSound)();
        }

        this.lastAdvanceMillis = now;
      }
    }
  }, {
    key: "getBranchCount",
    value: function getBranchCount() {
      var count = this.trunk.getBranchCount();
      return count;
    } // renderAxis() {
    //   p5.push();
    //   p5.translate(0, -50, 0);
    //   p5.strokeWeight(3);
    //   p5.stroke(255, 0, 0); // RED X
    //   p5.line(0, 0, 0, 15, 0, 0);
    //   p5.stroke(0, 255, 0); // GREEN Y
    //   p5.line(0, 0, 0, 0, 15, 0);
    //   p5.stroke(0, 0, 255); // BLUE Z
    //   p5.line(0, 0, 0, 0, 0, 15);
    //   p5.pop();
    // }

  }]);

  return Tree;
}();

exports.default = Tree;
},{"three":"node_modules/three/build/three.module.js","./branch":"branch.js","./threeapp":"threeapp.js","./util":"util.js"}],"raindrop.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var THREE = _interopRequireWildcard(require("three"));

var _threeapp = require("./threeapp");

var _util = require("./util");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Drop = /*#__PURE__*/function () {
  function Drop(p5, x_, y_, z_) {
    _classCallCheck(this, Drop);

    this.p5 = p5;
    this.x = x_;
    this.y = y_;
    this.z = z_;
    this.hit = false;
    this.kill = false;
    this.diam = 0;
    this.max_diam = p5.random(20, 40);
    this.vel = p5.random(5, 10);
    this.dir = 0 - p5.radians(90 + 10);
    var material = new THREE.LineBasicMaterial({
      color: new THREE.Color(225, 234, 234)
    });
    var points = [];
    points.push(new THREE.Vector3(0, 0, 0));
    points.push(new THREE.Vector3(0, 20, 0));
    var geometry = new THREE.BufferGeometry().setFromPoints(points);
    var line = new THREE.Line(geometry, material);
    line.position.set(this.x, this.y, this.z);
    this.line = line;

    _threeapp.scene.add(line);

    var geometry = this.getEllipsisGeometry(0);
    var material = new THREE.LineBasicMaterial({
      color: new THREE.Color(225, 234, 234),
      opacity: 0.1
    });
    material.transparent = true; // Create the final object to add to the scene

    var ellipse = new THREE.Line(geometry, material);
    ellipse.rotation.set(Math.PI / 2, 0, 0);
    this.ellipse = ellipse;
    this.ellipse.visible = false;

    _threeapp.scene.add(ellipse);
  }

  _createClass(Drop, [{
    key: "getThreeObject",
    value: function getThreeObject() {
      return this.threeObject;
    }
  }, {
    key: "update",
    value: function update() {
      var p5 = this.p5;

      if (!this.hit) {
        this.x += p5.cos(this.dir) * this.vel;
        this.y += p5.sin(this.dir) * this.vel;

        if (this.y < 0) {
          this.hit = true;
          this.y = 0; // hide the three.js line

          this.line.visible = false; // set position/geometry before showing ellipsis
          // otherwise it will flicker at position 0,0

          this.renderEllipsis();
          this.ellipse.visible = true;
          (0, _util.playRainSound)();
        }
      } else {
        if (this.diam < this.max_diam) {
          this.diam++;
        } else {
          this.kill = true;

          _threeapp.scene.remove(this.line);

          _threeapp.scene.remove(this.ellipse);
        }
      }
    }
  }, {
    key: "getEllipsisGeometry",
    value: function getEllipsisGeometry(diam) {
      var curve = new THREE.EllipseCurve(0, 0, // ax, aY
      diam, diam, // xRadius, yRadius
      0, 2 * Math.PI, // aStartAngle, aEndAngle
      false, // aClockwise
      0 // aRotation
      );
      var points = curve.getPoints(50);
      var geometry = new THREE.BufferGeometry().setFromPoints(points);
      return geometry;
    }
  }, {
    key: "renderEllipsis",
    value: function renderEllipsis() {
      this.ellipse.position.set(this.x, this.y, this.z);
      this.ellipse.geometry = this.getEllipsisGeometry(this.diam);
      this.ellipse.material.opacity = this.p5.map(this.diam, 0, this.max_diam, 1, 0);
    }
  }, {
    key: "render",
    value: function render() {
      // push();
      // stroke(225, 234, 234);
      // noFill();
      // rotateX(-HALF_PI);
      // translate(this.x, this.y, this.z);
      if (!this.hit) {
        this.line.position.set(this.x, this.y, this.z); // rotate(this.dir);
        // line(0, 0, 20, 0);
      } else {
        this.renderEllipsis(); // rotateX(HALF_PI);
        // stroke(225, 234, 234, map(this.diam, 0, this.max_diam, 255, 0));
        // ellipse(0, 0, this.diam, this.diam);
      } // pop();

    }
  }]);

  return Drop;
}();

exports.default = Drop;
},{"three":"node_modules/three/build/three.module.js","./threeapp":"threeapp.js","./util":"util.js"}],"util.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTrees = createTrees;
exports.populateHopes = populateHopes;
exports.handleWind = handleWind;
exports.handleShowers = handleShowers;
exports.playRainSound = playRainSound;
exports.playGrowthSound = playGrowthSound;
exports.playFlowerSound = playFlowerSound;
exports.startSounds = startSounds;

var _globals = require("./globals.js");

var _tree = _interopRequireDefault(require("./tree.js"));

var _raindrop = _interopRequireDefault(require("./raindrop"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createDrop(p5) {
  var w = _globals.GLOBALS.h_area;
  var h = _globals.GLOBALS.w_area;
  var x = p5.random(-w / 2, w / 2) + w / 2;
  var y = 500;
  var z = p5.random(-h / 2, h / 2);
  var aux = new _raindrop.default(p5, x, y, z);

  _globals.GLOBALS.raindrops.push(aux);
}

function createTrees(p5) {
  var w = _globals.GLOBALS.h_area;
  var h = _globals.GLOBALS.w_area;
  var x = 0;
  var y = 0;
  var mindist = _globals.GLOBALS.min_tree_dist;
  var points = [];
  var numpoints = _globals.GLOBALS.tree_amt;

  for (var i = 0; i < numpoints; i++) {
    var aux = getPVector(p5, points, x, y, w, h, mindist);
    points.push(aux);
  }

  for (var _i = 0; _i < points.length; _i++) {
    var _aux = points[_i];

    if (_aux.x != -1000000) {
      var tree = new _tree.default(p5, _aux.x, _aux.y, _globals.GLOBALS.hopes[_i % _globals.GLOBALS.hopes.length]);

      _globals.GLOBALS.trees.push(tree);
    }
  } // console.log("CREATED " + GLOBALS.trees.length + " TREES");

}

function getPVector(p5, points, x, y, w, h, mindist) {
  var atempts = 10000;
  var success = false;
  var ret = p5.createVector(0, 0);

  for (var i = 0; i < atempts; i++) {
    ret = p5.createVector(p5.random(x - w / 2, x + w / 2), p5.random(y - h / 2, y + h / 2));
    var val = p5.sq(ret.x - x) / p5.sq(w / 2) + p5.sq(ret.y - y) / p5.sq(h / 2);

    if (val < 1) {
      var ok = true;

      for (var j = 0; j < points.length; j++) {
        if (p5.dist(ret.x, ret.y, points[j].x, points[j].y) < mindist * 2) {
          ok = false;
          break;
        }
      }

      if (ok) {
        success = true;
        break;
      }
    }
  }

  if (!success) {
    ret = p5.createVector(-1000000, -1000000);
  }

  return ret;
}

function populateHopes() {
  function shuffle(a) {
    var j, x, i;

    for (i = a.length - 1; i > 0; i--) {
      j = Math.floor(Math.random() * (i + 1));
      x = a[i];
      a[i] = a[j];
      a[j] = x;
    }

    return a;
  }

  var hopes = ["espero que podamos irnos a la mierda.", "espero que nunca falte.", "espero que sea para todos.", "espero que salgamos.", "espero que haya sol.", "i wish to accept the future as it will unfold, despite the fright and uncertainty. i hope for some good news. i hope we can all make it out the other side.", "que ganas de morfar con amigos y pasar un buen rato, sin paranoia.", "volver a correr, a saltar, a chocarnos los hombros, las piernas y las cabezas. ", "volver a tocarnos, abrazarnos y si posible a salpicarnos las caras con cerveza de otro vaso.", "dejar de tener expectativas y recuperar la ilusión.", "tengo la esperanza de volver a verte pasar.", "ojalá no perdamos la ternura."];
  shuffle(hopes);
  _globals.GLOBALS.hopes = hopes;
}

function handleWind(p5) {
  _globals.GLOBALS.wind_time_acum += p5.deltaTime; // THIS IS A P5JS thing

  if (_globals.GLOBALS.wind_time_acum > _globals.GLOBALS.wind_interval) {
    _globals.GLOBALS.wind_new = p5.map(p5.float(_globals.GLOBALS.wind_values[_globals.GLOBALS.wind_index]), 0, 8, 0, p5.radians(20));
    _globals.GLOBALS.wind_time_acum -= _globals.GLOBALS.wind_interval;
    _globals.GLOBALS.wind_index++;

    if (_globals.GLOBALS.wind_index >= _globals.GLOBALS.wind_values.length) {
      _globals.GLOBALS.wind_index = 0;
    }
  }

  var f = 0.1; // dampening factor

  _globals.GLOBALS.wind = _globals.GLOBALS.wind_new * f + _globals.GLOBALS.wind * (1.0 - f);
  _globals.GLOBALS.prev_frame_time = p5.millis();

  if (_globals.GLOBALS.sound_enabled) {
    _globals.GLOBALS.wind_sound.volume(p5.map(_globals.GLOBALS.wind, 0, p5.radians(20), 0., 0.3));
  }
}

function handleShowers(p5) {
  if (p5.frameCount % 4 === 0) {
    var n = p5.noise(p5.frameCount * 0.01);

    if (n > _globals.GLOBALS.rain_thresh) {
      var amt = p5.map(n, _globals.GLOBALS.rain_thresh, 1, 1, 5);

      for (var i = 0; i < amt; i++) {
        createDrop(p5);
      }
    }
  }
} // assumes that array is non-empty!


function randomElementFromArray(items) {
  return items[Math.floor(Math.random() * items.length)];
}

function playRainSound() {
  if (_globals.GLOBALS.sound_enabled) {
    randomElementFromArray(_globals.GLOBALS.rain_sounds).play();
  }
}

function playGrowthSound() {
  if (_globals.GLOBALS.sound_enabled) {
    randomElementFromArray(_globals.GLOBALS.growth_sounds).play();
  }
}

function playFlowerSound() {
  if (_globals.GLOBALS.sound_enabled) {
    randomElementFromArray(_globals.GLOBALS.flower_sounds).play();
  }
}

function startSounds() {
  _globals.GLOBALS.wind_sound.play();

  _globals.GLOBALS.rain_sounds.forEach(function (sound) {
    sound.fade(0, 0.25, 10000);
  });

  _globals.GLOBALS.growth_sounds.forEach(function (sound) {
    sound.fade(0, 0.15, 10000);
  });

  _globals.GLOBALS.flower_sounds.forEach(function (sound) {
    sound.fade(0, 0.35, 10000);
  });
}
},{"./globals.js":"globals.js","./tree.js":"tree.js","./raindrop":"raindrop.js"}],"wind_data_small.txt":[function(require,module,exports) {
module.exports = "/wind_data_small.906a8d68.txt";
},{}],"ApercuProLight_FromTTF.json":[function(require,module,exports) {
module.exports = {
  "glyphs": {
    "0": {
      "ha": 825,
      "x_min": 78,
      "x_max": 747,
      "o": "m 413 -11 q 163 123 249 -11 q 78 486 78 257 q 163 849 78 715 q 413 983 249 983 q 662 849 576 983 q 747 486 747 715 q 662 123 747 257 q 413 -11 576 -11 m 413 67 q 544 119 489 67 q 629 267 600 172 q 658 486 658 363 q 629 705 658 610 q 544 853 600 800 q 413 906 489 906 q 281 853 336 906 q 196 705 225 800 q 167 486 167 610 q 196 267 167 363 q 281 119 225 172 q 413 67 336 67 z "
    },
    "1": {
      "ha": 444,
      "x_min": 72,
      "x_max": 319,
      "o": "m 233 835 l 72 733 l 72 829 l 297 972 l 319 972 l 319 0 l 233 0 l 233 835 z "
    },
    "2": {
      "ha": 685,
      "x_min": 44,
      "x_max": 619,
      "o": "m 44 32 l 399 490 q 486 621 465 575 q 507 728 507 667 q 461 858 507 810 q 335 906 415 906 q 209 851 260 906 q 146 710 158 796 l 65 725 q 150 911 76 839 q 335 983 224 983 q 523 915 450 983 q 596 725 596 847 q 566 599 596 660 q 478 463 536 538 l 181 78 l 619 78 l 619 0 l 44 0 l 44 32 z "
    },
    "3": {
      "ha": 739,
      "x_min": 67,
      "x_max": 672,
      "o": "m 365 -11 q 163 63 244 -11 q 67 267 81 136 l 153 279 q 218 124 164 182 q 365 67 272 67 q 527 128 471 67 q 583 297 583 190 q 526 469 583 410 q 365 529 469 529 q 279 504 319 529 l 238 558 l 489 894 l 115 894 l 115 972 l 624 972 l 624 949 l 361 600 q 397 604 374 604 q 533 568 469 604 q 634 462 596 532 q 672 297 672 392 q 635 137 672 207 q 529 28 599 67 q 365 -11 460 -11 z "
    },
    "4": {
      "ha": 750,
      "x_min": 61,
      "x_max": 706,
      "o": "m 490 224 l 61 224 l 61 247 l 471 972 l 576 972 l 576 301 l 706 301 l 706 224 l 576 224 l 576 0 l 490 0 l 490 224 m 490 301 l 490 850 l 183 301 l 490 301 z "
    },
    "5": {
      "ha": 701,
      "x_min": 64,
      "x_max": 649,
      "o": "m 356 -11 q 158 56 235 -11 q 64 256 81 124 l 149 271 q 356 67 176 67 q 507 133 454 67 q 560 317 560 200 q 507 503 560 439 q 363 567 454 567 q 236 531 290 567 q 149 436 182 494 l 88 450 l 138 972 l 592 972 l 592 894 l 215 894 l 182 574 q 371 644 253 644 q 516 605 453 644 q 614 491 579 565 q 649 317 649 417 q 613 147 649 221 q 510 31 576 72 q 356 -11 444 -11 z "
    },
    "6": {
      "ha": 739,
      "x_min": 67,
      "x_max": 672,
      "o": "m 369 -11 q 212 31 281 -11 q 105 144 143 72 q 67 306 67 217 q 129 513 67 406 l 406 983 l 496 983 l 279 599 q 320 616 293 610 q 369 622 347 622 q 527 581 458 622 q 634 467 596 539 q 672 306 672 394 q 634 144 672 217 q 527 31 596 72 q 369 -11 458 -11 m 369 67 q 480 97 431 67 q 556 183 529 128 q 583 306 583 238 q 524 480 583 415 q 369 544 464 544 q 215 480 275 544 q 156 306 156 415 q 183 183 156 238 q 259 97 210 128 q 369 67 308 67 z "
    },
    "7": {
      "ha": 631,
      "x_min": 47,
      "x_max": 586,
      "o": "m 483 894 l 47 894 l 47 972 l 586 972 l 586 944 l 201 0 l 111 0 l 483 894 z "
    },
    "8": {
      "ha": 722,
      "x_min": 69,
      "x_max": 653,
      "o": "m 361 -11 q 215 22 282 -11 q 109 118 149 54 q 69 272 69 182 q 114 430 69 361 q 225 524 158 499 q 138 605 172 551 q 103 731 103 658 q 135 862 103 804 q 226 951 168 919 q 361 983 285 983 q 496 951 438 983 q 587 862 554 919 q 619 731 619 804 q 585 605 619 658 q 497 524 550 551 q 608 430 564 499 q 653 272 653 361 q 613 118 653 182 q 507 22 574 54 q 361 -11 440 -11 m 361 556 q 486 603 439 556 q 533 731 533 651 q 486 858 533 810 q 361 906 439 906 q 236 858 283 906 q 189 731 189 810 q 236 603 189 651 q 361 556 283 556 m 361 67 q 509 122 454 67 q 564 272 564 176 q 508 423 564 368 q 361 478 453 478 q 214 423 269 478 q 158 272 158 368 q 214 122 158 176 q 361 67 269 67 z "
    },
    "9": {
      "ha": 739,
      "x_min": 67,
      "x_max": 672,
      "o": "m 460 374 q 419 356 446 363 q 369 350 392 350 q 212 392 281 350 q 105 506 143 433 q 67 667 67 578 q 105 828 67 756 q 212 942 143 900 q 369 983 281 983 q 527 942 458 983 q 634 828 596 900 q 672 667 672 756 q 621 488 672 579 l 333 -11 l 243 -11 l 460 374 m 369 428 q 524 492 464 428 q 583 667 583 557 q 556 790 583 735 q 480 875 529 844 q 369 906 431 906 q 259 875 308 906 q 183 790 210 844 q 156 667 156 735 q 215 492 156 557 q 369 428 275 428 z "
    },
    "\r": {
      "ha": 350,
      "x_min": 0,
      "x_max": 0,
      "o": ""
    },
    " ": {
      "ha": 350,
      "x_min": 0,
      "x_max": 0,
      "o": ""
    },
    "!": {
      "ha": 403,
      "x_min": 125,
      "x_max": 278,
      "o": "m 143 972 l 260 972 l 229 256 l 174 256 l 143 972 m 201 -3 q 147 19 168 -3 q 125 74 125 40 q 147 128 125 107 q 201 150 168 150 q 256 128 235 150 q 278 74 278 107 q 256 19 278 40 q 201 -3 235 -3 z "
    },
    "\"": {
      "ha": 467,
      "x_min": 69,
      "x_max": 397,
      "o": "m 69 983 l 193 983 l 164 667 l 99 667 l 69 983 m 274 983 l 397 983 l 368 667 l 303 667 l 274 983 z "
    },
    "#": {
      "ha": 893,
      "x_min": 56,
      "x_max": 838,
      "o": "m 219 297 l 56 297 l 56 372 l 235 372 l 281 600 l 111 600 l 111 675 l 297 675 l 357 972 l 435 972 l 375 675 l 596 675 l 657 972 l 735 972 l 674 675 l 838 675 l 838 600 l 658 600 l 613 372 l 782 372 l 782 297 l 596 297 l 536 0 l 458 0 l 518 297 l 297 297 l 236 0 l 158 0 l 219 297 m 535 372 l 581 600 l 358 600 l 313 372 l 535 372 z "
    },
    "$": {
      "ha": 703,
      "x_min": 58,
      "x_max": 633,
      "o": "m 633 268 q 565 76 633 151 q 390 -10 497 0 l 390 -125 l 307 -125 l 307 -7 q 141 83 208 11 q 58 251 74 154 l 138 299 q 363 75 189 75 q 488 124 439 75 q 538 264 538 172 q 511 364 538 324 q 442 431 485 404 q 326 493 400 458 q 169 601 226 540 q 113 757 113 663 q 167 908 113 846 q 307 981 222 969 l 307 1097 l 390 1097 l 390 981 q 507 934 463 972 q 581 833 551 896 l 506 786 q 344 897 456 897 q 242 858 281 897 q 204 764 204 818 q 231 673 204 711 q 299 610 258 635 q 408 554 340 585 q 574 440 515 506 q 633 268 633 374 z "
    },
    "%": {
      "ha": 1172,
      "x_min": 86,
      "x_max": 1086,
      "o": "m 181 13 l 933 1006 l 992 960 l 239 -33 l 181 13 m 304 539 q 192 569 242 539 q 115 649 143 599 q 86 761 86 700 q 115 873 86 822 q 192 953 143 924 q 304 983 242 983 q 416 953 367 983 q 494 873 465 924 q 522 761 522 822 q 494 649 522 700 q 416 569 465 599 q 304 539 367 539 m 304 614 q 408 656 369 614 q 447 761 447 697 q 408 867 447 825 q 304 908 369 908 q 200 867 239 908 q 161 761 161 825 q 200 656 161 697 q 304 614 239 614 m 868 -11 q 756 19 806 -11 q 678 99 707 49 q 650 211 650 150 q 678 323 650 272 q 756 403 707 374 q 868 433 806 433 q 980 403 931 433 q 1058 323 1029 374 q 1086 211 1086 272 q 1058 99 1086 150 q 980 19 1029 49 q 868 -11 931 -11 m 868 64 q 972 106 933 64 q 1011 211 1011 147 q 972 317 1011 275 q 868 358 933 358 q 764 317 803 358 q 725 211 725 275 q 764 106 725 147 q 868 64 803 64 z "
    },
    "&": {
      "ha": 817,
      "x_min": 58,
      "x_max": 800,
      "o": "m 342 -11 q 136 63 214 -11 q 58 269 58 138 q 115 453 58 378 q 251 569 172 529 q 185 674 211 625 q 160 776 160 722 q 189 888 160 842 q 266 959 218 935 q 369 983 314 983 q 524 929 467 983 q 582 789 582 875 q 525 648 582 707 q 376 542 468 589 l 603 251 q 676 429 642 326 l 736 360 q 657 182 697 250 l 800 0 l 700 0 l 610 114 q 342 -11 508 -11 m 326 604 q 455 688 414 647 q 496 782 496 728 q 463 872 496 836 q 369 908 431 908 q 280 874 314 908 q 246 782 246 840 q 326 604 246 708 m 342 69 q 462 97 410 69 q 557 181 514 124 l 301 507 q 185 408 226 467 q 144 267 144 349 q 199 124 144 178 q 342 69 254 69 z "
    },
    "'": {
      "ha": 263,
      "x_min": 69,
      "x_max": 193,
      "o": "m 69 983 l 193 983 l 164 667 l 99 667 l 69 983 z "
    },
    "(": {
      "ha": 346,
      "x_min": 72,
      "x_max": 315,
      "o": "m 224 -69 q 72 486 72 176 q 224 1042 72 796 l 315 1042 q 168 486 168 803 q 315 -69 168 169 l 224 -69 z "
    },
    ")": {
      "ha": 346,
      "x_min": 31,
      "x_max": 274,
      "o": "m 31 -69 q 178 486 178 169 q 31 1042 178 803 l 122 1042 q 274 486 274 796 q 122 -69 274 176 l 31 -69 z "
    },
    "*": {
      "ha": 672,
      "x_min": 79,
      "x_max": 593,
      "o": "m 153 543 l 272 704 l 79 769 l 104 844 l 297 781 l 297 983 l 375 983 l 375 781 l 568 844 l 593 769 l 400 704 l 519 543 l 456 496 l 336 658 l 217 496 l 153 543 z "
    },
    "+": {
      "ha": 764,
      "x_min": 97,
      "x_max": 667,
      "o": "m 343 400 l 97 400 l 97 478 l 343 478 l 343 722 l 421 722 l 421 478 l 667 478 l 667 400 l 421 400 l 421 154 l 343 154 l 343 400 z "
    },
    ",": {
      "ha": 308,
      "x_min": 42,
      "x_max": 239,
      "o": "m 111 122 l 239 122 l 106 -107 l 42 -107 l 111 122 z "
    },
    "-": {
      "ha": 651,
      "x_min": 97,
      "x_max": 554,
      "o": "m 97 479 l 554 479 l 554 401 l 97 401 l 97 479 z "
    },
    ".": {
      "ha": 308,
      "x_min": 83,
      "x_max": 225,
      "o": "m 154 -3 q 103 17 124 -3 q 83 68 83 38 q 103 119 83 99 q 154 139 124 139 q 205 119 185 139 q 225 68 225 99 q 205 17 225 38 q 154 -3 185 -3 z "
    },
    "/": {
      "ha": 719,
      "x_min": 11,
      "x_max": 708,
      "o": "m 617 1042 l 708 1042 l 103 -69 l 11 -69 l 617 1042 z "
    },
    ":": {
      "ha": 308,
      "x_min": 83,
      "x_max": 225,
      "o": "m 154 506 q 103 526 124 506 q 83 576 83 546 q 103 627 83 607 q 154 647 124 647 q 205 627 185 647 q 225 576 225 607 q 205 526 225 546 q 154 506 185 506 m 154 -3 q 103 17 124 -3 q 83 68 83 38 q 103 119 83 99 q 154 139 124 139 q 205 119 185 139 q 225 68 225 99 q 205 17 225 38 q 154 -3 185 -3 z "
    },
    ";": {
      "ha": 308,
      "x_min": 42,
      "x_max": 239,
      "o": "m 168 506 q 117 526 138 506 q 97 576 97 546 q 117 627 97 607 q 168 647 138 647 q 219 627 199 647 q 239 576 239 607 q 219 526 239 546 q 168 506 199 506 m 111 122 l 239 122 l 106 -107 l 42 -107 l 111 122 z "
    },
    "<": {
      "ha": 628,
      "x_min": 78,
      "x_max": 542,
      "o": "m 78 383 l 78 478 l 542 728 l 542 642 l 149 431 l 542 219 l 542 133 l 78 383 z "
    },
    "=": {
      "ha": 732,
      "x_min": 97,
      "x_max": 635,
      "o": "m 97 593 l 635 593 l 635 515 l 97 515 l 97 593 m 97 363 l 635 363 l 635 285 l 97 285 l 97 363 z "
    },
    ">": {
      "ha": 628,
      "x_min": 86,
      "x_max": 550,
      "o": "m 86 219 l 479 431 l 86 642 l 86 728 l 550 478 l 550 383 l 86 133 l 86 219 z "
    },
    "?": {
      "ha": 608,
      "x_min": 69,
      "x_max": 539,
      "o": "m 314 274 q 192 317 242 274 q 142 442 142 360 q 180 551 142 507 q 300 639 218 596 q 398 696 368 675 q 439 735 428 717 q 450 785 450 754 q 415 872 450 840 q 314 903 379 903 q 213 867 251 903 q 157 761 175 832 l 69 776 q 151 928 86 874 q 324 983 217 983 q 478 929 418 983 q 539 789 539 875 q 502 682 539 725 q 368 589 465 639 q 280 535 310 558 q 239 491 250 513 q 228 439 228 469 q 251 378 228 401 q 311 354 275 354 q 379 376 353 354 q 421 446 406 397 l 490 419 q 314 274 450 274 m 317 -3 q 262 19 283 -3 q 240 74 240 40 q 262 128 240 107 q 317 150 283 150 q 372 128 350 150 q 393 74 393 107 q 372 19 393 40 q 317 -3 350 -3 z "
    },
    "@": {
      "ha": 1219,
      "x_min": 83,
      "x_max": 1136,
      "o": "m 624 -131 q 348 -65 471 -131 q 154 126 225 1 q 83 418 83 250 q 160 734 83 603 q 363 931 238 865 q 632 997 488 997 q 894 939 781 997 q 1072 767 1008 881 q 1136 489 1136 653 q 1069 235 1136 319 q 899 150 1001 150 q 801 182 840 150 q 749 258 761 214 q 561 150 678 150 q 388 221 449 150 q 326 410 326 292 q 363 566 326 496 q 466 676 400 636 q 614 717 532 717 q 708 693 667 717 q 769 629 750 669 l 789 707 l 864 707 l 831 339 l 828 307 q 904 228 828 228 q 1010 299 974 228 q 1046 489 1046 369 q 936 806 1046 693 q 625 919 826 919 q 405 860 508 919 q 238 686 301 800 q 174 418 174 572 q 233 165 174 272 q 394 3 292 58 q 624 -53 496 -53 q 793 -32 715 -53 q 965 43 871 -11 l 996 -26 q 808 -108 888 -85 q 624 -131 728 -131 m 571 228 q 668 260 626 228 q 731 347 710 293 q 753 461 753 400 q 714 591 753 543 q 604 639 675 639 q 469 572 519 639 q 418 406 418 506 q 459 274 418 319 q 571 228 500 228 z "
    },
    "A": {
      "ha": 817,
      "x_min": 17,
      "x_max": 800,
      "o": "m 368 972 l 449 972 l 800 0 l 706 0 l 608 276 l 208 276 l 111 0 l 17 0 l 368 972 m 579 363 l 408 847 l 238 363 l 579 363 z "
    },
    "B": {
      "ha": 839,
      "x_min": 125,
      "x_max": 758,
      "o": "m 125 972 l 438 972 q 637 906 565 972 q 708 724 708 840 q 674 602 708 649 q 586 532 640 556 q 712 442 665 504 q 758 281 758 379 q 678 76 758 153 q 460 0 597 0 l 125 0 l 125 972 m 438 561 q 569 602 524 561 q 614 724 614 643 q 569 845 614 804 q 438 886 524 886 l 217 886 l 217 561 l 438 561 m 442 86 q 607 131 551 86 q 663 281 663 176 q 607 430 663 385 q 442 475 551 475 l 217 475 l 217 86 l 442 86 z "
    },
    "C": {
      "ha": 938,
      "x_min": 72,
      "x_max": 868,
      "o": "m 501 -11 q 290 44 388 -11 q 132 213 192 100 q 72 486 72 325 q 132 760 72 647 q 290 928 192 872 q 501 983 388 983 q 735 909 639 983 q 868 706 831 835 l 778 679 q 680 840 750 783 q 501 897 610 897 q 328 849 403 897 q 210 708 253 801 q 168 486 168 615 q 210 264 168 357 q 328 123 253 171 q 501 75 403 75 q 680 132 610 75 q 778 293 750 189 l 868 267 q 735 63 831 138 q 501 -11 639 -11 z "
    },
    "D": {
      "ha": 894,
      "x_min": 125,
      "x_max": 822,
      "o": "m 125 972 l 381 972 q 606 914 506 972 q 765 745 707 856 q 822 486 822 635 q 765 227 822 338 q 606 58 707 117 q 381 0 506 0 l 125 0 l 125 972 m 382 86 q 553 129 475 86 q 679 263 632 172 q 726 486 726 353 q 679 710 726 619 q 553 843 632 800 q 382 886 475 886 l 217 886 l 217 86 l 382 86 z "
    },
    "E": {
      "ha": 765,
      "x_min": 125,
      "x_max": 688,
      "o": "m 125 972 l 674 972 l 674 886 l 217 886 l 217 561 l 590 561 l 590 475 l 217 475 l 217 86 l 688 86 l 688 0 l 125 0 l 125 972 z "
    },
    "F": {
      "ha": 733,
      "x_min": 125,
      "x_max": 683,
      "o": "m 125 972 l 683 972 l 683 886 l 217 886 l 217 550 l 600 550 l 600 464 l 217 464 l 217 0 l 125 0 l 125 972 z "
    },
    "G": {
      "ha": 965,
      "x_min": 72,
      "x_max": 879,
      "o": "m 499 -11 q 288 46 385 -11 q 131 215 190 103 q 72 486 72 326 q 131 758 72 646 q 288 926 190 869 q 499 983 385 983 q 740 908 642 983 q 874 700 838 832 l 783 675 q 677 840 750 782 q 499 897 604 897 q 327 849 401 897 q 210 709 253 801 q 168 486 168 617 q 210 263 168 356 q 327 123 253 171 q 499 75 401 75 q 712 159 638 75 q 788 404 786 243 l 563 404 l 563 490 l 879 490 l 879 0 l 799 0 l 788 150 q 672 32 749 75 q 499 -11 594 -11 z "
    },
    "H": {
      "ha": 928,
      "x_min": 125,
      "x_max": 803,
      "o": "m 125 972 l 217 972 l 217 561 l 711 561 l 711 972 l 803 972 l 803 0 l 711 0 l 711 475 l 217 475 l 217 0 l 125 0 l 125 972 z "
    },
    "I": {
      "ha": 342,
      "x_min": 125,
      "x_max": 217,
      "o": "m 125 972 l 217 972 l 217 0 l 125 0 l 125 972 z "
    },
    "J": {
      "ha": 699,
      "x_min": 42,
      "x_max": 590,
      "o": "m 317 -11 q 126 60 194 -11 q 42 238 57 132 l 136 258 q 193 124 149 172 q 317 75 238 75 q 448 125 397 75 q 499 275 499 175 l 499 972 l 590 972 l 590 285 q 553 124 590 192 q 453 23 515 57 q 317 -11 390 -11 z "
    },
    "K": {
      "ha": 769,
      "x_min": 125,
      "x_max": 747,
      "o": "m 125 972 l 217 972 l 217 557 l 596 972 l 713 972 l 314 536 l 747 0 l 635 0 l 217 515 l 217 0 l 125 0 l 125 972 z "
    },
    "L": {
      "ha": 728,
      "x_min": 125,
      "x_max": 672,
      "o": "m 125 972 l 217 972 l 217 86 l 672 86 l 672 0 l 125 0 l 125 972 z "
    },
    "M": {
      "ha": 1056,
      "x_min": 125,
      "x_max": 931,
      "o": "m 125 972 l 239 972 l 528 240 l 817 972 l 931 972 l 931 0 l 839 0 l 839 794 l 557 89 l 499 89 l 217 794 l 217 0 l 125 0 l 125 972 z "
    },
    "N": {
      "ha": 932,
      "x_min": 125,
      "x_max": 807,
      "o": "m 125 972 l 233 972 l 715 146 l 715 972 l 807 972 l 807 0 l 699 0 l 217 824 l 217 0 l 125 0 l 125 972 z "
    },
    "O": {
      "ha": 997,
      "x_min": 72,
      "x_max": 925,
      "o": "m 499 -11 q 286 50 383 -11 q 131 224 189 111 q 72 486 72 336 q 131 749 72 636 q 286 922 189 861 q 499 983 383 983 q 711 922 614 983 q 867 749 808 861 q 925 486 925 636 q 867 224 925 336 q 711 50 808 111 q 499 -11 614 -11 m 499 75 q 667 122 592 75 q 785 262 742 169 q 829 486 829 354 q 785 710 829 618 q 667 850 742 803 q 499 897 592 897 q 331 850 406 897 q 212 710 256 803 q 168 486 168 618 q 212 262 168 354 q 331 122 256 169 q 499 75 406 75 z "
    },
    "P": {
      "ha": 797,
      "x_min": 125,
      "x_max": 736,
      "o": "m 125 972 l 456 972 q 661 901 586 972 q 736 704 736 829 q 661 508 736 579 q 456 436 586 436 l 217 436 l 217 0 l 125 0 l 125 972 m 457 522 q 596 572 551 522 q 640 704 640 621 q 596 837 640 788 q 457 886 551 886 l 217 886 l 217 522 l 457 522 z "
    },
    "Q": {
      "ha": 997,
      "x_min": 72,
      "x_max": 925,
      "o": "m 499 -11 q 286 50 383 -11 q 131 224 189 111 q 72 486 72 336 q 131 749 72 636 q 286 922 189 861 q 499 983 383 983 q 711 922 614 983 q 867 749 808 861 q 925 486 925 636 q 897 295 925 382 q 815 143 868 208 l 908 51 l 846 -11 l 754 81 q 634 13 700 36 q 499 -11 568 -11 m 499 75 q 693 140 611 75 l 590 244 l 653 307 l 753 206 q 829 486 829 315 q 785 710 829 618 q 667 850 742 803 q 499 897 592 897 q 331 850 406 897 q 212 710 256 803 q 168 486 168 618 q 212 262 168 354 q 331 122 256 169 q 499 75 406 75 z "
    },
    "R": {
      "ha": 853,
      "x_min": 125,
      "x_max": 806,
      "o": "m 125 972 l 438 972 q 642 910 569 972 q 715 726 715 849 q 660 560 715 621 q 503 485 604 499 l 806 0 l 703 0 l 399 481 l 217 481 l 217 0 l 125 0 l 125 972 m 432 567 q 575 606 528 567 q 622 726 622 644 q 575 847 622 808 q 432 886 528 886 l 217 886 l 217 567 l 432 567 z "
    },
    "S": {
      "ha": 703,
      "x_min": 58,
      "x_max": 633,
      "o": "m 363 -11 q 219 24 283 -11 q 113 119 154 60 q 58 251 71 179 l 138 299 q 363 75 189 75 q 488 124 439 75 q 538 264 538 172 q 511 364 538 324 q 442 431 485 404 q 326 493 400 458 q 169 601 226 540 q 113 757 113 663 q 143 874 113 822 q 227 955 174 926 q 344 983 281 983 q 493 944 438 983 q 581 833 549 904 l 506 786 q 344 897 456 897 q 242 858 281 897 q 204 764 204 818 q 231 673 204 711 q 299 610 258 635 q 408 554 340 585 q 574 440 515 506 q 633 268 633 374 q 598 122 633 186 q 501 24 563 58 q 363 -11 439 -11 z "
    },
    "T": {
      "ha": 756,
      "x_min": 42,
      "x_max": 714,
      "o": "m 332 886 l 42 886 l 42 972 l 714 972 l 714 886 l 424 886 l 424 0 l 332 0 l 332 886 z "
    },
    "U": {
      "ha": 883,
      "x_min": 108,
      "x_max": 775,
      "o": "m 442 -11 q 275 26 351 -11 q 153 135 199 63 q 108 311 108 208 l 108 972 l 200 972 l 200 303 q 263 140 200 206 q 442 75 325 75 q 621 140 558 75 q 683 303 683 206 l 683 972 l 775 972 l 775 311 q 730 135 775 208 q 608 26 685 63 q 442 -11 532 -11 z "
    },
    "V": {
      "ha": 811,
      "x_min": 17,
      "x_max": 794,
      "o": "m 17 972 l 111 972 l 406 131 l 700 972 l 794 972 l 454 0 l 357 0 l 17 972 z "
    },
    "W": {
      "ha": 1193,
      "x_min": 17,
      "x_max": 1176,
      "o": "m 17 972 l 113 972 l 332 143 l 556 869 l 638 869 l 861 143 l 1081 972 l 1176 972 l 910 0 l 817 0 l 596 728 l 376 0 l 283 0 l 17 972 z "
    },
    "X": {
      "ha": 772,
      "x_min": 22,
      "x_max": 750,
      "o": "m 336 535 l 82 972 l 183 972 l 386 619 l 589 972 l 690 972 l 436 535 l 750 0 l 649 0 l 386 449 l 124 0 l 22 0 l 336 535 z "
    },
    "Y": {
      "ha": 711,
      "x_min": 17,
      "x_max": 694,
      "o": "m 310 422 l 17 972 l 124 972 l 356 513 l 588 972 l 694 972 l 401 422 l 401 0 l 310 0 l 310 422 z "
    },
    "Z": {
      "ha": 740,
      "x_min": 60,
      "x_max": 681,
      "o": "m 60 44 l 549 886 l 76 886 l 76 972 l 671 972 l 671 928 l 188 86 l 681 86 l 681 0 l 60 0 l 60 44 z "
    },
    "[": {
      "ha": 413,
      "x_min": 125,
      "x_max": 374,
      "o": "m 125 1042 l 374 1042 l 374 964 l 208 964 l 208 8 l 374 8 l 374 -69 l 125 -69 l 125 1042 z "
    },
    "\\": {
      "ha": 719,
      "x_min": 11,
      "x_max": 708,
      "o": "m 11 1042 l 103 1042 l 708 -69 l 617 -69 l 11 1042 z "
    },
    "]": {
      "ha": 413,
      "x_min": 39,
      "x_max": 288,
      "o": "m 39 8 l 204 8 l 204 964 l 39 964 l 39 1042 l 288 1042 l 288 -69 l 39 -69 l 39 8 z "
    },
    "^": {
      "ha": 667,
      "x_min": 44,
      "x_max": 622,
      "o": "m 300 972 l 367 972 l 622 596 l 526 596 l 333 892 l 140 596 l 44 596 l 300 972 z "
    },
    "_": {
      "ha": 660,
      "x_min": 46,
      "x_max": 614,
      "o": "m 46 0 l 614 0 l 614 -78 l 46 -78 l 46 0 z "
    },
    "`": {
      "ha": 290,
      "x_min": 29,
      "x_max": 256,
      "o": "m 29 972 l 158 972 l 256 778 l 186 778 l 29 972 z "
    },
    "a": {
      "ha": 686,
      "x_min": 69,
      "x_max": 594,
      "o": "m 288 -11 q 131 41 192 -11 q 69 201 69 93 q 153 373 69 315 q 388 431 238 431 l 508 431 l 508 461 q 465 590 508 549 q 347 631 422 631 q 238 594 279 631 q 181 500 197 558 l 97 519 q 181 659 111 607 q 347 711 251 711 q 524 645 454 711 q 594 464 594 579 l 594 0 l 529 0 l 508 108 q 422 22 476 54 q 288 -11 367 -11 m 296 69 q 394 95 346 69 q 476 178 443 121 q 508 324 508 235 l 508 350 l 390 350 q 217 311 274 350 q 160 201 160 272 q 196 103 160 138 q 296 69 232 69 z "
    },
    "b": {
      "ha": 794,
      "x_min": 108,
      "x_max": 728,
      "o": "m 415 -11 q 285 19 349 -11 q 194 92 222 50 l 194 0 l 108 0 l 108 983 l 194 983 l 194 601 q 292 682 233 653 q 415 711 350 711 q 585 663 514 711 q 692 533 656 615 q 728 350 728 451 q 692 167 728 249 q 585 37 656 85 q 415 -11 514 -11 m 411 69 q 578 148 519 69 q 638 350 638 226 q 578 551 638 472 q 411 631 518 631 q 245 551 304 631 q 186 350 186 472 q 244 148 186 226 q 411 69 303 69 z "
    },
    "c": {
      "ha": 717,
      "x_min": 67,
      "x_max": 658,
      "o": "m 376 -11 q 208 40 278 -11 q 102 173 138 90 q 67 350 67 256 q 102 527 67 444 q 208 660 138 610 q 376 711 278 711 q 658 518 586 711 l 581 488 q 376 631 525 631 q 213 551 269 631 q 157 350 157 471 q 213 149 157 229 q 376 69 269 69 q 502 106 453 69 q 581 213 551 142 l 658 182 q 551 38 622 88 q 376 -11 479 -11 z "
    },
    "d": {
      "ha": 794,
      "x_min": 67,
      "x_max": 686,
      "o": "m 379 -11 q 210 37 281 -11 q 103 167 139 85 q 67 350 67 249 q 103 533 67 451 q 210 663 139 615 q 379 711 281 711 q 506 683 449 711 q 600 601 563 654 l 600 983 l 686 983 l 686 0 l 600 0 l 600 100 q 506 22 568 54 q 379 -11 444 -11 m 383 69 q 550 148 492 69 q 608 350 608 226 q 549 551 608 472 q 383 631 490 631 q 217 551 276 631 q 157 350 157 472 q 216 148 157 226 q 383 69 275 69 z "
    },
    "e": {
      "ha": 751,
      "x_min": 67,
      "x_max": 685,
      "o": "m 378 -11 q 215 35 286 -11 q 106 164 144 82 q 67 350 67 246 q 106 536 67 454 q 215 665 144 618 q 378 711 286 711 q 537 671 467 711 q 646 558 607 631 q 685 389 685 485 l 685 350 l 157 350 q 216 147 157 225 q 378 69 275 69 q 506 104 457 69 q 593 219 554 139 l 669 182 q 547 33 617 78 q 378 -11 478 -11 m 596 431 q 527 577 583 524 q 378 631 471 631 q 237 575 293 631 q 163 431 181 519 l 596 431 z "
    },
    "f": {
      "ha": 436,
      "x_min": 17,
      "x_max": 428,
      "o": "m 128 619 l 17 619 l 17 700 l 128 700 l 128 744 q 184 924 128 865 q 344 983 240 983 q 428 965 394 983 l 410 886 q 338 903 374 903 q 247 867 279 903 q 214 758 214 831 l 214 700 l 383 700 l 383 619 l 214 619 l 214 0 l 128 0 l 128 619 z "
    },
    "g": {
      "ha": 668,
      "x_min": 56,
      "x_max": 632,
      "o": "m 344 -294 q 133 -233 211 -294 q 56 -64 56 -172 q 76 22 56 -15 q 128 83 96 60 q 72 197 72 117 q 96 272 72 239 q 158 322 119 304 q 119 392 133 353 q 106 476 106 432 q 137 599 106 546 q 222 682 168 653 q 343 711 276 711 q 464 679 407 711 l 589 750 l 629 676 l 532 622 q 581 476 581 560 q 549 353 581 407 q 464 271 518 300 q 343 242 410 242 q 213 275 268 242 q 156 197 156 250 q 180 147 156 163 q 242 131 204 131 l 422 131 q 575 85 518 131 q 632 -53 632 40 q 553 -235 632 -176 q 344 -294 475 -294 m 343 317 q 451 360 407 317 q 494 476 494 403 q 451 593 494 550 q 343 636 407 636 q 235 593 279 636 q 192 476 192 550 q 235 360 192 403 q 343 317 279 317 m 344 -217 q 496 -174 443 -217 q 549 -64 549 -132 q 413 56 549 56 l 269 56 q 201 60 232 56 q 139 -67 139 19 q 191 -176 139 -136 q 344 -217 243 -217 z "
    },
    "h": {
      "ha": 771,
      "x_min": 108,
      "x_max": 663,
      "o": "m 108 983 l 194 983 l 194 547 q 299 669 229 628 q 444 711 368 711 q 605 651 547 711 q 663 481 663 590 l 663 0 l 576 0 l 576 469 q 539 588 576 546 q 431 631 501 631 q 313 590 367 631 q 226 473 258 549 q 194 299 194 397 l 194 0 l 108 0 l 108 983 z "
    },
    "i": {
      "ha": 303,
      "x_min": 81,
      "x_max": 222,
      "o": "m 151 831 q 101 851 121 831 q 81 901 81 871 q 101 952 81 932 q 151 972 121 972 q 202 952 182 972 q 222 901 222 932 q 202 851 222 871 q 151 831 182 831 m 108 700 l 194 700 l 194 0 l 108 0 l 108 700 z "
    },
    "j": {
      "ha": 303,
      "x_min": 1,
      "x_max": 222,
      "o": "m 151 831 q 101 851 121 831 q 81 901 81 871 q 101 952 81 932 q 151 972 121 972 q 202 952 182 972 q 222 901 222 932 q 202 851 222 871 q 151 831 182 831 m 1 -214 q 83 -167 58 -197 q 108 -76 108 -137 l 108 700 l 194 700 l 194 -89 q 21 -294 194 -267 l 1 -214 z "
    },
    "k": {
      "ha": 638,
      "x_min": 108,
      "x_max": 621,
      "o": "m 108 983 l 194 983 l 194 390 l 488 700 l 596 700 l 293 379 l 621 0 l 511 0 l 194 368 l 194 0 l 108 0 l 108 983 z "
    },
    "l": {
      "ha": 303,
      "x_min": 108,
      "x_max": 194,
      "o": "m 108 983 l 194 983 l 194 0 l 108 0 l 108 983 z "
    },
    "m": {
      "ha": 1142,
      "x_min": 108,
      "x_max": 1033,
      "o": "m 108 700 l 194 700 l 194 554 q 285 669 228 626 q 417 711 343 711 q 607 556 575 711 q 705 667 643 624 q 836 711 767 711 q 985 654 938 711 q 1033 481 1033 597 l 1033 0 l 947 0 l 947 469 q 919 591 947 551 q 822 631 892 631 q 717 591 765 631 q 642 478 669 551 q 614 307 614 404 l 614 0 l 528 0 l 528 469 q 500 591 528 551 q 403 631 472 631 q 298 591 346 631 q 222 478 250 551 q 194 307 194 404 l 194 0 l 108 0 l 108 700 z "
    },
    "n": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 108 700 l 194 700 l 194 554 q 295 668 231 625 q 435 711 360 711 q 592 651 535 711 q 650 481 650 590 l 650 0 l 564 0 l 564 469 q 528 589 564 547 q 421 631 493 631 q 306 591 357 631 q 224 478 254 551 q 194 307 194 404 l 194 0 l 108 0 l 108 700 z "
    },
    "o": {
      "ha": 789,
      "x_min": 67,
      "x_max": 722,
      "o": "m 394 -11 q 222 40 296 -11 q 107 174 147 90 q 67 350 67 257 q 107 526 67 443 q 222 660 147 610 q 394 711 296 711 q 567 660 493 711 q 682 526 642 610 q 722 350 722 443 q 682 174 722 257 q 567 40 642 90 q 394 -11 493 -11 m 394 69 q 523 109 469 69 q 604 213 576 149 q 632 350 632 278 q 604 487 632 422 q 523 591 576 551 q 394 631 469 631 q 266 591 319 631 q 185 487 213 551 q 157 350 157 422 q 185 213 157 278 q 266 109 213 149 q 394 69 319 69 z "
    },
    "p": {
      "ha": 794,
      "x_min": 108,
      "x_max": 728,
      "o": "m 108 700 l 194 700 l 194 600 q 285 678 224 646 q 415 711 347 711 q 585 663 514 711 q 692 533 656 615 q 728 350 728 451 q 692 167 728 249 q 585 37 656 85 q 415 -11 514 -11 q 290 18 351 -11 q 194 99 229 47 l 194 -283 l 108 -283 l 108 700 m 411 69 q 578 149 518 69 q 638 350 638 228 q 578 552 638 474 q 411 631 519 631 q 244 552 303 631 q 186 350 186 474 q 245 149 186 228 q 411 69 304 69 z "
    },
    "q": {
      "ha": 794,
      "x_min": 67,
      "x_max": 686,
      "o": "m 600 99 q 506 17 563 46 q 379 -11 449 -11 q 210 37 281 -11 q 103 167 139 85 q 67 350 67 249 q 103 533 67 451 q 210 663 139 615 q 379 711 281 711 q 509 681 446 711 q 600 608 572 650 l 600 700 l 686 700 l 686 -283 l 600 -283 l 600 99 m 383 69 q 549 149 490 69 q 608 350 608 228 q 550 552 608 474 q 383 631 492 631 q 216 552 275 631 q 157 350 157 474 q 217 149 157 228 q 383 69 276 69 z "
    },
    "r": {
      "ha": 528,
      "x_min": 108,
      "x_max": 506,
      "o": "m 108 700 l 194 700 l 194 575 q 278 676 226 640 q 400 711 331 711 q 452 706 428 711 q 506 688 476 700 l 486 606 q 388 631 440 631 q 290 590 333 631 q 220 467 246 549 q 194 271 194 386 l 194 0 l 108 0 l 108 700 z "
    },
    "s": {
      "ha": 597,
      "x_min": 64,
      "x_max": 533,
      "o": "m 317 -11 q 147 44 210 -11 q 64 181 83 100 l 140 221 q 203 109 163 149 q 317 69 244 69 q 410 103 376 69 q 443 193 443 136 q 405 274 443 244 q 289 332 367 304 q 158 406 203 363 q 113 528 113 450 q 168 661 113 611 q 308 711 224 711 q 422 685 375 711 q 503 603 469 658 l 442 550 q 381 612 414 593 q 304 631 347 631 q 231 603 260 631 q 201 531 201 576 q 238 456 201 485 q 363 396 274 428 q 485 319 438 368 q 533 194 533 269 q 475 44 533 99 q 317 -11 417 -11 z "
    },
    "t": {
      "ha": 476,
      "x_min": 17,
      "x_max": 438,
      "o": "m 315 -11 q 188 41 235 -11 q 140 199 140 93 l 140 619 l 17 619 l 17 700 l 140 700 l 140 926 l 226 983 l 226 700 l 415 700 l 415 619 l 226 619 l 226 185 q 253 99 226 128 q 326 69 281 69 q 414 92 379 69 l 438 14 q 315 -11 392 -11 z "
    },
    "u": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 324 -11 q 166 49 224 -11 q 108 219 108 110 l 108 700 l 194 700 l 194 231 q 230 111 194 153 q 338 69 265 69 q 453 109 401 69 q 534 222 504 149 q 564 393 564 296 l 564 700 l 650 700 l 650 0 l 564 0 l 564 146 q 463 32 528 75 q 324 -11 399 -11 z "
    },
    "v": {
      "ha": 611,
      "x_min": 22,
      "x_max": 589,
      "o": "m 22 700 l 113 700 l 306 115 l 499 700 l 589 700 l 353 0 l 258 0 l 22 700 z "
    },
    "w": {
      "ha": 928,
      "x_min": 19,
      "x_max": 908,
      "o": "m 19 700 l 110 700 l 274 122 l 421 700 l 507 700 l 654 122 l 818 700 l 908 700 l 699 0 l 610 0 l 464 572 l 318 0 l 229 0 l 19 700 z "
    },
    "x": {
      "ha": 594,
      "x_min": 14,
      "x_max": 581,
      "o": "m 250 382 l 53 700 l 149 700 l 297 458 l 446 700 l 542 700 l 344 382 l 581 0 l 490 0 l 297 306 l 104 0 l 14 0 l 250 382 z "
    },
    "y": {
      "ha": 611,
      "x_min": 14,
      "x_max": 597,
      "o": "m 265 4 l 14 700 l 104 700 l 313 133 l 507 700 l 597 700 l 250 -283 l 164 -283 l 265 4 z "
    },
    "z": {
      "ha": 594,
      "x_min": 50,
      "x_max": 536,
      "o": "m 50 42 l 407 619 l 67 619 l 67 700 l 521 700 l 521 653 l 168 81 l 536 81 l 536 0 l 50 0 l 50 42 z "
    },
    "{": {
      "ha": 388,
      "x_min": 44,
      "x_max": 349,
      "o": "m 285 -69 q 190 -31 226 -69 q 154 75 154 8 l 154 329 q 129 419 154 392 q 44 447 104 447 l 44 525 q 129 553 104 525 q 154 643 154 581 l 154 897 q 190 1003 154 964 q 285 1042 226 1042 l 349 1042 l 349 964 l 307 964 q 254 947 271 964 q 238 894 238 931 l 238 621 q 216 532 238 561 q 150 486 194 503 q 216 440 194 469 q 238 351 238 411 l 238 78 q 254 25 238 42 q 307 8 271 8 l 349 8 l 349 -69 l 285 -69 z "
    },
    "|": {
      "ha": 333,
      "x_min": 125,
      "x_max": 208,
      "o": "m 125 1042 l 208 1042 l 208 -69 l 125 -69 l 125 1042 z "
    },
    "}": {
      "ha": 388,
      "x_min": 39,
      "x_max": 343,
      "o": "m 39 8 l 81 8 q 133 25 117 8 q 150 78 150 42 l 150 351 q 172 440 150 411 q 238 486 193 469 q 172 532 193 503 q 150 621 150 561 l 150 894 q 133 947 150 931 q 81 964 117 964 l 39 964 l 39 1042 l 103 1042 q 197 1003 161 1042 q 233 897 233 964 l 233 643 q 258 553 233 581 q 343 525 283 525 l 343 447 q 258 419 283 447 q 233 329 233 392 l 233 75 q 197 -31 233 8 q 103 -69 161 -69 l 39 -69 l 39 8 z "
    },
    "~": {
      "ha": 739,
      "x_min": 69,
      "x_max": 669,
      "o": "m 500 378 q 437 387 464 378 q 372 415 410 396 q 311 444 338 435 q 250 453 285 453 q 182 436 214 453 q 125 390 150 419 l 69 444 q 148 522 104 492 q 239 553 192 553 q 302 544 275 553 q 367 515 329 535 q 428 487 401 496 q 489 478 454 478 q 557 494 525 478 q 614 540 589 511 l 669 486 q 591 408 635 439 q 500 378 547 378 z "
    },
    " ": {
      "ha": 350,
      "x_min": 0,
      "x_max": 0,
      "o": ""
    },
    "¡": {
      "ha": 403,
      "x_min": 125,
      "x_max": 278,
      "o": "m 201 539 q 147 560 168 539 q 125 615 125 582 q 147 670 125 649 q 201 692 168 692 q 256 670 235 692 q 278 615 278 649 q 256 560 278 582 q 201 539 235 539 m 174 433 l 229 433 l 260 -283 l 143 -283 l 174 433 z "
    },
    "¢": {
      "ha": 717,
      "x_min": 67,
      "x_max": 658,
      "o": "m 338 126 q 190 188 251 136 q 97 319 128 240 q 67 486 67 397 q 97 652 67 574 q 190 783 128 731 q 338 846 251 836 l 338 1042 l 421 1042 l 421 846 q 566 788 506 836 q 658 654 626 739 l 581 624 q 502 731 551 694 q 376 767 453 767 q 213 687 269 767 q 157 486 157 607 q 213 285 157 365 q 376 206 269 206 q 502 242 453 206 q 581 349 551 278 l 658 318 q 421 126 593 147 l 421 -69 l 338 -69 l 338 126 z "
    },
    "£": {
      "ha": 721,
      "x_min": 54,
      "x_max": 689,
      "o": "m 54 65 q 170 213 133 142 q 207 360 207 283 q 189 465 207 411 l 72 465 l 72 546 l 160 546 q 134 626 143 590 q 125 704 125 663 q 195 909 125 835 q 381 983 265 983 q 538 931 472 983 q 638 788 603 879 l 561 753 q 485 866 526 829 q 381 903 444 903 q 260 851 306 903 q 214 703 214 799 q 222 627 214 661 q 246 546 231 593 l 474 546 l 474 465 l 271 465 q 285 357 285 410 q 252 215 285 290 q 174 100 219 140 q 232 123 200 115 q 292 131 264 131 q 349 121 325 131 q 408 92 374 111 q 450 71 435 78 q 483 64 465 64 q 557 88 529 64 q 624 181 585 111 l 689 143 q 599 24 644 58 q 486 -11 553 -11 q 424 -2 449 -11 q 365 24 399 7 q 319 46 339 39 q 272 53 299 53 q 194 38 226 53 q 122 -11 163 22 l 54 65 z "
    },
    "¤": {
      "ha": 758,
      "x_min": 40,
      "x_max": 718,
      "o": "m 40 164 l 161 257 q 108 426 108 332 q 161 596 108 521 l 40 689 l 117 765 l 208 647 q 379 707 282 707 q 550 647 476 707 l 642 765 l 718 689 l 597 596 q 650 426 650 521 q 597 257 650 332 l 718 164 l 642 88 l 550 206 q 379 146 476 146 q 208 206 282 146 l 117 88 l 40 164 m 379 221 q 519 278 467 221 q 572 426 572 335 q 519 575 572 518 q 379 632 467 632 q 239 575 292 632 q 186 426 186 518 q 239 278 186 335 q 379 221 292 221 z "
    },
    "¥": {
      "ha": 692,
      "x_min": 17,
      "x_max": 675,
      "o": "m 300 224 l 76 224 l 76 301 l 300 301 l 300 422 l 76 422 l 76 500 l 260 500 l 17 972 l 124 972 l 346 515 l 568 972 l 675 972 l 432 500 l 615 500 l 615 422 l 392 422 l 392 301 l 615 301 l 615 224 l 392 224 l 392 0 l 300 0 l 300 224 z "
    },
    "¦": {
      "ha": 333,
      "x_min": 125,
      "x_max": 208,
      "o": "m 125 1042 l 208 1042 l 208 557 l 125 557 l 125 1042 m 125 415 l 208 415 l 208 -69 l 125 -69 l 125 415 z "
    },
    "§": {
      "ha": 686,
      "x_min": 58,
      "x_max": 617,
      "o": "m 338 -294 q 174 -242 238 -294 q 86 -92 110 -190 l 164 -65 q 227 -174 183 -133 q 338 -214 271 -214 q 442 -170 401 -214 q 483 -46 483 -126 q 460 28 483 -3 q 401 81 438 58 q 296 139 364 104 q 199 190 244 164 q 92 277 125 232 q 58 394 58 322 q 171 574 58 503 q 120 644 138 607 q 103 732 103 681 q 135 868 103 811 q 222 954 168 925 q 338 983 275 983 q 501 931 438 983 q 589 781 565 879 l 511 754 q 448 863 492 822 q 338 903 404 903 q 233 859 274 903 q 192 735 192 815 q 215 661 192 692 q 274 608 238 631 q 379 550 311 585 q 476 499 431 525 q 583 412 550 457 q 617 294 617 367 q 504 115 617 186 q 555 45 538 82 q 572 -43 572 8 q 540 -179 572 -122 q 453 -265 507 -236 q 338 -294 400 -294 m 435 168 q 508 223 482 190 q 533 296 533 256 q 503 369 533 336 q 427 428 474 401 q 296 494 381 456 l 240 521 q 167 466 193 499 q 142 393 142 433 q 172 320 142 353 q 248 260 201 288 q 379 194 294 233 l 435 168 z "
    },
    "¨": {
      "ha": 406,
      "x_min": 28,
      "x_max": 378,
      "o": "m 96 819 q 47 839 67 819 q 28 886 28 858 q 47 935 28 915 q 96 956 67 956 q 144 935 125 956 q 164 886 164 915 q 144 839 164 858 q 96 819 125 819 m 308 819 q 261 839 281 819 q 242 886 242 858 q 261 935 242 915 q 308 956 281 956 q 358 935 338 956 q 378 886 378 915 q 358 839 378 858 q 308 819 338 819 z "
    },
    "©": {
      "ha": 1211,
      "x_min": 83,
      "x_max": 1128,
      "o": "m 606 -56 q 338 15 457 -56 q 151 210 218 86 q 83 486 83 333 q 151 763 83 639 q 338 957 218 886 q 606 1028 457 1028 q 874 957 754 1028 q 1060 763 993 886 q 1128 486 1128 639 q 1060 210 1128 333 q 874 15 993 86 q 606 -56 754 -56 m 606 31 q 833 90 733 31 q 987 254 932 150 q 1042 486 1042 358 q 987 718 1042 614 q 833 882 932 822 q 606 942 733 942 q 378 882 478 942 q 224 718 279 822 q 169 486 169 614 q 224 254 169 358 q 378 90 279 150 q 606 31 478 31 m 606 186 q 480 218 542 186 q 376 317 418 250 q 335 486 335 385 q 376 655 335 588 q 480 754 418 722 q 606 786 542 786 q 753 738 692 786 q 838 603 815 690 l 764 583 q 706 679 743 647 q 606 711 668 711 q 469 653 522 711 q 417 486 417 596 q 469 319 417 376 q 606 261 522 261 q 706 293 668 261 q 764 389 743 325 l 838 369 q 753 234 815 282 q 606 186 692 186 z "
    },
    "ª": {
      "ha": 597,
      "x_min": 92,
      "x_max": 504,
      "o": "m 263 411 q 140 454 189 411 q 92 578 92 497 q 158 713 92 667 q 344 758 225 758 l 436 758 l 436 782 q 310 911 436 911 q 181 811 211 911 l 114 828 q 181 938 128 899 q 310 978 235 978 q 451 931 399 978 q 504 783 504 885 l 504 417 l 453 417 l 439 504 q 369 437 414 463 q 263 411 325 411 m 269 478 q 385 525 333 478 q 436 674 436 572 l 436 694 l 347 694 q 213 663 257 694 q 169 578 169 632 q 197 503 169 528 q 269 478 224 478 z "
    },
    "«": {
      "ha": 839,
      "x_min": 69,
      "x_max": 756,
      "o": "m 69 401 l 69 460 l 435 731 l 435 636 l 160 431 l 435 225 l 435 131 l 69 401 m 390 401 l 390 460 l 756 731 l 756 636 l 481 431 l 756 225 l 756 131 l 390 401 z "
    },
    "¬": {
      "ha": 782,
      "x_min": 97,
      "x_max": 685,
      "o": "m 596 447 l 97 447 l 97 528 l 685 528 l 685 197 l 596 197 l 596 447 z "
    },
    "­": {
      "ha": 651,
      "x_min": 97,
      "x_max": 554,
      "o": "m 97 479 l 554 479 l 554 401 l 97 401 l 97 479 z "
    },
    "®": {
      "ha": 1211,
      "x_min": 83,
      "x_max": 1128,
      "o": "m 606 -56 q 338 15 457 -56 q 151 210 218 86 q 83 486 83 333 q 151 763 83 639 q 338 957 218 886 q 606 1028 457 1028 q 874 957 754 1028 q 1060 763 993 886 q 1128 486 1128 639 q 1060 210 1128 333 q 874 15 993 86 q 606 -56 754 -56 m 606 31 q 833 90 733 31 q 987 254 932 150 q 1042 486 1042 358 q 987 718 1042 614 q 833 882 932 822 q 606 942 733 942 q 378 882 478 942 q 224 718 279 822 q 169 486 169 614 q 224 254 169 358 q 378 90 279 150 q 606 31 478 31 m 417 782 l 617 782 q 751 735 701 782 q 801 613 801 689 q 764 505 801 550 q 668 449 726 460 l 844 190 l 758 190 l 583 443 l 499 443 l 499 190 l 417 190 l 417 782 m 617 518 q 693 543 667 518 q 719 613 719 568 q 693 683 719 658 q 617 707 667 707 l 499 707 l 499 518 l 617 518 z "
    },
    "¯": {
      "ha": 376,
      "x_min": 21,
      "x_max": 356,
      "o": "m 21 917 l 356 917 l 356 839 l 21 839 l 21 917 z "
    },
    "°": {
      "ha": 469,
      "x_min": 83,
      "x_max": 386,
      "o": "m 235 669 q 126 713 168 669 q 83 824 83 757 q 126 934 83 890 q 235 978 168 978 q 344 934 301 978 q 386 824 386 890 q 344 713 386 757 q 235 669 301 669 m 235 736 q 296 760 272 736 q 319 824 319 785 q 296 887 319 863 q 235 911 272 911 q 174 887 197 911 q 150 824 150 863 q 174 760 150 785 q 235 736 197 736 z "
    },
    "±": {
      "ha": 764,
      "x_min": 97,
      "x_max": 667,
      "o": "m 343 514 l 97 514 l 97 592 l 343 592 l 343 836 l 421 836 l 421 592 l 667 592 l 667 514 l 421 514 l 421 268 l 343 268 l 343 514 m 97 76 l 667 76 l 667 -1 l 97 -1 l 97 76 z "
    },
    "²": {
      "ha": 443,
      "x_min": 47,
      "x_max": 396,
      "o": "m 47 443 l 251 697 q 294 763 282 736 q 307 822 307 790 q 285 885 307 863 q 221 908 263 908 q 160 879 183 908 q 132 803 138 850 l 57 822 q 108 934 64 890 q 221 978 153 978 q 339 935 296 978 q 382 822 382 892 q 328 676 382 746 l 174 486 l 396 486 l 396 417 l 47 417 l 47 443 z "
    },
    "³": {
      "ha": 447,
      "x_min": 50,
      "x_max": 404,
      "o": "m 229 411 q 106 454 156 411 q 50 574 57 497 l 125 585 q 157 507 131 536 q 229 478 183 478 q 304 510 279 478 q 329 594 329 543 q 304 676 329 646 q 229 707 279 707 q 181 693 203 707 l 144 742 l 268 906 l 81 906 l 81 972 l 376 972 l 376 949 l 238 761 q 263 763 246 763 q 364 718 324 763 q 404 594 404 674 q 359 464 404 517 q 229 411 314 411 z "
    },
    "´": {
      "ha": 290,
      "x_min": 35,
      "x_max": 261,
      "o": "m 132 972 l 261 972 l 104 778 l 35 778 l 132 972 z "
    },
    "µ": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 108 700 l 194 700 l 194 231 q 230 111 194 153 q 338 69 265 69 q 453 109 401 69 q 534 222 504 149 q 564 393 564 296 l 564 700 l 650 700 l 650 0 l 564 0 l 564 146 q 463 32 528 75 q 324 -11 399 -11 q 194 25 247 -11 l 194 -283 l 108 -283 l 108 700 z "
    },
    "¶": {
      "ha": 904,
      "x_min": 85,
      "x_max": 810,
      "o": "m 325 492 q 204 524 260 492 q 117 611 149 556 q 85 732 85 667 q 117 853 85 797 q 204 940 149 908 q 325 972 260 972 l 810 972 l 810 886 l 729 886 l 729 -283 l 638 -283 l 638 886 l 417 886 l 417 -283 l 325 -283 l 325 492 z "
    },
    "·": {
      "ha": 392,
      "x_min": 125,
      "x_max": 267,
      "o": "m 196 415 q 145 435 165 415 q 125 486 125 456 q 145 537 125 517 q 196 557 165 557 q 247 537 226 557 q 267 486 267 517 q 247 435 267 456 q 196 415 226 415 z "
    },
    "¸": {
      "ha": 243,
      "x_min": 15,
      "x_max": 228,
      "o": "m 15 -254 l 151 -83 l 228 -83 l 115 -297 l 15 -254 z "
    },
    "¹": {
      "ha": 307,
      "x_min": 39,
      "x_max": 226,
      "o": "m 157 869 l 39 813 l 39 890 l 204 972 l 226 972 l 226 417 l 157 417 l 157 869 z "
    },
    "º": {
      "ha": 711,
      "x_min": 99,
      "x_max": 613,
      "o": "m 356 411 q 220 451 279 411 q 130 557 161 492 q 99 694 99 622 q 130 832 99 767 q 220 938 161 897 q 356 978 279 978 q 491 938 432 978 q 581 832 550 897 q 613 694 613 767 q 581 557 613 622 q 491 451 550 492 q 356 411 432 411 m 356 478 q 490 542 442 478 q 538 694 538 606 q 490 847 538 783 q 356 911 442 911 q 222 847 269 911 q 174 694 174 783 q 222 542 174 606 q 356 478 269 478 z "
    },
    "»": {
      "ha": 839,
      "x_min": 83,
      "x_max": 769,
      "o": "m 83 225 l 358 431 l 83 636 l 83 731 l 449 460 l 449 401 l 83 131 l 83 225 m 404 225 l 679 431 l 404 636 l 404 731 l 769 460 l 769 401 l 404 131 l 404 225 z "
    },
    "¼": {
      "ha": 1001,
      "x_min": 39,
      "x_max": 964,
      "o": "m 157 869 l 39 813 l 39 890 l 204 972 l 226 972 l 226 417 l 157 417 l 157 869 m 117 13 l 869 1006 l 928 960 l 175 -33 l 117 13 m 822 115 l 585 115 l 585 139 l 810 556 l 892 556 l 892 182 l 964 182 l 964 115 l 892 115 l 892 0 l 822 0 l 822 115 m 822 182 l 822 453 l 681 182 l 822 182 z "
    },
    "½": {
      "ha": 1099,
      "x_min": 39,
      "x_max": 1051,
      "o": "m 157 869 l 39 813 l 39 890 l 204 972 l 226 972 l 226 417 l 157 417 l 157 869 m 117 13 l 869 1006 l 928 960 l 175 -33 l 117 13 m 703 26 l 907 281 q 950 347 938 319 q 963 406 963 374 q 940 469 963 446 q 876 492 918 492 q 816 463 839 492 q 788 386 793 433 l 713 406 q 764 517 719 474 q 876 561 808 561 q 994 518 951 561 q 1038 406 1038 475 q 983 260 1038 329 l 829 69 l 1051 69 l 1051 0 l 703 0 l 703 26 z "
    },
    "¾": {
      "ha": 1074,
      "x_min": 50,
      "x_max": 1036,
      "o": "m 229 411 q 106 454 156 411 q 50 574 57 497 l 125 585 q 157 507 131 536 q 229 478 183 478 q 304 510 279 478 q 329 594 329 543 q 304 676 329 646 q 229 707 279 707 q 181 693 203 707 l 144 742 l 268 906 l 81 906 l 81 972 l 376 972 l 376 949 l 238 761 q 263 763 246 763 q 364 718 324 763 q 404 594 404 674 q 359 464 404 517 q 229 411 314 411 m 189 13 l 942 1006 l 1000 960 l 247 -33 l 189 13 m 894 115 l 657 115 l 657 139 l 882 556 l 964 556 l 964 182 l 1036 182 l 1036 115 l 964 115 l 964 0 l 894 0 l 894 115 m 894 182 l 894 453 l 753 182 l 894 182 z "
    },
    "¿": {
      "ha": 608,
      "x_min": 69,
      "x_max": 539,
      "o": "m 294 415 q 417 372 367 415 q 467 247 467 329 q 428 138 467 182 q 308 50 390 93 q 210 -7 240 14 q 169 -47 181 -28 q 158 -96 158 -65 q 194 -183 158 -151 q 294 -214 229 -214 q 395 -178 357 -214 q 451 -72 433 -143 l 539 -87 q 457 -240 522 -185 q 285 -294 392 -294 q 130 -240 190 -294 q 69 -100 69 -186 q 106 7 69 -36 q 240 100 143 50 q 328 153 299 131 q 369 198 358 176 q 381 250 381 219 q 357 311 381 288 q 297 335 333 335 q 229 313 256 335 q 188 243 203 292 l 118 269 q 294 415 158 415 m 292 692 q 347 670 325 692 q 368 615 368 649 q 347 560 368 582 q 292 539 325 539 q 237 560 258 539 q 215 615 215 582 q 237 670 215 649 q 292 692 258 692 z "
    },
    "À": {
      "ha": 817,
      "x_min": 17,
      "x_max": 800,
      "o": "m 368 972 l 449 972 l 800 0 l 706 0 l 608 276 l 208 276 l 111 0 l 17 0 l 368 972 m 579 363 l 408 847 l 238 363 l 579 363 m 217 1244 l 346 1244 l 443 1050 l 374 1050 l 217 1244 z "
    },
    "Á": {
      "ha": 817,
      "x_min": 17,
      "x_max": 800,
      "o": "m 368 972 l 449 972 l 800 0 l 706 0 l 608 276 l 208 276 l 111 0 l 17 0 l 368 972 m 579 363 l 408 847 l 238 363 l 579 363 m 471 1244 l 600 1244 l 443 1050 l 374 1050 l 471 1244 z "
    },
    "Â": {
      "ha": 817,
      "x_min": 17,
      "x_max": 800,
      "o": "m 368 972 l 449 972 l 800 0 l 706 0 l 608 276 l 208 276 l 111 0 l 17 0 l 368 972 m 579 363 l 408 847 l 238 363 l 579 363 m 393 1244 l 424 1244 l 610 1050 l 510 1050 l 408 1158 l 307 1050 l 207 1050 l 393 1244 z "
    },
    "Ã": {
      "ha": 817,
      "x_min": 17,
      "x_max": 800,
      "o": "m 368 972 l 449 972 l 800 0 l 706 0 l 608 276 l 208 276 l 111 0 l 17 0 l 368 972 m 579 363 l 408 847 l 238 363 l 579 363 m 174 1131 q 235 1200 199 1174 q 311 1226 271 1226 q 368 1218 344 1226 q 418 1194 392 1210 q 458 1175 443 1181 q 493 1169 474 1169 q 579 1226 538 1169 l 642 1176 q 581 1107 617 1133 q 504 1081 544 1081 q 447 1089 471 1081 q 397 1113 424 1097 q 357 1132 372 1126 q 322 1138 342 1138 q 236 1081 278 1138 l 174 1131 z "
    },
    "Ä": {
      "ha": 817,
      "x_min": 17,
      "x_max": 800,
      "o": "m 368 972 l 449 972 l 800 0 l 706 0 l 608 276 l 208 276 l 111 0 l 17 0 l 368 972 m 579 363 l 408 847 l 238 363 l 579 363 m 300 1092 q 251 1111 271 1092 q 232 1158 232 1131 q 251 1208 232 1188 q 300 1228 271 1228 q 349 1208 329 1228 q 368 1158 368 1188 q 349 1111 368 1131 q 300 1092 329 1092 m 513 1092 q 465 1111 485 1092 q 446 1158 446 1131 q 465 1208 446 1188 q 513 1228 485 1228 q 562 1208 542 1228 q 582 1158 582 1188 q 562 1111 582 1131 q 513 1092 542 1092 z "
    },
    "Å": {
      "ha": 817,
      "x_min": 17,
      "x_max": 800,
      "o": "m 368 972 l 449 972 l 800 0 l 706 0 l 608 276 l 208 276 l 111 0 l 17 0 l 368 972 m 579 363 l 408 847 l 238 363 l 579 363 m 408 1049 q 313 1086 351 1049 q 274 1179 274 1124 q 313 1276 274 1236 q 408 1315 351 1315 q 505 1276 467 1315 q 543 1179 543 1238 q 505 1086 543 1124 q 408 1049 467 1049 m 408 1108 q 460 1128 440 1108 q 479 1181 479 1149 q 460 1235 479 1214 q 408 1256 440 1256 q 358 1234 378 1256 q 338 1181 338 1213 q 358 1128 338 1149 q 408 1108 378 1108 z "
    },
    "Æ": {
      "ha": 1139,
      "x_min": 17,
      "x_max": 1061,
      "o": "m 443 972 l 1047 972 l 1047 886 l 590 886 l 590 561 l 964 561 l 964 475 l 590 475 l 590 86 l 1061 86 l 1061 0 l 499 0 l 499 276 l 233 276 l 113 0 l 17 0 l 443 972 m 499 363 l 499 847 l 483 847 l 271 363 l 499 363 z "
    },
    "Ç": {
      "ha": 938,
      "x_min": 72,
      "x_max": 868,
      "o": "m 501 -11 q 290 44 388 -11 q 132 213 192 100 q 72 486 72 325 q 132 760 72 647 q 290 928 192 872 q 501 983 388 983 q 735 909 639 983 q 868 706 831 835 l 778 679 q 680 840 750 783 q 501 897 610 897 q 328 849 403 897 q 210 708 253 801 q 168 486 168 615 q 210 264 168 357 q 328 123 253 171 q 501 75 403 75 q 680 132 610 75 q 778 293 750 189 l 868 267 q 735 63 831 138 q 501 -11 639 -11 m 339 -254 l 475 -83 l 551 -83 l 439 -297 l 339 -254 z "
    },
    "È": {
      "ha": 765,
      "x_min": 125,
      "x_max": 688,
      "o": "m 125 972 l 674 972 l 674 886 l 217 886 l 217 561 l 590 561 l 590 475 l 217 475 l 217 86 l 688 86 l 688 0 l 125 0 l 125 972 m 219 1244 l 349 1244 l 446 1050 l 376 1050 l 219 1244 z "
    },
    "É": {
      "ha": 765,
      "x_min": 125,
      "x_max": 688,
      "o": "m 125 972 l 674 972 l 674 886 l 217 886 l 217 561 l 590 561 l 590 475 l 217 475 l 217 86 l 688 86 l 688 0 l 125 0 l 125 972 m 474 1244 l 603 1244 l 446 1050 l 376 1050 l 474 1244 z "
    },
    "Ê": {
      "ha": 765,
      "x_min": 125,
      "x_max": 688,
      "o": "m 125 972 l 674 972 l 674 886 l 217 886 l 217 561 l 590 561 l 590 475 l 217 475 l 217 86 l 688 86 l 688 0 l 125 0 l 125 972 m 396 1244 l 426 1244 l 613 1050 l 513 1050 l 411 1158 l 310 1050 l 210 1050 l 396 1244 z "
    },
    "Ë": {
      "ha": 765,
      "x_min": 125,
      "x_max": 688,
      "o": "m 125 972 l 674 972 l 674 886 l 217 886 l 217 561 l 590 561 l 590 475 l 217 475 l 217 86 l 688 86 l 688 0 l 125 0 l 125 972 m 303 1092 q 254 1111 274 1092 q 235 1158 235 1131 q 254 1208 235 1188 q 303 1228 274 1228 q 351 1208 332 1228 q 371 1158 371 1188 q 351 1111 371 1131 q 303 1092 332 1092 m 515 1092 q 468 1111 488 1092 q 449 1158 449 1131 q 468 1208 449 1188 q 515 1228 488 1228 q 565 1208 544 1228 q 585 1158 585 1188 q 565 1111 585 1131 q 515 1092 544 1092 z "
    },
    "Ì": {
      "ha": 342,
      "x_min": -21,
      "x_max": 217,
      "o": "m 125 972 l 217 972 l 217 0 l 125 0 l 125 972 m -21 1244 l 108 1244 l 206 1050 l 136 1050 l -21 1244 z "
    },
    "Í": {
      "ha": 342,
      "x_min": 125,
      "x_max": 363,
      "o": "m 125 972 l 217 972 l 217 0 l 125 0 l 125 972 m 233 1244 l 363 1244 l 206 1050 l 136 1050 l 233 1244 z "
    },
    "Î": {
      "ha": 342,
      "x_min": -31,
      "x_max": 372,
      "o": "m 125 972 l 217 972 l 217 0 l 125 0 l 125 972 m 156 1244 l 186 1244 l 372 1050 l 272 1050 l 171 1158 l 69 1050 l -31 1050 l 156 1244 z "
    },
    "Ï": {
      "ha": 342,
      "x_min": -6,
      "x_max": 344,
      "o": "m 125 972 l 217 972 l 217 0 l 125 0 l 125 972 m 63 1092 q 14 1111 33 1092 q -6 1158 -6 1131 q 14 1208 -6 1188 q 63 1228 33 1228 q 111 1208 92 1228 q 131 1158 131 1188 q 111 1111 131 1131 q 63 1092 92 1092 m 275 1092 q 228 1111 247 1092 q 208 1158 208 1131 q 228 1208 208 1188 q 275 1228 247 1228 q 324 1208 304 1228 q 344 1158 344 1188 q 324 1111 344 1131 q 275 1092 304 1092 z "
    },
    "Ð": {
      "ha": 894,
      "x_min": 28,
      "x_max": 822,
      "o": "m 125 972 l 381 972 q 606 914 506 972 q 765 745 707 856 q 822 486 822 635 q 765 227 822 338 q 606 58 707 117 q 381 0 506 0 l 125 0 l 125 972 m 382 86 q 553 129 475 86 q 679 263 632 172 q 726 486 726 353 q 679 710 726 619 q 553 843 632 800 q 382 886 475 886 l 217 886 l 217 86 l 382 86 m 28 529 l 353 529 l 353 443 l 28 443 l 28 529 z "
    },
    "Ñ": {
      "ha": 932,
      "x_min": 125,
      "x_max": 807,
      "o": "m 125 972 l 233 972 l 715 146 l 715 972 l 807 972 l 807 0 l 699 0 l 217 824 l 217 0 l 125 0 l 125 972 m 232 1131 q 293 1200 257 1174 q 369 1226 329 1226 q 426 1218 403 1226 q 476 1194 450 1210 q 516 1175 501 1181 q 551 1169 531 1169 q 638 1226 596 1169 l 700 1176 q 639 1107 675 1133 q 563 1081 603 1081 q 506 1089 529 1081 q 456 1113 482 1097 q 415 1132 431 1126 q 381 1138 400 1138 q 294 1081 336 1138 l 232 1131 z "
    },
    "Ò": {
      "ha": 997,
      "x_min": 72,
      "x_max": 925,
      "o": "m 499 -11 q 286 50 383 -11 q 131 224 189 111 q 72 486 72 336 q 131 749 72 636 q 286 922 189 861 q 499 983 383 983 q 711 922 614 983 q 867 749 808 861 q 925 486 925 636 q 867 224 925 336 q 711 50 808 111 q 499 -11 614 -11 m 499 75 q 667 122 592 75 q 785 262 742 169 q 829 486 829 354 q 785 710 829 618 q 667 850 742 803 q 499 897 592 897 q 331 850 406 897 q 212 710 256 803 q 168 486 168 618 q 212 262 168 354 q 331 122 256 169 q 499 75 406 75 m 307 1244 l 436 1244 l 533 1050 l 464 1050 l 307 1244 z "
    },
    "Ó": {
      "ha": 997,
      "x_min": 72,
      "x_max": 925,
      "o": "m 499 -11 q 286 50 383 -11 q 131 224 189 111 q 72 486 72 336 q 131 749 72 636 q 286 922 189 861 q 499 983 383 983 q 711 922 614 983 q 867 749 808 861 q 925 486 925 636 q 867 224 925 336 q 711 50 808 111 q 499 -11 614 -11 m 499 75 q 667 122 592 75 q 785 262 742 169 q 829 486 829 354 q 785 710 829 618 q 667 850 742 803 q 499 897 592 897 q 331 850 406 897 q 212 710 256 803 q 168 486 168 618 q 212 262 168 354 q 331 122 256 169 q 499 75 406 75 m 561 1244 l 690 1244 l 533 1050 l 464 1050 l 561 1244 z "
    },
    "Ô": {
      "ha": 997,
      "x_min": 72,
      "x_max": 925,
      "o": "m 499 -11 q 286 50 383 -11 q 131 224 189 111 q 72 486 72 336 q 131 749 72 636 q 286 922 189 861 q 499 983 383 983 q 711 922 614 983 q 867 749 808 861 q 925 486 925 636 q 867 224 925 336 q 711 50 808 111 q 499 -11 614 -11 m 499 75 q 667 122 592 75 q 785 262 742 169 q 829 486 829 354 q 785 710 829 618 q 667 850 742 803 q 499 897 592 897 q 331 850 406 897 q 212 710 256 803 q 168 486 168 618 q 212 262 168 354 q 331 122 256 169 q 499 75 406 75 m 483 1244 l 514 1244 l 700 1050 l 600 1050 l 499 1158 l 397 1050 l 297 1050 l 483 1244 z "
    },
    "Õ": {
      "ha": 997,
      "x_min": 72,
      "x_max": 925,
      "o": "m 499 -11 q 286 50 383 -11 q 131 224 189 111 q 72 486 72 336 q 131 749 72 636 q 286 922 189 861 q 499 983 383 983 q 711 922 614 983 q 867 749 808 861 q 925 486 925 636 q 867 224 925 336 q 711 50 808 111 q 499 -11 614 -11 m 499 75 q 667 122 592 75 q 785 262 742 169 q 829 486 829 354 q 785 710 829 618 q 667 850 742 803 q 499 897 592 897 q 331 850 406 897 q 212 710 256 803 q 168 486 168 618 q 212 262 168 354 q 331 122 256 169 q 499 75 406 75 m 264 1131 q 325 1200 289 1174 q 401 1226 361 1226 q 458 1218 435 1226 q 508 1194 482 1210 q 548 1175 533 1181 q 583 1169 563 1169 q 669 1226 628 1169 l 732 1176 q 671 1107 707 1133 q 594 1081 635 1081 q 538 1089 561 1081 q 488 1113 514 1097 q 447 1132 463 1126 q 413 1138 432 1138 q 326 1081 368 1138 l 264 1131 z "
    },
    "Ö": {
      "ha": 997,
      "x_min": 72,
      "x_max": 925,
      "o": "m 499 -11 q 286 50 383 -11 q 131 224 189 111 q 72 486 72 336 q 131 749 72 636 q 286 922 189 861 q 499 983 383 983 q 711 922 614 983 q 867 749 808 861 q 925 486 925 636 q 867 224 925 336 q 711 50 808 111 q 499 -11 614 -11 m 499 75 q 667 122 592 75 q 785 262 742 169 q 829 486 829 354 q 785 710 829 618 q 667 850 742 803 q 499 897 592 897 q 331 850 406 897 q 212 710 256 803 q 168 486 168 618 q 212 262 168 354 q 331 122 256 169 q 499 75 406 75 m 390 1092 q 342 1111 361 1092 q 322 1158 322 1131 q 342 1208 322 1188 q 390 1228 361 1228 q 439 1208 419 1228 q 458 1158 458 1188 q 439 1111 458 1131 q 390 1092 419 1092 m 603 1092 q 556 1111 575 1092 q 536 1158 536 1131 q 556 1208 536 1188 q 603 1228 575 1228 q 652 1208 632 1228 q 672 1158 672 1188 q 652 1111 672 1131 q 603 1092 632 1092 z "
    },
    "×": {
      "ha": 728,
      "x_min": 96,
      "x_max": 632,
      "o": "m 96 225 l 308 439 l 96 651 l 150 707 l 364 493 l 575 706 l 631 650 l 418 439 l 632 225 l 576 171 l 364 383 l 150 171 l 96 225 z "
    },
    "Ø": {
      "ha": 997,
      "x_min": 72,
      "x_max": 925,
      "o": "m 499 -11 q 286 50 383 -11 q 131 224 189 111 q 72 486 72 336 q 131 749 72 636 q 286 922 189 861 q 499 983 383 983 q 711 922 614 983 q 867 749 808 861 q 925 486 925 636 q 867 224 925 336 q 711 50 808 111 q 499 -11 614 -11 m 499 75 q 667 122 592 75 q 785 262 742 169 q 829 486 829 354 q 785 710 829 618 q 667 850 742 803 q 499 897 592 897 q 331 850 406 897 q 212 710 256 803 q 168 486 168 618 q 212 262 168 354 q 331 122 256 169 q 499 75 406 75 m 93 26 l 840 994 l 904 946 l 157 -22 l 93 26 z "
    },
    "Ù": {
      "ha": 883,
      "x_min": 108,
      "x_max": 775,
      "o": "m 442 -11 q 275 26 351 -11 q 153 135 199 63 q 108 311 108 208 l 108 972 l 200 972 l 200 303 q 263 140 200 206 q 442 75 325 75 q 621 140 558 75 q 683 303 683 206 l 683 972 l 775 972 l 775 311 q 730 135 775 208 q 608 26 685 63 q 442 -11 532 -11 m 250 1244 l 379 1244 l 476 1050 l 407 1050 l 250 1244 z "
    },
    "Ú": {
      "ha": 883,
      "x_min": 108,
      "x_max": 775,
      "o": "m 442 -11 q 275 26 351 -11 q 153 135 199 63 q 108 311 108 208 l 108 972 l 200 972 l 200 303 q 263 140 200 206 q 442 75 325 75 q 621 140 558 75 q 683 303 683 206 l 683 972 l 775 972 l 775 311 q 730 135 775 208 q 608 26 685 63 q 442 -11 532 -11 m 504 1244 l 633 1244 l 476 1050 l 407 1050 l 504 1244 z "
    },
    "Û": {
      "ha": 883,
      "x_min": 108,
      "x_max": 775,
      "o": "m 442 -11 q 275 26 351 -11 q 153 135 199 63 q 108 311 108 208 l 108 972 l 200 972 l 200 303 q 263 140 200 206 q 442 75 325 75 q 621 140 558 75 q 683 303 683 206 l 683 972 l 775 972 l 775 311 q 730 135 775 208 q 608 26 685 63 q 442 -11 532 -11 m 426 1244 l 457 1244 l 643 1050 l 543 1050 l 442 1158 l 340 1050 l 240 1050 l 426 1244 z "
    },
    "Ü": {
      "ha": 883,
      "x_min": 108,
      "x_max": 775,
      "o": "m 442 -11 q 275 26 351 -11 q 153 135 199 63 q 108 311 108 208 l 108 972 l 200 972 l 200 303 q 263 140 200 206 q 442 75 325 75 q 621 140 558 75 q 683 303 683 206 l 683 972 l 775 972 l 775 311 q 730 135 775 208 q 608 26 685 63 q 442 -11 532 -11 m 333 1092 q 285 1111 304 1092 q 265 1158 265 1131 q 285 1208 265 1188 q 333 1228 304 1228 q 382 1208 363 1228 q 401 1158 401 1188 q 382 1111 401 1131 q 333 1092 363 1092 m 546 1092 q 499 1111 518 1092 q 479 1158 479 1131 q 499 1208 479 1188 q 546 1228 518 1228 q 595 1208 575 1228 q 615 1158 615 1188 q 595 1111 615 1131 q 546 1092 575 1092 z "
    },
    "Ý": {
      "ha": 711,
      "x_min": 17,
      "x_max": 694,
      "o": "m 310 422 l 17 972 l 124 972 l 356 513 l 588 972 l 694 972 l 401 422 l 401 0 l 310 0 l 310 422 m 418 1244 l 547 1244 l 390 1050 l 321 1050 l 418 1244 z "
    },
    "Þ": {
      "ha": 797,
      "x_min": 125,
      "x_max": 736,
      "o": "m 125 972 l 217 972 l 217 754 l 456 754 q 661 683 586 754 q 736 486 736 611 q 661 290 736 361 q 456 218 586 218 l 217 218 l 217 0 l 125 0 l 125 972 m 457 304 q 596 353 551 304 q 640 486 640 403 q 596 619 640 569 q 457 668 551 668 l 217 668 l 217 304 l 457 304 z "
    },
    "ß": {
      "ha": 786,
      "x_min": 56,
      "x_max": 706,
      "o": "m 413 -11 q 306 -1 357 -11 l 306 85 q 403 69 357 69 q 562 125 507 69 q 617 276 617 181 q 551 438 617 385 q 376 492 485 492 l 332 492 l 332 569 l 385 569 q 513 615 467 569 q 558 736 558 660 q 513 858 558 813 q 394 903 468 903 q 266 845 313 903 q 219 676 219 788 l 219 0 l 131 0 l 131 492 l 56 492 l 56 569 l 131 569 l 131 678 q 204 904 131 825 q 396 983 278 983 q 574 916 507 983 q 642 743 642 849 q 604 608 642 665 q 510 536 567 550 q 649 450 593 513 q 706 278 706 388 q 668 125 706 190 q 564 24 631 60 q 413 -11 497 -11 z "
    },
    "à": {
      "ha": 686,
      "x_min": 69,
      "x_max": 594,
      "o": "m 288 -11 q 131 41 192 -11 q 69 201 69 93 q 153 373 69 315 q 388 431 238 431 l 508 431 l 508 461 q 465 590 508 549 q 347 631 422 631 q 238 594 279 631 q 181 500 197 558 l 97 519 q 181 659 111 607 q 347 711 251 711 q 524 645 454 711 q 594 464 594 579 l 594 0 l 529 0 l 508 108 q 422 22 476 54 q 288 -11 367 -11 m 296 69 q 394 95 346 69 q 476 178 443 121 q 508 324 508 235 l 508 350 l 390 350 q 217 311 274 350 q 160 201 160 272 q 196 103 160 138 q 296 69 232 69 m 156 972 l 285 972 l 382 778 l 313 778 l 156 972 z "
    },
    "á": {
      "ha": 686,
      "x_min": 69,
      "x_max": 594,
      "o": "m 288 -11 q 131 41 192 -11 q 69 201 69 93 q 153 373 69 315 q 388 431 238 431 l 508 431 l 508 461 q 465 590 508 549 q 347 631 422 631 q 238 594 279 631 q 181 500 197 558 l 97 519 q 181 659 111 607 q 347 711 251 711 q 524 645 454 711 q 594 464 594 579 l 594 0 l 529 0 l 508 108 q 422 22 476 54 q 288 -11 367 -11 m 296 69 q 394 95 346 69 q 476 178 443 121 q 508 324 508 235 l 508 350 l 390 350 q 217 311 274 350 q 160 201 160 272 q 196 103 160 138 q 296 69 232 69 m 410 972 l 539 972 l 382 778 l 313 778 l 410 972 z "
    },
    "â": {
      "ha": 686,
      "x_min": 69,
      "x_max": 594,
      "o": "m 288 -11 q 131 41 192 -11 q 69 201 69 93 q 153 373 69 315 q 388 431 238 431 l 508 431 l 508 461 q 465 590 508 549 q 347 631 422 631 q 238 594 279 631 q 181 500 197 558 l 97 519 q 181 659 111 607 q 347 711 251 711 q 524 645 454 711 q 594 464 594 579 l 594 0 l 529 0 l 508 108 q 422 22 476 54 q 288 -11 367 -11 m 296 69 q 394 95 346 69 q 476 178 443 121 q 508 324 508 235 l 508 350 l 390 350 q 217 311 274 350 q 160 201 160 272 q 196 103 160 138 q 296 69 232 69 m 332 972 l 363 972 l 549 778 l 449 778 l 347 886 l 246 778 l 146 778 l 332 972 z "
    },
    "ã": {
      "ha": 686,
      "x_min": 69,
      "x_max": 594,
      "o": "m 288 -11 q 131 41 192 -11 q 69 201 69 93 q 153 373 69 315 q 388 431 238 431 l 508 431 l 508 461 q 465 590 508 549 q 347 631 422 631 q 238 594 279 631 q 181 500 197 558 l 97 519 q 181 659 111 607 q 347 711 251 711 q 524 645 454 711 q 594 464 594 579 l 594 0 l 529 0 l 508 108 q 422 22 476 54 q 288 -11 367 -11 m 296 69 q 394 95 346 69 q 476 178 443 121 q 508 324 508 235 l 508 350 l 390 350 q 217 311 274 350 q 160 201 160 272 q 196 103 160 138 q 296 69 232 69 m 113 858 q 174 928 138 901 q 250 954 210 954 q 307 946 283 954 q 357 922 331 938 q 397 903 382 908 q 432 897 413 897 q 518 954 476 897 l 581 904 q 519 835 556 861 q 443 808 483 808 q 386 817 410 808 q 336 840 363 825 q 296 860 311 854 q 261 865 281 865 q 175 808 217 865 l 113 858 z "
    },
    "ä": {
      "ha": 686,
      "x_min": 69,
      "x_max": 594,
      "o": "m 288 -11 q 131 41 192 -11 q 69 201 69 93 q 153 373 69 315 q 388 431 238 431 l 508 431 l 508 461 q 465 590 508 549 q 347 631 422 631 q 238 594 279 631 q 181 500 197 558 l 97 519 q 181 659 111 607 q 347 711 251 711 q 524 645 454 711 q 594 464 594 579 l 594 0 l 529 0 l 508 108 q 422 22 476 54 q 288 -11 367 -11 m 296 69 q 394 95 346 69 q 476 178 443 121 q 508 324 508 235 l 508 350 l 390 350 q 217 311 274 350 q 160 201 160 272 q 196 103 160 138 q 296 69 232 69 m 240 819 q 192 839 211 819 q 172 886 172 858 q 192 935 172 915 q 240 956 211 956 q 289 935 269 956 q 308 886 308 915 q 289 839 308 858 q 240 819 269 819 m 453 819 q 406 839 425 819 q 386 886 386 858 q 406 935 386 915 q 453 956 425 956 q 502 935 482 956 q 522 886 522 915 q 502 839 522 858 q 453 819 482 819 z "
    },
    "å": {
      "ha": 686,
      "x_min": 69,
      "x_max": 594,
      "o": "m 288 -11 q 131 41 192 -11 q 69 201 69 93 q 153 373 69 315 q 388 431 238 431 l 508 431 l 508 461 q 465 590 508 549 q 347 631 422 631 q 238 594 279 631 q 181 500 197 558 l 97 519 q 181 659 111 607 q 347 711 251 711 q 524 645 454 711 q 594 464 594 579 l 594 0 l 529 0 l 508 108 q 422 22 476 54 q 288 -11 367 -11 m 296 69 q 394 95 346 69 q 476 178 443 121 q 508 324 508 235 l 508 350 l 390 350 q 217 311 274 350 q 160 201 160 272 q 196 103 160 138 q 296 69 232 69 m 347 776 q 251 814 290 776 q 213 907 213 851 q 251 1003 213 964 q 347 1043 290 1043 q 444 1004 406 1043 q 482 907 482 965 q 444 814 482 851 q 347 776 406 776 m 347 836 q 399 856 379 836 q 418 908 418 876 q 399 963 418 942 q 347 983 379 983 q 297 962 317 983 q 276 908 276 940 q 297 856 276 876 q 347 836 317 836 z "
    },
    "æ": {
      "ha": 1193,
      "x_min": 69,
      "x_max": 1126,
      "o": "m 288 -11 q 131 41 192 -11 q 69 201 69 93 q 153 373 69 315 q 388 431 238 431 l 508 431 l 508 461 q 465 590 508 549 q 347 631 422 631 q 238 594 279 631 q 181 500 197 558 l 97 519 q 181 659 111 607 q 347 711 251 711 q 485 675 425 711 q 574 576 546 639 q 678 676 615 640 q 819 711 742 711 q 978 671 908 711 q 1088 558 1049 631 q 1126 389 1126 485 l 1126 350 l 599 350 q 658 147 599 225 q 819 69 717 69 q 948 105 897 69 q 1033 214 999 140 l 1111 182 q 989 33 1058 78 q 819 -11 919 -11 q 654 37 726 -11 q 549 165 582 85 q 447 33 517 76 q 288 -11 378 -11 m 1038 431 q 969 577 1025 524 q 819 631 913 631 q 678 575 735 631 q 604 431 622 519 l 1038 431 m 296 69 q 394 95 346 69 q 476 178 443 121 q 508 324 508 235 l 508 350 l 390 350 q 217 311 274 350 q 160 201 160 272 q 196 103 160 138 q 296 69 232 69 z "
    },
    "ç": {
      "ha": 717,
      "x_min": 67,
      "x_max": 658,
      "o": "m 376 -11 q 208 40 278 -11 q 102 173 138 90 q 67 350 67 256 q 102 527 67 444 q 208 660 138 610 q 376 711 278 711 q 658 518 586 711 l 581 488 q 376 631 525 631 q 213 551 269 631 q 157 350 157 471 q 213 149 157 229 q 376 69 269 69 q 502 106 453 69 q 581 213 551 142 l 658 182 q 551 38 622 88 q 376 -11 479 -11 m 215 -254 l 351 -83 l 428 -83 l 315 -297 l 215 -254 z "
    },
    "è": {
      "ha": 751,
      "x_min": 67,
      "x_max": 685,
      "o": "m 378 -11 q 215 35 286 -11 q 106 164 144 82 q 67 350 67 246 q 106 536 67 454 q 215 665 144 618 q 378 711 286 711 q 537 671 467 711 q 646 558 607 631 q 685 389 685 485 l 685 350 l 157 350 q 216 147 157 225 q 378 69 275 69 q 506 104 457 69 q 593 219 554 139 l 669 182 q 547 33 617 78 q 378 -11 478 -11 m 596 431 q 527 577 583 524 q 378 631 471 631 q 237 575 293 631 q 163 431 181 519 l 596 431 m 186 972 l 315 972 l 413 778 l 343 778 l 186 972 z "
    },
    "é": {
      "ha": 751,
      "x_min": 67,
      "x_max": 685,
      "o": "m 378 -11 q 215 35 286 -11 q 106 164 144 82 q 67 350 67 246 q 106 536 67 454 q 215 665 144 618 q 378 711 286 711 q 537 671 467 711 q 646 558 607 631 q 685 389 685 485 l 685 350 l 157 350 q 216 147 157 225 q 378 69 275 69 q 506 104 457 69 q 593 219 554 139 l 669 182 q 547 33 617 78 q 378 -11 478 -11 m 596 431 q 527 577 583 524 q 378 631 471 631 q 237 575 293 631 q 163 431 181 519 l 596 431 m 440 972 l 569 972 l 413 778 l 343 778 l 440 972 z "
    },
    "ê": {
      "ha": 751,
      "x_min": 67,
      "x_max": 685,
      "o": "m 378 -11 q 215 35 286 -11 q 106 164 144 82 q 67 350 67 246 q 106 536 67 454 q 215 665 144 618 q 378 711 286 711 q 537 671 467 711 q 646 558 607 631 q 685 389 685 485 l 685 350 l 157 350 q 216 147 157 225 q 378 69 275 69 q 506 104 457 69 q 593 219 554 139 l 669 182 q 547 33 617 78 q 378 -11 478 -11 m 596 431 q 527 577 583 524 q 378 631 471 631 q 237 575 293 631 q 163 431 181 519 l 596 431 m 363 972 l 393 972 l 579 778 l 479 778 l 378 886 l 276 778 l 176 778 l 363 972 z "
    },
    "ë": {
      "ha": 751,
      "x_min": 67,
      "x_max": 685,
      "o": "m 378 -11 q 215 35 286 -11 q 106 164 144 82 q 67 350 67 246 q 106 536 67 454 q 215 665 144 618 q 378 711 286 711 q 537 671 467 711 q 646 558 607 631 q 685 389 685 485 l 685 350 l 157 350 q 216 147 157 225 q 378 69 275 69 q 506 104 457 69 q 593 219 554 139 l 669 182 q 547 33 617 78 q 378 -11 478 -11 m 596 431 q 527 577 583 524 q 378 631 471 631 q 237 575 293 631 q 163 431 181 519 l 596 431 m 271 819 q 222 839 242 819 q 203 886 203 858 q 222 935 203 915 q 271 956 242 956 q 319 935 300 956 q 339 886 339 915 q 319 839 339 858 q 271 819 300 819 m 483 819 q 436 839 456 819 q 417 886 417 858 q 436 935 417 915 q 483 956 456 956 q 533 935 513 956 q 553 886 553 915 q 533 839 553 858 q 483 819 513 819 z "
    },
    "ì": {
      "ha": 303,
      "x_min": -40,
      "x_max": 194,
      "o": "m 108 700 l 194 700 l 194 0 l 108 0 l 108 700 m -40 972 l 89 972 l 186 778 l 117 778 l -40 972 z "
    },
    "í": {
      "ha": 303,
      "x_min": 108,
      "x_max": 343,
      "o": "m 108 700 l 194 700 l 194 0 l 108 0 l 108 700 m 214 972 l 343 972 l 186 778 l 117 778 l 214 972 z "
    },
    "î": {
      "ha": 303,
      "x_min": -50,
      "x_max": 353,
      "o": "m 108 700 l 194 700 l 194 0 l 108 0 l 108 700 m 136 972 l 167 972 l 353 778 l 253 778 l 151 886 l 50 778 l -50 778 l 136 972 z "
    },
    "ï": {
      "ha": 303,
      "x_min": -24,
      "x_max": 326,
      "o": "m 108 700 l 194 700 l 194 0 l 108 0 l 108 700 m 44 819 q -4 839 15 819 q -24 886 -24 858 q -4 935 -24 915 q 44 956 15 956 q 93 935 74 956 q 113 886 113 915 q 93 839 113 858 q 44 819 74 819 m 257 819 q 210 839 229 819 q 190 886 190 858 q 210 935 190 915 q 257 956 229 956 q 306 935 286 956 q 326 886 326 915 q 306 839 326 858 q 257 819 286 819 z "
    },
    "ð": {
      "ha": 775,
      "x_min": 67,
      "x_max": 708,
      "o": "m 388 -11 q 216 40 289 -11 q 105 174 143 90 q 67 350 67 257 q 105 526 67 443 q 216 660 143 610 q 388 711 289 711 q 492 690 442 711 q 576 632 543 668 q 508 745 558 686 q 390 856 458 804 l 329 765 l 271 807 l 332 896 q 219 954 276 931 l 260 1014 q 374 957 321 986 l 426 1035 l 485 993 l 433 918 q 642 682 575 821 q 708 350 708 543 q 670 174 708 257 q 559 40 632 90 q 388 -11 486 -11 m 388 69 q 515 109 463 69 q 592 213 567 149 q 618 350 618 276 q 592 488 618 424 q 515 591 567 551 q 388 631 463 631 q 260 591 313 631 q 183 488 208 551 q 157 350 157 424 q 183 213 157 276 q 260 109 208 149 q 388 69 313 69 z "
    },
    "ñ": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 108 700 l 194 700 l 194 554 q 295 668 231 625 q 435 711 360 711 q 592 651 535 711 q 650 481 650 590 l 650 0 l 564 0 l 564 469 q 528 589 564 547 q 421 631 493 631 q 306 591 357 631 q 224 478 254 551 q 194 307 194 404 l 194 0 l 108 0 l 108 700 m 160 858 q 221 928 185 901 q 297 954 257 954 q 354 946 331 954 q 404 922 378 938 q 444 903 429 908 q 479 897 460 897 q 565 954 524 897 l 628 904 q 567 835 603 861 q 490 808 531 808 q 433 817 457 808 q 383 840 410 825 q 343 860 358 854 q 308 865 328 865 q 222 808 264 865 l 160 858 z "
    },
    "ò": {
      "ha": 789,
      "x_min": 67,
      "x_max": 722,
      "o": "m 394 -11 q 222 40 296 -11 q 107 174 147 90 q 67 350 67 257 q 107 526 67 443 q 222 660 147 610 q 394 711 296 711 q 567 660 493 711 q 682 526 642 610 q 722 350 722 443 q 682 174 722 257 q 567 40 642 90 q 394 -11 493 -11 m 394 69 q 523 109 469 69 q 604 213 576 149 q 632 350 632 278 q 604 487 632 422 q 523 591 576 551 q 394 631 469 631 q 266 591 319 631 q 185 487 213 551 q 157 350 157 422 q 185 213 157 278 q 266 109 213 149 q 394 69 319 69 m 203 972 l 332 972 l 429 778 l 360 778 l 203 972 z "
    },
    "ó": {
      "ha": 789,
      "x_min": 67,
      "x_max": 722,
      "o": "m 394 -11 q 222 40 296 -11 q 107 174 147 90 q 67 350 67 257 q 107 526 67 443 q 222 660 147 610 q 394 711 296 711 q 567 660 493 711 q 682 526 642 610 q 722 350 722 443 q 682 174 722 257 q 567 40 642 90 q 394 -11 493 -11 m 394 69 q 523 109 469 69 q 604 213 576 149 q 632 350 632 278 q 604 487 632 422 q 523 591 576 551 q 394 631 469 631 q 266 591 319 631 q 185 487 213 551 q 157 350 157 422 q 185 213 157 278 q 266 109 213 149 q 394 69 319 69 m 457 972 l 586 972 l 429 778 l 360 778 l 457 972 z "
    },
    "ô": {
      "ha": 789,
      "x_min": 67,
      "x_max": 722,
      "o": "m 394 -11 q 222 40 296 -11 q 107 174 147 90 q 67 350 67 257 q 107 526 67 443 q 222 660 147 610 q 394 711 296 711 q 567 660 493 711 q 682 526 642 610 q 722 350 722 443 q 682 174 722 257 q 567 40 642 90 q 394 -11 493 -11 m 394 69 q 523 109 469 69 q 604 213 576 149 q 632 350 632 278 q 604 487 632 422 q 523 591 576 551 q 394 631 469 631 q 266 591 319 631 q 185 487 213 551 q 157 350 157 422 q 185 213 157 278 q 266 109 213 149 q 394 69 319 69 m 379 972 l 410 972 l 596 778 l 496 778 l 394 886 l 293 778 l 193 778 l 379 972 z "
    },
    "õ": {
      "ha": 789,
      "x_min": 67,
      "x_max": 722,
      "o": "m 394 -11 q 222 40 296 -11 q 107 174 147 90 q 67 350 67 257 q 107 526 67 443 q 222 660 147 610 q 394 711 296 711 q 567 660 493 711 q 682 526 642 610 q 722 350 722 443 q 682 174 722 257 q 567 40 642 90 q 394 -11 493 -11 m 394 69 q 523 109 469 69 q 604 213 576 149 q 632 350 632 278 q 604 487 632 422 q 523 591 576 551 q 394 631 469 631 q 266 591 319 631 q 185 487 213 551 q 157 350 157 422 q 185 213 157 278 q 266 109 213 149 q 394 69 319 69 m 160 858 q 221 928 185 901 q 297 954 257 954 q 354 946 331 954 q 404 922 378 938 q 444 903 429 908 q 479 897 460 897 q 565 954 524 897 l 628 904 q 567 835 603 861 q 490 808 531 808 q 433 817 457 808 q 383 840 410 825 q 343 860 358 854 q 308 865 328 865 q 222 808 264 865 l 160 858 z "
    },
    "ö": {
      "ha": 789,
      "x_min": 67,
      "x_max": 722,
      "o": "m 394 -11 q 222 40 296 -11 q 107 174 147 90 q 67 350 67 257 q 107 526 67 443 q 222 660 147 610 q 394 711 296 711 q 567 660 493 711 q 682 526 642 610 q 722 350 722 443 q 682 174 722 257 q 567 40 642 90 q 394 -11 493 -11 m 394 69 q 523 109 469 69 q 604 213 576 149 q 632 350 632 278 q 604 487 632 422 q 523 591 576 551 q 394 631 469 631 q 266 591 319 631 q 185 487 213 551 q 157 350 157 422 q 185 213 157 278 q 266 109 213 149 q 394 69 319 69 m 288 819 q 239 839 258 819 q 219 886 219 858 q 239 935 219 915 q 288 956 258 956 q 336 935 317 956 q 356 886 356 915 q 336 839 356 858 q 288 819 317 819 m 500 819 q 453 839 472 819 q 433 886 433 858 q 453 935 433 915 q 500 956 472 956 q 549 935 529 956 q 569 886 569 915 q 549 839 569 858 q 500 819 529 819 z "
    },
    "÷": {
      "ha": 764,
      "x_min": 97,
      "x_max": 667,
      "o": "m 381 622 q 330 642 350 622 q 310 693 310 663 q 330 744 310 724 q 381 764 350 764 q 431 744 411 764 q 451 693 451 724 q 431 642 451 663 q 381 622 411 622 m 97 478 l 667 478 l 667 400 l 97 400 l 97 478 m 381 114 q 330 134 350 114 q 310 185 310 154 q 330 235 310 215 q 381 256 350 256 q 431 235 411 256 q 451 185 451 215 q 431 134 451 154 q 381 114 411 114 z "
    },
    "ø": {
      "ha": 789,
      "x_min": 67,
      "x_max": 722,
      "o": "m 394 -11 q 222 40 296 -11 q 107 174 147 90 q 67 350 67 257 q 107 526 67 443 q 222 660 147 610 q 394 711 296 711 q 567 660 493 711 q 682 526 642 610 q 722 350 722 443 q 682 174 722 257 q 567 40 642 90 q 394 -11 493 -11 m 394 69 q 523 109 469 69 q 604 213 576 149 q 632 350 632 278 q 604 487 632 422 q 523 591 576 551 q 394 631 469 631 q 266 591 319 631 q 185 487 213 551 q 157 350 157 422 q 185 213 157 278 q 266 109 213 149 q 394 69 319 69 m 67 -1 l 658 750 l 722 701 l 131 -50 l 67 -1 z "
    },
    "ù": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 324 -11 q 166 49 224 -11 q 108 219 108 110 l 108 700 l 194 700 l 194 231 q 230 111 194 153 q 338 69 265 69 q 453 109 401 69 q 534 222 504 149 q 564 393 564 296 l 564 700 l 650 700 l 650 0 l 564 0 l 564 146 q 463 32 528 75 q 324 -11 399 -11 m 188 972 l 317 972 l 414 778 l 344 778 l 188 972 z "
    },
    "ú": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 324 -11 q 166 49 224 -11 q 108 219 108 110 l 108 700 l 194 700 l 194 231 q 230 111 194 153 q 338 69 265 69 q 453 109 401 69 q 534 222 504 149 q 564 393 564 296 l 564 700 l 650 700 l 650 0 l 564 0 l 564 146 q 463 32 528 75 q 324 -11 399 -11 m 442 972 l 571 972 l 414 778 l 344 778 l 442 972 z "
    },
    "û": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 324 -11 q 166 49 224 -11 q 108 219 108 110 l 108 700 l 194 700 l 194 231 q 230 111 194 153 q 338 69 265 69 q 453 109 401 69 q 534 222 504 149 q 564 393 564 296 l 564 700 l 650 700 l 650 0 l 564 0 l 564 146 q 463 32 528 75 q 324 -11 399 -11 m 364 972 l 394 972 l 581 778 l 481 778 l 379 886 l 278 778 l 178 778 l 364 972 z "
    },
    "ü": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 324 -11 q 166 49 224 -11 q 108 219 108 110 l 108 700 l 194 700 l 194 231 q 230 111 194 153 q 338 69 265 69 q 453 109 401 69 q 534 222 504 149 q 564 393 564 296 l 564 700 l 650 700 l 650 0 l 564 0 l 564 146 q 463 32 528 75 q 324 -11 399 -11 m 272 819 q 224 839 243 819 q 204 886 204 858 q 224 935 204 915 q 272 956 243 956 q 321 935 301 956 q 340 886 340 915 q 321 839 340 858 q 272 819 301 819 m 485 819 q 438 839 457 819 q 418 886 418 858 q 438 935 418 915 q 485 956 457 956 q 534 935 514 956 q 554 886 554 915 q 534 839 554 858 q 485 819 514 819 z "
    },
    "ý": {
      "ha": 611,
      "x_min": 14,
      "x_max": 597,
      "o": "m 265 4 l 14 700 l 104 700 l 313 133 l 507 700 l 597 700 l 250 -283 l 164 -283 l 265 4 m 368 972 l 497 972 l 340 778 l 271 778 l 368 972 z "
    },
    "þ": {
      "ha": 794,
      "x_min": 108,
      "x_max": 728,
      "o": "m 108 983 l 194 983 l 194 601 q 286 678 225 646 q 415 711 347 711 q 585 663 514 711 q 692 533 656 615 q 728 350 728 451 q 692 167 728 249 q 585 37 656 85 q 415 -11 514 -11 q 290 18 351 -11 q 194 99 229 47 l 194 -283 l 108 -283 l 108 983 m 411 69 q 578 149 518 69 q 638 350 638 228 q 578 552 638 474 q 411 631 519 631 q 244 552 303 631 q 186 350 186 474 q 245 149 186 228 q 411 69 304 69 z "
    },
    "ÿ": {
      "ha": 611,
      "x_min": 14,
      "x_max": 597,
      "o": "m 265 4 l 14 700 l 104 700 l 313 133 l 507 700 l 597 700 l 250 -283 l 164 -283 l 265 4 m 199 819 q 150 839 169 819 q 131 886 131 858 q 150 935 131 915 q 199 956 169 956 q 247 935 228 956 q 267 886 267 915 q 247 839 267 858 q 199 819 228 819 m 411 819 q 364 839 383 819 q 344 886 344 858 q 364 935 344 915 q 411 956 383 956 q 460 935 440 956 q 481 886 481 915 q 460 839 481 858 q 411 819 440 819 z "
    },
    "Ā": {
      "ha": 817,
      "x_min": 17,
      "x_max": 800,
      "o": "m 368 972 l 449 972 l 800 0 l 706 0 l 608 276 l 208 276 l 111 0 l 17 0 l 368 972 m 579 363 l 408 847 l 238 363 l 579 363 m 240 1189 l 575 1189 l 575 1111 l 240 1111 l 240 1189 z "
    },
    "ā": {
      "ha": 686,
      "x_min": 69,
      "x_max": 594,
      "o": "m 288 -11 q 131 41 192 -11 q 69 201 69 93 q 153 373 69 315 q 388 431 238 431 l 508 431 l 508 461 q 465 590 508 549 q 347 631 422 631 q 238 594 279 631 q 181 500 197 558 l 97 519 q 181 659 111 607 q 347 711 251 711 q 524 645 454 711 q 594 464 594 579 l 594 0 l 529 0 l 508 108 q 422 22 476 54 q 288 -11 367 -11 m 296 69 q 394 95 346 69 q 476 178 443 121 q 508 324 508 235 l 508 350 l 390 350 q 217 311 274 350 q 160 201 160 272 q 196 103 160 138 q 296 69 232 69 m 179 917 l 514 917 l 514 839 l 179 839 l 179 917 z "
    },
    "Ă": {
      "ha": 817,
      "x_min": 17,
      "x_max": 800,
      "o": "m 368 972 l 449 972 l 800 0 l 706 0 l 608 276 l 208 276 l 111 0 l 17 0 l 368 972 m 579 363 l 408 847 l 238 363 l 579 363 m 408 1093 q 302 1135 342 1093 q 263 1244 263 1176 l 333 1244 q 353 1185 333 1208 q 408 1163 372 1163 q 465 1185 446 1163 q 483 1244 483 1207 l 554 1244 q 515 1135 554 1176 q 408 1093 476 1093 z "
    },
    "ă": {
      "ha": 686,
      "x_min": 69,
      "x_max": 594,
      "o": "m 288 -11 q 131 41 192 -11 q 69 201 69 93 q 153 373 69 315 q 388 431 238 431 l 508 431 l 508 461 q 465 590 508 549 q 347 631 422 631 q 238 594 279 631 q 181 500 197 558 l 97 519 q 181 659 111 607 q 347 711 251 711 q 524 645 454 711 q 594 464 594 579 l 594 0 l 529 0 l 508 108 q 422 22 476 54 q 288 -11 367 -11 m 296 69 q 394 95 346 69 q 476 178 443 121 q 508 324 508 235 l 508 350 l 390 350 q 217 311 274 350 q 160 201 160 272 q 196 103 160 138 q 296 69 232 69 m 347 821 q 241 863 281 821 q 201 972 201 904 l 272 972 q 292 913 272 936 q 347 890 311 890 q 403 913 385 890 q 422 972 422 935 l 493 972 q 454 863 493 904 q 347 821 415 821 z "
    },
    "Ą": {
      "ha": 817,
      "x_min": 17,
      "x_max": 828,
      "o": "m 368 972 l 449 972 l 800 0 l 706 0 l 608 276 l 208 276 l 111 0 l 17 0 l 368 972 m 579 363 l 408 847 l 238 363 l 579 363 m 754 -235 q 674 -206 704 -235 q 644 -128 644 -176 q 663 -59 644 -93 q 714 0 681 -25 l 800 0 q 740 -62 758 -37 q 722 -111 722 -86 q 735 -145 722 -133 q 768 -157 747 -157 q 806 -146 789 -157 l 828 -215 q 794 -231 810 -226 q 754 -235 778 -235 z "
    },
    "ą": {
      "ha": 692,
      "x_min": 69,
      "x_max": 622,
      "o": "m 622 -215 q 588 -231 604 -226 q 549 -235 572 -235 q 469 -206 499 -235 q 439 -128 439 -176 q 529 0 439 -51 l 508 108 q 422 22 476 54 q 288 -11 367 -11 q 131 41 192 -11 q 69 201 69 93 q 153 373 69 315 q 388 431 238 431 l 508 431 l 508 461 q 465 590 508 549 q 347 631 422 631 q 238 594 279 631 q 181 500 197 558 l 97 519 q 181 659 111 607 q 347 711 251 711 q 524 645 454 711 q 594 464 594 579 l 594 0 q 535 -62 553 -37 q 517 -111 517 -86 q 529 -145 517 -133 q 563 -157 542 -157 q 600 -146 583 -157 l 622 -215 m 508 350 l 390 350 q 217 311 274 350 q 160 201 160 272 q 196 103 160 138 q 296 69 232 69 q 394 95 346 69 q 476 178 443 121 q 508 324 508 235 l 508 350 z "
    },
    "Ć": {
      "ha": 938,
      "x_min": 72,
      "x_max": 868,
      "o": "m 501 -11 q 290 44 388 -11 q 132 213 192 100 q 72 486 72 325 q 132 760 72 647 q 290 928 192 872 q 501 983 388 983 q 735 909 639 983 q 868 706 831 835 l 778 679 q 680 840 750 783 q 501 897 610 897 q 328 849 403 897 q 210 708 253 801 q 168 486 168 615 q 210 264 168 357 q 328 123 253 171 q 501 75 403 75 q 680 132 610 75 q 778 293 750 189 l 868 267 q 735 63 831 138 q 501 -11 639 -11 m 564 1244 l 693 1244 l 536 1050 l 467 1050 l 564 1244 z "
    },
    "ć": {
      "ha": 717,
      "x_min": 67,
      "x_max": 658,
      "o": "m 376 -11 q 208 40 278 -11 q 102 173 138 90 q 67 350 67 256 q 102 527 67 444 q 208 660 138 610 q 376 711 278 711 q 658 518 586 711 l 581 488 q 376 631 525 631 q 213 551 269 631 q 157 350 157 471 q 213 149 157 229 q 376 69 269 69 q 502 106 453 69 q 581 213 551 142 l 658 182 q 551 38 622 88 q 376 -11 479 -11 m 440 972 l 569 972 l 413 778 l 343 778 l 440 972 z "
    },
    "Ĉ": {
      "ha": 938,
      "x_min": 72,
      "x_max": 868,
      "o": "m 501 -11 q 290 44 388 -11 q 132 213 192 100 q 72 486 72 325 q 132 760 72 647 q 290 928 192 872 q 501 983 388 983 q 735 909 639 983 q 868 706 831 835 l 778 679 q 680 840 750 783 q 501 897 610 897 q 328 849 403 897 q 210 708 253 801 q 168 486 168 615 q 210 264 168 357 q 328 123 253 171 q 501 75 403 75 q 680 132 610 75 q 778 293 750 189 l 868 267 q 735 63 831 138 q 501 -11 639 -11 m 486 1244 l 517 1244 l 703 1050 l 603 1050 l 501 1158 l 400 1050 l 300 1050 l 486 1244 z "
    },
    "ĉ": {
      "ha": 717,
      "x_min": 67,
      "x_max": 658,
      "o": "m 376 -11 q 208 40 278 -11 q 102 173 138 90 q 67 350 67 256 q 102 527 67 444 q 208 660 138 610 q 376 711 278 711 q 658 518 586 711 l 581 488 q 376 631 525 631 q 213 551 269 631 q 157 350 157 471 q 213 149 157 229 q 376 69 269 69 q 502 106 453 69 q 581 213 551 142 l 658 182 q 551 38 622 88 q 376 -11 479 -11 m 363 972 l 393 972 l 579 778 l 479 778 l 378 886 l 276 778 l 176 778 l 363 972 z "
    },
    "Ċ": {
      "ha": 938,
      "x_min": 72,
      "x_max": 868,
      "o": "m 501 -11 q 290 44 388 -11 q 132 213 192 100 q 72 486 72 325 q 132 760 72 647 q 290 928 192 872 q 501 983 388 983 q 735 909 639 983 q 868 706 831 835 l 778 679 q 680 840 750 783 q 501 897 610 897 q 328 849 403 897 q 210 708 253 801 q 168 486 168 615 q 210 264 168 357 q 328 123 253 171 q 501 75 403 75 q 680 132 610 75 q 778 293 750 189 l 868 267 q 735 63 831 138 q 501 -11 639 -11 m 501 1103 q 451 1123 471 1103 q 431 1174 431 1143 q 451 1224 431 1204 q 501 1244 471 1244 q 552 1224 532 1244 q 572 1174 572 1204 q 552 1123 572 1143 q 501 1103 532 1103 z "
    },
    "ċ": {
      "ha": 717,
      "x_min": 67,
      "x_max": 658,
      "o": "m 376 -11 q 208 40 278 -11 q 102 173 138 90 q 67 350 67 256 q 102 527 67 444 q 208 660 138 610 q 376 711 278 711 q 658 518 586 711 l 581 488 q 376 631 525 631 q 213 551 269 631 q 157 350 157 471 q 213 149 157 229 q 376 69 269 69 q 502 106 453 69 q 581 213 551 142 l 658 182 q 551 38 622 88 q 376 -11 479 -11 m 378 831 q 327 851 347 831 q 307 901 307 871 q 327 952 307 932 q 378 972 347 972 q 428 952 408 972 q 449 901 449 932 q 428 851 449 871 q 378 831 408 831 z "
    },
    "Č": {
      "ha": 938,
      "x_min": 72,
      "x_max": 868,
      "o": "m 501 -11 q 290 44 388 -11 q 132 213 192 100 q 72 486 72 325 q 132 760 72 647 q 290 928 192 872 q 501 983 388 983 q 735 909 639 983 q 868 706 831 835 l 778 679 q 680 840 750 783 q 501 897 610 897 q 328 849 403 897 q 210 708 253 801 q 168 486 168 615 q 210 264 168 357 q 328 123 253 171 q 501 75 403 75 q 680 132 610 75 q 778 293 750 189 l 868 267 q 735 63 831 138 q 501 -11 639 -11 m 300 1244 l 400 1244 l 501 1136 l 603 1244 l 703 1244 l 517 1050 l 486 1050 l 300 1244 z "
    },
    "č": {
      "ha": 717,
      "x_min": 67,
      "x_max": 658,
      "o": "m 376 -11 q 208 40 278 -11 q 102 173 138 90 q 67 350 67 256 q 102 527 67 444 q 208 660 138 610 q 376 711 278 711 q 658 518 586 711 l 581 488 q 376 631 525 631 q 213 551 269 631 q 157 350 157 471 q 213 149 157 229 q 376 69 269 69 q 502 106 453 69 q 581 213 551 142 l 658 182 q 551 38 622 88 q 376 -11 479 -11 m 176 972 l 276 972 l 378 864 l 479 972 l 579 972 l 393 778 l 363 778 l 176 972 z "
    },
    "Ď": {
      "ha": 894,
      "x_min": 125,
      "x_max": 822,
      "o": "m 125 972 l 381 972 q 606 914 506 972 q 765 745 707 856 q 822 486 822 635 q 765 227 822 338 q 606 58 707 117 q 381 0 506 0 l 125 0 l 125 972 m 382 86 q 553 129 475 86 q 679 263 632 172 q 726 486 726 353 q 679 710 726 619 q 553 843 632 800 q 382 886 475 886 l 217 886 l 217 86 l 382 86 m 131 1244 l 231 1244 l 332 1136 l 433 1244 l 533 1244 l 347 1050 l 317 1050 l 131 1244 z "
    },
    "ď": {
      "ha": 951,
      "x_min": 67,
      "x_max": 951,
      "o": "m 379 -11 q 210 37 281 -11 q 103 167 139 85 q 67 350 67 249 q 103 533 67 451 q 210 663 139 615 q 379 711 281 711 q 506 683 449 711 q 600 601 563 654 l 600 983 l 686 983 l 686 0 l 600 0 l 600 100 q 506 22 568 54 q 379 -11 444 -11 m 383 69 q 550 148 492 69 q 608 350 608 226 q 549 551 608 472 q 383 631 490 631 q 217 551 276 631 q 157 350 157 472 q 216 148 157 226 q 383 69 275 69 m 842 983 l 951 983 l 860 753 l 800 753 l 842 983 z "
    },
    "Đ": {
      "ha": 894,
      "x_min": 28,
      "x_max": 822,
      "o": "m 125 972 l 381 972 q 606 914 506 972 q 765 745 707 856 q 822 486 822 635 q 765 227 822 338 q 606 58 707 117 q 381 0 506 0 l 125 0 l 125 972 m 382 86 q 553 129 475 86 q 679 263 632 172 q 726 486 726 353 q 679 710 726 619 q 553 843 632 800 q 382 886 475 886 l 217 886 l 217 86 l 382 86 m 28 529 l 353 529 l 353 443 l 28 443 l 28 529 z "
    },
    "đ": {
      "ha": 794,
      "x_min": 67,
      "x_max": 788,
      "o": "m 379 -11 q 210 37 281 -11 q 103 167 139 85 q 67 350 67 249 q 103 533 67 451 q 210 663 139 615 q 379 711 281 711 q 506 683 449 711 q 600 601 563 654 l 600 983 l 686 983 l 686 0 l 600 0 l 600 100 q 506 22 568 54 q 379 -11 444 -11 m 383 69 q 550 148 492 69 q 608 350 608 226 q 549 551 608 472 q 383 631 490 631 q 217 551 276 631 q 157 350 157 472 q 216 148 157 226 q 383 69 275 69 m 413 881 l 788 881 l 788 803 l 413 803 l 413 881 z "
    },
    "Ē": {
      "ha": 765,
      "x_min": 125,
      "x_max": 688,
      "o": "m 125 972 l 674 972 l 674 886 l 217 886 l 217 561 l 590 561 l 590 475 l 217 475 l 217 86 l 688 86 l 688 0 l 125 0 l 125 972 m 243 1189 l 578 1189 l 578 1111 l 243 1111 l 243 1189 z "
    },
    "ē": {
      "ha": 751,
      "x_min": 67,
      "x_max": 685,
      "o": "m 378 -11 q 215 35 286 -11 q 106 164 144 82 q 67 350 67 246 q 106 536 67 454 q 215 665 144 618 q 378 711 286 711 q 537 671 467 711 q 646 558 607 631 q 685 389 685 485 l 685 350 l 157 350 q 216 147 157 225 q 378 69 275 69 q 506 104 457 69 q 593 219 554 139 l 669 182 q 547 33 617 78 q 378 -11 478 -11 m 596 431 q 527 577 583 524 q 378 631 471 631 q 237 575 293 631 q 163 431 181 519 l 596 431 m 210 917 l 544 917 l 544 839 l 210 839 l 210 917 z "
    },
    "Ĕ": {
      "ha": 765,
      "x_min": 125,
      "x_max": 688,
      "o": "m 125 972 l 674 972 l 674 886 l 217 886 l 217 561 l 590 561 l 590 475 l 217 475 l 217 86 l 688 86 l 688 0 l 125 0 l 125 972 m 411 1093 q 305 1135 344 1093 q 265 1244 265 1176 l 336 1244 q 356 1185 336 1208 q 411 1163 375 1163 q 467 1185 449 1163 q 486 1244 486 1207 l 557 1244 q 518 1135 557 1176 q 411 1093 479 1093 z "
    },
    "ĕ": {
      "ha": 751,
      "x_min": 67,
      "x_max": 685,
      "o": "m 378 -11 q 215 35 286 -11 q 106 164 144 82 q 67 350 67 246 q 106 536 67 454 q 215 665 144 618 q 378 711 286 711 q 537 671 467 711 q 646 558 607 631 q 685 389 685 485 l 685 350 l 157 350 q 216 147 157 225 q 378 69 275 69 q 506 104 457 69 q 593 219 554 139 l 669 182 q 547 33 617 78 q 378 -11 478 -11 m 596 431 q 527 577 583 524 q 378 631 471 631 q 237 575 293 631 q 163 431 181 519 l 596 431 m 378 821 q 272 863 311 821 q 232 972 232 904 l 303 972 q 322 913 303 936 q 378 890 342 890 q 434 913 415 890 q 453 972 453 935 l 524 972 q 485 863 524 904 q 378 821 446 821 z "
    },
    "Ė": {
      "ha": 765,
      "x_min": 125,
      "x_max": 688,
      "o": "m 125 972 l 674 972 l 674 886 l 217 886 l 217 561 l 590 561 l 590 475 l 217 475 l 217 86 l 688 86 l 688 0 l 125 0 l 125 972 m 411 1103 q 360 1123 381 1103 q 340 1174 340 1143 q 360 1224 340 1204 q 411 1244 381 1244 q 462 1224 442 1244 q 482 1174 482 1204 q 462 1123 482 1143 q 411 1103 442 1103 z "
    },
    "ė": {
      "ha": 751,
      "x_min": 67,
      "x_max": 685,
      "o": "m 378 -11 q 215 35 286 -11 q 106 164 144 82 q 67 350 67 246 q 106 536 67 454 q 215 665 144 618 q 378 711 286 711 q 537 671 467 711 q 646 558 607 631 q 685 389 685 485 l 685 350 l 157 350 q 216 147 157 225 q 378 69 275 69 q 506 104 457 69 q 593 219 554 139 l 669 182 q 547 33 617 78 q 378 -11 478 -11 m 596 431 q 527 577 583 524 q 378 631 471 631 q 237 575 293 631 q 163 431 181 519 l 596 431 m 378 831 q 327 851 347 831 q 307 901 307 871 q 327 952 307 932 q 378 972 347 972 q 428 952 408 972 q 449 901 449 932 q 428 851 449 871 q 378 831 408 831 z "
    },
    "Ę": {
      "ha": 765,
      "x_min": 125,
      "x_max": 715,
      "o": "m 125 972 l 674 972 l 674 886 l 217 886 l 217 561 l 590 561 l 590 475 l 217 475 l 217 86 l 688 86 l 688 0 l 125 0 l 125 972 m 642 -235 q 562 -206 592 -235 q 532 -128 532 -176 q 550 -59 532 -93 q 601 0 568 -25 l 688 0 q 628 -62 646 -37 q 610 -111 610 -86 q 622 -145 610 -133 q 656 -157 635 -157 q 693 -146 676 -157 l 715 -215 q 681 -231 697 -226 q 642 -235 665 -235 z "
    },
    "ę": {
      "ha": 751,
      "x_min": 67,
      "x_max": 685,
      "o": "m 378 -11 q 215 35 286 -11 q 106 164 144 82 q 67 350 67 246 q 106 536 67 454 q 215 665 144 618 q 378 711 286 711 q 537 671 467 711 q 646 558 607 631 q 685 389 685 485 l 685 350 l 157 350 q 216 147 157 225 q 378 69 275 69 q 506 104 457 69 q 593 219 554 139 l 669 182 q 547 33 617 78 q 378 -11 478 -11 m 596 431 q 527 577 583 524 q 378 631 471 631 q 237 575 293 631 q 163 431 181 519 l 596 431 m 425 -235 q 345 -206 375 -235 q 315 -128 315 -176 q 333 -59 315 -93 q 385 0 351 -25 l 471 0 q 411 -62 429 -37 q 393 -111 393 -86 q 406 -145 393 -133 q 439 -157 418 -157 q 476 -146 460 -157 l 499 -215 q 465 -231 481 -226 q 425 -235 449 -235 z "
    },
    "Ě": {
      "ha": 765,
      "x_min": 125,
      "x_max": 688,
      "o": "m 125 972 l 674 972 l 674 886 l 217 886 l 217 561 l 590 561 l 590 475 l 217 475 l 217 86 l 688 86 l 688 0 l 125 0 l 125 972 m 210 1244 l 310 1244 l 411 1136 l 513 1244 l 613 1244 l 426 1050 l 396 1050 l 210 1244 z "
    },
    "ě": {
      "ha": 751,
      "x_min": 67,
      "x_max": 685,
      "o": "m 378 -11 q 215 35 286 -11 q 106 164 144 82 q 67 350 67 246 q 106 536 67 454 q 215 665 144 618 q 378 711 286 711 q 537 671 467 711 q 646 558 607 631 q 685 389 685 485 l 685 350 l 157 350 q 216 147 157 225 q 378 69 275 69 q 506 104 457 69 q 593 219 554 139 l 669 182 q 547 33 617 78 q 378 -11 478 -11 m 596 431 q 527 577 583 524 q 378 631 471 631 q 237 575 293 631 q 163 431 181 519 l 596 431 m 176 972 l 276 972 l 378 864 l 479 972 l 579 972 l 393 778 l 363 778 l 176 972 z "
    },
    "Ĝ": {
      "ha": 965,
      "x_min": 72,
      "x_max": 879,
      "o": "m 499 -11 q 288 46 385 -11 q 131 215 190 103 q 72 486 72 326 q 131 758 72 646 q 288 926 190 869 q 499 983 385 983 q 740 908 642 983 q 874 700 838 832 l 783 675 q 677 840 750 782 q 499 897 604 897 q 327 849 401 897 q 210 709 253 801 q 168 486 168 617 q 210 263 168 356 q 327 123 253 171 q 499 75 401 75 q 712 159 638 75 q 788 404 786 243 l 563 404 l 563 490 l 879 490 l 879 0 l 799 0 l 788 150 q 672 32 749 75 q 499 -11 594 -11 m 483 1244 l 514 1244 l 700 1050 l 600 1050 l 499 1158 l 397 1050 l 297 1050 l 483 1244 z "
    },
    "ĝ": {
      "ha": 668,
      "x_min": 56,
      "x_max": 632,
      "o": "m 344 -294 q 133 -233 211 -294 q 56 -64 56 -172 q 76 22 56 -15 q 128 83 96 60 q 72 197 72 117 q 96 272 72 239 q 158 322 119 304 q 119 392 133 353 q 106 476 106 432 q 137 599 106 546 q 222 682 168 653 q 343 711 276 711 q 464 679 407 711 l 589 750 l 629 676 l 532 622 q 581 476 581 560 q 549 353 581 407 q 464 271 518 300 q 343 242 410 242 q 213 275 268 242 q 156 197 156 250 q 180 147 156 163 q 242 131 204 131 l 422 131 q 575 85 518 131 q 632 -53 632 40 q 553 -235 632 -176 q 344 -294 475 -294 m 343 317 q 451 360 407 317 q 494 476 494 403 q 451 593 494 550 q 343 636 407 636 q 235 593 279 636 q 192 476 192 550 q 235 360 192 403 q 343 317 279 317 m 344 -217 q 496 -174 443 -217 q 549 -64 549 -132 q 413 56 549 56 l 269 56 q 201 60 232 56 q 139 -67 139 19 q 191 -176 139 -136 q 344 -217 243 -217 m 329 972 l 360 972 l 546 778 l 446 778 l 344 886 l 243 778 l 143 778 l 329 972 z "
    },
    "Ğ": {
      "ha": 965,
      "x_min": 72,
      "x_max": 879,
      "o": "m 499 -11 q 288 46 385 -11 q 131 215 190 103 q 72 486 72 326 q 131 758 72 646 q 288 926 190 869 q 499 983 385 983 q 740 908 642 983 q 874 700 838 832 l 783 675 q 677 840 750 782 q 499 897 604 897 q 327 849 401 897 q 210 709 253 801 q 168 486 168 617 q 210 263 168 356 q 327 123 253 171 q 499 75 401 75 q 712 159 638 75 q 788 404 786 243 l 563 404 l 563 490 l 879 490 l 879 0 l 799 0 l 788 150 q 672 32 749 75 q 499 -11 594 -11 m 499 1093 q 392 1135 432 1093 q 353 1244 353 1176 l 424 1244 q 443 1185 424 1208 q 499 1163 463 1163 q 555 1185 536 1163 q 574 1244 574 1207 l 644 1244 q 606 1135 644 1176 q 499 1093 567 1093 z "
    },
    "ğ": {
      "ha": 668,
      "x_min": 56,
      "x_max": 632,
      "o": "m 344 -294 q 133 -233 211 -294 q 56 -64 56 -172 q 76 22 56 -15 q 128 83 96 60 q 72 197 72 117 q 96 272 72 239 q 158 322 119 304 q 119 392 133 353 q 106 476 106 432 q 137 599 106 546 q 222 682 168 653 q 343 711 276 711 q 464 679 407 711 l 589 750 l 629 676 l 532 622 q 581 476 581 560 q 549 353 581 407 q 464 271 518 300 q 343 242 410 242 q 213 275 268 242 q 156 197 156 250 q 180 147 156 163 q 242 131 204 131 l 422 131 q 575 85 518 131 q 632 -53 632 40 q 553 -235 632 -176 q 344 -294 475 -294 m 343 317 q 451 360 407 317 q 494 476 494 403 q 451 593 494 550 q 343 636 407 636 q 235 593 279 636 q 192 476 192 550 q 235 360 192 403 q 343 317 279 317 m 344 -217 q 496 -174 443 -217 q 549 -64 549 -132 q 413 56 549 56 l 269 56 q 201 60 232 56 q 139 -67 139 19 q 191 -176 139 -136 q 344 -217 243 -217 m 344 821 q 238 863 278 821 q 199 972 199 904 l 269 972 q 289 913 269 936 q 344 890 308 890 q 401 913 382 890 q 419 972 419 935 l 490 972 q 451 863 490 904 q 344 821 413 821 z "
    },
    "Ġ": {
      "ha": 965,
      "x_min": 72,
      "x_max": 879,
      "o": "m 499 -11 q 288 46 385 -11 q 131 215 190 103 q 72 486 72 326 q 131 758 72 646 q 288 926 190 869 q 499 983 385 983 q 740 908 642 983 q 874 700 838 832 l 783 675 q 677 840 750 782 q 499 897 604 897 q 327 849 401 897 q 210 709 253 801 q 168 486 168 617 q 210 263 168 356 q 327 123 253 171 q 499 75 401 75 q 712 159 638 75 q 788 404 786 243 l 563 404 l 563 490 l 879 490 l 879 0 l 799 0 l 788 150 q 672 32 749 75 q 499 -11 594 -11 m 499 1103 q 448 1123 468 1103 q 428 1174 428 1143 q 448 1224 428 1204 q 499 1244 468 1244 q 549 1224 529 1244 q 569 1174 569 1204 q 549 1123 569 1143 q 499 1103 529 1103 z "
    },
    "ġ": {
      "ha": 668,
      "x_min": 56,
      "x_max": 632,
      "o": "m 344 -294 q 133 -233 211 -294 q 56 -64 56 -172 q 76 22 56 -15 q 128 83 96 60 q 72 197 72 117 q 96 272 72 239 q 158 322 119 304 q 119 392 133 353 q 106 476 106 432 q 137 599 106 546 q 222 682 168 653 q 343 711 276 711 q 464 679 407 711 l 589 750 l 629 676 l 532 622 q 581 476 581 560 q 549 353 581 407 q 464 271 518 300 q 343 242 410 242 q 213 275 268 242 q 156 197 156 250 q 180 147 156 163 q 242 131 204 131 l 422 131 q 575 85 518 131 q 632 -53 632 40 q 553 -235 632 -176 q 344 -294 475 -294 m 343 317 q 451 360 407 317 q 494 476 494 403 q 451 593 494 550 q 343 636 407 636 q 235 593 279 636 q 192 476 192 550 q 235 360 192 403 q 343 317 279 317 m 344 -217 q 496 -174 443 -217 q 549 -64 549 -132 q 413 56 549 56 l 269 56 q 201 60 232 56 q 139 -67 139 19 q 191 -176 139 -136 q 344 -217 243 -217 m 344 831 q 294 851 314 831 q 274 901 274 871 q 294 952 274 932 q 344 972 314 972 q 395 952 375 972 q 415 901 415 932 q 395 851 415 871 q 344 831 375 831 z "
    },
    "Ģ": {
      "ha": 965,
      "x_min": 72,
      "x_max": 879,
      "o": "m 499 -11 q 288 46 385 -11 q 131 215 190 103 q 72 486 72 326 q 131 758 72 646 q 288 926 190 869 q 499 983 385 983 q 740 908 642 983 q 874 700 838 832 l 783 675 q 677 840 750 782 q 499 897 604 897 q 327 849 401 897 q 210 709 253 801 q 168 486 168 617 q 210 263 168 356 q 327 123 253 171 q 499 75 401 75 q 712 159 638 75 q 788 404 786 243 l 563 404 l 563 490 l 879 490 l 879 0 l 799 0 l 788 150 q 672 32 749 75 q 499 -11 594 -11 m 449 -72 l 571 -72 l 444 -303 l 392 -303 l 449 -72 z "
    },
    "ģ": {
      "ha": 668,
      "x_min": 56,
      "x_max": 632,
      "o": "m 344 -294 q 133 -233 211 -294 q 56 -64 56 -172 q 76 22 56 -15 q 128 83 96 60 q 72 197 72 117 q 96 272 72 239 q 158 322 119 304 q 119 392 133 353 q 106 476 106 432 q 137 599 106 546 q 222 682 168 653 q 343 711 276 711 q 464 679 407 711 l 589 750 l 629 676 l 532 622 q 581 476 581 560 q 549 353 581 407 q 464 271 518 300 q 343 242 410 242 q 213 275 268 242 q 156 197 156 250 q 180 147 156 163 q 242 131 204 131 l 422 131 q 575 85 518 131 q 632 -53 632 40 q 553 -235 632 -176 q 344 -294 475 -294 m 343 317 q 451 360 407 317 q 494 476 494 403 q 451 593 494 550 q 343 636 407 636 q 235 593 279 636 q 192 476 192 550 q 235 360 192 403 q 343 317 279 317 m 344 -217 q 496 -174 443 -217 q 549 -64 549 -132 q 413 56 549 56 l 269 56 q 201 60 232 56 q 139 -67 139 19 q 191 -176 139 -136 q 344 -217 243 -217 m 397 1014 l 461 1014 l 404 814 l 285 814 l 397 1014 z "
    },
    "Ĥ": {
      "ha": 928,
      "x_min": 125,
      "x_max": 803,
      "o": "m 125 972 l 217 972 l 217 561 l 711 561 l 711 972 l 803 972 l 803 0 l 711 0 l 711 475 l 217 475 l 217 0 l 125 0 l 125 972 m 449 1244 l 479 1244 l 665 1050 l 565 1050 l 464 1158 l 363 1050 l 263 1050 l 449 1244 z "
    },
    "ĥ": {
      "ha": 771,
      "x_min": 97,
      "x_max": 663,
      "o": "m 108 983 l 194 983 l 194 547 q 299 669 229 628 q 444 711 368 711 q 605 651 547 711 q 663 481 663 590 l 663 0 l 576 0 l 576 469 q 539 588 576 546 q 431 631 501 631 q 313 590 367 631 q 226 473 258 549 q 194 299 194 397 l 194 0 l 108 0 l 108 983 m 283 1244 l 314 1244 l 500 1050 l 400 1050 l 299 1158 l 197 1050 l 97 1050 l 283 1244 z "
    },
    "Ħ": {
      "ha": 928,
      "x_min": 29,
      "x_max": 899,
      "o": "m 125 972 l 217 972 l 217 561 l 711 561 l 711 972 l 803 972 l 803 0 l 711 0 l 711 475 l 217 475 l 217 0 l 125 0 l 125 972 m 29 807 l 899 807 l 899 726 l 29 726 l 29 807 z "
    },
    "ħ": {
      "ha": 771,
      "x_min": 7,
      "x_max": 663,
      "o": "m 108 983 l 194 983 l 194 547 q 299 669 229 628 q 444 711 368 711 q 605 651 547 711 q 663 481 663 590 l 663 0 l 576 0 l 576 469 q 539 588 576 546 q 431 631 501 631 q 313 590 367 631 q 226 473 258 549 q 194 299 194 397 l 194 0 l 108 0 l 108 983 m 7 881 l 382 881 l 382 803 l 7 803 l 7 881 z "
    },
    "Ĩ": {
      "ha": 342,
      "x_min": -64,
      "x_max": 404,
      "o": "m 125 972 l 217 972 l 217 0 l 125 0 l 125 972 m -64 1131 q -3 1200 -39 1174 q 74 1226 33 1226 q 131 1218 107 1226 q 181 1194 154 1210 q 220 1175 206 1181 q 256 1169 235 1169 q 342 1226 300 1169 l 404 1176 q 343 1107 379 1133 q 267 1081 307 1081 q 210 1089 233 1081 q 160 1113 186 1097 q 119 1132 135 1126 q 85 1138 104 1138 q -1 1081 40 1138 l -64 1131 z "
    },
    "ĩ": {
      "ha": 303,
      "x_min": -83,
      "x_max": 385,
      "o": "m 108 700 l 194 700 l 194 0 l 108 0 l 108 700 m -83 858 q -22 928 -58 901 q 54 954 14 954 q 111 946 88 954 q 161 922 135 938 q 201 903 186 908 q 236 897 217 897 q 322 954 281 897 l 385 904 q 324 835 360 861 q 247 808 288 808 q 190 817 214 808 q 140 840 167 825 q 100 860 115 854 q 65 865 85 865 q -21 808 21 865 l -83 858 z "
    },
    "Ī": {
      "ha": 342,
      "x_min": 3,
      "x_max": 338,
      "o": "m 125 972 l 217 972 l 217 0 l 125 0 l 125 972 m 3 1189 l 338 1189 l 338 1111 l 3 1111 l 3 1189 z "
    },
    "ī": {
      "ha": 303,
      "x_min": -17,
      "x_max": 318,
      "o": "m 108 700 l 194 700 l 194 0 l 108 0 l 108 700 m -17 917 l 318 917 l 318 839 l -17 839 l -17 917 z "
    },
    "Ĭ": {
      "ha": 342,
      "x_min": 25,
      "x_max": 317,
      "o": "m 125 972 l 217 972 l 217 0 l 125 0 l 125 972 m 171 1093 q 65 1135 104 1093 q 25 1244 25 1176 l 96 1244 q 115 1185 96 1208 q 171 1163 135 1163 q 227 1185 208 1163 q 246 1244 246 1207 l 317 1244 q 278 1135 317 1176 q 171 1093 239 1093 z "
    },
    "ĭ": {
      "ha": 303,
      "x_min": 6,
      "x_max": 297,
      "o": "m 108 700 l 194 700 l 194 0 l 108 0 l 108 700 m 151 821 q 45 863 85 821 q 6 972 6 904 l 76 972 q 96 913 76 936 q 151 890 115 890 q 208 913 189 890 q 226 972 226 935 l 297 972 q 258 863 297 904 q 151 821 219 821 z "
    },
    "Į": {
      "ha": 342,
      "x_min": 61,
      "x_max": 244,
      "o": "m 125 972 l 217 972 l 217 0 l 125 0 l 125 972 m 171 -235 q 91 -206 121 -235 q 61 -128 61 -176 q 79 -59 61 -93 q 131 0 97 -25 l 217 0 q 157 -62 175 -37 q 139 -111 139 -86 q 151 -145 139 -133 q 185 -157 164 -157 q 222 -146 206 -157 l 244 -215 q 210 -231 226 -226 q 171 -235 194 -235 z "
    },
    "į": {
      "ha": 303,
      "x_min": 39,
      "x_max": 222,
      "o": "m 108 700 l 194 700 l 194 0 l 108 0 l 108 700 m 151 831 q 101 851 121 831 q 81 901 81 871 q 101 952 81 932 q 151 972 121 972 q 202 952 182 972 q 222 901 222 932 q 202 851 222 871 q 151 831 182 831 m 149 -235 q 69 -206 99 -235 q 39 -128 39 -176 q 57 -59 39 -93 q 108 0 75 -25 l 194 0 q 135 -62 153 -37 q 117 -111 117 -86 q 129 -145 117 -133 q 163 -157 142 -157 q 200 -146 183 -157 l 222 -215 q 188 -231 204 -226 q 149 -235 172 -235 z "
    },
    "İ": {
      "ha": 342,
      "x_min": 100,
      "x_max": 242,
      "o": "m 125 972 l 217 972 l 217 0 l 125 0 l 125 972 m 171 1103 q 120 1123 140 1103 q 100 1174 100 1143 q 120 1224 100 1204 q 171 1244 140 1244 q 222 1224 201 1244 q 242 1174 242 1204 q 222 1123 242 1143 q 171 1103 201 1103 z "
    },
    "ı": {
      "ha": 303,
      "x_min": 108,
      "x_max": 194,
      "o": "m 108 700 l 194 700 l 194 0 l 108 0 l 108 700 z "
    },
    "Ĳ": {
      "ha": 1040,
      "x_min": 125,
      "x_max": 932,
      "o": "m 125 972 l 217 972 l 217 0 l 125 0 l 125 972 m 658 -11 q 467 60 536 -11 q 383 238 399 132 l 478 258 q 535 124 490 172 q 658 75 579 75 q 790 125 739 75 q 840 275 840 175 l 840 972 l 932 972 l 932 285 q 894 124 932 192 q 794 23 857 57 q 658 -11 732 -11 z "
    },
    "ĳ": {
      "ha": 606,
      "x_min": 81,
      "x_max": 525,
      "o": "m 151 831 q 101 851 121 831 q 81 901 81 871 q 101 952 81 932 q 151 972 121 972 q 202 952 182 972 q 222 901 222 932 q 202 851 222 871 q 151 831 182 831 m 108 700 l 194 700 l 194 0 l 108 0 l 108 700 m 454 831 q 403 851 424 831 q 383 901 383 871 q 403 952 383 932 q 454 972 424 972 q 505 952 485 972 q 525 901 525 932 q 505 851 525 871 q 454 831 485 831 m 304 -214 q 386 -167 361 -197 q 411 -76 411 -137 l 411 700 l 497 700 l 497 -89 q 324 -294 497 -267 l 304 -214 z "
    },
    "Ĵ": {
      "ha": 699,
      "x_min": 42,
      "x_max": 744,
      "o": "m 317 -11 q 126 60 194 -11 q 42 238 57 132 l 136 258 q 193 124 149 172 q 317 75 238 75 q 448 125 397 75 q 499 275 499 175 l 499 972 l 590 972 l 590 285 q 553 124 590 192 q 453 23 515 57 q 317 -11 390 -11 m 528 1244 l 558 1244 l 744 1050 l 644 1050 l 543 1158 l 442 1050 l 342 1050 l 528 1244 z "
    },
    "ĵ": {
      "ha": 303,
      "x_min": -50,
      "x_max": 353,
      "o": "m 1 -214 q 83 -167 58 -197 q 108 -76 108 -137 l 108 700 l 194 700 l 194 -89 q 21 -294 194 -267 l 1 -214 m 136 972 l 167 972 l 353 778 l 253 778 l 151 886 l 50 778 l -50 778 l 136 972 z "
    },
    "Ķ": {
      "ha": 769,
      "x_min": 125,
      "x_max": 747,
      "o": "m 125 972 l 217 972 l 217 557 l 596 972 l 713 972 l 314 536 l 747 0 l 635 0 l 217 515 l 217 0 l 125 0 l 125 972 m 353 -72 l 475 -72 l 349 -303 l 296 -303 l 353 -72 z "
    },
    "ķ": {
      "ha": 638,
      "x_min": 108,
      "x_max": 621,
      "o": "m 108 983 l 194 983 l 194 390 l 488 700 l 596 700 l 293 379 l 621 0 l 511 0 l 194 368 l 194 0 l 108 0 l 108 983 m 274 -72 l 396 -72 l 269 -303 l 217 -303 l 274 -72 z "
    },
    "ĸ": {
      "ha": 638,
      "x_min": 108,
      "x_max": 621,
      "o": "m 108 700 l 194 700 l 194 390 l 488 700 l 596 700 l 293 379 l 621 0 l 511 0 l 194 368 l 194 0 l 108 0 l 108 700 z "
    },
    "Ĺ": {
      "ha": 728,
      "x_min": 125,
      "x_max": 672,
      "o": "m 125 972 l 217 972 l 217 86 l 672 86 l 672 0 l 125 0 l 125 972 m 233 1244 l 363 1244 l 206 1050 l 136 1050 l 233 1244 z "
    },
    "ĺ": {
      "ha": 303,
      "x_min": 108,
      "x_max": 343,
      "o": "m 108 983 l 194 983 l 194 0 l 108 0 l 108 983 m 214 1244 l 343 1244 l 186 1050 l 117 1050 l 214 1244 z "
    },
    "Ļ": {
      "ha": 728,
      "x_min": 125,
      "x_max": 672,
      "o": "m 125 972 l 217 972 l 217 86 l 672 86 l 672 0 l 125 0 l 125 972 m 333 -72 l 456 -72 l 329 -303 l 276 -303 l 333 -72 z "
    },
    "ļ": {
      "ha": 303,
      "x_min": 33,
      "x_max": 213,
      "o": "m 108 983 l 194 983 l 194 0 l 108 0 l 108 983 m 90 -72 l 213 -72 l 86 -303 l 33 -303 l 90 -72 z "
    },
    "Ľ": {
      "ha": 728,
      "x_min": 125,
      "x_max": 672,
      "o": "m 125 972 l 217 972 l 217 86 l 672 86 l 672 0 l 125 0 l 125 972 m 554 983 l 664 983 l 572 753 l 513 753 l 554 983 z "
    },
    "ľ": {
      "ha": 467,
      "x_min": 108,
      "x_max": 467,
      "o": "m 108 983 l 194 983 l 194 0 l 108 0 l 108 983 m 357 983 l 467 983 l 375 753 l 315 753 l 357 983 z "
    },
    "Ŀ": {
      "ha": 728,
      "x_min": 125,
      "x_max": 672,
      "o": "m 125 972 l 217 972 l 217 86 l 672 86 l 672 0 l 125 0 l 125 972 m 542 414 q 491 434 511 414 q 471 485 471 454 q 491 535 471 515 q 542 556 511 556 q 592 535 572 556 q 613 485 613 515 q 592 434 613 454 q 542 414 572 414 z "
    },
    "ŀ": {
      "ha": 578,
      "x_min": 108,
      "x_max": 519,
      "o": "m 108 983 l 194 983 l 194 0 l 108 0 l 108 983 m 449 414 q 398 434 418 414 q 378 485 378 454 q 398 535 378 515 q 449 556 418 556 q 499 535 479 556 q 519 485 519 515 q 499 434 519 454 q 449 414 479 414 z "
    },
    "Ł": {
      "ha": 783,
      "x_min": 24,
      "x_max": 728,
      "o": "m 181 972 l 272 972 l 272 86 l 728 86 l 728 0 l 181 0 l 181 972 m 24 346 l 426 579 l 464 514 l 57 281 l 24 346 z "
    },
    "ł": {
      "ha": 303,
      "x_min": -36,
      "x_max": 339,
      "o": "m 108 983 l 194 983 l 194 0 l 108 0 l 108 983 m -36 425 l 301 613 l 339 547 l 1 360 l -36 425 z "
    },
    "Ń": {
      "ha": 932,
      "x_min": 125,
      "x_max": 807,
      "o": "m 125 972 l 233 972 l 715 146 l 715 972 l 807 972 l 807 0 l 699 0 l 217 824 l 217 0 l 125 0 l 125 972 m 529 1244 l 658 1244 l 501 1050 l 432 1050 l 529 1244 z "
    },
    "ń": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 108 700 l 194 700 l 194 554 q 295 668 231 625 q 435 711 360 711 q 592 651 535 711 q 650 481 650 590 l 650 0 l 564 0 l 564 469 q 528 589 564 547 q 421 631 493 631 q 306 591 357 631 q 224 478 254 551 q 194 307 194 404 l 194 0 l 108 0 l 108 700 m 457 972 l 586 972 l 429 778 l 360 778 l 457 972 z "
    },
    "Ņ": {
      "ha": 932,
      "x_min": 125,
      "x_max": 807,
      "o": "m 125 972 l 233 972 l 715 146 l 715 972 l 807 972 l 807 0 l 699 0 l 217 824 l 217 0 l 125 0 l 125 972 m 406 -72 l 528 -72 l 401 -303 l 349 -303 l 406 -72 z "
    },
    "ņ": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 108 700 l 194 700 l 194 554 q 295 668 231 625 q 435 711 360 711 q 592 651 535 711 q 650 481 650 590 l 650 0 l 564 0 l 564 469 q 528 589 564 547 q 421 631 493 631 q 306 591 357 631 q 224 478 254 551 q 194 307 194 404 l 194 0 l 108 0 l 108 700 m 318 -72 l 440 -72 l 314 -303 l 261 -303 l 318 -72 z "
    },
    "Ň": {
      "ha": 932,
      "x_min": 125,
      "x_max": 807,
      "o": "m 125 972 l 233 972 l 715 146 l 715 972 l 807 972 l 807 0 l 699 0 l 217 824 l 217 0 l 125 0 l 125 972 m 265 1244 l 365 1244 l 467 1136 l 568 1244 l 668 1244 l 482 1050 l 451 1050 l 265 1244 z "
    },
    "ň": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 108 700 l 194 700 l 194 554 q 295 668 231 625 q 435 711 360 711 q 592 651 535 711 q 650 481 650 590 l 650 0 l 564 0 l 564 469 q 528 589 564 547 q 421 631 493 631 q 306 591 357 631 q 224 478 254 551 q 194 307 194 404 l 194 0 l 108 0 l 108 700 m 193 972 l 293 972 l 394 864 l 496 972 l 596 972 l 410 778 l 379 778 l 193 972 z "
    },
    "Ŋ": {
      "ha": 932,
      "x_min": 125,
      "x_max": 807,
      "o": "m 546 -208 q 715 -8 715 -208 l 715 0 l 217 824 l 217 0 l 125 0 l 125 972 l 233 972 l 715 171 l 715 972 l 807 972 l 807 1 q 736 -221 807 -147 q 546 -294 665 -294 l 546 -208 z "
    },
    "ŋ": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 457 -214 q 539 -167 514 -197 q 564 -76 564 -137 l 564 469 q 528 589 564 547 q 421 631 493 631 q 306 591 357 631 q 224 478 254 551 q 194 307 194 404 l 194 0 l 108 0 l 108 700 l 194 700 l 194 554 q 295 668 231 625 q 435 711 360 711 q 592 651 535 711 q 650 481 650 590 l 650 -89 q 476 -294 650 -267 l 457 -214 z "
    },
    "Ō": {
      "ha": 997,
      "x_min": 72,
      "x_max": 925,
      "o": "m 499 -11 q 286 50 383 -11 q 131 224 189 111 q 72 486 72 336 q 131 749 72 636 q 286 922 189 861 q 499 983 383 983 q 711 922 614 983 q 867 749 808 861 q 925 486 925 636 q 867 224 925 336 q 711 50 808 111 q 499 -11 614 -11 m 499 75 q 667 122 592 75 q 785 262 742 169 q 829 486 829 354 q 785 710 829 618 q 667 850 742 803 q 499 897 592 897 q 331 850 406 897 q 212 710 256 803 q 168 486 168 618 q 212 262 168 354 q 331 122 256 169 q 499 75 406 75 m 331 1189 l 665 1189 l 665 1111 l 331 1111 l 331 1189 z "
    },
    "ō": {
      "ha": 789,
      "x_min": 67,
      "x_max": 722,
      "o": "m 394 -11 q 222 40 296 -11 q 107 174 147 90 q 67 350 67 257 q 107 526 67 443 q 222 660 147 610 q 394 711 296 711 q 567 660 493 711 q 682 526 642 610 q 722 350 722 443 q 682 174 722 257 q 567 40 642 90 q 394 -11 493 -11 m 394 69 q 523 109 469 69 q 604 213 576 149 q 632 350 632 278 q 604 487 632 422 q 523 591 576 551 q 394 631 469 631 q 266 591 319 631 q 185 487 213 551 q 157 350 157 422 q 185 213 157 278 q 266 109 213 149 q 394 69 319 69 m 226 917 l 561 917 l 561 839 l 226 839 l 226 917 z "
    },
    "Ŏ": {
      "ha": 997,
      "x_min": 72,
      "x_max": 925,
      "o": "m 499 -11 q 286 50 383 -11 q 131 224 189 111 q 72 486 72 336 q 131 749 72 636 q 286 922 189 861 q 499 983 383 983 q 711 922 614 983 q 867 749 808 861 q 925 486 925 636 q 867 224 925 336 q 711 50 808 111 q 499 -11 614 -11 m 499 75 q 667 122 592 75 q 785 262 742 169 q 829 486 829 354 q 785 710 829 618 q 667 850 742 803 q 499 897 592 897 q 331 850 406 897 q 212 710 256 803 q 168 486 168 618 q 212 262 168 354 q 331 122 256 169 q 499 75 406 75 m 499 1093 q 392 1135 432 1093 q 353 1244 353 1176 l 424 1244 q 443 1185 424 1208 q 499 1163 463 1163 q 555 1185 536 1163 q 574 1244 574 1207 l 644 1244 q 606 1135 644 1176 q 499 1093 567 1093 z "
    },
    "ŏ": {
      "ha": 789,
      "x_min": 67,
      "x_max": 722,
      "o": "m 394 -11 q 222 40 296 -11 q 107 174 147 90 q 67 350 67 257 q 107 526 67 443 q 222 660 147 610 q 394 711 296 711 q 567 660 493 711 q 682 526 642 610 q 722 350 722 443 q 682 174 722 257 q 567 40 642 90 q 394 -11 493 -11 m 394 69 q 523 109 469 69 q 604 213 576 149 q 632 350 632 278 q 604 487 632 422 q 523 591 576 551 q 394 631 469 631 q 266 591 319 631 q 185 487 213 551 q 157 350 157 422 q 185 213 157 278 q 266 109 213 149 q 394 69 319 69 m 394 821 q 288 863 328 821 q 249 972 249 904 l 319 972 q 339 913 319 936 q 394 890 358 890 q 451 913 432 890 q 469 972 469 935 l 540 972 q 501 863 540 904 q 394 821 463 821 z "
    },
    "Ő": {
      "ha": 997,
      "x_min": 72,
      "x_max": 925,
      "o": "m 499 -11 q 286 50 383 -11 q 131 224 189 111 q 72 486 72 336 q 131 749 72 636 q 286 922 189 861 q 499 983 383 983 q 711 922 614 983 q 867 749 808 861 q 925 486 925 636 q 867 224 925 336 q 711 50 808 111 q 499 -11 614 -11 m 499 75 q 667 122 592 75 q 785 262 742 169 q 829 486 829 354 q 785 710 829 618 q 667 850 742 803 q 499 897 592 897 q 331 850 406 897 q 212 710 256 803 q 168 486 168 618 q 212 262 168 354 q 331 122 256 169 q 499 75 406 75 m 456 1244 l 585 1244 l 426 1050 l 358 1050 l 456 1244 m 667 1244 l 796 1244 l 638 1050 l 569 1050 l 667 1244 z "
    },
    "ő": {
      "ha": 789,
      "x_min": 67,
      "x_max": 722,
      "o": "m 394 -11 q 222 40 296 -11 q 107 174 147 90 q 67 350 67 257 q 107 526 67 443 q 222 660 147 610 q 394 711 296 711 q 567 660 493 711 q 682 526 642 610 q 722 350 722 443 q 682 174 722 257 q 567 40 642 90 q 394 -11 493 -11 m 394 69 q 523 109 469 69 q 604 213 576 149 q 632 350 632 278 q 604 487 632 422 q 523 591 576 551 q 394 631 469 631 q 266 591 319 631 q 185 487 213 551 q 157 350 157 422 q 185 213 157 278 q 266 109 213 149 q 394 69 319 69 m 324 972 l 453 972 l 294 778 l 226 778 l 324 972 m 535 972 l 664 972 l 506 778 l 438 778 l 535 972 z "
    },
    "Œ": {
      "ha": 1474,
      "x_min": 72,
      "x_max": 1396,
      "o": "m 499 -11 q 286 50 383 -11 q 131 224 189 111 q 72 486 72 336 q 131 749 72 636 q 286 922 189 861 q 499 983 383 983 q 687 937 599 983 q 833 806 775 890 l 833 972 l 1382 972 l 1382 886 l 925 886 l 925 561 l 1299 561 l 1299 475 l 925 475 l 925 86 l 1396 86 l 1396 0 l 833 0 l 833 167 q 687 35 775 82 q 499 -11 599 -11 m 499 75 q 667 122 592 75 q 785 262 742 169 q 829 486 829 354 q 785 710 829 618 q 667 850 742 803 q 499 897 592 897 q 331 850 406 897 q 212 710 256 803 q 168 486 168 618 q 212 262 168 354 q 331 122 256 169 q 499 75 406 75 z "
    },
    "œ": {
      "ha": 1317,
      "x_min": 67,
      "x_max": 1250,
      "o": "m 394 -11 q 222 40 296 -11 q 107 174 147 90 q 67 350 67 257 q 107 526 67 443 q 222 660 147 610 q 394 711 296 711 q 559 665 488 711 q 674 542 631 619 q 783 666 713 621 q 943 711 853 711 q 1102 671 1032 711 q 1211 558 1172 631 q 1250 389 1250 485 l 1250 350 l 722 350 q 784 142 725 214 q 943 69 843 69 q 1072 105 1021 69 q 1157 214 1122 140 l 1235 182 q 1113 33 1182 78 q 943 -11 1043 -11 q 783 34 853 -11 q 674 158 713 79 q 559 35 631 81 q 394 -11 488 -11 m 394 69 q 523 109 469 69 q 604 213 576 149 q 632 350 632 278 q 604 487 632 422 q 523 591 576 551 q 394 631 469 631 q 266 591 319 631 q 185 487 213 551 q 157 350 157 422 q 185 213 157 278 q 266 109 213 149 q 394 69 319 69 m 1161 431 q 1092 577 1149 524 q 943 631 1036 631 q 803 575 858 631 q 729 431 747 519 l 1161 431 z "
    },
    "Ŕ": {
      "ha": 853,
      "x_min": 125,
      "x_max": 806,
      "o": "m 125 972 l 438 972 q 642 910 569 972 q 715 726 715 849 q 660 560 715 621 q 503 485 604 499 l 806 0 l 703 0 l 399 481 l 217 481 l 217 0 l 125 0 l 125 972 m 432 567 q 575 606 528 567 q 622 726 622 644 q 575 847 622 808 q 432 886 528 886 l 217 886 l 217 567 l 432 567 m 400 1244 l 529 1244 l 372 1050 l 303 1050 l 400 1244 z "
    },
    "ŕ": {
      "ha": 528,
      "x_min": 108,
      "x_max": 506,
      "o": "m 108 700 l 194 700 l 194 575 q 278 676 226 640 q 400 711 331 711 q 452 706 428 711 q 506 688 476 700 l 486 606 q 388 631 440 631 q 290 590 333 631 q 220 467 246 549 q 194 271 194 386 l 194 0 l 108 0 l 108 700 m 347 972 l 476 972 l 319 778 l 250 778 l 347 972 z "
    },
    "Ŗ": {
      "ha": 853,
      "x_min": 125,
      "x_max": 806,
      "o": "m 125 972 l 438 972 q 642 910 569 972 q 715 726 715 849 q 660 560 715 621 q 503 485 604 499 l 806 0 l 703 0 l 399 481 l 217 481 l 217 0 l 125 0 l 125 972 m 432 567 q 575 606 528 567 q 622 726 622 644 q 575 847 622 808 q 432 886 528 886 l 217 886 l 217 567 l 432 567 m 371 -72 l 493 -72 l 367 -303 l 314 -303 l 371 -72 z "
    },
    "ŗ": {
      "ha": 528,
      "x_min": 33,
      "x_max": 506,
      "o": "m 108 700 l 194 700 l 194 575 q 278 676 226 640 q 400 711 331 711 q 452 706 428 711 q 506 688 476 700 l 486 606 q 388 631 440 631 q 290 590 333 631 q 220 467 246 549 q 194 271 194 386 l 194 0 l 108 0 l 108 700 m 90 -72 l 213 -72 l 86 -303 l 33 -303 l 90 -72 z "
    },
    "Ř": {
      "ha": 853,
      "x_min": 125,
      "x_max": 806,
      "o": "m 125 972 l 438 972 q 642 910 569 972 q 715 726 715 849 q 660 560 715 621 q 503 485 604 499 l 806 0 l 703 0 l 399 481 l 217 481 l 217 0 l 125 0 l 125 972 m 432 567 q 575 606 528 567 q 622 726 622 644 q 575 847 622 808 q 432 886 528 886 l 217 886 l 217 567 l 432 567 m 136 1244 l 236 1244 l 338 1136 l 439 1244 l 539 1244 l 353 1050 l 322 1050 l 136 1244 z "
    },
    "ř": {
      "ha": 528,
      "x_min": 83,
      "x_max": 506,
      "o": "m 108 700 l 194 700 l 194 575 q 278 676 226 640 q 400 711 331 711 q 452 706 428 711 q 506 688 476 700 l 486 606 q 388 631 440 631 q 290 590 333 631 q 220 467 246 549 q 194 271 194 386 l 194 0 l 108 0 l 108 700 m 83 972 l 183 972 l 285 864 l 386 972 l 486 972 l 300 778 l 269 778 l 83 972 z "
    },
    "Ś": {
      "ha": 703,
      "x_min": 58,
      "x_max": 633,
      "o": "m 363 -11 q 219 24 283 -11 q 113 119 154 60 q 58 251 71 179 l 138 299 q 363 75 189 75 q 488 124 439 75 q 538 264 538 172 q 511 364 538 324 q 442 431 485 404 q 326 493 400 458 q 169 601 226 540 q 113 757 113 663 q 143 874 113 822 q 227 955 174 926 q 344 983 281 983 q 493 944 438 983 q 581 833 549 904 l 506 786 q 344 897 456 897 q 242 858 281 897 q 204 764 204 818 q 231 673 204 711 q 299 610 258 635 q 408 554 340 585 q 574 440 515 506 q 633 268 633 374 q 598 122 633 186 q 501 24 563 58 q 363 -11 439 -11 m 407 1244 l 536 1244 l 379 1050 l 310 1050 l 407 1244 z "
    },
    "ś": {
      "ha": 597,
      "x_min": 64,
      "x_max": 533,
      "o": "m 317 -11 q 147 44 210 -11 q 64 181 83 100 l 140 221 q 203 109 163 149 q 317 69 244 69 q 410 103 376 69 q 443 193 443 136 q 405 274 443 244 q 289 332 367 304 q 158 406 203 363 q 113 528 113 450 q 168 661 113 611 q 308 711 224 711 q 422 685 375 711 q 503 603 469 658 l 442 550 q 381 612 414 593 q 304 631 347 631 q 231 603 260 631 q 201 531 201 576 q 238 456 201 485 q 363 396 274 428 q 485 319 438 368 q 533 194 533 269 q 475 44 533 99 q 317 -11 417 -11 m 371 972 l 500 972 l 343 778 l 274 778 l 371 972 z "
    },
    "Ŝ": {
      "ha": 703,
      "x_min": 58,
      "x_max": 633,
      "o": "m 363 -11 q 219 24 283 -11 q 113 119 154 60 q 58 251 71 179 l 138 299 q 363 75 189 75 q 488 124 439 75 q 538 264 538 172 q 511 364 538 324 q 442 431 485 404 q 326 493 400 458 q 169 601 226 540 q 113 757 113 663 q 143 874 113 822 q 227 955 174 926 q 344 983 281 983 q 493 944 438 983 q 581 833 549 904 l 506 786 q 344 897 456 897 q 242 858 281 897 q 204 764 204 818 q 231 673 204 711 q 299 610 258 635 q 408 554 340 585 q 574 440 515 506 q 633 268 633 374 q 598 122 633 186 q 501 24 563 58 q 363 -11 439 -11 m 329 1244 l 360 1244 l 546 1050 l 446 1050 l 344 1158 l 243 1050 l 143 1050 l 329 1244 z "
    },
    "ŝ": {
      "ha": 597,
      "x_min": 64,
      "x_max": 533,
      "o": "m 317 -11 q 147 44 210 -11 q 64 181 83 100 l 140 221 q 203 109 163 149 q 317 69 244 69 q 410 103 376 69 q 443 193 443 136 q 405 274 443 244 q 289 332 367 304 q 158 406 203 363 q 113 528 113 450 q 168 661 113 611 q 308 711 224 711 q 422 685 375 711 q 503 603 469 658 l 442 550 q 381 612 414 593 q 304 631 347 631 q 231 603 260 631 q 201 531 201 576 q 238 456 201 485 q 363 396 274 428 q 485 319 438 368 q 533 194 533 269 q 475 44 533 99 q 317 -11 417 -11 m 293 972 l 324 972 l 510 778 l 410 778 l 308 886 l 207 778 l 107 778 l 293 972 z "
    },
    "Ş": {
      "ha": 703,
      "x_min": 58,
      "x_max": 633,
      "o": "m 363 -11 q 219 24 283 -11 q 113 119 154 60 q 58 251 71 179 l 138 299 q 363 75 189 75 q 488 124 439 75 q 538 264 538 172 q 511 364 538 324 q 442 431 485 404 q 326 493 400 458 q 169 601 226 540 q 113 757 113 663 q 143 874 113 822 q 227 955 174 926 q 344 983 281 983 q 493 944 438 983 q 581 833 549 904 l 506 786 q 344 897 456 897 q 242 858 281 897 q 204 764 204 818 q 231 673 204 711 q 299 610 258 635 q 408 554 340 585 q 574 440 515 506 q 633 268 633 374 q 598 122 633 186 q 501 24 563 58 q 363 -11 439 -11 m 188 -254 l 324 -83 l 400 -83 l 288 -297 l 188 -254 z "
    },
    "ş": {
      "ha": 597,
      "x_min": 64,
      "x_max": 533,
      "o": "m 317 -11 q 147 44 210 -11 q 64 181 83 100 l 140 221 q 203 109 163 149 q 317 69 244 69 q 410 103 376 69 q 443 193 443 136 q 405 274 443 244 q 289 332 367 304 q 158 406 203 363 q 113 528 113 450 q 168 661 113 611 q 308 711 224 711 q 422 685 375 711 q 503 603 469 658 l 442 550 q 381 612 414 593 q 304 631 347 631 q 231 603 260 631 q 201 531 201 576 q 238 456 201 485 q 363 396 274 428 q 485 319 438 368 q 533 194 533 269 q 475 44 533 99 q 317 -11 417 -11 m 138 -254 l 274 -83 l 350 -83 l 238 -297 l 138 -254 z "
    },
    "Š": {
      "ha": 703,
      "x_min": 58,
      "x_max": 633,
      "o": "m 363 -11 q 219 24 283 -11 q 113 119 154 60 q 58 251 71 179 l 138 299 q 363 75 189 75 q 488 124 439 75 q 538 264 538 172 q 511 364 538 324 q 442 431 485 404 q 326 493 400 458 q 169 601 226 540 q 113 757 113 663 q 143 874 113 822 q 227 955 174 926 q 344 983 281 983 q 493 944 438 983 q 581 833 549 904 l 506 786 q 344 897 456 897 q 242 858 281 897 q 204 764 204 818 q 231 673 204 711 q 299 610 258 635 q 408 554 340 585 q 574 440 515 506 q 633 268 633 374 q 598 122 633 186 q 501 24 563 58 q 363 -11 439 -11 m 143 1244 l 243 1244 l 344 1136 l 446 1244 l 546 1244 l 360 1050 l 329 1050 l 143 1244 z "
    },
    "š": {
      "ha": 597,
      "x_min": 64,
      "x_max": 533,
      "o": "m 317 -11 q 147 44 210 -11 q 64 181 83 100 l 140 221 q 203 109 163 149 q 317 69 244 69 q 410 103 376 69 q 443 193 443 136 q 405 274 443 244 q 289 332 367 304 q 158 406 203 363 q 113 528 113 450 q 168 661 113 611 q 308 711 224 711 q 422 685 375 711 q 503 603 469 658 l 442 550 q 381 612 414 593 q 304 631 347 631 q 231 603 260 631 q 201 531 201 576 q 238 456 201 485 q 363 396 274 428 q 485 319 438 368 q 533 194 533 269 q 475 44 533 99 q 317 -11 417 -11 m 107 972 l 207 972 l 308 864 l 410 972 l 510 972 l 324 778 l 293 778 l 107 972 z "
    },
    "Ţ": {
      "ha": 756,
      "x_min": 42,
      "x_max": 714,
      "o": "m 332 886 l 42 886 l 42 972 l 714 972 l 714 886 l 424 886 l 424 0 l 332 0 l 332 886 m 206 -254 l 342 -83 l 418 -83 l 306 -297 l 206 -254 z "
    },
    "ţ": {
      "ha": 476,
      "x_min": 17,
      "x_max": 438,
      "o": "m 315 -11 q 188 41 235 -11 q 140 199 140 93 l 140 619 l 17 619 l 17 700 l 140 700 l 140 926 l 226 983 l 226 700 l 415 700 l 415 619 l 226 619 l 226 185 q 253 99 226 128 q 326 69 281 69 q 414 92 379 69 l 438 14 q 315 -11 392 -11 m 135 -254 l 271 -83 l 347 -83 l 235 -297 l 135 -254 z "
    },
    "Ť": {
      "ha": 756,
      "x_min": 42,
      "x_max": 714,
      "o": "m 332 886 l 42 886 l 42 972 l 714 972 l 714 886 l 424 886 l 424 0 l 332 0 l 332 886 m 176 1244 l 276 1244 l 378 1136 l 479 1244 l 579 1244 l 393 1050 l 363 1050 l 176 1244 z "
    },
    "ť": {
      "ha": 476,
      "x_min": 17,
      "x_max": 507,
      "o": "m 315 -11 q 188 41 235 -11 q 140 199 140 93 l 140 619 l 17 619 l 17 700 l 140 700 l 140 926 l 226 983 l 226 700 l 415 700 l 415 619 l 226 619 l 226 185 q 253 99 226 128 q 326 69 281 69 q 414 92 379 69 l 438 14 q 315 -11 392 -11 m 397 983 l 507 983 l 415 753 l 356 753 l 397 983 z "
    },
    "Ŧ": {
      "ha": 756,
      "x_min": 42,
      "x_max": 714,
      "o": "m 332 886 l 42 886 l 42 972 l 714 972 l 714 886 l 424 886 l 424 0 l 332 0 l 332 886 m 118 529 l 638 529 l 638 443 l 118 443 l 118 529 z "
    },
    "ŧ": {
      "ha": 476,
      "x_min": 17,
      "x_max": 438,
      "o": "m 315 -11 q 188 41 235 -11 q 140 199 140 93 l 140 619 l 17 619 l 17 700 l 140 700 l 140 926 l 226 983 l 226 700 l 415 700 l 415 619 l 226 619 l 226 185 q 253 99 226 128 q 326 69 281 69 q 414 92 379 69 l 438 14 q 315 -11 392 -11 m 22 431 l 397 431 l 397 353 l 22 353 l 22 431 z "
    },
    "Ũ": {
      "ha": 883,
      "x_min": 108,
      "x_max": 775,
      "o": "m 442 -11 q 275 26 351 -11 q 153 135 199 63 q 108 311 108 208 l 108 972 l 200 972 l 200 303 q 263 140 200 206 q 442 75 325 75 q 621 140 558 75 q 683 303 683 206 l 683 972 l 775 972 l 775 311 q 730 135 775 208 q 608 26 685 63 q 442 -11 532 -11 m 207 1131 q 268 1200 232 1174 q 344 1226 304 1226 q 401 1218 378 1226 q 451 1194 425 1210 q 491 1175 476 1181 q 526 1169 506 1169 q 613 1226 571 1169 l 675 1176 q 614 1107 650 1133 q 538 1081 578 1081 q 481 1089 504 1081 q 431 1113 457 1097 q 390 1132 406 1126 q 356 1138 375 1138 q 269 1081 311 1138 l 207 1131 z "
    },
    "ũ": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 324 -11 q 166 49 224 -11 q 108 219 108 110 l 108 700 l 194 700 l 194 231 q 230 111 194 153 q 338 69 265 69 q 453 109 401 69 q 534 222 504 149 q 564 393 564 296 l 564 700 l 650 700 l 650 0 l 564 0 l 564 146 q 463 32 528 75 q 324 -11 399 -11 m 144 858 q 206 928 169 901 q 282 954 242 954 q 339 946 315 954 q 389 922 363 938 q 429 903 414 908 q 464 897 444 897 q 550 954 508 897 l 613 904 q 551 835 588 861 q 475 808 515 808 q 418 817 442 808 q 368 840 394 825 q 328 860 343 854 q 293 865 313 865 q 207 808 249 865 l 144 858 z "
    },
    "Ū": {
      "ha": 883,
      "x_min": 108,
      "x_max": 775,
      "o": "m 442 -11 q 275 26 351 -11 q 153 135 199 63 q 108 311 108 208 l 108 972 l 200 972 l 200 303 q 263 140 200 206 q 442 75 325 75 q 621 140 558 75 q 683 303 683 206 l 683 972 l 775 972 l 775 311 q 730 135 775 208 q 608 26 685 63 q 442 -11 532 -11 m 274 1189 l 608 1189 l 608 1111 l 274 1111 l 274 1189 z "
    },
    "ū": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 324 -11 q 166 49 224 -11 q 108 219 108 110 l 108 700 l 194 700 l 194 231 q 230 111 194 153 q 338 69 265 69 q 453 109 401 69 q 534 222 504 149 q 564 393 564 296 l 564 700 l 650 700 l 650 0 l 564 0 l 564 146 q 463 32 528 75 q 324 -11 399 -11 m 211 917 l 546 917 l 546 839 l 211 839 l 211 917 z "
    },
    "Ŭ": {
      "ha": 883,
      "x_min": 108,
      "x_max": 775,
      "o": "m 442 -11 q 275 26 351 -11 q 153 135 199 63 q 108 311 108 208 l 108 972 l 200 972 l 200 303 q 263 140 200 206 q 442 75 325 75 q 621 140 558 75 q 683 303 683 206 l 683 972 l 775 972 l 775 311 q 730 135 775 208 q 608 26 685 63 q 442 -11 532 -11 m 442 1093 q 335 1135 375 1093 q 296 1244 296 1176 l 367 1244 q 386 1185 367 1208 q 442 1163 406 1163 q 498 1185 479 1163 q 517 1244 517 1207 l 588 1244 q 549 1135 588 1176 q 442 1093 510 1093 z "
    },
    "ŭ": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 324 -11 q 166 49 224 -11 q 108 219 108 110 l 108 700 l 194 700 l 194 231 q 230 111 194 153 q 338 69 265 69 q 453 109 401 69 q 534 222 504 149 q 564 393 564 296 l 564 700 l 650 700 l 650 0 l 564 0 l 564 146 q 463 32 528 75 q 324 -11 399 -11 m 379 821 q 273 863 313 821 q 233 972 233 904 l 304 972 q 324 913 304 936 q 379 890 343 890 q 435 913 417 890 q 454 972 454 935 l 525 972 q 486 863 525 904 q 379 821 447 821 z "
    },
    "Ů": {
      "ha": 883,
      "x_min": 108,
      "x_max": 775,
      "o": "m 442 -11 q 275 26 351 -11 q 153 135 199 63 q 108 311 108 208 l 108 972 l 200 972 l 200 303 q 263 140 200 206 q 442 75 325 75 q 621 140 558 75 q 683 303 683 206 l 683 972 l 775 972 l 775 311 q 730 135 775 208 q 608 26 685 63 q 442 -11 532 -11 m 442 1049 q 346 1086 385 1049 q 307 1179 307 1124 q 346 1276 307 1236 q 442 1315 385 1315 q 538 1276 500 1315 q 576 1179 576 1238 q 538 1086 576 1124 q 442 1049 500 1049 m 442 1108 q 493 1128 474 1108 q 513 1181 513 1149 q 493 1235 513 1214 q 442 1256 474 1256 q 391 1234 411 1256 q 371 1181 371 1213 q 391 1128 371 1149 q 442 1108 411 1108 z "
    },
    "ů": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 324 -11 q 166 49 224 -11 q 108 219 108 110 l 108 700 l 194 700 l 194 231 q 230 111 194 153 q 338 69 265 69 q 453 109 401 69 q 534 222 504 149 q 564 393 564 296 l 564 700 l 650 700 l 650 0 l 564 0 l 564 146 q 463 32 528 75 q 324 -11 399 -11 m 379 776 q 283 814 322 776 q 244 907 244 851 q 283 1003 244 964 q 379 1043 322 1043 q 476 1004 438 1043 q 514 907 514 965 q 476 814 514 851 q 379 776 438 776 m 379 836 q 431 856 411 836 q 450 908 450 876 q 431 963 450 942 q 379 983 411 983 q 328 962 349 983 q 308 908 308 940 q 328 856 308 876 q 379 836 349 836 z "
    },
    "Ű": {
      "ha": 883,
      "x_min": 108,
      "x_max": 775,
      "o": "m 442 -11 q 275 26 351 -11 q 153 135 199 63 q 108 311 108 208 l 108 972 l 200 972 l 200 303 q 263 140 200 206 q 442 75 325 75 q 621 140 558 75 q 683 303 683 206 l 683 972 l 775 972 l 775 311 q 730 135 775 208 q 608 26 685 63 q 442 -11 532 -11 m 399 1244 l 528 1244 l 369 1050 l 301 1050 l 399 1244 m 610 1244 l 739 1244 l 581 1050 l 513 1050 l 610 1244 z "
    },
    "ű": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 324 -11 q 166 49 224 -11 q 108 219 108 110 l 108 700 l 194 700 l 194 231 q 230 111 194 153 q 338 69 265 69 q 453 109 401 69 q 534 222 504 149 q 564 393 564 296 l 564 700 l 650 700 l 650 0 l 564 0 l 564 146 q 463 32 528 75 q 324 -11 399 -11 m 308 972 l 438 972 l 279 778 l 211 778 l 308 972 m 519 972 l 649 972 l 490 778 l 422 778 l 519 972 z "
    },
    "Ų": {
      "ha": 883,
      "x_min": 108,
      "x_max": 775,
      "o": "m 442 -11 q 275 26 351 -11 q 153 135 199 63 q 108 311 108 208 l 108 972 l 200 972 l 200 303 q 263 140 200 206 q 442 75 325 75 q 621 140 558 75 q 683 303 683 206 l 683 972 l 775 972 l 775 311 q 730 135 775 208 q 608 26 685 63 q 442 -11 532 -11 m 490 -235 q 410 -206 440 -235 q 381 -128 381 -176 q 399 -59 381 -93 q 450 0 417 -25 l 536 0 q 476 -62 494 -37 q 458 -111 458 -86 q 471 -145 458 -133 q 504 -157 483 -157 q 542 -146 525 -157 l 564 -215 q 530 -231 546 -226 q 490 -235 514 -235 z "
    },
    "ų": {
      "ha": 758,
      "x_min": 108,
      "x_max": 678,
      "o": "m 324 -11 q 166 49 224 -11 q 108 219 108 110 l 108 700 l 194 700 l 194 231 q 230 111 194 153 q 338 69 265 69 q 453 109 401 69 q 534 222 504 149 q 564 393 564 296 l 564 700 l 650 700 l 650 0 l 564 0 l 564 146 q 463 32 528 75 q 324 -11 399 -11 m 604 -235 q 524 -206 554 -235 q 494 -128 494 -176 q 513 -59 494 -93 q 564 0 531 -25 l 650 0 q 590 -62 608 -37 q 572 -111 572 -86 q 585 -145 572 -133 q 618 -157 597 -157 q 656 -146 639 -157 l 678 -215 q 644 -231 660 -226 q 604 -235 628 -235 z "
    },
    "Ŵ": {
      "ha": 1193,
      "x_min": 17,
      "x_max": 1176,
      "o": "m 17 972 l 113 972 l 332 143 l 556 869 l 638 869 l 861 143 l 1081 972 l 1176 972 l 910 0 l 817 0 l 596 728 l 376 0 l 283 0 l 17 972 m 582 1244 l 613 1244 l 799 1050 l 699 1050 l 597 1158 l 496 1050 l 396 1050 l 582 1244 z "
    },
    "ŵ": {
      "ha": 928,
      "x_min": 19,
      "x_max": 908,
      "o": "m 19 700 l 110 700 l 274 122 l 421 700 l 507 700 l 654 122 l 818 700 l 908 700 l 699 0 l 610 0 l 464 572 l 318 0 l 229 0 l 19 700 m 449 972 l 479 972 l 665 778 l 565 778 l 464 886 l 363 778 l 263 778 l 449 972 z "
    },
    "Ŷ": {
      "ha": 711,
      "x_min": 17,
      "x_max": 694,
      "o": "m 310 422 l 17 972 l 124 972 l 356 513 l 588 972 l 694 972 l 401 422 l 401 0 l 310 0 l 310 422 m 340 1244 l 371 1244 l 557 1050 l 457 1050 l 356 1158 l 254 1050 l 154 1050 l 340 1244 z "
    },
    "ŷ": {
      "ha": 611,
      "x_min": 14,
      "x_max": 597,
      "o": "m 265 4 l 14 700 l 104 700 l 313 133 l 507 700 l 597 700 l 250 -283 l 164 -283 l 265 4 m 290 972 l 321 972 l 507 778 l 407 778 l 306 886 l 204 778 l 104 778 l 290 972 z "
    },
    "Ÿ": {
      "ha": 711,
      "x_min": 17,
      "x_max": 694,
      "o": "m 310 422 l 17 972 l 124 972 l 356 513 l 588 972 l 694 972 l 401 422 l 401 0 l 310 0 l 310 422 m 247 1092 q 199 1111 218 1092 q 179 1158 179 1131 q 199 1208 179 1188 q 247 1228 218 1228 q 296 1208 276 1228 q 315 1158 315 1188 q 296 1111 315 1131 q 247 1092 276 1092 m 460 1092 q 413 1111 432 1092 q 393 1158 393 1131 q 413 1208 393 1188 q 460 1228 432 1228 q 509 1208 489 1228 q 529 1158 529 1188 q 509 1111 529 1131 q 460 1092 489 1092 z "
    },
    "Ź": {
      "ha": 740,
      "x_min": 60,
      "x_max": 681,
      "o": "m 60 44 l 549 886 l 76 886 l 76 972 l 671 972 l 671 928 l 188 86 l 681 86 l 681 0 l 60 0 l 60 44 m 436 1244 l 565 1244 l 408 1050 l 339 1050 l 436 1244 z "
    },
    "ź": {
      "ha": 594,
      "x_min": 50,
      "x_max": 536,
      "o": "m 50 42 l 407 619 l 67 619 l 67 700 l 521 700 l 521 653 l 168 81 l 536 81 l 536 0 l 50 0 l 50 42 m 357 972 l 486 972 l 329 778 l 260 778 l 357 972 z "
    },
    "Ż": {
      "ha": 740,
      "x_min": 60,
      "x_max": 681,
      "o": "m 60 44 l 549 886 l 76 886 l 76 972 l 671 972 l 671 928 l 188 86 l 681 86 l 681 0 l 60 0 l 60 44 m 374 1103 q 323 1123 343 1103 q 303 1174 303 1143 q 323 1224 303 1204 q 374 1244 343 1244 q 424 1224 404 1244 q 444 1174 444 1204 q 424 1123 444 1143 q 374 1103 404 1103 z "
    },
    "ż": {
      "ha": 594,
      "x_min": 50,
      "x_max": 536,
      "o": "m 50 42 l 407 619 l 67 619 l 67 700 l 521 700 l 521 653 l 168 81 l 536 81 l 536 0 l 50 0 l 50 42 m 294 831 q 244 851 264 831 q 224 901 224 871 q 244 952 224 932 q 294 972 264 972 q 345 952 325 972 q 365 901 365 932 q 345 851 365 871 q 294 831 325 831 z "
    },
    "Ž": {
      "ha": 740,
      "x_min": 60,
      "x_max": 681,
      "o": "m 60 44 l 549 886 l 76 886 l 76 972 l 671 972 l 671 928 l 188 86 l 681 86 l 681 0 l 60 0 l 60 44 m 172 1244 l 272 1244 l 374 1136 l 475 1244 l 575 1244 l 389 1050 l 358 1050 l 172 1244 z "
    },
    "ž": {
      "ha": 594,
      "x_min": 50,
      "x_max": 536,
      "o": "m 50 42 l 407 619 l 67 619 l 67 700 l 521 700 l 521 653 l 168 81 l 536 81 l 536 0 l 50 0 l 50 42 m 93 972 l 193 972 l 294 864 l 396 972 l 496 972 l 310 778 l 279 778 l 93 972 z "
    },
    "ƒ": {
      "ha": 650,
      "x_min": -103,
      "x_max": 653,
      "o": "m -12 -294 q -64 -289 -37 -294 q -103 -276 -90 -283 l -69 -197 q 0 -214 -36 -214 q 101 -179 65 -214 q 151 -69 136 -144 l 285 619 l 160 619 l 176 700 l 301 700 l 310 744 q 397 928 333 874 q 568 983 461 983 q 617 978 593 983 q 653 965 640 974 l 619 886 q 588 899 603 896 q 550 903 574 903 q 452 867 492 903 q 399 758 413 831 l 388 700 l 557 700 l 540 619 l 371 619 l 240 -56 q 154 -240 215 -186 q -12 -294 93 -294 z "
    },
    "Ƶ": {
      "ha": 740,
      "x_min": 60,
      "x_max": 681,
      "o": "m 681 86 l 681 0 l 60 0 l 60 44 l 293 446 l 135 446 l 135 526 l 340 526 l 549 886 l 76 886 l 76 972 l 671 972 l 671 928 l 440 526 l 607 526 l 607 446 l 394 446 l 188 86 l 681 86 z "
    },
    "ƶ": {
      "ha": 594,
      "x_min": 50,
      "x_max": 536,
      "o": "m 50 42 l 226 328 l 88 328 l 88 406 l 275 406 l 407 619 l 67 619 l 67 700 l 521 700 l 521 653 l 368 406 l 493 406 l 493 328 l 321 328 l 168 81 l 536 81 l 536 0 l 50 0 l 50 42 z "
    },
    "Ǻ": {
      "ha": 817,
      "x_min": 17,
      "x_max": 800,
      "o": "m 368 972 l 449 972 l 800 0 l 706 0 l 608 276 l 208 276 l 111 0 l 17 0 l 368 972 m 579 363 l 408 847 l 238 363 l 579 363 m 408 1049 q 313 1086 351 1049 q 274 1179 274 1124 q 313 1276 274 1236 q 408 1315 351 1315 q 505 1276 467 1315 q 543 1179 543 1238 q 505 1086 543 1124 q 408 1049 467 1049 m 408 1108 q 460 1128 440 1108 q 479 1181 479 1149 q 460 1235 479 1214 q 408 1256 440 1256 q 358 1234 378 1256 q 338 1181 338 1213 q 358 1128 338 1149 q 408 1108 378 1108 m 471 1546 l 600 1546 l 443 1351 l 374 1351 l 471 1546 z "
    },
    "ǻ": {
      "ha": 686,
      "x_min": 69,
      "x_max": 594,
      "o": "m 288 -11 q 131 41 192 -11 q 69 201 69 93 q 153 373 69 315 q 388 431 238 431 l 508 431 l 508 461 q 465 590 508 549 q 347 631 422 631 q 238 594 279 631 q 181 500 197 558 l 97 519 q 181 659 111 607 q 347 711 251 711 q 524 645 454 711 q 594 464 594 579 l 594 0 l 529 0 l 508 108 q 422 22 476 54 q 288 -11 367 -11 m 296 69 q 394 95 346 69 q 476 178 443 121 q 508 324 508 235 l 508 350 l 390 350 q 217 311 274 350 q 160 201 160 272 q 196 103 160 138 q 296 69 232 69 m 347 776 q 251 814 290 776 q 213 907 213 851 q 251 1003 213 964 q 347 1043 290 1043 q 444 1004 406 1043 q 482 907 482 965 q 444 814 482 851 q 347 776 406 776 m 347 836 q 399 856 379 836 q 418 908 418 876 q 399 963 418 942 q 347 983 379 983 q 297 962 317 983 q 276 908 276 940 q 297 856 276 876 q 347 836 317 836 m 410 1297 l 539 1297 l 382 1103 l 313 1103 l 410 1297 z "
    },
    "Ǽ": {
      "ha": 1139,
      "x_min": 17,
      "x_max": 1061,
      "o": "m 443 972 l 1047 972 l 1047 886 l 590 886 l 590 561 l 964 561 l 964 475 l 590 475 l 590 86 l 1061 86 l 1061 0 l 499 0 l 499 276 l 233 276 l 113 0 l 17 0 l 443 972 m 499 363 l 499 847 l 483 847 l 271 363 l 499 363 m 821 1244 l 950 1244 l 793 1050 l 724 1050 l 821 1244 z "
    },
    "ǽ": {
      "ha": 1193,
      "x_min": 69,
      "x_max": 1126,
      "o": "m 288 -11 q 131 41 192 -11 q 69 201 69 93 q 153 373 69 315 q 388 431 238 431 l 508 431 l 508 461 q 465 590 508 549 q 347 631 422 631 q 238 594 279 631 q 181 500 197 558 l 97 519 q 181 659 111 607 q 347 711 251 711 q 485 675 425 711 q 574 576 546 639 q 678 676 615 640 q 819 711 742 711 q 978 671 908 711 q 1088 558 1049 631 q 1126 389 1126 485 l 1126 350 l 599 350 q 658 147 599 225 q 819 69 717 69 q 948 105 897 69 q 1033 214 999 140 l 1111 182 q 989 33 1058 78 q 819 -11 919 -11 q 654 37 726 -11 q 549 165 582 85 q 447 33 517 76 q 288 -11 378 -11 m 1038 431 q 969 577 1025 524 q 819 631 913 631 q 678 575 735 631 q 604 431 622 519 l 1038 431 m 296 69 q 394 95 346 69 q 476 178 443 121 q 508 324 508 235 l 508 350 l 390 350 q 217 311 274 350 q 160 201 160 272 q 196 103 160 138 q 296 69 232 69 m 643 972 l 772 972 l 615 778 l 546 778 l 643 972 z "
    },
    "Ș": {
      "ha": 703,
      "x_min": 58,
      "x_max": 633,
      "o": "m 363 -11 q 219 24 283 -11 q 113 119 154 60 q 58 251 71 179 l 138 299 q 363 75 189 75 q 488 124 439 75 q 538 264 538 172 q 511 364 538 324 q 442 431 485 404 q 326 493 400 458 q 169 601 226 540 q 113 757 113 663 q 143 874 113 822 q 227 955 174 926 q 344 983 281 983 q 493 944 438 983 q 581 833 549 904 l 506 786 q 344 897 456 897 q 242 858 281 897 q 204 764 204 818 q 231 673 204 711 q 299 610 258 635 q 408 554 340 585 q 574 440 515 506 q 633 268 633 374 q 598 122 633 186 q 501 24 563 58 q 363 -11 439 -11 m 299 -72 l 421 -72 l 294 -303 l 242 -303 l 299 -72 z "
    },
    "ș": {
      "ha": 597,
      "x_min": 64,
      "x_max": 533,
      "o": "m 317 -11 q 147 44 210 -11 q 64 181 83 100 l 140 221 q 203 109 163 149 q 317 69 244 69 q 410 103 376 69 q 443 193 443 136 q 405 274 443 244 q 289 332 367 304 q 158 406 203 363 q 113 528 113 450 q 168 661 113 611 q 308 711 224 711 q 422 685 375 711 q 503 603 469 658 l 442 550 q 381 612 414 593 q 304 631 347 631 q 231 603 260 631 q 201 531 201 576 q 238 456 201 485 q 363 396 274 428 q 485 319 438 368 q 533 194 533 269 q 475 44 533 99 q 317 -11 417 -11 m 249 -72 l 371 -72 l 244 -303 l 192 -303 l 249 -72 z "
    },
    "Ț": {
      "ha": 756,
      "x_min": 42,
      "x_max": 714,
      "o": "m 332 886 l 42 886 l 42 972 l 714 972 l 714 886 l 424 886 l 424 0 l 332 0 l 332 886 m 317 -72 l 439 -72 l 313 -303 l 260 -303 l 317 -72 z "
    },
    "ț": {
      "ha": 476,
      "x_min": 17,
      "x_max": 438,
      "o": "m 315 -11 q 188 41 235 -11 q 140 199 140 93 l 140 619 l 17 619 l 17 700 l 140 700 l 140 926 l 226 983 l 226 700 l 415 700 l 415 619 l 226 619 l 226 185 q 253 99 226 128 q 326 69 281 69 q 414 92 379 69 l 438 14 q 315 -11 392 -11 m 246 -72 l 368 -72 l 242 -303 l 189 -303 l 246 -72 z "
    },
    "ȷ": {
      "ha": 303,
      "x_min": 1,
      "x_max": 194,
      "o": "m 1 -214 q 83 -167 58 -197 q 108 -76 108 -137 l 108 700 l 194 700 l 194 -89 q 21 -294 194 -267 l 1 -214 z "
    },
    "ˆ": {
      "ha": 514,
      "x_min": 56,
      "x_max": 458,
      "o": "m 242 972 l 272 972 l 458 778 l 358 778 l 257 886 l 156 778 l 56 778 l 242 972 z "
    },
    "ˇ": {
      "ha": 514,
      "x_min": 56,
      "x_max": 458,
      "o": "m 56 972 l 156 972 l 257 864 l 358 972 l 458 972 l 272 778 l 242 778 l 56 972 z "
    },
    "ˉ": {
      "ha": 335,
      "x_min": 0,
      "x_max": 335,
      "o": "m 0 917 l 335 917 l 335 839 l 0 839 l 0 917 z "
    },
    "˘": {
      "ha": 369,
      "x_min": 39,
      "x_max": 331,
      "o": "m 185 821 q 78 863 118 821 q 39 972 39 904 l 110 972 q 129 913 110 936 q 185 890 149 890 q 241 913 222 890 q 260 972 260 935 l 331 972 q 292 863 331 904 q 185 821 253 821 z "
    },
    "˙": {
      "ha": 347,
      "x_min": 103,
      "x_max": 244,
      "o": "m 174 831 q 123 851 143 831 q 103 901 103 871 q 123 952 103 932 q 174 972 143 972 q 224 952 204 972 q 244 901 244 932 q 224 851 244 871 q 174 831 204 831 z "
    },
    "˚": {
      "ha": 325,
      "x_min": 28,
      "x_max": 297,
      "o": "m 163 776 q 67 814 106 776 q 28 907 28 851 q 67 1003 28 964 q 163 1043 106 1043 q 259 1004 221 1043 q 297 907 297 965 q 259 814 297 851 q 163 776 221 776 m 163 836 q 214 856 194 836 q 233 908 233 876 q 214 963 233 942 q 163 983 194 983 q 112 962 132 983 q 92 908 92 940 q 112 856 92 876 q 163 836 132 836 z "
    },
    "˛": {
      "ha": 289,
      "x_min": 44,
      "x_max": 228,
      "o": "m 154 -235 q 74 -206 104 -235 q 44 -128 44 -176 q 63 -59 44 -93 q 114 0 81 -25 l 200 0 q 140 -62 158 -37 q 122 -111 122 -86 q 135 -145 122 -133 q 168 -157 147 -157 q 206 -146 189 -157 l 228 -215 q 194 -231 210 -226 q 154 -235 178 -235 z "
    },
    "˜": {
      "ha": 524,
      "x_min": 28,
      "x_max": 496,
      "o": "m 28 858 q 89 928 53 901 q 165 954 125 954 q 222 946 199 954 q 272 922 246 938 q 313 903 297 908 q 347 897 328 897 q 433 954 392 897 l 496 904 q 435 835 471 861 q 358 808 399 808 q 301 817 325 808 q 251 840 278 825 q 211 860 226 854 q 176 865 196 865 q 90 808 132 865 l 28 858 z "
    },
    "˝": {
      "ha": 501,
      "x_min": 35,
      "x_max": 472,
      "o": "m 132 972 l 261 972 l 103 778 l 35 778 l 132 972 m 343 972 l 472 972 l 314 778 l 246 778 l 343 972 z "
    },
    "̀": {
      "ha": 0,
      "x_min": -226,
      "x_max": 0,
      "o": "m -226 972 l -97 972 l 0 778 l -69 778 l -226 972 z "
    },
    "́": {
      "ha": 0,
      "x_min": -226,
      "x_max": 0,
      "o": "m -129 972 l 0 972 l -157 778 l -226 778 l -129 972 z "
    },
    "̂": {
      "ha": 0,
      "x_min": -403,
      "x_max": 0,
      "o": "m -217 972 l -186 972 l 0 778 l -100 778 l -201 886 l -303 778 l -403 778 l -217 972 z "
    },
    "̃": {
      "ha": 0,
      "x_min": -468,
      "x_max": 0,
      "o": "m -468 858 q -407 928 -443 901 q -331 954 -371 954 q -274 946 -297 954 q -224 922 -250 938 q -183 903 -199 908 q -149 897 -168 897 q -62 954 -104 897 l 0 904 q -61 835 -25 861 q -137 808 -97 808 q -194 817 -171 808 q -244 840 -218 825 q -285 860 -269 854 q -319 865 -300 865 q -406 808 -364 865 l -468 858 z "
    },
    "̄": {
      "ha": 0,
      "x_min": -335,
      "x_max": 0,
      "o": "m -335 917 l 0 917 l 0 839 l -335 839 l -335 917 z "
    },
    "̆": {
      "ha": 0,
      "x_min": -292,
      "x_max": 0,
      "o": "m -146 821 q -252 863 -212 821 q -292 972 -292 904 l -221 972 q -201 913 -221 936 q -146 890 -182 890 q -90 913 -108 890 q -71 972 -71 935 l 0 972 q -39 863 0 904 q -146 821 -78 821 z "
    },
    "̇": {
      "ha": 0,
      "x_min": -142,
      "x_max": 0,
      "o": "m -71 831 q -122 851 -101 831 q -142 901 -142 871 q -122 952 -142 932 q -71 972 -101 972 q -20 952 -40 972 q 0 901 0 932 q -20 851 0 871 q -71 831 -40 831 z "
    },
    "̈": {
      "ha": 0,
      "x_min": -350,
      "x_max": 0,
      "o": "m -282 819 q -331 839 -311 819 q -350 886 -350 858 q -331 935 -350 915 q -282 956 -311 956 q -233 935 -253 956 q -214 886 -214 915 q -233 839 -214 858 q -282 819 -253 819 m -69 819 q -117 839 -97 819 q -136 886 -136 858 q -117 935 -136 915 q -69 956 -97 956 q -20 935 -40 956 q 0 886 0 915 q -20 839 0 858 q -69 819 -40 819 z "
    },
    "̊": {
      "ha": 0,
      "x_min": -269,
      "x_max": 0,
      "o": "m -135 776 q -231 814 -192 776 q -269 907 -269 851 q -231 1003 -269 964 q -135 1043 -192 1043 q -38 1004 -76 1043 q 0 907 0 965 q -38 814 0 851 q -135 776 -76 776 m -135 836 q -83 856 -103 836 q -64 908 -64 876 q -83 963 -64 942 q -135 983 -103 983 q -185 962 -165 983 q -206 908 -206 940 q -185 856 -206 876 q -135 836 -165 836 z "
    },
    "̋": {
      "ha": 0,
      "x_min": -437,
      "x_max": 0,
      "o": "m -340 972 l -211 972 l -369 778 l -437 778 l -340 972 m -129 972 l 0 972 l -158 778 l -226 778 l -129 972 z "
    },
    "̌": {
      "ha": 0,
      "x_min": -403,
      "x_max": 0,
      "o": "m -403 972 l -303 972 l -201 864 l -100 972 l 0 972 l -186 778 l -217 778 l -403 972 z "
    },
    "̒": {
      "ha": 0,
      "x_min": -176,
      "x_max": 0,
      "o": "m -64 1014 l 0 1014 l -57 814 l -176 814 l -64 1014 z "
    },
    "̦": {
      "ha": 0,
      "x_min": -179,
      "x_max": 0,
      "o": "m -122 -72 l 0 -72 l -126 -303 l -179 -303 l -122 -72 z "
    },
    "̧": {
      "ha": 0,
      "x_min": -212,
      "x_max": 0,
      "o": "m -212 -254 l -76 -83 l 0 -83 l -112 -297 l -212 -254 z "
    },
    "̨": {
      "ha": 0,
      "x_min": -183,
      "x_max": 0,
      "o": "m -74 -235 q -153 -206 -124 -235 q -183 -128 -183 -176 q -165 -59 -183 -93 q -114 0 -147 -25 l -28 0 q -87 -62 -69 -37 q -106 -111 -106 -86 q -93 -145 -106 -133 q -60 -157 -81 -157 q -22 -146 -39 -157 l 0 -215 q -34 -231 -18 -226 q -74 -235 -50 -235 z "
    },
    "̵": {
      "ha": 0,
      "x_min": -375,
      "x_max": 0,
      "o": "m -375 525 l 0 525 l 0 447 l -375 447 l -375 525 z "
    },
    "̶": {
      "ha": 0,
      "x_min": -869,
      "x_max": 0,
      "o": "m -869 526 l 0 526 l 0 446 l -869 446 l -869 526 z "
    },
    "̷": {
      "ha": 0,
      "x_min": -375,
      "x_max": 0,
      "o": "m -375 446 l -37 633 l 0 568 l -337 381 l -375 446 z "
    },
    "̸": {
      "ha": 0,
      "x_min": -656,
      "x_max": 0,
      "o": "m -656 -1 l -64 750 l 0 701 l -592 -50 l -656 -1 z "
    },
    ";": {
      "ha": 308,
      "x_min": 42,
      "x_max": 239,
      "o": "m 168 506 q 117 526 138 506 q 97 576 97 546 q 117 627 97 607 q 168 647 138 647 q 219 627 199 647 q 239 576 239 607 q 219 526 239 546 q 168 506 199 506 m 111 122 l 239 122 l 106 -107 l 42 -107 l 111 122 z "
    },
    "΄": {
      "ha": 360,
      "x_min": 83,
      "x_max": 276,
      "o": "m 147 972 l 276 972 l 153 778 l 83 778 l 147 972 z "
    },
    "΅": {
      "ha": 457,
      "x_min": 28,
      "x_max": 429,
      "o": "m 211 972 l 313 972 l 203 778 l 147 778 l 211 972 m 86 818 q 44 835 61 818 q 28 875 28 851 q 44 917 28 900 q 86 935 61 935 q 129 917 113 935 q 146 875 146 900 q 129 835 146 851 q 86 818 113 818 m 369 818 q 328 835 346 818 q 311 875 311 851 q 328 917 311 900 q 369 935 346 935 q 412 917 394 935 q 429 875 429 900 q 412 835 429 851 q 369 818 394 818 z "
    },
    "Ά": {
      "ha": 824,
      "x_min": 0,
      "x_max": 807,
      "o": "m 375 972 l 456 972 l 807 0 l 713 0 l 615 276 l 215 276 l 118 0 l 24 0 l 375 972 m 586 363 l 415 847 l 244 363 l 586 363 m 64 972 l 193 972 l 69 778 l 0 778 l 64 972 z "
    },
    "·": {
      "ha": 308,
      "x_min": 83,
      "x_max": 225,
      "o": "m 154 415 q 103 435 124 415 q 83 486 83 456 q 103 537 83 517 q 154 557 124 557 q 205 537 185 557 q 225 486 225 517 q 205 435 225 456 q 154 415 185 415 z "
    },
    "Έ": {
      "ha": 903,
      "x_min": 0,
      "x_max": 825,
      "o": "m 263 972 l 811 972 l 811 886 l 354 886 l 354 561 l 728 561 l 728 475 l 354 475 l 354 86 l 825 86 l 825 0 l 263 0 l 263 972 m 64 972 l 193 972 l 69 778 l 0 778 l 64 972 z "
    },
    "Ή": {
      "ha": 1065,
      "x_min": 0,
      "x_max": 940,
      "o": "m 263 972 l 354 972 l 354 561 l 849 561 l 849 972 l 940 972 l 940 0 l 849 0 l 849 475 l 354 475 l 354 0 l 263 0 l 263 972 m 64 972 l 193 972 l 69 778 l 0 778 l 64 972 z "
    },
    "Ί": {
      "ha": 479,
      "x_min": 0,
      "x_max": 354,
      "o": "m 263 972 l 354 972 l 354 0 l 263 0 l 263 972 m 64 972 l 193 972 l 69 778 l 0 778 l 64 972 z "
    },
    "Ό": {
      "ha": 1061,
      "x_min": 0,
      "x_max": 989,
      "o": "m 563 -11 q 350 50 447 -11 q 194 224 253 111 q 136 486 136 336 q 194 749 136 636 q 350 922 253 861 q 563 983 447 983 q 775 922 678 983 q 931 749 872 861 q 989 486 989 636 q 931 224 989 336 q 775 50 872 111 q 563 -11 678 -11 m 563 75 q 731 122 656 75 q 849 262 806 169 q 893 486 893 354 q 849 710 893 618 q 731 850 806 803 q 563 897 656 897 q 394 850 469 897 q 276 710 319 803 q 232 486 232 618 q 276 262 232 354 q 394 122 319 169 q 563 75 469 75 m 64 972 l 193 972 l 69 778 l 0 778 l 64 972 z "
    },
    "Ύ": {
      "ha": 950,
      "x_min": 0,
      "x_max": 933,
      "o": "m 549 422 l 256 972 l 363 972 l 594 513 l 826 972 l 933 972 l 640 422 l 640 0 l 549 0 l 549 422 m 64 972 l 193 972 l 69 778 l 0 778 l 64 972 z "
    },
    "Ώ": {
      "ha": 1024,
      "x_min": 0,
      "x_max": 976,
      "o": "m 149 86 l 371 86 q 201 299 267 185 q 135 549 135 413 q 186 772 135 674 q 333 927 238 871 q 556 983 428 983 q 778 927 683 983 q 925 772 874 871 q 976 549 976 674 q 910 299 976 413 q 740 86 844 185 l 963 86 l 963 0 l 626 0 l 626 86 q 820 308 760 203 q 881 549 881 413 q 840 731 881 651 q 725 853 799 810 q 556 897 651 897 q 386 853 460 897 q 272 731 313 810 q 231 549 231 651 q 291 308 231 413 q 485 86 351 203 l 485 0 l 149 0 l 149 86 m 64 972 l 193 972 l 69 778 l 0 778 l 64 972 z "
    },
    "ΐ": {
      "ha": 303,
      "x_min": -50,
      "x_max": 351,
      "o": "m 108 700 l 194 700 l 194 0 l 108 0 l 108 700 m 133 972 l 235 972 l 125 778 l 69 778 l 133 972 m 8 818 q -33 835 -17 818 q -50 875 -50 851 q -33 917 -50 900 q 8 935 -17 935 q 51 917 35 935 q 68 875 68 900 q 51 835 68 851 q 8 818 35 818 m 292 818 q 251 835 268 818 q 233 875 233 851 q 251 917 233 900 q 292 935 268 935 q 334 917 317 935 q 351 875 351 900 q 334 835 351 851 q 292 818 317 818 z "
    },
    "Α": {
      "ha": 817,
      "x_min": 17,
      "x_max": 800,
      "o": "m 368 972 l 449 972 l 800 0 l 706 0 l 608 276 l 208 276 l 111 0 l 17 0 l 368 972 m 579 363 l 408 847 l 238 363 l 579 363 z "
    },
    "Β": {
      "ha": 839,
      "x_min": 125,
      "x_max": 758,
      "o": "m 125 972 l 438 972 q 637 906 565 972 q 708 724 708 840 q 674 602 708 649 q 586 532 640 556 q 712 442 665 504 q 758 281 758 379 q 678 76 758 153 q 460 0 597 0 l 125 0 l 125 972 m 438 561 q 569 602 524 561 q 614 724 614 643 q 569 845 614 804 q 438 886 524 886 l 217 886 l 217 561 l 438 561 m 442 86 q 607 131 551 86 q 663 281 663 176 q 607 430 663 385 q 442 475 551 475 l 217 475 l 217 86 l 442 86 z "
    },
    "Γ": {
      "ha": 729,
      "x_min": 125,
      "x_max": 688,
      "o": "m 125 972 l 688 972 l 688 886 l 217 886 l 217 0 l 125 0 l 125 972 z "
    },
    "Δ": {
      "ha": 817,
      "x_min": 17,
      "x_max": 800,
      "o": "m 800 0 l 17 0 l 368 972 l 449 972 l 800 0 m 675 86 l 408 847 l 142 86 l 675 86 z "
    },
    "Ε": {
      "ha": 765,
      "x_min": 125,
      "x_max": 688,
      "o": "m 125 972 l 674 972 l 674 886 l 217 886 l 217 561 l 590 561 l 590 475 l 217 475 l 217 86 l 688 86 l 688 0 l 125 0 l 125 972 z "
    },
    "Ζ": {
      "ha": 740,
      "x_min": 60,
      "x_max": 681,
      "o": "m 60 44 l 549 886 l 76 886 l 76 972 l 671 972 l 671 928 l 188 86 l 681 86 l 681 0 l 60 0 l 60 44 z "
    },
    "Η": {
      "ha": 928,
      "x_min": 125,
      "x_max": 803,
      "o": "m 125 972 l 217 972 l 217 561 l 711 561 l 711 972 l 803 972 l 803 0 l 711 0 l 711 475 l 217 475 l 217 0 l 125 0 l 125 972 z "
    },
    "Θ": {
      "ha": 997,
      "x_min": 72,
      "x_max": 925,
      "o": "m 499 -11 q 286 50 383 -11 q 131 224 189 111 q 72 486 72 336 q 131 749 72 636 q 286 922 189 861 q 499 983 383 983 q 711 922 614 983 q 867 749 808 861 q 925 486 925 636 q 867 224 925 336 q 711 50 808 111 q 499 -11 614 -11 m 499 75 q 667 122 592 75 q 785 262 742 169 q 829 486 829 354 q 785 710 829 618 q 667 850 742 803 q 499 897 592 897 q 331 850 406 897 q 212 710 256 803 q 168 486 168 618 q 212 262 168 354 q 331 122 256 169 q 499 75 406 75 m 332 525 l 667 525 l 667 447 l 332 447 l 332 525 z "
    },
    "Ι": {
      "ha": 342,
      "x_min": 125,
      "x_max": 217,
      "o": "m 125 972 l 217 972 l 217 0 l 125 0 l 125 972 z "
    },
    "Κ": {
      "ha": 769,
      "x_min": 125,
      "x_max": 747,
      "o": "m 125 972 l 217 972 l 217 557 l 596 972 l 713 972 l 314 536 l 747 0 l 635 0 l 217 515 l 217 0 l 125 0 l 125 972 z "
    },
    "Λ": {
      "ha": 817,
      "x_min": 17,
      "x_max": 800,
      "o": "m 368 972 l 449 972 l 800 0 l 706 0 l 408 847 l 111 0 l 17 0 l 368 972 z "
    },
    "Μ": {
      "ha": 1056,
      "x_min": 125,
      "x_max": 931,
      "o": "m 125 972 l 239 972 l 528 240 l 817 972 l 931 972 l 931 0 l 839 0 l 839 794 l 557 89 l 499 89 l 217 794 l 217 0 l 125 0 l 125 972 z "
    },
    "Ν": {
      "ha": 932,
      "x_min": 125,
      "x_max": 807,
      "o": "m 125 972 l 233 972 l 715 146 l 715 972 l 807 972 l 807 0 l 699 0 l 217 824 l 217 0 l 125 0 l 125 972 z "
    },
    "Ξ": {
      "ha": 746,
      "x_min": 78,
      "x_max": 668,
      "o": "m 85 972 l 661 972 l 661 886 l 85 886 l 85 972 m 154 561 l 592 561 l 592 475 l 154 475 l 154 561 m 78 86 l 668 86 l 668 0 l 78 0 l 78 86 z "
    },
    "Ο": {
      "ha": 997,
      "x_min": 72,
      "x_max": 925,
      "o": "m 499 -11 q 286 50 383 -11 q 131 224 189 111 q 72 486 72 336 q 131 749 72 636 q 286 922 189 861 q 499 983 383 983 q 711 922 614 983 q 867 749 808 861 q 925 486 925 636 q 867 224 925 336 q 711 50 808 111 q 499 -11 614 -11 m 499 75 q 667 122 592 75 q 785 262 742 169 q 829 486 829 354 q 785 710 829 618 q 667 850 742 803 q 499 897 592 897 q 331 850 406 897 q 212 710 256 803 q 168 486 168 618 q 212 262 168 354 q 331 122 256 169 q 499 75 406 75 z "
    },
    "Π": {
      "ha": 913,
      "x_min": 125,
      "x_max": 788,
      "o": "m 125 972 l 788 972 l 788 0 l 696 0 l 696 886 l 217 886 l 217 0 l 125 0 l 125 972 z "
    },
    "Ρ": {
      "ha": 797,
      "x_min": 125,
      "x_max": 736,
      "o": "m 125 972 l 456 972 q 661 901 586 972 q 736 704 736 829 q 661 508 736 579 q 456 436 586 436 l 217 436 l 217 0 l 125 0 l 125 972 m 457 522 q 596 572 551 522 q 640 704 640 621 q 596 837 640 788 q 457 886 551 886 l 217 886 l 217 522 l 457 522 z "
    },
    "Σ": {
      "ha": 735,
      "x_min": 79,
      "x_max": 657,
      "o": "m 79 44 l 378 486 l 79 928 l 79 972 l 646 972 l 646 886 l 215 886 l 472 500 l 472 472 l 215 86 l 657 86 l 657 0 l 79 0 l 79 44 z "
    },
    "Τ": {
      "ha": 756,
      "x_min": 42,
      "x_max": 714,
      "o": "m 332 886 l 42 886 l 42 972 l 714 972 l 714 886 l 424 886 l 424 0 l 332 0 l 332 886 z "
    },
    "Υ": {
      "ha": 711,
      "x_min": 17,
      "x_max": 694,
      "o": "m 310 422 l 17 972 l 124 972 l 356 513 l 588 972 l 694 972 l 401 422 l 401 0 l 310 0 l 310 422 z "
    },
    "Φ": {
      "ha": 1053,
      "x_min": 72,
      "x_max": 981,
      "o": "m 481 100 q 266 148 358 100 q 123 283 174 196 q 72 486 72 371 q 123 689 72 601 q 266 824 174 776 q 481 872 358 872 l 481 972 l 572 972 l 572 872 q 787 824 694 872 q 930 689 879 776 q 981 486 981 601 q 930 283 981 371 q 787 148 879 196 q 572 100 694 100 l 572 0 l 481 0 l 481 100 m 481 786 q 252 705 336 786 q 168 486 168 624 q 252 267 168 349 q 481 186 336 186 l 481 786 m 572 186 q 801 267 717 186 q 885 486 885 349 q 801 705 885 624 q 572 786 717 786 l 572 186 z "
    },
    "Χ": {
      "ha": 772,
      "x_min": 22,
      "x_max": 750,
      "o": "m 336 535 l 82 972 l 183 972 l 386 619 l 589 972 l 690 972 l 436 535 l 750 0 l 649 0 l 386 449 l 124 0 l 22 0 l 336 535 z "
    },
    "Ψ": {
      "ha": 1003,
      "x_min": 108,
      "x_max": 894,
      "o": "m 456 261 q 271 308 350 261 q 150 438 192 356 q 108 622 108 519 l 108 972 l 200 972 l 200 622 q 267 423 200 499 q 449 347 335 347 l 456 347 l 456 972 l 547 972 l 547 347 l 554 347 q 735 423 668 347 q 803 622 803 499 l 803 972 l 894 972 l 894 622 q 853 438 894 519 q 732 308 811 356 q 547 261 653 261 l 547 0 l 456 0 l 456 261 z "
    },
    "Ω": {
      "ha": 936,
      "x_min": 47,
      "x_max": 889,
      "o": "m 61 86 l 283 86 q 113 299 179 185 q 47 549 47 413 q 99 772 47 674 q 245 927 150 871 q 468 983 340 983 q 691 927 596 983 q 838 772 786 871 q 889 549 889 674 q 823 299 889 413 q 653 86 757 185 l 875 86 l 875 0 l 539 0 l 539 86 q 733 308 672 203 q 793 549 793 413 q 752 731 793 651 q 638 853 711 810 q 468 897 564 897 q 299 853 372 897 q 184 731 225 810 q 143 549 143 651 q 203 308 143 413 q 397 86 264 203 l 397 0 l 61 0 l 61 86 z "
    },
    "Ϊ": {
      "ha": 342,
      "x_min": -6,
      "x_max": 344,
      "o": "m 125 972 l 217 972 l 217 0 l 125 0 l 125 972 m 63 1092 q 14 1111 33 1092 q -6 1158 -6 1131 q 14 1208 -6 1188 q 63 1228 33 1228 q 111 1208 92 1228 q 131 1158 131 1188 q 111 1111 131 1131 q 63 1092 92 1092 m 275 1092 q 228 1111 247 1092 q 208 1158 208 1131 q 228 1208 208 1188 q 275 1228 247 1228 q 324 1208 304 1228 q 344 1158 344 1188 q 324 1111 344 1131 q 275 1092 304 1092 z "
    },
    "Ϋ": {
      "ha": 711,
      "x_min": 17,
      "x_max": 694,
      "o": "m 310 422 l 17 972 l 124 972 l 356 513 l 588 972 l 694 972 l 401 422 l 401 0 l 310 0 l 310 422 m 247 1092 q 199 1111 218 1092 q 179 1158 179 1131 q 199 1208 179 1188 q 247 1228 218 1228 q 296 1208 276 1228 q 315 1158 315 1188 q 296 1111 315 1131 q 247 1092 276 1092 m 460 1092 q 413 1111 432 1092 q 393 1158 393 1131 q 413 1208 393 1188 q 460 1228 432 1228 q 509 1208 489 1228 q 529 1158 529 1188 q 509 1111 529 1131 q 460 1092 489 1092 z "
    },
    "ά": {
      "ha": 794,
      "x_min": 67,
      "x_max": 686,
      "o": "m 379 -11 q 210 37 281 -11 q 103 167 139 85 q 67 350 67 249 q 103 533 67 451 q 210 663 139 615 q 379 711 281 711 q 506 683 449 711 q 600 601 563 654 l 600 700 l 686 700 l 686 0 l 600 0 l 600 100 q 506 22 568 54 q 379 -11 444 -11 m 383 69 q 550 148 492 69 q 608 350 608 226 q 549 551 608 472 q 383 631 490 631 q 217 551 276 631 q 157 350 157 472 q 216 148 157 226 q 383 69 275 69 m 422 972 l 551 972 l 428 778 l 358 778 l 422 972 z "
    },
    "έ": {
      "ha": 589,
      "x_min": 64,
      "x_max": 533,
      "o": "m 299 -11 q 181 15 235 -11 q 96 88 128 42 q 64 193 64 135 q 99 303 64 260 q 192 368 135 346 q 115 433 142 390 q 89 525 89 475 q 149 660 89 610 q 301 711 208 711 q 442 668 386 711 q 511 547 497 625 l 432 529 q 385 606 419 581 q 301 631 351 631 q 210 602 246 631 q 175 524 175 574 q 211 437 175 468 q 307 406 247 406 l 344 406 l 344 331 l 310 331 q 196 297 238 331 q 154 197 154 264 q 197 105 154 140 q 299 69 239 69 q 453 194 421 69 l 533 179 q 458 40 518 90 q 299 -11 397 -11 m 324 972 l 453 972 l 329 778 l 260 778 l 324 972 z "
    },
    "ή": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 564 469 q 528 589 564 547 q 421 631 493 631 q 306 591 357 631 q 224 478 254 551 q 194 307 194 404 l 194 0 l 108 0 l 108 700 l 194 700 l 194 554 q 295 668 231 625 q 435 711 360 711 q 592 651 535 711 q 650 481 650 590 l 650 -283 l 564 -283 l 564 469 m 419 972 l 549 972 l 425 778 l 356 778 l 419 972 z "
    },
    "ί": {
      "ha": 303,
      "x_min": 108,
      "x_max": 306,
      "o": "m 108 700 l 194 700 l 194 0 l 108 0 l 108 700 m 176 972 l 306 972 l 182 778 l 113 778 l 176 972 z "
    },
    "ΰ": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 379 -11 q 183 65 257 -11 q 108 289 108 140 l 108 700 l 194 700 l 194 300 q 244 124 194 179 q 379 69 294 69 q 514 124 464 69 q 564 300 564 179 l 564 700 l 650 700 l 650 289 q 576 65 650 140 q 379 -11 501 -11 m 361 972 l 463 972 l 353 778 l 297 778 l 361 972 m 236 818 q 194 835 211 818 q 178 875 178 851 q 194 917 178 900 q 236 935 211 935 q 279 917 263 935 q 296 875 296 900 q 279 835 296 851 q 236 818 263 818 m 519 818 q 478 835 496 818 q 461 875 461 851 q 478 917 461 900 q 519 935 496 935 q 562 917 544 935 q 579 875 579 900 q 562 835 579 851 q 519 818 544 818 z "
    },
    "α": {
      "ha": 794,
      "x_min": 67,
      "x_max": 686,
      "o": "m 379 -11 q 210 37 281 -11 q 103 167 139 85 q 67 350 67 249 q 103 533 67 451 q 210 663 139 615 q 379 711 281 711 q 506 683 449 711 q 600 601 563 654 l 600 700 l 686 700 l 686 0 l 600 0 l 600 100 q 506 22 568 54 q 379 -11 444 -11 m 383 69 q 550 148 492 69 q 608 350 608 226 q 549 551 608 472 q 383 631 490 631 q 217 551 276 631 q 157 350 157 472 q 216 148 157 226 q 383 69 275 69 z "
    },
    "β": {
      "ha": 750,
      "x_min": 108,
      "x_max": 683,
      "o": "m 108 699 q 144 852 108 788 q 240 950 179 917 q 376 983 300 983 q 509 952 451 983 q 599 865 567 921 q 631 740 631 810 q 588 608 631 665 q 488 536 546 550 q 626 450 568 515 q 683 276 683 385 q 646 126 683 192 q 543 25 608 61 q 396 -11 478 -11 q 276 15 332 -11 q 197 81 221 40 l 197 -283 l 108 -283 l 108 699 m 396 69 q 544 127 494 69 q 594 276 594 185 q 528 438 594 383 q 354 492 463 492 l 310 492 l 310 569 l 363 569 q 494 616 446 569 q 542 740 542 663 q 494 858 542 814 q 376 903 447 903 q 246 853 294 903 q 197 704 197 804 l 197 288 q 250 126 197 182 q 396 69 303 69 z "
    },
    "γ": {
      "ha": 628,
      "x_min": 22,
      "x_max": 606,
      "o": "m 271 6 l 22 700 l 113 700 l 314 133 l 515 700 l 606 700 l 357 6 l 357 -283 l 271 -283 l 271 6 z "
    },
    "δ": {
      "ha": 789,
      "x_min": 67,
      "x_max": 722,
      "o": "m 394 -11 q 222 40 296 -11 q 107 174 147 90 q 67 350 67 257 q 103 517 67 439 q 211 647 140 596 q 378 704 282 697 l 144 886 l 144 972 l 649 972 l 649 886 l 281 886 l 547 682 q 681 530 639 613 q 722 350 722 447 q 682 174 722 257 q 567 40 642 90 q 394 -11 493 -11 m 394 69 q 523 109 469 69 q 604 213 576 149 q 632 350 632 278 q 604 487 632 422 q 523 591 576 551 q 394 631 469 631 q 266 591 319 631 q 185 487 213 551 q 157 350 157 422 q 185 213 157 278 q 266 109 213 149 q 394 69 319 69 z "
    },
    "ε": {
      "ha": 589,
      "x_min": 64,
      "x_max": 533,
      "o": "m 299 -11 q 181 15 235 -11 q 96 88 128 42 q 64 193 64 135 q 99 303 64 260 q 192 368 135 346 q 115 433 142 390 q 89 525 89 475 q 149 660 89 610 q 301 711 208 711 q 442 668 386 711 q 511 547 497 625 l 432 529 q 385 606 419 581 q 301 631 351 631 q 210 602 246 631 q 175 524 175 574 q 211 437 175 468 q 307 406 247 406 l 344 406 l 344 331 l 310 331 q 196 297 238 331 q 154 197 154 264 q 197 105 154 140 q 299 69 239 69 q 453 194 421 69 l 533 179 q 458 40 518 90 q 299 -11 397 -11 z "
    },
    "ζ": {
      "ha": 635,
      "x_min": 56,
      "x_max": 618,
      "o": "m 394 -294 q 259 -260 319 -294 q 164 -162 199 -225 l 229 -106 q 308 -188 268 -162 q 394 -214 347 -214 q 490 -183 453 -214 q 528 -93 528 -151 q 492 -8 528 -40 q 382 25 457 25 l 317 25 q 131 87 207 25 q 56 268 56 149 q 89 410 56 343 q 193 554 122 476 l 500 892 l 89 892 l 89 972 l 617 972 l 617 903 l 261 508 q 173 386 200 440 q 146 274 146 332 q 194 148 146 190 q 331 106 242 106 l 393 106 q 558 52 497 106 q 618 -87 618 -1 q 592 -190 618 -143 q 516 -266 567 -237 q 394 -294 465 -294 z "
    },
    "η": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 564 469 q 528 589 564 547 q 421 631 493 631 q 306 591 357 631 q 224 478 254 551 q 194 307 194 404 l 194 0 l 108 0 l 108 700 l 194 700 l 194 554 q 295 668 231 625 q 435 711 360 711 q 592 651 535 711 q 650 481 650 590 l 650 -283 l 564 -283 l 564 469 z "
    },
    "θ": {
      "ha": 847,
      "x_min": 67,
      "x_max": 781,
      "o": "m 424 983 q 611 923 531 983 q 736 750 692 863 q 781 486 781 638 q 736 222 781 335 q 611 49 692 110 q 424 -11 531 -11 q 236 49 317 -11 q 111 222 156 110 q 67 486 67 335 q 111 750 67 638 q 236 923 156 863 q 424 983 317 983 m 424 903 q 233 806 303 903 q 158 526 164 710 l 689 526 q 614 806 683 710 q 424 903 544 903 m 424 69 q 614 166 544 69 q 689 446 683 263 l 158 446 q 233 166 164 263 q 424 69 303 69 z "
    },
    "ι": {
      "ha": 303,
      "x_min": 108,
      "x_max": 194,
      "o": "m 108 700 l 194 700 l 194 0 l 108 0 l 108 700 z "
    },
    "κ": {
      "ha": 638,
      "x_min": 108,
      "x_max": 621,
      "o": "m 108 700 l 194 700 l 194 390 l 488 700 l 596 700 l 293 379 l 621 0 l 511 0 l 194 368 l 194 0 l 108 0 l 108 700 z "
    },
    "λ": {
      "ha": 611,
      "x_min": 14,
      "x_max": 597,
      "o": "m 267 700 l 228 807 q 181 883 208 863 q 113 904 154 904 q 68 896 89 904 l 51 969 q 119 983 82 983 q 299 842 247 983 l 597 0 l 507 0 l 313 567 l 104 0 l 14 0 l 267 700 z "
    },
    "μ": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 108 700 l 194 700 l 194 231 q 230 111 194 153 q 338 69 265 69 q 453 109 401 69 q 534 222 504 149 q 564 393 564 296 l 564 700 l 650 700 l 650 0 l 564 0 l 564 146 q 466 32 528 75 q 331 -11 404 -11 q 250 5 286 -11 q 194 49 214 21 l 194 -283 l 108 -283 l 108 700 z "
    },
    "ν": {
      "ha": 611,
      "x_min": 22,
      "x_max": 589,
      "o": "m 22 700 l 113 700 l 306 115 l 499 700 l 589 700 l 353 0 l 258 0 l 22 700 z "
    },
    "ξ": {
      "ha": 639,
      "x_min": 67,
      "x_max": 622,
      "o": "m 388 -294 q 265 -267 321 -294 q 163 -172 208 -239 l 225 -117 q 386 -214 297 -214 q 485 -183 447 -214 q 522 -93 522 -153 q 488 -7 522 -39 q 376 25 453 25 l 328 25 q 198 58 258 25 q 102 151 138 90 q 67 292 67 211 q 114 446 67 386 q 231 531 161 506 q 132 613 169 560 q 94 738 94 665 q 126 859 94 803 q 219 949 158 915 q 361 983 279 983 q 534 927 464 983 q 622 764 604 871 l 536 747 q 477 863 521 822 q 361 903 433 903 q 233 856 282 903 q 185 736 185 810 q 236 617 185 661 q 374 572 288 572 l 465 572 l 465 492 l 363 492 q 217 442 276 492 q 157 294 157 392 q 214 152 157 199 q 349 106 271 106 l 388 106 q 553 55 493 106 q 613 -85 613 4 q 551 -235 613 -175 q 388 -294 490 -294 z "
    },
    "ο": {
      "ha": 789,
      "x_min": 67,
      "x_max": 722,
      "o": "m 394 -11 q 222 40 296 -11 q 107 174 147 90 q 67 350 67 257 q 107 526 67 443 q 222 660 147 610 q 394 711 296 711 q 567 660 493 711 q 682 526 642 610 q 722 350 722 443 q 682 174 722 257 q 567 40 642 90 q 394 -11 493 -11 m 394 69 q 523 109 469 69 q 604 213 576 149 q 632 350 632 278 q 604 487 632 422 q 523 591 576 551 q 394 631 469 631 q 266 591 319 631 q 185 487 213 551 q 157 350 157 422 q 185 213 157 278 q 266 109 213 149 q 394 69 319 69 z "
    },
    "π": {
      "ha": 768,
      "x_min": 36,
      "x_max": 732,
      "o": "m 160 622 l 36 622 l 36 700 l 732 700 l 732 622 l 608 622 l 608 0 l 522 0 l 522 622 l 246 622 l 246 0 l 160 0 l 160 622 z "
    },
    "ρ": {
      "ha": 794,
      "x_min": 108,
      "x_max": 728,
      "o": "m 108 361 q 188 614 108 517 q 415 711 268 711 q 585 663 514 711 q 692 533 656 615 q 728 350 728 451 q 692 167 728 249 q 585 37 656 85 q 415 -11 514 -11 q 290 18 351 -11 q 194 99 229 47 l 194 -283 l 108 -283 l 108 361 m 415 69 q 580 149 522 69 q 638 350 638 228 q 580 552 638 474 q 415 631 522 631 q 251 553 308 631 q 194 350 194 475 q 251 148 194 226 q 415 69 308 69 z "
    },
    "ς": {
      "ha": 717,
      "x_min": 67,
      "x_max": 658,
      "o": "m 393 -294 q 197 -228 271 -294 l 247 -154 q 393 -214 318 -214 q 497 -186 460 -214 q 533 -104 533 -158 q 408 11 533 11 l 383 11 q 226 53 299 11 q 110 172 153 94 q 67 350 67 249 q 102 527 67 444 q 208 660 138 610 q 376 711 278 711 q 658 518 586 711 l 581 488 q 502 594 551 558 q 376 631 453 631 q 213 551 269 631 q 157 350 157 471 q 190 210 157 269 q 279 122 224 151 q 401 92 335 92 l 428 92 q 569 43 515 92 q 624 -97 624 -6 q 596 -196 624 -151 q 516 -267 568 -240 q 393 -294 464 -294 z "
    },
    "σ": {
      "ha": 794,
      "x_min": 67,
      "x_max": 786,
      "o": "m 786 619 l 617 619 q 695 497 668 568 q 722 350 722 426 q 682 174 722 257 q 567 40 642 90 q 394 -11 493 -11 q 222 40 296 -11 q 107 174 147 90 q 67 350 67 257 q 107 526 67 443 q 222 660 147 610 q 394 711 296 711 q 481 700 439 711 l 786 700 l 786 619 m 394 69 q 523 109 469 69 q 604 213 576 149 q 632 350 632 278 q 604 487 632 422 q 523 591 576 551 q 394 631 469 631 q 266 591 319 631 q 185 487 213 551 q 157 350 157 422 q 185 213 157 278 q 266 109 213 149 q 394 69 319 69 z "
    },
    "τ": {
      "ha": 514,
      "x_min": 17,
      "x_max": 497,
      "o": "m 214 619 l 17 619 l 17 700 l 497 700 l 497 619 l 300 619 l 300 0 l 214 0 l 214 619 z "
    },
    "υ": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 379 -11 q 183 65 257 -11 q 108 289 108 140 l 108 700 l 194 700 l 194 300 q 244 124 194 179 q 379 69 294 69 q 514 124 464 69 q 564 300 564 179 l 564 700 l 650 700 l 650 289 q 576 65 650 140 q 379 -11 501 -11 z "
    },
    "φ": {
      "ha": 931,
      "x_min": 67,
      "x_max": 864,
      "o": "m 422 -11 q 235 37 315 -11 q 110 167 154 85 q 67 350 67 250 q 110 531 67 449 q 233 661 153 613 q 422 711 314 710 l 422 853 l 508 853 l 508 711 q 697 661 617 710 q 821 531 778 613 q 864 350 864 449 q 820 167 864 250 q 696 37 776 85 q 508 -11 615 -11 l 508 -283 l 422 -283 l 422 -11 m 422 69 l 422 631 l 413 631 q 226 553 296 631 q 157 350 157 475 q 226 147 157 225 q 413 69 296 69 l 422 69 m 518 69 q 704 147 635 69 q 774 350 774 225 q 704 553 774 475 q 518 631 635 631 l 508 631 l 508 69 l 518 69 z "
    },
    "χ": {
      "ha": 594,
      "x_min": 14,
      "x_max": 581,
      "o": "m 250 382 l 53 700 l 149 700 l 297 458 l 446 700 l 542 700 l 344 382 l 581 0 l 490 0 l 297 306 l 104 0 l 14 0 l 250 382 z "
    },
    "ψ": {
      "ha": 983,
      "x_min": 108,
      "x_max": 875,
      "o": "m 449 -11 q 266 35 343 -11 q 149 164 189 82 q 108 350 108 246 l 108 700 l 194 700 l 194 350 q 226 206 194 269 q 315 106 257 142 q 449 69 372 69 l 449 853 l 535 853 l 535 69 q 669 106 611 69 q 758 206 726 142 q 789 350 789 269 l 789 700 l 875 700 l 875 350 q 835 164 875 246 q 717 35 794 82 q 535 -11 640 -11 l 535 -283 l 449 -283 l 449 -11 z "
    },
    "ω": {
      "ha": 1025,
      "x_min": 58,
      "x_max": 964,
      "o": "m 306 -11 q 183 24 239 -11 q 92 131 126 60 q 58 304 58 201 q 94 513 58 421 q 203 711 131 604 l 275 660 q 180 485 211 568 q 149 307 149 401 q 196 127 149 185 q 314 69 243 69 q 429 126 390 69 q 468 272 468 183 l 468 519 l 554 519 l 554 272 q 593 126 554 183 q 708 69 632 69 q 826 127 779 69 q 874 307 874 185 q 842 485 874 401 q 747 660 811 568 l 819 711 q 928 513 892 604 q 964 304 964 421 q 930 131 964 201 q 840 24 896 60 q 717 -11 783 -11 q 590 23 638 -11 q 511 126 542 57 q 433 23 481 57 q 306 -11 385 -11 z "
    },
    "ϊ": {
      "ha": 303,
      "x_min": -24,
      "x_max": 326,
      "o": "m 108 700 l 194 700 l 194 0 l 108 0 l 108 700 m 44 819 q -4 839 15 819 q -24 886 -24 858 q -4 935 -24 915 q 44 956 15 956 q 93 935 74 956 q 113 886 113 915 q 93 839 113 858 q 44 819 74 819 m 257 819 q 210 839 229 819 q 190 886 190 858 q 210 935 190 915 q 257 956 229 956 q 306 935 286 956 q 326 886 326 915 q 306 839 326 858 q 257 819 286 819 z "
    },
    "ϋ": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 379 -11 q 183 65 257 -11 q 108 289 108 140 l 108 700 l 194 700 l 194 300 q 244 124 194 179 q 379 69 294 69 q 514 124 464 69 q 564 300 564 179 l 564 700 l 650 700 l 650 289 q 576 65 650 140 q 379 -11 501 -11 m 272 819 q 224 839 243 819 q 204 886 204 858 q 224 935 204 915 q 272 956 243 956 q 321 935 301 956 q 340 886 340 915 q 321 839 340 858 q 272 819 301 819 m 485 819 q 438 839 457 819 q 418 886 418 858 q 438 935 418 915 q 485 956 457 956 q 534 935 514 956 q 554 886 554 915 q 534 839 554 858 q 485 819 514 819 z "
    },
    "ό": {
      "ha": 789,
      "x_min": 67,
      "x_max": 722,
      "o": "m 394 -11 q 222 40 296 -11 q 107 174 147 90 q 67 350 67 257 q 107 526 67 443 q 222 660 147 610 q 394 711 296 711 q 567 660 493 711 q 682 526 642 610 q 722 350 722 443 q 682 174 722 257 q 567 40 642 90 q 394 -11 493 -11 m 394 69 q 523 109 469 69 q 604 213 576 149 q 632 350 632 278 q 604 487 632 422 q 523 591 576 551 q 394 631 469 631 q 266 591 319 631 q 185 487 213 551 q 157 350 157 422 q 185 213 157 278 q 266 109 213 149 q 394 69 319 69 m 419 972 l 549 972 l 425 778 l 356 778 l 419 972 z "
    },
    "ύ": {
      "ha": 758,
      "x_min": 108,
      "x_max": 650,
      "o": "m 379 -11 q 183 65 257 -11 q 108 289 108 140 l 108 700 l 194 700 l 194 300 q 244 124 194 179 q 379 69 294 69 q 514 124 464 69 q 564 300 564 179 l 564 700 l 650 700 l 650 289 q 576 65 650 140 q 379 -11 501 -11 m 404 972 l 533 972 l 410 778 l 340 778 l 404 972 z "
    },
    "ώ": {
      "ha": 1025,
      "x_min": 58,
      "x_max": 964,
      "o": "m 306 -11 q 183 24 239 -11 q 92 131 126 60 q 58 304 58 201 q 94 513 58 421 q 203 711 131 604 l 275 660 q 180 485 211 568 q 149 307 149 401 q 196 127 149 185 q 314 69 243 69 q 429 126 390 69 q 468 272 468 183 l 468 519 l 554 519 l 554 272 q 593 126 554 183 q 708 69 632 69 q 826 127 779 69 q 874 307 874 185 q 842 485 874 401 q 747 660 811 568 l 819 711 q 928 513 892 604 q 964 304 964 421 q 930 131 964 201 q 840 24 896 60 q 717 -11 783 -11 q 590 23 638 -11 q 511 126 542 57 q 433 23 481 57 q 306 -11 385 -11 m 536 972 l 665 972 l 542 778 l 472 778 l 536 972 z "
    },
    "Ѐ": {
      "ha": 765,
      "x_min": 125,
      "x_max": 688,
      "o": "m 125 972 l 674 972 l 674 886 l 217 886 l 217 561 l 590 561 l 590 475 l 217 475 l 217 86 l 688 86 l 688 0 l 125 0 l 125 972 m 219 1244 l 349 1244 l 446 1050 l 376 1050 l 219 1244 z "
    },
    "Ё": {
      "ha": 765,
      "x_min": 125,
      "x_max": 688,
      "o": "m 125 972 l 674 972 l 674 886 l 217 886 l 217 561 l 590 561 l 590 475 l 217 475 l 217 86 l 688 86 l 688 0 l 125 0 l 125 972 m 303 1092 q 254 1111 274 1092 q 235 1158 235 1131 q 254 1208 235 1188 q 303 1228 274 1228 q 351 1208 332 1228 q 371 1158 371 1188 q 351 1111 371 1131 q 303 1092 332 1092 m 515 1092 q 468 1111 488 1092 q 449 1158 449 1131 q 468 1208 449 1188 q 515 1228 488 1228 q 565 1208 544 1228 q 585 1158 585 1188 q 565 1111 585 1131 q 515 1092 544 1092 z "
    },
    "Ђ": {
      "ha": 1000,
      "x_min": 42,
      "x_max": 892,
      "o": "m 699 69 q 781 116 756 86 q 806 207 806 146 l 806 469 q 768 588 806 546 q 660 631 731 631 q 542 590 596 631 q 456 473 488 549 q 424 299 424 397 l 424 0 l 332 0 l 332 886 l 42 886 l 42 972 l 714 972 l 714 886 l 424 886 l 424 547 q 528 669 458 628 q 674 711 597 711 q 834 651 776 711 q 892 481 892 590 l 892 194 q 718 -11 892 17 l 699 69 z "
    },
    "Ѓ": {
      "ha": 729,
      "x_min": 125,
      "x_max": 688,
      "o": "m 125 972 l 688 972 l 688 886 l 217 886 l 217 0 l 125 0 l 125 972 m 468 1244 l 597 1244 l 440 1050 l 371 1050 l 468 1244 z "
    },
    "Є": {
      "ha": 908,
      "x_min": 72,
      "x_max": 839,
      "o": "m 471 -11 q 267 44 357 -11 q 124 212 176 100 q 72 486 72 324 q 124 760 72 649 q 267 928 176 872 q 471 983 357 983 q 703 907 604 983 q 839 706 803 831 l 751 679 q 649 837 724 776 q 471 897 575 897 q 256 801 335 897 q 168 529 178 704 l 640 529 l 640 443 l 168 443 q 256 172 178 268 q 471 75 335 75 q 649 135 575 75 q 751 293 724 196 l 839 267 q 703 65 803 142 q 471 -11 604 -11 z "
    },
    "Ѕ": {
      "ha": 703,
      "x_min": 58,
      "x_max": 633,
      "o": "m 363 -11 q 219 24 283 -11 q 113 119 154 60 q 58 251 71 179 l 138 299 q 363 75 189 75 q 488 124 439 75 q 538 264 538 172 q 511 364 538 324 q 442 431 485 404 q 326 493 400 458 q 169 601 226 540 q 113 757 113 663 q 143 874 113 822 q 227 955 174 926 q 344 983 281 983 q 493 944 438 983 q 581 833 549 904 l 506 786 q 344 897 456 897 q 242 858 281 897 q 204 764 204 818 q 231 673 204 711 q 299 610 258 635 q 408 554 340 585 q 574 440 515 506 q 633 268 633 374 q 598 122 633 186 q 501 24 563 58 q 363 -11 439 -11 z "
    },
    "І": {
      "ha": 342,
      "x_min": 125,
      "x_max": 217,
      "o": "m 125 972 l 217 972 l 217 0 l 125 0 l 125 972 z "
    },
    "Ї": {
      "ha": 342,
      "x_min": -6,
      "x_max": 344,
      "o": "m 125 972 l 217 972 l 217 0 l 125 0 l 125 972 m 63 1092 q 14 1111 33 1092 q -6 1158 -6 1131 q 14 1208 -6 1188 q 63 1228 33 1228 q 111 1208 92 1228 q 131 1158 131 1188 q 111 1111 131 1131 q 63 1092 92 1092 m 275 1092 q 228 1111 247 1092 q 208 1158 208 1131 q 228 1208 208 1188 q 275 1228 247 1228 q 324 1208 304 1228 q 344 1158 344 1188 q 324 1111 344 1131 q 275 1092 304 1092 z "
    },
    "Ј": {
      "ha": 699,
      "x_min": 42,
      "x_max": 590,
      "o": "m 317 -11 q 126 60 194 -11 q 42 238 57 132 l 136 258 q 193 124 149 172 q 317 75 238 75 q 448 125 397 75 q 499 275 499 175 l 499 972 l 590 972 l 590 285 q 553 124 590 192 q 453 23 515 57 q 317 -11 390 -11 z "
    },
    "Љ": {
      "ha": 1300,
      "x_min": 61,
      "x_max": 1219,
      "o": "m 61 86 q 173 120 136 86 q 217 249 210 154 l 267 972 l 683 972 l 683 561 l 921 561 q 1139 485 1058 561 q 1219 281 1219 408 q 1139 76 1219 153 q 921 0 1058 0 l 592 0 l 592 886 l 349 886 l 304 240 q 239 59 296 118 q 61 0 182 0 l 61 86 m 903 86 q 1068 131 1013 86 q 1124 281 1124 176 q 1068 430 1124 385 q 903 475 1013 475 l 683 475 l 683 86 l 903 86 z "
    },
    "Њ": {
      "ha": 1304,
      "x_min": 125,
      "x_max": 1224,
      "o": "m 125 972 l 217 972 l 217 561 l 608 561 l 608 972 l 700 972 l 700 561 l 925 561 q 1143 485 1063 561 q 1224 281 1224 408 q 1143 76 1224 153 q 925 0 1063 0 l 608 0 l 608 475 l 217 475 l 217 0 l 125 0 l 125 972 m 907 86 q 1072 131 1017 86 q 1128 281 1128 176 q 1072 430 1128 385 q 907 475 1017 475 l 700 475 l 700 86 l 907 86 z "
    },
    "Ћ": {
      "ha": 1000,
      "x_min": 42,
      "x_max": 892,
      "o": "m 332 886 l 42 886 l 42 972 l 714 972 l 714 886 l 424 886 l 424 547 q 528 669 458 628 q 674 711 597 711 q 834 651 776 711 q 892 481 892 590 l 892 0 l 806 0 l 806 469 q 768 588 806 546 q 660 631 731 631 q 542 590 596 631 q 456 473 488 549 q 424 299 424 397 l 424 0 l 332 0 l 332 886 z "
    },
    "Ќ": {
      "ha": 769,
      "x_min": 125,
      "x_max": 747,
      "o": "m 125 972 l 217 972 l 217 557 l 596 972 l 713 972 l 314 536 l 747 0 l 635 0 l 217 515 l 217 0 l 125 0 l 125 972 m 440 1244 l 569 1244 l 413 1050 l 343 1050 l 440 1244 z "
    },
    "Ѝ": {
      "ha": 932,
      "x_min": 125,
      "x_max": 807,
      "o": "m 125 972 l 217 972 l 217 146 l 699 972 l 807 972 l 807 0 l 715 0 l 715 824 l 233 0 l 125 0 l 125 972 m 275 1244 l 404 1244 l 501 1050 l 432 1050 l 275 1244 z "
    },
    "Ў": {
      "ha": 710,
      "x_min": 17,
      "x_max": 693,
      "o": "m 311 257 l 17 972 l 113 972 l 358 376 l 599 972 l 693 972 l 296 0 l 208 0 l 311 257 m 356 1093 q 249 1135 289 1093 q 210 1244 210 1176 l 281 1244 q 300 1185 281 1208 q 356 1163 319 1163 q 412 1185 393 1163 q 431 1244 431 1207 l 501 1244 q 463 1135 501 1176 q 356 1093 424 1093 z "
    },
    "Џ": {
      "ha": 917,
      "x_min": 125,
      "x_max": 792,
      "o": "m 413 0 l 125 0 l 125 972 l 217 972 l 217 86 l 700 86 l 700 972 l 792 972 l 792 0 l 504 0 l 504 -172 l 413 -172 l 413 0 z "
    },
    "А": {
      "ha": 817,
      "x_min": 17,
      "x_max": 800,
      "o": "m 368 972 l 449 972 l 800 0 l 706 0 l 608 276 l 208 276 l 111 0 l 17 0 l 368 972 m 579 363 l 408 847 l 238 363 l 579 363 z "
    },
    "Б": {
      "ha": 839,
      "x_min": 125,
      "x_max": 758,
      "o": "m 125 972 l 665 972 l 665 886 l 217 886 l 217 561 l 460 561 q 678 485 597 561 q 758 281 758 408 q 678 76 758 153 q 460 0 597 0 l 125 0 l 125 972 m 442 86 q 607 131 551 86 q 663 281 663 176 q 607 430 663 385 q 442 475 551 475 l 217 475 l 217 86 l 442 86 z "
    },
    "В": {
      "ha": 839,
      "x_min": 125,
      "x_max": 758,
      "o": "m 125 972 l 438 972 q 637 906 565 972 q 708 724 708 840 q 674 602 708 649 q 586 532 640 556 q 712 442 665 504 q 758 281 758 379 q 678 76 758 153 q 460 0 597 0 l 125 0 l 125 972 m 438 561 q 569 602 524 561 q 614 724 614 643 q 569 845 614 804 q 438 886 524 886 l 217 886 l 217 561 l 438 561 m 442 86 q 607 131 551 86 q 663 281 663 176 q 607 430 663 385 q 442 475 551 475 l 217 475 l 217 86 l 442 86 z "
    },
    "Г": {
      "ha": 729,
      "x_min": 125,
      "x_max": 688,
      "o": "m 125 972 l 688 972 l 688 886 l 217 886 l 217 0 l 125 0 l 125 972 z "
    },
    "Д": {
      "ha": 901,
      "x_min": 53,
      "x_max": 849,
      "o": "m 53 86 l 121 86 l 264 972 l 764 972 l 764 86 l 849 86 l 832 -172 l 743 -172 l 743 0 l 158 0 l 158 -172 l 69 -172 l 53 86 m 672 86 l 672 886 l 339 886 l 218 86 l 672 86 z "
    },
    "Е": {
      "ha": 765,
      "x_min": 125,
      "x_max": 688,
      "o": "m 125 972 l 674 972 l 674 886 l 217 886 l 217 561 l 590 561 l 590 475 l 217 475 l 217 86 l 688 86 l 688 0 l 125 0 l 125 972 z "
    },
    "Ж": {
      "ha": 1197,
      "x_min": 22,
      "x_max": 1175,
      "o": "m 456 536 l 54 972 l 171 972 l 553 557 l 553 972 l 644 972 l 644 557 l 1026 972 l 1143 972 l 742 536 l 1175 0 l 1063 0 l 644 515 l 644 0 l 553 0 l 553 515 l 135 0 l 22 0 l 456 536 z "
    },
    "З": {
      "ha": 739,
      "x_min": 67,
      "x_max": 672,
      "o": "m 372 -11 q 176 52 258 -11 q 67 233 93 115 l 150 258 q 228 114 171 161 q 372 67 285 67 q 480 94 432 67 q 556 169 528 121 q 583 276 583 217 q 512 434 583 383 q 346 485 440 485 l 313 485 l 313 556 l 349 556 q 488 600 438 556 q 539 735 539 644 q 492 858 539 811 q 361 906 444 906 q 242 865 289 906 q 182 747 196 824 l 100 764 q 190 925 117 867 q 360 983 264 983 q 559 914 490 983 q 628 738 628 844 q 594 610 628 660 q 500 525 561 560 q 625 432 578 493 q 672 283 672 371 q 635 134 672 201 q 529 28 597 67 q 372 -11 461 -11 z "
    },
    "И": {
      "ha": 932,
      "x_min": 125,
      "x_max": 807,
      "o": "m 125 972 l 217 972 l 217 146 l 699 972 l 807 972 l 807 0 l 715 0 l 715 824 l 233 0 l 125 0 l 125 972 z "
    },
    "Й": {
      "ha": 932,
      "x_min": 125,
      "x_max": 807,
      "o": "m 125 972 l 217 972 l 217 146 l 699 972 l 807 972 l 807 0 l 715 0 l 715 824 l 233 0 l 125 0 l 125 972 m 467 1093 q 360 1135 400 1093 q 321 1244 321 1176 l 392 1244 q 411 1185 392 1208 q 467 1163 431 1163 q 523 1185 504 1163 q 542 1244 542 1207 l 613 1244 q 574 1135 613 1176 q 467 1093 535 1093 z "
    },
    "К": {
      "ha": 769,
      "x_min": 125,
      "x_max": 747,
      "o": "m 125 972 l 217 972 l 217 557 l 596 972 l 713 972 l 314 536 l 747 0 l 635 0 l 217 515 l 217 0 l 125 0 l 125 972 z "
    },
    "Л": {
      "ha": 913,
      "x_min": 61,
      "x_max": 788,
      "o": "m 61 86 q 172 121 135 86 q 217 249 210 156 l 269 972 l 788 972 l 788 0 l 696 0 l 696 886 l 351 886 l 304 240 q 239 60 296 119 q 61 0 182 0 l 61 86 z "
    },
    "М": {
      "ha": 1056,
      "x_min": 125,
      "x_max": 931,
      "o": "m 125 972 l 239 972 l 528 240 l 817 972 l 931 972 l 931 0 l 839 0 l 839 794 l 557 89 l 499 89 l 217 794 l 217 0 l 125 0 l 125 972 z "
    },
    "Н": {
      "ha": 928,
      "x_min": 125,
      "x_max": 803,
      "o": "m 125 972 l 217 972 l 217 561 l 711 561 l 711 972 l 803 972 l 803 0 l 711 0 l 711 475 l 217 475 l 217 0 l 125 0 l 125 972 z "
    },
    "О": {
      "ha": 997,
      "x_min": 72,
      "x_max": 925,
      "o": "m 499 -11 q 286 50 383 -11 q 131 224 189 111 q 72 486 72 336 q 131 749 72 636 q 286 922 189 861 q 499 983 383 983 q 711 922 614 983 q 867 749 808 861 q 925 486 925 636 q 867 224 925 336 q 711 50 808 111 q 499 -11 614 -11 m 499 75 q 667 122 592 75 q 785 262 742 169 q 829 486 829 354 q 785 710 829 618 q 667 850 742 803 q 499 897 592 897 q 331 850 406 897 q 212 710 256 803 q 168 486 168 618 q 212 262 168 354 q 331 122 256 169 q 499 75 406 75 z "
    },
    "П": {
      "ha": 913,
      "x_min": 125,
      "x_max": 788,
      "o": "m 125 972 l 788 972 l 788 0 l 696 0 l 696 886 l 217 886 l 217 0 l 125 0 l 125 972 z "
    },
    "Р": {
      "ha": 797,
      "x_min": 125,
      "x_max": 736,
      "o": "m 125 972 l 456 972 q 661 901 586 972 q 736 704 736 829 q 661 508 736 579 q 456 436 586 436 l 217 436 l 217 0 l 125 0 l 125 972 m 457 522 q 596 572 551 522 q 640 704 640 621 q 596 837 640 788 q 457 886 551 886 l 217 886 l 217 522 l 457 522 z "
    },
    "С": {
      "ha": 938,
      "x_min": 72,
      "x_max": 868,
      "o": "m 501 -11 q 290 44 388 -11 q 132 213 192 100 q 72 486 72 325 q 132 760 72 647 q 290 928 192 872 q 501 983 388 983 q 735 909 639 983 q 868 706 831 835 l 778 679 q 680 840 750 783 q 501 897 610 897 q 328 849 403 897 q 210 708 253 801 q 168 486 168 615 q 210 264 168 357 q 328 123 253 171 q 501 75 403 75 q 680 132 610 75 q 778 293 750 189 l 868 267 q 735 63 831 138 q 501 -11 639 -11 z "
    },
    "Т": {
      "ha": 756,
      "x_min": 42,
      "x_max": 714,
      "o": "m 332 886 l 42 886 l 42 972 l 714 972 l 714 886 l 424 886 l 424 0 l 332 0 l 332 886 z "
    },
    "У": {
      "ha": 710,
      "x_min": 17,
      "x_max": 693,
      "o": "m 311 257 l 17 972 l 113 972 l 358 376 l 599 972 l 693 972 l 296 0 l 208 0 l 311 257 z "
    },
    "Ф": {
      "ha": 1053,
      "x_min": 72,
      "x_max": 981,
      "o": "m 481 100 l 471 100 q 264 148 354 100 q 123 283 174 196 q 72 486 72 371 q 123 689 72 601 q 264 824 174 776 q 471 872 354 872 l 481 872 l 481 972 l 572 972 l 572 872 l 586 872 q 792 824 703 872 q 931 689 882 776 q 981 486 981 601 q 930 283 981 371 q 789 148 879 196 q 582 100 699 100 l 572 100 l 572 0 l 481 0 l 481 100 m 481 181 l 481 792 l 467 792 q 305 752 374 792 q 199 643 236 713 q 163 486 163 574 q 199 329 163 399 q 305 220 236 260 q 467 181 374 181 l 481 181 m 586 181 q 748 220 679 181 q 853 329 817 260 q 890 486 890 399 q 853 643 890 574 q 748 752 817 713 q 586 792 679 792 l 572 792 l 572 181 l 586 181 z "
    },
    "Х": {
      "ha": 772,
      "x_min": 22,
      "x_max": 750,
      "o": "m 336 535 l 82 972 l 183 972 l 386 619 l 589 972 l 690 972 l 436 535 l 750 0 l 649 0 l 386 449 l 124 0 l 22 0 l 336 535 z "
    },
    "Ц": {
      "ha": 929,
      "x_min": 125,
      "x_max": 876,
      "o": "m 771 0 l 125 0 l 125 972 l 217 972 l 217 86 l 696 86 l 696 972 l 788 972 l 788 86 l 876 86 l 860 -172 l 771 -172 l 771 0 z "
    },
    "Ч": {
      "ha": 863,
      "x_min": 108,
      "x_max": 738,
      "o": "m 646 463 q 378 381 531 381 q 180 451 251 381 q 108 667 108 521 l 108 972 l 200 972 l 200 674 q 253 517 200 567 q 400 467 306 467 q 532 494 465 467 q 646 569 599 522 l 646 972 l 738 972 l 738 0 l 646 0 l 646 463 z "
    },
    "Ш": {
      "ha": 1314,
      "x_min": 125,
      "x_max": 1189,
      "o": "m 125 972 l 217 972 l 217 86 l 611 86 l 611 972 l 703 972 l 703 86 l 1097 86 l 1097 972 l 1189 972 l 1189 0 l 125 0 l 125 972 z "
    },
    "Щ": {
      "ha": 1331,
      "x_min": 125,
      "x_max": 1278,
      "o": "m 1168 0 l 125 0 l 125 972 l 217 972 l 217 86 l 611 86 l 611 972 l 703 972 l 703 86 l 1097 86 l 1097 972 l 1189 972 l 1189 86 l 1278 86 l 1257 -172 l 1168 -172 l 1168 0 z "
    },
    "Ъ": {
      "ha": 924,
      "x_min": 36,
      "x_max": 843,
      "o": "m 210 886 l 36 886 l 36 972 l 301 972 l 301 561 l 544 561 q 763 485 682 561 q 843 281 843 408 q 763 76 843 153 q 544 0 682 0 l 210 0 l 210 886 m 526 86 q 692 131 636 86 q 747 281 747 176 q 692 430 747 385 q 526 475 636 475 l 301 475 l 301 86 l 526 86 z "
    },
    "Ы": {
      "ha": 1181,
      "x_min": 125,
      "x_max": 1056,
      "o": "m 125 972 l 217 972 l 217 561 l 460 561 q 678 485 597 561 q 758 281 758 408 q 678 76 758 153 q 460 0 597 0 l 125 0 l 125 972 m 442 86 q 607 131 551 86 q 663 281 663 176 q 607 430 663 385 q 442 475 551 475 l 217 475 l 217 86 l 442 86 m 964 972 l 1056 972 l 1056 0 l 964 0 l 964 972 z "
    },
    "Ь": {
      "ha": 839,
      "x_min": 125,
      "x_max": 758,
      "o": "m 125 972 l 217 972 l 217 561 l 460 561 q 678 485 597 561 q 758 281 758 408 q 678 76 758 153 q 460 0 597 0 l 125 0 l 125 972 m 442 86 q 607 131 551 86 q 663 281 663 176 q 607 430 663 385 q 442 475 551 475 l 217 475 l 217 86 l 442 86 z "
    },
    "Э": {
      "ha": 908,
      "x_min": 69,
      "x_max": 836,
      "o": "m 438 -11 q 205 65 304 -11 q 69 267 106 142 l 157 293 q 259 135 185 196 q 438 75 333 75 q 651 172 574 75 q 739 443 729 268 l 268 443 l 268 529 l 739 529 q 651 801 729 704 q 438 897 574 897 q 259 837 333 897 q 157 679 185 776 l 69 706 q 205 907 106 831 q 438 983 304 983 q 642 928 551 983 q 784 760 732 872 q 836 486 836 649 q 784 212 836 324 q 642 44 732 100 q 438 -11 551 -11 z "
    },
    "Ю": {
      "ha": 1392,
      "x_min": 125,
      "x_max": 1319,
      "o": "m 893 -11 q 690 44 783 -11 q 536 203 596 100 q 468 443 476 306 l 217 443 l 217 0 l 125 0 l 125 972 l 217 972 l 217 529 l 468 529 q 536 769 476 667 q 690 928 596 872 q 893 983 783 983 q 1106 922 1008 983 q 1261 749 1203 861 q 1319 486 1319 636 q 1261 224 1319 336 q 1106 50 1203 111 q 893 -11 1008 -11 m 893 75 q 1061 122 986 75 q 1180 262 1136 169 q 1224 486 1224 354 q 1180 710 1224 618 q 1061 850 1136 803 q 893 897 986 897 q 725 850 800 897 q 606 710 650 803 q 563 486 563 618 q 606 262 563 354 q 725 122 650 169 q 893 75 800 75 z "
    },
    "Я": {
      "ha": 853,
      "x_min": 47,
      "x_max": 728,
      "o": "m 350 485 q 193 560 249 499 q 138 726 138 621 q 210 910 138 849 q 415 972 283 972 l 728 972 l 728 0 l 636 0 l 636 481 l 454 481 l 150 0 l 47 0 l 350 485 m 636 567 l 636 886 l 421 886 q 278 847 325 886 q 231 726 231 808 q 278 606 231 644 q 421 567 325 567 l 636 567 z "
    },
    "а": {
      "ha": 686,
      "x_min": 69,
      "x_max": 594,
      "o": "m 288 -11 q 131 41 192 -11 q 69 201 69 93 q 153 373 69 315 q 388 431 238 431 l 508 431 l 508 461 q 465 590 508 549 q 347 631 422 631 q 238 594 279 631 q 181 500 197 558 l 97 519 q 181 659 111 607 q 347 711 251 711 q 524 645 454 711 q 594 464 594 579 l 594 0 l 529 0 l 508 108 q 422 22 476 54 q 288 -11 367 -11 m 296 69 q 394 95 346 69 q 476 178 443 121 q 508 324 508 235 l 508 350 l 390 350 q 217 311 274 350 q 160 201 160 272 q 196 103 160 138 q 296 69 232 69 z "
    },
    "б": {
      "ha": 793,
      "x_min": 67,
      "x_max": 726,
      "o": "m 397 -11 q 155 102 243 -11 q 67 431 67 215 q 159 845 67 718 q 422 972 251 972 l 474 972 q 553 986 531 972 q 586 1038 575 1000 l 654 1038 q 608 928 649 964 q 497 892 567 892 l 429 892 q 240 810 303 892 q 165 597 176 729 q 272 679 207 647 q 425 711 336 711 q 585 663 517 711 q 690 532 653 614 q 726 350 726 450 q 686 169 726 251 q 571 38 646 86 q 397 -11 496 -11 m 397 69 q 526 109 472 69 q 608 213 581 149 q 636 350 636 276 q 608 488 636 424 q 526 591 581 551 q 397 631 472 631 q 268 591 322 631 q 186 488 214 551 q 158 350 158 424 q 186 213 158 276 q 268 109 214 149 q 397 69 322 69 z "
    },
    "в": {
      "ha": 669,
      "x_min": 108,
      "x_max": 593,
      "o": "m 108 700 l 371 700 q 512 653 458 700 q 565 526 565 607 q 543 442 565 479 q 486 383 521 406 q 565 317 536 360 q 593 214 593 274 q 532 60 593 119 q 368 0 471 0 l 108 0 l 108 700 m 369 414 q 451 440 424 414 q 479 517 479 467 q 451 593 479 567 q 369 619 424 619 l 194 619 l 194 414 l 369 414 m 364 81 q 471 113 435 81 q 507 207 507 146 q 471 301 507 268 q 364 333 435 333 l 194 333 l 194 81 l 364 81 z "
    },
    "г": {
      "ha": 575,
      "x_min": 108,
      "x_max": 539,
      "o": "m 108 700 l 539 700 l 539 619 l 194 619 l 194 0 l 108 0 l 108 700 z "
    },
    "д": {
      "ha": 750,
      "x_min": 42,
      "x_max": 697,
      "o": "m 42 81 l 88 81 l 185 700 l 649 700 l 649 81 l 697 81 l 683 -158 l 597 -158 l 597 0 l 144 0 l 144 -158 l 58 -158 l 42 81 m 563 81 l 563 619 l 261 619 l 181 81 l 563 81 z "
    },
    "е": {
      "ha": 751,
      "x_min": 67,
      "x_max": 685,
      "o": "m 378 -11 q 215 35 286 -11 q 106 164 144 82 q 67 350 67 246 q 106 536 67 454 q 215 665 144 618 q 378 711 286 711 q 537 671 467 711 q 646 558 607 631 q 685 389 685 485 l 685 350 l 157 350 q 216 147 157 225 q 378 69 275 69 q 506 104 457 69 q 593 219 554 139 l 669 182 q 547 33 617 78 q 378 -11 478 -11 m 596 431 q 527 577 583 524 q 378 631 471 631 q 237 575 293 631 q 163 431 181 519 l 596 431 z "
    },
    "ж": {
      "ha": 972,
      "x_min": 17,
      "x_max": 956,
      "o": "m 344 379 l 42 700 l 150 700 l 443 390 l 443 700 l 529 700 l 529 390 l 822 700 l 931 700 l 628 379 l 956 0 l 846 0 l 529 368 l 529 0 l 443 0 l 443 368 l 126 0 l 17 0 l 344 379 z "
    },
    "з": {
      "ha": 575,
      "x_min": 56,
      "x_max": 511,
      "o": "m 292 -11 q 130 42 194 -11 q 56 188 65 96 l 142 197 q 188 106 150 142 q 292 69 226 69 q 385 106 349 69 q 421 197 421 142 q 378 296 421 261 q 261 331 336 331 l 236 331 l 236 406 l 258 406 q 359 433 321 406 q 397 518 397 461 q 365 600 397 569 q 281 631 333 631 q 199 604 233 631 q 153 532 164 578 l 74 553 q 142 669 88 626 q 278 711 197 711 q 427 665 371 711 q 483 538 483 618 q 458 435 483 476 q 393 371 433 394 q 480 306 449 350 q 511 199 511 263 q 449 47 511 106 q 292 -11 386 -11 z "
    },
    "и": {
      "ha": 764,
      "x_min": 108,
      "x_max": 656,
      "o": "m 108 700 l 194 700 l 194 136 l 564 700 l 656 700 l 656 0 l 569 0 l 569 564 l 200 0 l 108 0 l 108 700 z "
    },
    "й": {
      "ha": 764,
      "x_min": 108,
      "x_max": 656,
      "o": "m 108 700 l 194 700 l 194 136 l 564 700 l 656 700 l 656 0 l 569 0 l 569 564 l 200 0 l 108 0 l 108 700 m 379 821 q 273 863 313 821 q 233 972 233 904 l 304 972 q 324 913 304 936 q 379 890 343 890 q 435 913 417 890 q 454 972 454 935 l 525 972 q 486 863 525 904 q 379 821 447 821 z "
    },
    "к": {
      "ha": 638,
      "x_min": 108,
      "x_max": 621,
      "o": "m 108 700 l 194 700 l 194 390 l 488 700 l 596 700 l 293 379 l 621 0 l 511 0 l 194 368 l 194 0 l 108 0 l 108 700 z "
    },
    "л": {
      "ha": 778,
      "x_min": 39,
      "x_max": 669,
      "o": "m 39 81 q 141 110 113 81 q 176 210 169 140 l 225 700 l 669 700 l 669 0 l 583 0 l 583 619 l 306 619 l 261 189 q 199 45 250 90 q 39 0 149 0 l 39 81 z "
    },
    "м": {
      "ha": 847,
      "x_min": 108,
      "x_max": 739,
      "o": "m 108 700 l 225 700 l 424 206 l 622 700 l 739 700 l 739 0 l 653 0 l 653 564 l 454 64 l 393 64 l 194 564 l 194 0 l 108 0 l 108 700 z "
    },
    "н": {
      "ha": 731,
      "x_min": 108,
      "x_max": 622,
      "o": "m 108 700 l 194 700 l 194 413 l 536 413 l 536 700 l 622 700 l 622 0 l 536 0 l 536 332 l 194 332 l 194 0 l 108 0 l 108 700 z "
    },
    "о": {
      "ha": 789,
      "x_min": 67,
      "x_max": 722,
      "o": "m 394 -11 q 222 40 296 -11 q 107 174 147 90 q 67 350 67 257 q 107 526 67 443 q 222 660 147 610 q 394 711 296 711 q 567 660 493 711 q 682 526 642 610 q 722 350 722 443 q 682 174 722 257 q 567 40 642 90 q 394 -11 493 -11 m 394 69 q 523 109 469 69 q 604 213 576 149 q 632 350 632 278 q 604 487 632 422 q 523 591 576 551 q 394 631 469 631 q 266 591 319 631 q 185 487 213 551 q 157 350 157 422 q 185 213 157 278 q 266 109 213 149 q 394 69 319 69 z "
    },
    "п": {
      "ha": 732,
      "x_min": 108,
      "x_max": 624,
      "o": "m 108 700 l 624 700 l 624 0 l 538 0 l 538 619 l 194 619 l 194 0 l 108 0 l 108 700 z "
    },
    "р": {
      "ha": 794,
      "x_min": 108,
      "x_max": 728,
      "o": "m 108 700 l 194 700 l 194 600 q 285 678 224 646 q 415 711 347 711 q 585 663 514 711 q 692 533 656 615 q 728 350 728 451 q 692 167 728 249 q 585 37 656 85 q 415 -11 514 -11 q 290 18 351 -11 q 194 99 229 47 l 194 -283 l 108 -283 l 108 700 m 411 69 q 578 149 518 69 q 638 350 638 228 q 578 552 638 474 q 411 631 519 631 q 244 552 303 631 q 186 350 186 474 q 245 149 186 228 q 411 69 304 69 z "
    },
    "с": {
      "ha": 717,
      "x_min": 67,
      "x_max": 658,
      "o": "m 376 -11 q 208 40 278 -11 q 102 173 138 90 q 67 350 67 256 q 102 527 67 444 q 208 660 138 610 q 376 711 278 711 q 658 518 586 711 l 581 488 q 376 631 525 631 q 213 551 269 631 q 157 350 157 471 q 213 149 157 229 q 376 69 269 69 q 502 106 453 69 q 581 213 551 142 l 658 182 q 551 38 622 88 q 376 -11 479 -11 z "
    },
    "т": {
      "ha": 572,
      "x_min": 46,
      "x_max": 526,
      "o": "m 243 619 l 46 619 l 46 700 l 526 700 l 526 619 l 329 619 l 329 0 l 243 0 l 243 619 z "
    },
    "у": {
      "ha": 611,
      "x_min": 14,
      "x_max": 597,
      "o": "m 265 4 l 14 700 l 104 700 l 313 133 l 507 700 l 597 700 l 250 -283 l 164 -283 l 265 4 z "
    },
    "ф": {
      "ha": 947,
      "x_min": 67,
      "x_max": 881,
      "o": "m 431 -11 q 237 38 319 -11 q 110 170 154 88 q 67 350 67 253 q 110 530 67 447 q 237 662 154 613 q 431 711 319 711 l 431 983 l 517 983 l 517 711 q 710 662 628 711 q 837 530 793 613 q 881 350 881 447 q 837 170 881 253 q 710 38 793 88 q 517 -11 628 -11 l 517 -283 l 431 -283 l 431 -11 m 431 69 l 431 631 l 421 631 q 227 553 297 631 q 157 350 157 475 q 227 147 157 225 q 421 69 297 69 l 431 69 m 526 69 q 720 147 650 69 q 790 350 790 225 q 720 553 790 475 q 526 631 650 631 l 517 631 l 517 69 l 526 69 z "
    },
    "х": {
      "ha": 594,
      "x_min": 14,
      "x_max": 581,
      "o": "m 250 382 l 53 700 l 149 700 l 297 458 l 446 700 l 542 700 l 344 382 l 581 0 l 490 0 l 297 306 l 104 0 l 14 0 l 250 382 z "
    },
    "ц": {
      "ha": 725,
      "x_min": 108,
      "x_max": 672,
      "o": "m 572 0 l 108 0 l 108 700 l 194 700 l 194 81 l 538 81 l 538 700 l 624 700 l 624 81 l 672 81 l 658 -158 l 572 -158 l 572 0 z "
    },
    "ч": {
      "ha": 725,
      "x_min": 97,
      "x_max": 617,
      "o": "m 531 326 q 421 242 482 269 q 294 214 360 214 q 151 268 206 214 q 97 411 97 322 l 97 700 l 183 700 l 183 419 q 218 324 183 356 q 310 292 253 292 q 431 328 376 292 q 531 436 485 365 l 531 700 l 617 700 l 617 0 l 531 0 l 531 326 z "
    },
    "ш": {
      "ha": 1094,
      "x_min": 108,
      "x_max": 986,
      "o": "m 108 700 l 194 700 l 194 81 l 504 81 l 504 700 l 590 700 l 590 81 l 900 81 l 900 700 l 986 700 l 986 0 l 108 0 l 108 700 z "
    },
    "щ": {
      "ha": 1088,
      "x_min": 108,
      "x_max": 1035,
      "o": "m 935 0 l 108 0 l 108 700 l 194 700 l 194 81 l 504 81 l 504 700 l 590 700 l 590 81 l 900 81 l 900 700 l 986 700 l 986 81 l 1035 81 l 1021 -158 l 935 -158 l 935 0 z "
    },
    "ъ": {
      "ha": 713,
      "x_min": 33,
      "x_max": 646,
      "o": "m 176 619 l 33 619 l 33 700 l 263 700 l 263 433 l 413 433 q 585 376 525 433 q 646 217 646 318 q 585 58 646 115 q 413 0 525 0 l 176 0 l 176 619 m 375 81 q 508 113 467 81 q 550 217 550 146 q 508 320 550 288 q 375 353 467 353 l 263 353 l 263 81 l 375 81 z "
    },
    "ы": {
      "ha": 947,
      "x_min": 108,
      "x_max": 839,
      "o": "m 108 700 l 194 700 l 194 433 l 344 433 q 517 376 457 433 q 578 217 578 318 q 517 58 578 115 q 344 0 457 0 l 108 0 l 108 700 m 307 81 q 440 113 399 81 q 482 217 482 146 q 440 320 482 288 q 307 353 399 353 l 194 353 l 194 81 l 307 81 m 753 700 l 839 700 l 839 0 l 753 0 l 753 700 z "
    },
    "ь": {
      "ha": 644,
      "x_min": 108,
      "x_max": 578,
      "o": "m 108 700 l 194 700 l 194 433 l 344 433 q 517 376 457 433 q 578 217 578 318 q 517 58 578 115 q 344 0 457 0 l 108 0 l 108 700 m 307 81 q 440 113 399 81 q 482 217 482 146 q 440 320 482 288 q 307 353 399 353 l 194 353 l 194 81 l 307 81 z "
    },
    "э": {
      "ha": 710,
      "x_min": 58,
      "x_max": 643,
      "o": "m 343 -11 q 172 36 244 -11 q 58 176 100 83 l 139 213 q 346 69 197 69 q 493 135 443 69 q 551 310 543 201 l 217 310 l 217 390 l 551 390 q 493 565 543 499 q 346 631 443 631 q 139 488 197 631 l 58 524 q 172 664 100 617 q 343 711 244 711 q 509 660 442 711 q 610 528 576 610 q 643 350 643 446 q 610 172 643 254 q 509 40 576 90 q 343 -11 442 -11 z "
    },
    "ю": {
      "ha": 1057,
      "x_min": 108,
      "x_max": 990,
      "o": "m 663 -11 q 500 33 571 -11 q 387 151 429 78 q 336 310 344 224 l 194 310 l 194 0 l 108 0 l 108 700 l 194 700 l 194 390 l 336 390 q 387 549 344 476 q 500 667 429 622 q 663 711 571 711 q 835 660 761 711 q 950 526 910 610 q 990 350 990 443 q 950 174 990 257 q 835 40 910 90 q 663 -11 761 -11 m 663 69 q 791 109 738 69 q 872 213 844 149 q 900 350 900 278 q 872 487 900 422 q 791 591 844 551 q 663 631 738 631 q 534 591 588 631 q 453 487 481 551 q 425 350 425 422 q 453 213 425 278 q 534 109 481 149 q 663 69 588 69 z "
    },
    "я": {
      "ha": 646,
      "x_min": 38,
      "x_max": 538,
      "o": "m 218 322 q 115 390 153 342 q 76 507 76 438 q 139 647 76 594 q 299 700 201 700 l 538 700 l 538 0 l 451 0 l 451 314 l 303 314 l 133 0 l 38 0 l 218 322 m 451 394 l 451 619 l 294 619 q 197 592 231 619 q 163 507 163 564 q 197 422 163 450 q 294 394 231 394 l 451 394 z "
    },
    "ѐ": {
      "ha": 751,
      "x_min": 67,
      "x_max": 685,
      "o": "m 378 -11 q 215 35 286 -11 q 106 164 144 82 q 67 350 67 246 q 106 536 67 454 q 215 665 144 618 q 378 711 286 711 q 537 671 467 711 q 646 558 607 631 q 685 389 685 485 l 685 350 l 157 350 q 216 147 157 225 q 378 69 275 69 q 506 104 457 69 q 593 219 554 139 l 669 182 q 547 33 617 78 q 378 -11 478 -11 m 596 431 q 527 577 583 524 q 378 631 471 631 q 237 575 293 631 q 163 431 181 519 l 596 431 m 186 972 l 315 972 l 413 778 l 343 778 l 186 972 z "
    },
    "ё": {
      "ha": 751,
      "x_min": 67,
      "x_max": 685,
      "o": "m 378 -11 q 215 35 286 -11 q 106 164 144 82 q 67 350 67 246 q 106 536 67 454 q 215 665 144 618 q 378 711 286 711 q 537 671 467 711 q 646 558 607 631 q 685 389 685 485 l 685 350 l 157 350 q 216 147 157 225 q 378 69 275 69 q 506 104 457 69 q 593 219 554 139 l 669 182 q 547 33 617 78 q 378 -11 478 -11 m 596 431 q 527 577 583 524 q 378 631 471 631 q 237 575 293 631 q 163 431 181 519 l 596 431 m 271 819 q 222 839 242 819 q 203 886 203 858 q 222 935 203 915 q 271 956 242 956 q 319 935 300 956 q 339 886 339 915 q 319 839 339 858 q 271 819 300 819 m 483 819 q 436 839 456 819 q 417 886 417 858 q 436 935 417 915 q 483 956 456 956 q 533 935 513 956 q 553 886 553 915 q 533 839 553 858 q 483 819 513 819 z "
    },
    "ђ": {
      "ha": 771,
      "x_min": 7,
      "x_max": 663,
      "o": "m 469 -214 q 551 -167 526 -197 q 576 -76 576 -137 l 576 469 q 539 588 576 546 q 431 631 501 631 q 313 590 367 631 q 226 473 258 549 q 194 299 194 397 l 194 0 l 108 0 l 108 803 l 7 803 l 7 881 l 108 881 l 108 983 l 194 983 l 194 881 l 382 881 l 382 803 l 194 803 l 194 547 q 299 669 229 628 q 444 711 368 711 q 605 651 547 711 q 663 481 663 590 l 663 -89 q 489 -294 663 -267 l 469 -214 z "
    },
    "ѓ": {
      "ha": 575,
      "x_min": 108,
      "x_max": 539,
      "o": "m 108 700 l 539 700 l 539 619 l 194 619 l 194 0 l 108 0 l 108 700 m 369 972 l 499 972 l 342 778 l 272 778 l 369 972 z "
    },
    "є": {
      "ha": 710,
      "x_min": 67,
      "x_max": 651,
      "o": "m 367 -11 q 201 40 268 -11 q 100 172 133 90 q 67 350 67 254 q 100 528 67 446 q 201 660 133 610 q 367 711 268 711 q 538 664 465 711 q 651 524 610 617 l 571 488 q 364 631 513 631 q 217 565 267 631 q 158 390 167 499 l 493 390 l 493 310 l 158 310 q 217 135 167 201 q 364 69 267 69 q 571 213 513 69 l 651 176 q 538 36 610 83 q 367 -11 465 -11 z "
    },
    "ѕ": {
      "ha": 597,
      "x_min": 64,
      "x_max": 533,
      "o": "m 317 -11 q 147 44 210 -11 q 64 181 83 100 l 140 221 q 203 109 163 149 q 317 69 244 69 q 410 103 376 69 q 443 193 443 136 q 405 274 443 244 q 289 332 367 304 q 158 406 203 363 q 113 528 113 450 q 168 661 113 611 q 308 711 224 711 q 422 685 375 711 q 503 603 469 658 l 442 550 q 381 612 414 593 q 304 631 347 631 q 231 603 260 631 q 201 531 201 576 q 238 456 201 485 q 363 396 274 428 q 485 319 438 368 q 533 194 533 269 q 475 44 533 99 q 317 -11 417 -11 z "
    },
    "і": {
      "ha": 303,
      "x_min": 81,
      "x_max": 222,
      "o": "m 151 831 q 101 851 121 831 q 81 901 81 871 q 101 952 81 932 q 151 972 121 972 q 202 952 182 972 q 222 901 222 932 q 202 851 222 871 q 151 831 182 831 m 108 700 l 194 700 l 194 0 l 108 0 l 108 700 z "
    },
    "ї": {
      "ha": 303,
      "x_min": -24,
      "x_max": 326,
      "o": "m 108 700 l 194 700 l 194 0 l 108 0 l 108 700 m 44 819 q -4 839 15 819 q -24 886 -24 858 q -4 935 -24 915 q 44 956 15 956 q 93 935 74 956 q 113 886 113 915 q 93 839 113 858 q 44 819 74 819 m 257 819 q 210 839 229 819 q 190 886 190 858 q 210 935 190 915 q 257 956 229 956 q 306 935 286 956 q 326 886 326 915 q 306 839 326 858 q 257 819 286 819 z "
    },
    "ј": {
      "ha": 303,
      "x_min": 1,
      "x_max": 222,
      "o": "m 151 831 q 101 851 121 831 q 81 901 81 871 q 101 952 81 932 q 151 972 121 972 q 202 952 182 972 q 222 901 222 932 q 202 851 222 871 q 151 831 182 831 m 1 -214 q 83 -167 58 -197 q 108 -76 108 -137 l 108 700 l 194 700 l 194 -89 q 21 -294 194 -267 l 1 -214 z "
    },
    "љ": {
      "ha": 1054,
      "x_min": 39,
      "x_max": 988,
      "o": "m 39 81 q 141 110 113 81 q 176 210 169 140 l 225 700 l 604 700 l 604 433 l 754 433 q 927 376 867 433 q 988 217 988 318 q 927 58 988 115 q 754 0 867 0 l 518 0 l 518 619 l 306 619 l 261 189 q 199 45 250 90 q 39 0 149 0 l 39 81 m 717 81 q 850 113 808 81 q 892 217 892 146 q 850 320 892 288 q 717 353 808 353 l 604 353 l 604 81 l 717 81 z "
    },
    "њ": {
      "ha": 1079,
      "x_min": 108,
      "x_max": 1013,
      "o": "m 108 700 l 194 700 l 194 433 l 536 433 l 536 700 l 622 700 l 622 433 l 779 433 q 952 376 892 433 q 1013 217 1013 318 q 952 58 1013 115 q 779 0 892 0 l 536 0 l 536 353 l 194 353 l 194 0 l 108 0 l 108 700 m 742 81 q 875 113 833 81 q 917 217 917 146 q 875 320 917 288 q 742 353 833 353 l 622 353 l 622 81 l 742 81 z "
    },
    "ћ": {
      "ha": 771,
      "x_min": 7,
      "x_max": 663,
      "o": "m 108 983 l 194 983 l 194 547 q 299 669 229 628 q 444 711 368 711 q 605 651 547 711 q 663 481 663 590 l 663 0 l 576 0 l 576 469 q 539 588 576 546 q 431 631 501 631 q 313 590 367 631 q 226 473 258 549 q 194 299 194 397 l 194 0 l 108 0 l 108 983 m 7 881 l 382 881 l 382 803 l 7 803 l 7 881 z "
    },
    "ќ": {
      "ha": 638,
      "x_min": 108,
      "x_max": 621,
      "o": "m 108 700 l 194 700 l 194 390 l 488 700 l 596 700 l 293 379 l 621 0 l 511 0 l 194 368 l 194 0 l 108 0 l 108 700 m 372 972 l 501 972 l 344 778 l 275 778 l 372 972 z "
    },
    "ѝ": {
      "ha": 764,
      "x_min": 108,
      "x_max": 656,
      "o": "m 108 700 l 194 700 l 194 136 l 564 700 l 656 700 l 656 0 l 569 0 l 569 564 l 200 0 l 108 0 l 108 700 m 188 972 l 317 972 l 414 778 l 344 778 l 188 972 z "
    },
    "ў": {
      "ha": 611,
      "x_min": 14,
      "x_max": 597,
      "o": "m 265 4 l 14 700 l 104 700 l 313 133 l 507 700 l 597 700 l 250 -283 l 164 -283 l 265 4 m 306 821 q 199 863 239 821 q 160 972 160 904 l 231 972 q 250 913 231 936 q 306 890 269 890 q 362 913 343 890 q 381 972 381 935 l 451 972 q 413 863 451 904 q 306 821 374 821 z "
    },
    "џ": {
      "ha": 731,
      "x_min": 108,
      "x_max": 622,
      "o": "m 322 0 l 108 0 l 108 700 l 194 700 l 194 81 l 536 81 l 536 700 l 622 700 l 622 0 l 408 0 l 408 -158 l 322 -158 l 322 0 z "
    },
    "Ѣ": {
      "ha": 899,
      "x_min": 14,
      "x_max": 818,
      "o": "m 519 561 q 738 485 657 561 q 818 281 818 408 q 738 76 818 153 q 519 0 657 0 l 185 0 l 185 726 l 14 726 l 14 813 l 185 813 l 185 972 l 276 972 l 276 813 l 489 813 l 489 726 l 276 726 l 276 561 l 519 561 m 501 86 q 667 131 611 86 q 722 281 722 176 q 667 430 722 385 q 501 475 611 475 l 276 475 l 276 86 l 501 86 z "
    },
    "ѣ": {
      "ha": 732,
      "x_min": 22,
      "x_max": 665,
      "o": "m 432 433 q 605 376 544 433 q 665 217 665 318 q 605 58 665 115 q 432 0 544 0 l 196 0 l 196 665 l 22 665 l 22 743 l 196 743 l 196 972 l 282 972 l 282 743 l 479 743 l 479 665 l 282 665 l 282 433 l 432 433 m 394 81 q 528 113 486 81 q 569 217 569 146 q 528 320 569 288 q 394 353 486 353 l 282 353 l 282 81 l 394 81 z "
    },
    "Ѳ": {
      "ha": 997,
      "x_min": 72,
      "x_max": 925,
      "o": "m 499 983 q 711 922 614 983 q 867 749 808 861 q 925 486 925 636 q 867 224 925 336 q 711 50 808 111 q 499 -11 614 -11 q 286 50 383 -11 q 131 224 189 111 q 72 486 72 336 q 131 749 72 636 q 286 922 189 861 q 499 983 383 983 m 499 897 q 338 855 410 897 q 220 728 265 813 q 169 525 175 644 l 828 525 q 777 728 822 644 q 660 855 732 813 q 499 897 588 897 m 499 75 q 660 117 588 75 q 777 244 732 160 q 828 447 822 328 l 169 447 q 220 244 175 328 q 338 117 265 160 q 499 75 410 75 z "
    },
    "ѳ": {
      "ha": 789,
      "x_min": 67,
      "x_max": 722,
      "o": "m 394 711 q 567 660 493 711 q 682 526 642 610 q 722 350 722 443 q 682 174 722 257 q 567 40 642 90 q 394 -11 493 -11 q 222 40 296 -11 q 107 174 147 90 q 67 350 67 257 q 107 526 67 443 q 222 660 147 610 q 394 711 296 711 m 394 631 q 231 561 293 631 q 158 389 169 492 l 631 389 q 558 561 619 492 q 394 631 496 631 m 394 69 q 558 139 496 69 q 631 311 619 208 l 158 311 q 231 139 169 208 q 394 69 293 69 z "
    },
    "Ѵ": {
      "ha": 863,
      "x_min": 17,
      "x_max": 863,
      "o": "m 624 753 q 678 883 654 840 q 744 949 701 925 q 863 972 786 972 l 863 886 q 794 874 819 886 q 753 835 769 863 q 718 753 738 808 l 454 0 l 357 0 l 17 972 l 111 972 l 406 131 l 624 753 z "
    },
    "ѵ": {
      "ha": 676,
      "x_min": 22,
      "x_max": 663,
      "o": "m 22 700 l 113 700 l 306 115 l 450 551 q 492 642 469 608 q 556 694 515 676 q 663 711 596 711 l 663 631 q 590 618 614 631 q 555 586 565 606 q 529 524 544 567 l 353 0 l 258 0 l 22 700 z "
    },
    "Ґ": {
      "ha": 729,
      "x_min": 125,
      "x_max": 688,
      "o": "m 688 1064 l 688 886 l 217 886 l 217 0 l 125 0 l 125 972 l 596 972 l 596 1064 l 688 1064 z "
    },
    "ґ": {
      "ha": 575,
      "x_min": 108,
      "x_max": 539,
      "o": "m 539 796 l 539 619 l 194 619 l 194 0 l 108 0 l 108 700 l 450 700 l 450 796 l 539 796 z "
    },
    "Ẁ": {
      "ha": 1193,
      "x_min": 17,
      "x_max": 1176,
      "o": "m 17 972 l 113 972 l 332 143 l 556 869 l 638 869 l 861 143 l 1081 972 l 1176 972 l 910 0 l 817 0 l 596 728 l 376 0 l 283 0 l 17 972 m 406 1244 l 535 1244 l 632 1050 l 563 1050 l 406 1244 z "
    },
    "ẁ": {
      "ha": 928,
      "x_min": 19,
      "x_max": 908,
      "o": "m 19 700 l 110 700 l 274 122 l 421 700 l 507 700 l 654 122 l 818 700 l 908 700 l 699 0 l 610 0 l 464 572 l 318 0 l 229 0 l 19 700 m 272 972 l 401 972 l 499 778 l 429 778 l 272 972 z "
    },
    "Ẃ": {
      "ha": 1193,
      "x_min": 17,
      "x_max": 1176,
      "o": "m 17 972 l 113 972 l 332 143 l 556 869 l 638 869 l 861 143 l 1081 972 l 1176 972 l 910 0 l 817 0 l 596 728 l 376 0 l 283 0 l 17 972 m 660 1244 l 789 1244 l 632 1050 l 563 1050 l 660 1244 z "
    },
    "ẃ": {
      "ha": 928,
      "x_min": 19,
      "x_max": 908,
      "o": "m 19 700 l 110 700 l 274 122 l 421 700 l 507 700 l 654 122 l 818 700 l 908 700 l 699 0 l 610 0 l 464 572 l 318 0 l 229 0 l 19 700 m 526 972 l 656 972 l 499 778 l 429 778 l 526 972 z "
    },
    "Ẅ": {
      "ha": 1193,
      "x_min": 17,
      "x_max": 1176,
      "o": "m 17 972 l 113 972 l 332 143 l 556 869 l 638 869 l 861 143 l 1081 972 l 1176 972 l 910 0 l 817 0 l 596 728 l 376 0 l 283 0 l 17 972 m 489 1092 q 440 1111 460 1092 q 421 1158 421 1131 q 440 1208 421 1188 q 489 1228 460 1228 q 538 1208 518 1228 q 557 1158 557 1188 q 538 1111 557 1131 q 489 1092 518 1092 m 701 1092 q 654 1111 674 1092 q 635 1158 635 1131 q 654 1208 635 1188 q 701 1228 674 1228 q 751 1208 731 1228 q 771 1158 771 1188 q 751 1111 771 1131 q 701 1092 731 1092 z "
    },
    "ẅ": {
      "ha": 928,
      "x_min": 19,
      "x_max": 908,
      "o": "m 19 700 l 110 700 l 274 122 l 421 700 l 507 700 l 654 122 l 818 700 l 908 700 l 699 0 l 610 0 l 464 572 l 318 0 l 229 0 l 19 700 m 357 819 q 308 839 328 819 q 289 886 289 858 q 308 935 289 915 q 357 956 328 956 q 406 935 386 956 q 425 886 425 915 q 406 839 425 858 q 357 819 386 819 m 569 819 q 522 839 542 819 q 503 886 503 858 q 522 935 503 915 q 569 956 542 956 q 619 935 599 956 q 639 886 639 915 q 619 839 639 858 q 569 819 599 819 z "
    },
    "ẞ": {
      "ha": 856,
      "x_min": 125,
      "x_max": 775,
      "o": "m 478 -11 q 331 15 408 -11 l 331 101 q 475 69 410 69 q 631 125 579 69 q 683 281 683 181 q 612 444 683 397 q 436 492 540 492 l 399 492 l 399 539 l 603 886 l 394 886 q 263 831 310 886 q 217 665 217 776 l 217 0 l 125 0 l 125 667 q 200 893 125 814 q 394 972 275 972 l 713 972 l 713 915 l 503 558 q 633 524 571 554 q 735 435 696 494 q 775 286 775 375 q 692 68 775 147 q 478 -11 610 -11 z "
    },
    "Ỳ": {
      "ha": 711,
      "x_min": 17,
      "x_max": 694,
      "o": "m 310 422 l 17 972 l 124 972 l 356 513 l 588 972 l 694 972 l 401 422 l 401 0 l 310 0 l 310 422 m 164 1244 l 293 1244 l 390 1050 l 321 1050 l 164 1244 z "
    },
    "ỳ": {
      "ha": 611,
      "x_min": 14,
      "x_max": 597,
      "o": "m 265 4 l 14 700 l 104 700 l 313 133 l 507 700 l 597 700 l 250 -283 l 164 -283 l 265 4 m 114 972 l 243 972 l 340 778 l 271 778 l 114 972 z "
    },
    "–": {
      "ha": 763,
      "x_min": 97,
      "x_max": 665,
      "o": "m 97 479 l 665 479 l 665 401 l 97 401 l 97 479 z "
    },
    "—": {
      "ha": 1047,
      "x_min": 97,
      "x_max": 950,
      "o": "m 97 479 l 950 479 l 950 401 l 97 401 l 97 479 z "
    },
    "‘": {
      "ha": 339,
      "x_min": 69,
      "x_max": 286,
      "o": "m 224 983 l 286 983 l 201 728 l 69 728 l 224 983 z "
    },
    "’": {
      "ha": 339,
      "x_min": 53,
      "x_max": 269,
      "o": "m 138 983 l 269 983 l 115 728 l 53 728 l 138 983 z "
    },
    "‚": {
      "ha": 339,
      "x_min": 53,
      "x_max": 269,
      "o": "m 138 124 l 269 124 l 115 -132 l 53 -132 l 138 124 z "
    },
    "“": {
      "ha": 538,
      "x_min": 69,
      "x_max": 485,
      "o": "m 400 728 l 268 728 l 422 983 l 485 983 l 400 728 m 201 728 l 69 728 l 224 983 l 286 983 l 201 728 z "
    },
    "”": {
      "ha": 538,
      "x_min": 53,
      "x_max": 468,
      "o": "m 138 983 l 269 983 l 115 728 l 53 728 l 138 983 m 336 983 l 468 983 l 314 728 l 251 728 l 336 983 z "
    },
    "„": {
      "ha": 526,
      "x_min": 42,
      "x_max": 457,
      "o": "m 126 122 l 258 122 l 104 -133 l 42 -133 l 126 122 m 325 122 l 457 122 l 303 -133 l 240 -133 l 325 122 z "
    },
    "†": {
      "ha": 556,
      "x_min": 49,
      "x_max": 507,
      "o": "m 236 622 l 49 622 l 49 700 l 236 700 l 236 1042 l 319 1042 l 319 700 l 507 700 l 507 622 l 319 622 l 319 -69 l 236 -69 l 236 622 z "
    },
    "‡": {
      "ha": 556,
      "x_min": 49,
      "x_max": 507,
      "o": "m 236 272 l 49 272 l 49 350 l 236 350 l 236 622 l 49 622 l 49 700 l 236 700 l 236 1042 l 319 1042 l 319 700 l 507 700 l 507 622 l 319 622 l 319 350 l 507 350 l 507 272 l 319 272 l 319 -69 l 236 -69 l 236 272 z "
    },
    "•": {
      "ha": 431,
      "x_min": 125,
      "x_max": 306,
      "o": "m 215 368 q 151 394 178 368 q 125 458 125 421 q 151 522 125 496 q 215 549 178 549 q 279 522 253 549 q 306 458 306 496 q 279 394 306 421 q 215 368 253 368 z "
    },
    "…": {
      "ha": 939,
      "x_min": 83,
      "x_max": 856,
      "o": "m 154 -3 q 103 17 124 -3 q 83 68 83 38 q 103 119 83 99 q 154 139 124 139 q 205 119 185 139 q 225 68 225 99 q 205 17 225 38 q 154 -3 185 -3 m 469 -3 q 419 17 439 -3 q 399 68 399 38 q 419 119 399 99 q 469 139 439 139 q 520 119 500 139 q 540 68 540 99 q 520 17 540 38 q 469 -3 500 -3 m 785 -3 q 734 17 754 -3 q 714 68 714 38 q 734 119 714 99 q 785 139 754 139 q 835 119 815 139 q 856 68 856 99 q 835 17 856 38 q 785 -3 815 -3 z "
    },
    "‰": {
      "ha": 1672,
      "x_min": 86,
      "x_max": 1586,
      "o": "m 181 13 l 933 1006 l 992 960 l 239 -33 l 181 13 m 304 539 q 192 569 242 539 q 115 649 143 599 q 86 761 86 700 q 115 873 86 822 q 192 953 143 924 q 304 983 242 983 q 416 953 367 983 q 494 873 465 924 q 522 761 522 822 q 494 649 522 700 q 416 569 465 599 q 304 539 367 539 m 304 614 q 408 656 369 614 q 447 761 447 697 q 408 867 447 825 q 304 908 369 908 q 200 867 239 908 q 161 761 161 825 q 200 656 161 697 q 304 614 239 614 m 868 -11 q 756 19 806 -11 q 678 99 707 49 q 650 211 650 150 q 678 323 650 272 q 756 403 707 374 q 868 433 806 433 q 980 403 931 433 q 1058 323 1029 374 q 1086 211 1086 272 q 1058 99 1086 150 q 980 19 1029 49 q 868 -11 931 -11 m 1368 -11 q 1256 19 1306 -11 q 1178 99 1207 49 q 1150 211 1150 150 q 1178 323 1150 272 q 1256 403 1207 374 q 1368 433 1306 433 q 1480 403 1431 433 q 1558 323 1529 374 q 1586 211 1586 272 q 1558 99 1586 150 q 1480 19 1529 49 q 1368 -11 1431 -11 m 868 64 q 972 106 933 64 q 1011 211 1011 147 q 972 317 1011 275 q 868 358 933 358 q 764 317 803 358 q 725 211 725 275 q 764 106 725 147 q 868 64 803 64 m 1368 64 q 1472 106 1433 64 q 1511 211 1511 147 q 1472 317 1511 275 q 1368 358 1433 358 q 1264 317 1303 358 q 1225 211 1225 275 q 1264 106 1225 147 q 1368 64 1303 64 z "
    },
    "‹": {
      "ha": 518,
      "x_min": 69,
      "x_max": 435,
      "o": "m 69 401 l 69 460 l 435 731 l 435 636 l 160 431 l 435 225 l 435 131 l 69 401 z "
    },
    "›": {
      "ha": 518,
      "x_min": 83,
      "x_max": 449,
      "o": "m 83 225 l 358 431 l 83 636 l 83 731 l 449 460 l 449 401 l 83 131 l 83 225 z "
    },
    "⁄": {
      "ha": 844,
      "x_min": 17,
      "x_max": 828,
      "o": "m 17 13 l 769 1006 l 828 960 l 75 -33 l 17 13 z "
    },
    "⁈": {
      "ha": 921,
      "x_min": 69,
      "x_max": 796,
      "o": "m 661 972 l 778 972 l 747 256 l 692 256 l 661 972 m 719 -3 q 665 19 686 -3 q 643 74 643 40 q 665 128 643 107 q 719 150 686 150 q 774 128 753 150 q 796 74 796 107 q 774 19 796 40 q 719 -3 753 -3 m 314 274 q 192 317 242 274 q 142 442 142 360 q 180 551 142 507 q 300 639 218 596 q 398 696 368 675 q 439 735 428 717 q 450 785 450 754 q 415 872 450 840 q 314 903 379 903 q 213 867 251 903 q 157 761 175 832 l 69 776 q 151 928 86 874 q 324 983 217 983 q 478 929 418 983 q 539 789 539 875 q 502 682 539 725 q 368 589 465 639 q 280 535 310 558 q 239 491 250 513 q 228 439 228 469 q 251 378 228 401 q 311 354 275 354 q 379 376 353 354 q 421 446 406 397 l 490 419 q 314 274 450 274 m 317 -3 q 262 19 283 -3 q 240 74 240 40 q 262 128 240 107 q 317 150 283 150 q 372 128 350 150 q 393 74 393 107 q 372 19 393 40 q 317 -3 350 -3 z "
    },
    "⁉": {
      "ha": 921,
      "x_min": 125,
      "x_max": 851,
      "o": "m 260 972 l 143 972 l 174 256 l 229 256 l 260 972 m 201 -3 q 256 19 235 -3 q 278 74 278 40 q 256 128 278 107 q 201 150 235 150 q 147 128 168 150 q 125 74 125 107 q 147 19 125 40 q 201 -3 168 -3 m 626 274 q 504 317 554 274 q 454 442 454 360 q 492 551 454 507 q 613 639 531 596 q 710 696 681 675 q 751 735 740 717 q 763 785 763 754 q 727 872 763 840 q 626 903 692 903 q 526 867 564 903 q 469 761 488 832 l 382 776 q 464 928 399 874 q 636 983 529 983 q 791 929 731 983 q 851 789 851 875 q 815 682 851 725 q 681 589 778 639 q 592 535 622 558 q 551 491 563 513 q 540 439 540 469 q 564 378 540 401 q 624 354 588 354 q 692 376 665 354 q 733 446 718 397 l 803 419 q 626 274 763 274 m 629 -3 q 574 19 596 -3 q 553 74 553 40 q 574 128 553 107 q 629 150 596 150 q 684 128 663 150 q 706 74 706 107 q 684 19 706 40 q 629 -3 663 -3 z "
    },
    "⁰": {
      "ha": 524,
      "x_min": 61,
      "x_max": 463,
      "o": "m 263 411 q 114 488 167 411 q 61 694 61 565 q 114 901 61 824 q 263 978 167 978 q 410 901 358 978 q 463 694 463 824 q 410 488 463 565 q 263 411 358 411 m 263 478 q 355 533 321 478 q 389 694 389 589 q 355 856 389 800 q 263 911 321 911 q 170 856 204 911 q 136 694 136 800 q 170 533 136 589 q 263 478 204 478 z "
    },
    "⁴": {
      "ha": 460,
      "x_min": 43,
      "x_max": 422,
      "o": "m 281 532 l 43 532 l 43 556 l 268 972 l 350 972 l 350 599 l 422 599 l 422 532 l 350 532 l 350 417 l 281 417 l 281 532 m 281 599 l 281 869 l 139 599 l 281 599 z "
    },
    "⁵": {
      "ha": 449,
      "x_min": 53,
      "x_max": 404,
      "o": "m 224 411 q 109 451 156 411 q 53 564 63 490 l 121 576 q 224 478 142 478 q 302 510 275 478 q 329 599 329 542 q 301 690 329 658 q 224 721 274 721 q 163 703 192 721 q 115 658 135 686 l 65 669 l 94 972 l 371 972 l 371 906 l 154 906 l 136 746 q 179 774 151 763 q 235 785 207 785 q 359 735 314 785 q 404 599 404 686 q 355 462 404 513 q 224 411 306 411 z "
    },
    "⁶": {
      "ha": 485,
      "x_min": 61,
      "x_max": 424,
      "o": "m 243 411 q 111 463 161 411 q 61 594 61 515 q 94 713 61 653 l 246 978 l 321 978 l 194 763 q 219 773 201 769 q 251 776 238 776 q 376 726 329 776 q 424 594 424 676 q 374 463 424 515 q 243 411 325 411 m 243 478 q 320 510 292 478 q 349 594 349 543 q 321 679 349 649 q 243 710 293 710 q 165 678 193 710 q 136 594 136 647 q 165 510 136 543 q 243 478 194 478 z "
    },
    "⁷": {
      "ha": 392,
      "x_min": 44,
      "x_max": 361,
      "o": "m 272 906 l 44 906 l 44 972 l 361 972 l 361 942 l 146 417 l 71 417 l 272 906 z "
    },
    "⁸": {
      "ha": 469,
      "x_min": 61,
      "x_max": 408,
      "o": "m 235 411 q 110 457 160 411 q 61 581 61 503 q 85 666 61 631 q 147 715 110 701 q 101 761 119 731 q 82 831 82 792 q 124 937 82 896 q 235 978 167 978 q 345 937 303 978 q 388 831 388 896 q 369 761 388 792 q 322 715 350 731 q 384 666 360 701 q 408 581 408 631 q 359 457 408 503 q 235 411 310 411 m 235 746 q 297 769 274 746 q 321 831 321 793 q 297 893 321 869 q 235 917 274 917 q 172 893 196 917 q 149 831 149 869 q 172 769 149 793 q 235 746 196 746 m 235 478 q 307 506 281 478 q 333 581 333 535 q 307 653 333 628 q 235 679 281 679 q 163 653 189 679 q 136 581 136 628 q 163 506 136 535 q 235 478 189 478 z "
    },
    "⁹": {
      "ha": 485,
      "x_min": 61,
      "x_max": 424,
      "o": "m 290 626 q 265 616 283 619 q 233 613 247 613 q 108 663 156 613 q 61 794 61 713 q 110 926 61 874 q 242 978 160 978 q 374 926 324 978 q 424 794 424 874 q 390 676 424 736 l 239 411 l 164 411 l 290 626 m 242 679 q 320 710 292 679 q 349 794 349 742 q 319 878 349 846 q 242 911 290 911 q 165 878 193 911 q 136 794 136 846 q 164 710 136 740 q 242 679 192 679 z "
    },
    "₀": {
      "ha": 524,
      "x_min": 61,
      "x_max": 463,
      "o": "m 263 -289 q 114 -212 167 -289 q 61 -6 61 -135 q 114 201 61 124 q 263 278 167 278 q 410 201 358 278 q 463 -6 463 124 q 410 -212 463 -135 q 263 -289 358 -289 m 263 -222 q 355 -167 321 -222 q 389 -6 389 -111 q 355 156 389 100 q 263 211 321 211 q 170 156 204 211 q 136 -6 136 100 q 170 -167 136 -111 q 263 -222 204 -222 z "
    },
    "₁": {
      "ha": 307,
      "x_min": 39,
      "x_max": 226,
      "o": "m 157 169 l 39 113 l 39 190 l 204 272 l 226 272 l 226 -283 l 157 -283 l 157 169 z "
    },
    "₂": {
      "ha": 443,
      "x_min": 47,
      "x_max": 396,
      "o": "m 47 -257 l 251 -3 q 294 63 282 36 q 307 122 307 90 q 285 185 307 163 q 221 208 263 208 q 160 179 183 208 q 132 103 138 150 l 57 122 q 108 234 64 190 q 221 278 153 278 q 339 235 296 278 q 382 122 382 192 q 328 -24 382 46 l 174 -214 l 396 -214 l 396 -283 l 47 -283 l 47 -257 z "
    },
    "₃": {
      "ha": 447,
      "x_min": 50,
      "x_max": 404,
      "o": "m 229 -289 q 106 -246 156 -289 q 50 -126 57 -203 l 125 -115 q 157 -193 131 -164 q 229 -222 183 -222 q 304 -190 279 -222 q 329 -106 329 -157 q 304 -24 329 -54 q 229 7 279 7 q 181 -7 203 7 l 144 42 l 268 206 l 81 206 l 81 272 l 376 272 l 376 249 l 238 61 q 263 63 246 63 q 364 18 324 63 q 404 -106 404 -26 q 359 -236 404 -183 q 229 -289 314 -289 z "
    },
    "₄": {
      "ha": 460,
      "x_min": 43,
      "x_max": 422,
      "o": "m 281 -168 l 43 -168 l 43 -144 l 268 272 l 350 272 l 350 -101 l 422 -101 l 422 -168 l 350 -168 l 350 -283 l 281 -283 l 281 -168 m 281 -101 l 281 169 l 139 -101 l 281 -101 z "
    },
    "₅": {
      "ha": 449,
      "x_min": 53,
      "x_max": 404,
      "o": "m 224 -289 q 109 -249 156 -289 q 53 -136 63 -210 l 121 -124 q 224 -222 142 -222 q 302 -190 275 -222 q 329 -101 329 -158 q 301 -10 329 -42 q 224 21 274 21 q 163 3 192 21 q 115 -42 135 -14 l 65 -31 l 94 272 l 371 272 l 371 206 l 154 206 l 136 46 q 179 74 151 63 q 235 85 207 85 q 359 35 314 85 q 404 -101 404 -14 q 355 -238 404 -187 q 224 -289 306 -289 z "
    },
    "₆": {
      "ha": 485,
      "x_min": 61,
      "x_max": 424,
      "o": "m 243 -289 q 111 -237 161 -289 q 61 -106 61 -185 q 94 13 61 -47 l 246 278 l 321 278 l 194 63 q 219 73 201 69 q 251 76 238 76 q 376 26 329 76 q 424 -106 424 -24 q 374 -237 424 -185 q 243 -289 325 -289 m 243 -222 q 320 -190 292 -222 q 349 -106 349 -157 q 321 -21 349 -51 q 243 10 293 10 q 165 -22 193 10 q 136 -106 136 -53 q 165 -190 136 -157 q 243 -222 194 -222 z "
    },
    "₇": {
      "ha": 392,
      "x_min": 44,
      "x_max": 361,
      "o": "m 272 206 l 44 206 l 44 272 l 361 272 l 361 242 l 146 -283 l 71 -283 l 272 206 z "
    },
    "₈": {
      "ha": 469,
      "x_min": 61,
      "x_max": 408,
      "o": "m 235 -289 q 110 -243 160 -289 q 61 -119 61 -197 q 85 -34 61 -69 q 147 15 110 1 q 101 61 119 31 q 82 131 82 92 q 124 237 82 196 q 235 278 167 278 q 345 237 303 278 q 388 131 388 196 q 369 61 388 92 q 322 15 350 31 q 384 -34 360 1 q 408 -119 408 -69 q 359 -243 408 -197 q 235 -289 310 -289 m 235 46 q 297 69 274 46 q 321 131 321 93 q 297 193 321 169 q 235 217 274 217 q 172 193 196 217 q 149 131 149 169 q 172 69 149 93 q 235 46 196 46 m 235 -222 q 307 -194 281 -222 q 333 -119 333 -165 q 307 -47 333 -72 q 235 -21 281 -21 q 163 -47 189 -21 q 136 -119 136 -72 q 163 -194 136 -165 q 235 -222 189 -222 z "
    },
    "₉": {
      "ha": 485,
      "x_min": 61,
      "x_max": 424,
      "o": "m 290 -74 q 265 -84 283 -81 q 233 -87 247 -87 q 108 -37 156 -87 q 61 94 61 13 q 110 226 61 174 q 242 278 160 278 q 374 226 324 278 q 424 94 424 174 q 390 -24 424 36 l 239 -289 l 164 -289 l 290 -74 m 242 -21 q 320 10 292 -21 q 349 94 349 42 q 319 178 349 146 q 242 211 290 211 q 165 178 193 211 q 136 94 136 146 q 164 10 136 40 q 242 -21 192 -21 z "
    },
    "₣": {
      "ha": 738,
      "x_min": 53,
      "x_max": 688,
      "o": "m 221 886 l 221 550 l 604 550 l 604 464 l 221 464 l 221 264 l 418 264 l 418 178 l 221 178 l 221 0 l 129 0 l 129 178 l 53 178 l 53 264 l 129 264 l 129 972 l 688 972 l 688 886 l 221 886 z "
    },
    "₨": {
      "ha": 1358,
      "x_min": 50,
      "x_max": 1294,
      "o": "m 451 972 q 644 920 572 972 q 726 765 715 868 l 819 765 l 819 688 l 726 688 q 663 549 717 600 q 517 485 608 497 l 819 0 l 717 0 l 413 481 l 231 481 l 231 0 l 139 0 l 139 688 l 50 688 l 50 765 l 139 765 l 139 972 l 451 972 m 231 765 l 633 765 q 446 886 614 886 l 231 886 l 231 765 m 1124 396 q 1247 319 1199 368 q 1294 194 1294 269 q 1236 44 1294 99 q 1078 -11 1178 -11 q 908 44 972 -11 q 825 181 844 100 l 901 221 q 965 109 924 149 q 1078 69 1006 69 q 1171 103 1138 69 q 1204 193 1204 136 q 1166 274 1204 244 q 1050 332 1128 304 q 919 406 964 363 q 874 528 874 450 q 929 661 874 611 q 1069 711 985 711 q 1183 685 1136 711 q 1264 603 1231 658 l 1203 550 q 1142 612 1175 593 q 1065 631 1108 631 q 992 603 1021 631 q 963 531 963 576 q 999 456 963 485 q 1124 396 1035 428 m 446 567 q 633 688 614 567 l 231 688 l 231 567 l 446 567 z "
    },
    "₫": {
      "ha": 664,
      "x_min": 67,
      "x_max": 611,
      "o": "m 611 833 l 542 833 l 542 253 l 461 253 l 461 321 q 396 267 439 289 q 306 244 353 244 q 135 319 196 244 q 75 511 75 393 q 135 703 75 628 q 304 778 196 778 q 394 758 354 778 q 461 703 435 738 l 461 833 l 325 833 l 325 900 l 461 900 l 461 972 l 542 972 l 542 900 l 611 900 l 611 833 m 314 317 q 426 371 386 317 q 467 511 467 425 q 426 651 467 597 q 314 704 386 704 q 200 651 240 704 q 160 511 160 597 q 200 370 160 424 q 314 317 240 317 m 611 97 l 67 97 l 67 164 l 611 164 l 611 97 z "
    },
    "€": {
      "ha": 850,
      "x_min": 49,
      "x_max": 789,
      "o": "m 524 -11 q 280 86 374 -11 q 164 346 186 183 l 49 346 l 89 424 l 158 424 l 158 549 l 49 549 l 89 626 l 164 626 q 280 886 186 789 q 524 983 374 983 q 679 943 615 983 q 789 822 743 903 l 713 781 q 635 873 685 840 q 524 906 586 906 q 345 833 415 906 q 254 626 275 761 l 613 626 l 572 549 l 247 549 l 247 424 l 613 424 l 572 346 l 254 346 q 345 139 275 211 q 524 67 415 67 q 635 99 586 67 q 713 192 685 132 l 789 150 q 679 29 743 69 q 524 -11 615 -11 z "
    },
    "₭": {
      "ha": 736,
      "x_min": 31,
      "x_max": 714,
      "o": "m 200 494 l 183 494 l 183 0 l 92 0 l 92 494 l 31 494 l 31 572 l 92 572 l 92 972 l 183 972 l 183 572 l 197 572 l 563 972 l 679 972 l 314 572 l 689 572 l 689 494 l 314 494 l 714 0 l 601 0 l 200 494 z "
    },
    "₱": {
      "ha": 890,
      "x_min": 50,
      "x_max": 840,
      "o": "m 840 731 l 747 731 q 749 704 749 722 q 747 678 749 686 l 840 678 l 840 592 l 729 592 q 633 476 701 517 q 468 436 565 436 l 229 436 l 229 0 l 138 0 l 138 592 l 50 592 l 50 678 l 138 678 l 138 731 l 50 731 l 50 817 l 138 817 l 138 972 l 468 972 q 633 932 565 972 q 729 817 701 892 l 840 817 l 840 731 m 229 817 l 624 817 q 469 886 579 886 l 229 886 l 229 817 m 653 704 q 651 731 653 722 l 229 731 l 229 678 l 651 678 q 653 704 653 686 m 469 522 q 624 592 579 522 l 229 592 l 229 522 l 469 522 z "
    },
    "₴": {
      "ha": 717,
      "x_min": 58,
      "x_max": 647,
      "o": "m 647 601 l 647 524 l 58 524 l 58 601 l 392 601 q 473 670 444 632 q 501 764 501 708 q 463 858 501 818 q 361 897 425 897 q 200 786 250 897 l 125 833 q 213 944 157 904 q 361 983 268 983 q 478 955 425 983 q 563 874 532 926 q 593 757 593 822 q 528 601 593 663 l 647 601 m 58 449 l 647 449 l 647 371 l 326 371 q 245 302 274 340 q 217 208 217 264 q 255 115 217 154 q 357 75 293 75 q 518 186 468 75 l 593 139 q 506 28 561 68 q 357 -11 450 -11 q 240 17 293 -11 q 156 98 186 46 q 125 215 125 150 q 190 371 125 310 l 58 371 l 58 449 z "
    },
    "₸": {
      "ha": 700,
      "x_min": 42,
      "x_max": 658,
      "o": "m 42 935 l 658 935 l 658 849 l 42 849 l 42 935 m 304 614 l 42 614 l 42 700 l 658 700 l 658 614 l 396 614 l 396 0 l 304 0 l 304 614 z "
    },
    "₺": {
      "ha": 856,
      "x_min": 31,
      "x_max": 790,
      "o": "m 790 360 l 790 268 q 715 72 790 143 q 510 0 640 0 l 263 0 l 263 389 l 31 332 l 31 410 l 263 467 l 263 556 l 31 499 l 31 576 l 263 633 l 263 972 l 354 972 l 354 656 l 599 715 l 599 638 l 354 578 l 354 489 l 599 549 l 599 471 l 354 411 l 354 86 l 511 86 q 650 135 606 86 q 694 268 694 185 l 694 360 l 790 360 z "
    },
    "₽": {
      "ha": 824,
      "x_min": 50,
      "x_max": 763,
      "o": "m 243 436 l 243 285 l 565 285 l 565 199 l 243 199 l 243 0 l 151 0 l 151 199 l 50 199 l 50 285 l 151 285 l 151 436 l 50 436 l 50 522 l 151 522 l 151 972 l 482 972 q 688 901 613 972 q 763 704 763 829 q 688 508 763 579 q 482 436 613 436 l 243 436 m 243 522 l 483 522 q 622 572 578 522 q 667 704 667 621 q 622 837 667 788 q 483 886 578 886 l 243 886 l 243 522 z "
    },
    "₿": {
      "ha": 839,
      "x_min": 125,
      "x_max": 758,
      "o": "m 758 281 q 694 93 758 167 q 517 4 629 19 l 517 -97 l 425 -97 l 425 0 l 357 0 l 357 -97 l 265 -97 l 265 0 l 125 0 l 125 972 l 265 972 l 265 1069 l 357 1069 l 357 972 l 425 972 l 425 1069 l 517 1069 l 517 965 q 658 883 608 946 q 708 724 708 821 q 674 602 708 649 q 586 532 640 556 q 712 442 665 504 q 758 281 758 379 m 217 561 l 438 561 q 569 602 524 561 q 614 724 614 643 q 569 845 614 804 q 438 886 524 886 l 217 886 l 217 561 m 442 86 q 607 131 551 86 q 663 281 663 176 q 607 430 663 385 q 442 475 551 475 l 217 475 l 217 86 l 442 86 z "
    },
    "ℓ": {
      "ha": 546,
      "x_min": 22,
      "x_max": 508,
      "o": "m 508 169 q 432 35 479 81 q 303 -11 385 -11 q 175 35 221 -11 q 129 172 129 81 l 129 444 q 67 403 97 421 l 22 465 q 129 539 90 508 l 129 826 q 163 937 129 890 q 269 983 197 983 q 372 938 340 983 q 403 831 403 893 q 363 671 403 751 q 251 538 322 590 l 221 514 l 221 168 q 244 94 221 119 q 307 69 267 69 q 384 98 354 69 q 436 199 414 126 l 508 169 m 269 900 q 221 822 221 900 l 221 613 q 291 713 265 654 q 317 831 317 772 q 269 900 317 900 z "
    },
    "№": {
      "ha": 1701,
      "x_min": 125,
      "x_max": 1635,
      "o": "m 125 972 l 233 972 l 715 146 l 715 972 l 807 972 l 807 0 l 699 0 l 217 824 l 217 0 l 125 0 l 125 972 m 1024 78 l 1592 78 l 1592 0 l 1024 0 l 1024 78 m 1307 261 q 1134 312 1208 261 q 1019 446 1060 363 q 979 622 979 529 q 1019 799 979 715 q 1134 933 1060 882 q 1307 983 1208 983 q 1480 933 1406 983 q 1594 799 1554 882 q 1635 622 1635 715 q 1594 446 1635 529 q 1480 312 1554 363 q 1307 261 1406 261 m 1307 342 q 1435 381 1382 342 q 1517 485 1489 421 q 1544 622 1544 550 q 1517 759 1544 694 q 1435 863 1489 824 q 1307 903 1382 903 q 1178 863 1232 903 q 1097 759 1125 824 q 1069 622 1069 694 q 1097 485 1069 550 q 1178 381 1125 421 q 1307 342 1232 342 z "
    },
    "℗": {
      "ha": 1211,
      "x_min": 83,
      "x_max": 1128,
      "o": "m 606 -56 q 338 15 457 -56 q 151 210 218 86 q 83 486 83 333 q 151 763 83 639 q 338 957 218 886 q 606 1028 457 1028 q 874 957 754 1028 q 1060 763 993 886 q 1128 486 1128 639 q 1060 210 1128 333 q 874 15 993 86 q 606 -56 754 -56 m 606 31 q 833 90 733 31 q 987 254 932 150 q 1042 486 1042 358 q 987 718 1042 614 q 833 882 932 822 q 606 942 733 942 q 378 882 478 942 q 224 718 279 822 q 169 486 169 614 q 224 254 169 358 q 378 90 279 150 q 606 31 478 31 m 436 782 l 636 782 q 771 735 721 782 q 821 613 821 689 q 772 487 821 531 q 636 443 722 443 l 518 443 l 518 190 l 436 190 l 436 782 m 636 518 q 713 543 686 518 q 739 613 739 568 q 713 683 739 658 q 636 707 686 707 l 518 707 l 518 518 l 636 518 z "
    },
    "℠": {
      "ha": 1122,
      "x_min": 56,
      "x_max": 1000,
      "o": "m 238 406 q 117 448 168 406 q 56 556 67 490 l 111 590 q 154 499 124 529 q 239 468 185 468 q 313 494 283 468 q 342 564 342 519 q 312 640 342 610 q 214 696 282 671 q 89 849 89 742 q 129 945 89 907 q 235 983 169 983 q 324 960 292 983 q 379 890 356 936 l 325 856 q 235 921 299 921 q 176 900 199 921 q 154 847 154 879 q 178 790 154 810 q 233 756 201 769 q 275 738 264 743 q 374 669 339 708 q 410 567 410 631 q 359 451 410 497 q 238 406 308 406 m 528 972 l 600 972 l 764 581 l 928 972 l 1000 972 l 1000 417 l 932 417 l 932 826 l 783 468 l 744 468 l 596 826 l 596 417 l 528 417 l 528 972 z "
    },
    "™": {
      "ha": 1126,
      "x_min": 42,
      "x_max": 1004,
      "o": "m 200 911 l 42 911 l 42 972 l 426 972 l 426 911 l 268 911 l 268 417 l 200 417 l 200 911 m 532 972 l 604 972 l 768 581 l 932 972 l 1004 972 l 1004 417 l 936 417 l 936 826 l 788 468 l 749 468 l 600 826 l 600 417 l 532 417 l 532 972 z "
    },
    "Ω": {
      "ha": 936,
      "x_min": 47,
      "x_max": 889,
      "o": "m 61 86 l 283 86 q 113 299 179 185 q 47 549 47 413 q 99 772 47 674 q 245 927 150 871 q 468 983 340 983 q 691 927 596 983 q 838 772 786 871 q 889 549 889 674 q 823 299 889 413 q 653 86 757 185 l 875 86 l 875 0 l 539 0 l 539 86 q 733 308 672 203 q 793 549 793 413 q 752 731 793 651 q 638 853 711 810 q 468 897 564 897 q 299 853 372 897 q 184 731 225 810 q 143 549 143 651 q 203 308 143 413 q 397 86 264 203 l 397 0 l 61 0 l 61 86 z "
    },
    "℮": {
      "ha": 1058,
      "x_min": 42,
      "x_max": 1017,
      "o": "m 218 213 q 349 99 264 142 q 529 56 433 56 q 747 110 649 56 q 889 263 844 165 l 967 263 q 788 65 907 140 q 529 -10 669 -10 q 274 57 385 -10 q 102 237 163 124 q 42 486 42 350 q 102 738 42 624 q 274 917 163 851 q 529 983 385 983 q 781 920 669 983 q 954 744 892 857 q 1017 486 1017 631 l 218 486 l 218 213 m 529 921 q 352 881 435 921 q 218 772 269 840 l 218 551 l 847 551 l 847 768 q 717 876 803 832 q 529 921 632 921 z "
    },
    "⅓": {
      "ha": 1097,
      "x_min": 39,
      "x_max": 1054,
      "o": "m 157 869 l 39 813 l 39 890 l 204 972 l 226 972 l 226 417 l 157 417 l 157 869 m 117 13 l 869 1006 l 928 960 l 175 -33 l 117 13 m 879 -11 q 756 32 806 -11 q 700 151 707 75 l 775 163 q 807 85 781 114 q 879 56 833 56 q 954 88 929 56 q 979 172 979 121 q 954 254 979 224 q 879 285 929 285 q 831 271 853 285 l 794 319 l 918 483 l 731 483 l 731 550 l 1026 550 l 1026 526 l 888 339 q 913 340 896 340 q 1014 296 974 340 q 1054 172 1054 251 q 1009 42 1054 94 q 879 -11 964 -11 z "
    },
    "⅔": {
      "ha": 1225,
      "x_min": 47,
      "x_max": 1182,
      "o": "m 47 443 l 251 697 q 294 763 282 736 q 307 822 307 790 q 285 885 307 863 q 221 908 263 908 q 160 879 183 908 q 132 803 138 850 l 57 822 q 108 934 64 890 q 221 978 153 978 q 339 935 296 978 q 382 822 382 892 q 328 676 382 746 l 174 486 l 396 486 l 396 417 l 47 417 l 47 443 m 244 13 l 997 1006 l 1056 960 l 303 -33 l 244 13 m 1007 -11 q 884 32 933 -11 q 828 151 835 75 l 903 163 q 935 85 908 114 q 1007 56 961 56 q 1082 88 1057 56 q 1107 172 1107 121 q 1082 254 1107 224 q 1007 285 1057 285 q 958 271 981 285 l 922 319 l 1046 483 l 858 483 l 858 550 l 1154 550 l 1154 526 l 1015 339 q 1040 340 1024 340 q 1142 296 1101 340 q 1182 172 1182 251 q 1137 42 1182 94 q 1007 -11 1092 -11 z "
    },
    "⅛": {
      "ha": 1094,
      "x_min": 39,
      "x_max": 1033,
      "o": "m 157 869 l 39 813 l 39 890 l 204 972 l 226 972 l 226 417 l 157 417 l 157 869 m 117 13 l 869 1006 l 928 960 l 175 -33 l 117 13 m 860 -11 q 735 35 785 -11 q 686 158 686 81 q 710 244 686 208 q 772 293 735 279 q 726 339 744 308 q 707 408 707 369 q 749 515 707 474 q 860 556 792 556 q 970 515 928 556 q 1013 408 1013 474 q 994 339 1013 369 q 947 293 975 308 q 1009 244 985 279 q 1033 158 1033 208 q 984 35 1033 81 q 860 -11 935 -11 m 860 324 q 922 347 899 324 q 946 408 946 371 q 922 471 946 447 q 860 494 899 494 q 797 471 821 494 q 774 408 774 447 q 797 347 774 371 q 860 324 821 324 m 860 56 q 932 84 906 56 q 958 158 958 113 q 932 231 958 206 q 860 257 906 257 q 788 231 814 257 q 761 158 761 206 q 788 84 761 113 q 860 56 814 56 z "
    },
    "⅜": {
      "ha": 1167,
      "x_min": 50,
      "x_max": 1106,
      "o": "m 229 411 q 106 454 156 411 q 50 574 57 497 l 125 585 q 157 507 131 536 q 229 478 183 478 q 304 510 279 478 q 329 594 329 543 q 304 676 329 646 q 229 707 279 707 q 181 693 203 707 l 144 742 l 268 906 l 81 906 l 81 972 l 376 972 l 376 949 l 238 761 q 263 763 246 763 q 364 718 324 763 q 404 594 404 674 q 359 464 404 517 q 229 411 314 411 m 189 13 l 942 1006 l 1000 960 l 247 -33 l 189 13 m 932 -11 q 808 35 857 -11 q 758 158 758 81 q 783 244 758 208 q 844 293 807 279 q 798 339 817 308 q 779 408 779 369 q 822 515 779 474 q 932 556 864 556 q 1042 515 1000 556 q 1085 408 1085 474 q 1066 339 1085 369 q 1019 293 1047 308 q 1081 244 1057 279 q 1106 158 1106 208 q 1056 35 1106 81 q 932 -11 1007 -11 m 932 324 q 994 347 971 324 q 1018 408 1018 371 q 994 471 1018 447 q 932 494 971 494 q 869 471 893 494 q 846 408 846 447 q 869 347 846 371 q 932 324 893 324 m 932 56 q 1004 84 978 56 q 1031 158 1031 113 q 1004 231 1031 206 q 932 257 978 257 q 860 231 886 257 q 833 158 833 206 q 860 84 833 113 q 932 56 886 56 z "
    },
    "⅝": {
      "ha": 1167,
      "x_min": 53,
      "x_max": 1106,
      "o": "m 224 411 q 109 451 156 411 q 53 564 63 490 l 121 576 q 224 478 142 478 q 302 510 275 478 q 329 599 329 542 q 301 690 329 658 q 224 721 274 721 q 163 703 192 721 q 115 658 135 686 l 65 669 l 94 972 l 371 972 l 371 906 l 154 906 l 136 746 q 179 774 151 763 q 235 785 207 785 q 359 735 314 785 q 404 599 404 686 q 355 462 404 513 q 224 411 306 411 m 189 13 l 942 1006 l 1000 960 l 247 -33 l 189 13 m 932 -11 q 808 35 857 -11 q 758 158 758 81 q 783 244 758 208 q 844 293 807 279 q 798 339 817 308 q 779 408 779 369 q 822 515 779 474 q 932 556 864 556 q 1042 515 1000 556 q 1085 408 1085 474 q 1066 339 1085 369 q 1019 293 1047 308 q 1081 244 1057 279 q 1106 158 1106 208 q 1056 35 1106 81 q 932 -11 1007 -11 m 932 324 q 994 347 971 324 q 1018 408 1018 371 q 994 471 1018 447 q 932 494 971 494 q 869 471 893 494 q 846 408 846 447 q 869 347 846 371 q 932 324 893 324 m 932 56 q 1004 84 978 56 q 1031 158 1031 113 q 1004 231 1031 206 q 932 257 978 257 q 860 231 886 257 q 833 158 833 206 q 860 84 833 113 q 932 56 886 56 z "
    },
    "⅞": {
      "ha": 1043,
      "x_min": 44,
      "x_max": 982,
      "o": "m 272 906 l 44 906 l 44 972 l 361 972 l 361 942 l 146 417 l 71 417 l 272 906 m 65 13 l 818 1006 l 876 960 l 124 -33 l 65 13 m 808 -11 q 684 35 733 -11 q 635 158 635 81 q 659 244 635 208 q 721 293 683 279 q 674 339 693 308 q 656 408 656 369 q 698 515 656 474 q 808 556 740 556 q 919 515 876 556 q 961 408 961 474 q 942 339 961 369 q 896 293 924 308 q 958 244 933 279 q 982 158 982 208 q 933 35 982 81 q 808 -11 883 -11 m 808 324 q 871 347 847 324 q 894 408 894 371 q 871 471 894 447 q 808 494 847 494 q 746 471 769 494 q 722 408 722 447 q 746 347 722 371 q 808 324 769 324 m 808 56 q 881 84 854 56 q 907 158 907 113 q 881 231 907 206 q 808 257 854 257 q 736 231 763 257 q 710 158 710 206 q 736 84 710 113 q 808 56 763 56 z "
    },
    "←": {
      "ha": 893,
      "x_min": 75,
      "x_max": 818,
      "o": "m 75 486 l 389 799 l 446 740 l 236 526 l 818 526 l 818 446 l 236 446 l 446 232 l 389 174 l 75 486 z "
    },
    "↑": {
      "ha": 875,
      "x_min": 125,
      "x_max": 750,
      "o": "m 397 697 l 183 488 l 125 544 l 438 858 l 750 544 l 692 488 l 478 697 l 478 114 l 397 114 l 397 697 z "
    },
    "→": {
      "ha": 893,
      "x_min": 75,
      "x_max": 818,
      "o": "m 447 232 l 657 446 l 75 446 l 75 526 l 657 526 l 447 740 l 504 799 l 818 486 l 504 174 l 447 232 z "
    },
    "↓": {
      "ha": 875,
      "x_min": 125,
      "x_max": 750,
      "o": "m 125 428 l 183 485 l 397 275 l 397 858 l 478 858 l 478 275 l 692 485 l 750 428 l 438 114 l 125 428 z "
    },
    "↔": {
      "ha": 1040,
      "x_min": 75,
      "x_max": 965,
      "o": "m 75 486 l 389 799 l 446 740 l 236 526 l 818 526 l 818 446 l 236 446 l 446 232 l 389 174 l 75 486 m 594 232 l 804 446 l 222 446 l 222 526 l 804 526 l 594 740 l 651 799 l 965 486 l 651 174 l 594 232 z "
    },
    "↕": {
      "ha": 833,
      "x_min": 104,
      "x_max": 729,
      "o": "m 376 778 l 163 568 l 104 625 l 417 939 l 729 625 l 671 568 l 457 778 l 457 194 l 376 194 l 376 778 m 104 347 l 163 404 l 376 194 l 376 778 l 457 778 l 457 194 l 671 404 l 729 347 l 417 33 l 104 347 z "
    },
    "↖": {
      "ha": 881,
      "x_min": 164,
      "x_max": 718,
      "o": "m 249 619 l 249 321 l 164 321 l 164 764 l 606 764 l 606 678 l 307 678 l 718 268 l 658 208 l 249 619 z "
    },
    "↗": {
      "ha": 881,
      "x_min": 164,
      "x_max": 718,
      "o": "m 164 268 l 575 678 l 276 678 l 276 764 l 718 764 l 718 321 l 633 321 l 633 619 l 224 208 l 164 268 z "
    },
    "↘": {
      "ha": 881,
      "x_min": 164,
      "x_max": 718,
      "o": "m 276 294 l 575 294 l 164 704 l 224 764 l 633 353 l 633 651 l 718 651 l 718 208 l 276 208 l 276 294 z "
    },
    "↙": {
      "ha": 881,
      "x_min": 163,
      "x_max": 717,
      "o": "m 163 651 l 247 651 l 247 353 l 657 764 l 717 704 l 306 294 l 604 294 l 604 208 l 163 208 l 163 651 z "
    },
    "∂": {
      "ha": 797,
      "x_min": 67,
      "x_max": 731,
      "o": "m 342 -11 q 199 26 261 -11 q 101 131 136 64 q 67 286 67 199 q 113 497 67 399 q 247 653 160 594 q 447 711 333 711 q 559 689 504 711 q 639 632 614 667 q 567 829 626 756 q 414 903 507 903 q 308 869 351 903 q 236 778 265 836 l 146 801 q 254 934 183 885 q 424 983 325 983 q 651 857 572 983 q 731 493 731 731 q 688 241 731 356 q 557 58 644 126 q 342 -11 469 -11 m 342 69 q 494 117 426 69 q 598 242 561 164 q 635 410 635 321 q 582 572 635 514 q 435 631 529 631 q 288 582 350 631 q 192 455 225 533 q 158 289 158 376 q 209 131 158 192 q 342 69 260 69 z "
    },
    "∆": {
      "ha": 781,
      "x_min": 17,
      "x_max": 764,
      "o": "m 17 22 l 344 972 l 436 972 l 764 22 l 764 0 l 17 0 l 17 22 m 650 81 l 390 843 l 131 81 l 650 81 z "
    },
    "∏": {
      "ha": 740,
      "x_min": 125,
      "x_max": 615,
      "o": "m 125 972 l 615 972 l 615 0 l 529 0 l 529 894 l 211 894 l 211 0 l 125 0 l 125 972 z "
    },
    "∑": {
      "ha": 735,
      "x_min": 79,
      "x_max": 657,
      "o": "m 79 21 l 378 486 l 79 951 l 79 972 l 657 972 l 657 894 l 210 894 l 464 497 l 464 475 l 210 78 l 657 78 l 657 0 l 79 0 l 79 21 z "
    },
    "−": {
      "ha": 764,
      "x_min": 97,
      "x_max": 667,
      "o": "m 97 478 l 667 478 l 667 400 l 97 400 l 97 478 z "
    },
    "∕": {
      "ha": 719,
      "x_min": 11,
      "x_max": 708,
      "o": "m 617 1042 l 708 1042 l 103 -69 l 11 -69 l 617 1042 z "
    },
    "∙": {
      "ha": 499,
      "x_min": 125,
      "x_max": 374,
      "o": "m 250 296 q 162 333 199 296 q 125 421 125 369 q 162 510 125 474 q 250 546 199 546 q 338 509 301 546 q 374 421 374 472 q 338 333 374 369 q 250 296 301 296 z "
    },
    "√": {
      "ha": 708,
      "x_min": 53,
      "x_max": 697,
      "o": "m 183 463 l 53 463 l 53 540 l 238 540 l 367 150 l 619 983 l 697 983 l 399 0 l 333 0 l 183 463 z "
    },
    "∞": {
      "ha": 1208,
      "x_min": 79,
      "x_max": 1129,
      "o": "m 329 233 q 148 307 217 233 q 79 499 79 381 q 148 690 79 617 q 329 764 217 764 q 477 717 411 764 q 604 579 543 669 q 731 717 665 669 q 879 764 797 764 q 1060 690 992 764 q 1129 499 1129 617 q 1060 307 1129 381 q 879 233 992 233 q 731 281 797 233 q 604 418 665 328 q 477 281 543 328 q 329 233 411 233 m 347 311 q 465 359 408 311 q 567 499 521 407 q 465 638 521 590 q 347 686 408 686 q 215 636 264 686 q 165 499 165 586 q 215 361 165 411 q 347 311 264 311 m 861 311 q 994 361 944 311 q 1043 499 1043 411 q 994 636 1043 586 q 861 686 944 686 q 744 638 800 686 q 642 499 688 590 q 744 359 688 407 q 861 311 800 311 z "
    },
    "∫": {
      "ha": 650,
      "x_min": -103,
      "x_max": 653,
      "o": "m -12 -294 q -64 -289 -37 -294 q -103 -276 -90 -283 l -69 -197 q 0 -214 -36 -214 q 101 -179 65 -214 q 151 -69 136 -144 l 310 744 q 398 928 335 874 q 568 983 461 983 q 617 978 593 983 q 653 965 640 974 l 619 886 q 588 899 603 896 q 550 903 574 903 q 452 867 492 903 q 399 758 413 831 l 240 -56 q 154 -240 215 -186 q -12 -294 93 -294 z "
    },
    "≈": {
      "ha": 739,
      "x_min": 69,
      "x_max": 669,
      "o": "m 500 239 q 437 248 464 239 q 372 276 410 257 q 311 305 338 296 q 250 314 285 314 q 182 297 214 314 q 125 251 150 281 l 69 306 q 148 383 104 353 q 239 414 192 414 q 302 405 275 414 q 367 376 329 396 q 428 348 401 357 q 489 339 454 339 q 557 356 525 339 q 614 401 589 372 l 669 347 q 591 269 635 300 q 500 239 547 239 m 500 517 q 437 526 464 517 q 372 554 410 535 q 311 583 338 574 q 250 592 285 592 q 182 575 214 592 q 125 529 150 558 l 69 583 q 148 661 104 631 q 239 692 192 692 q 302 683 275 692 q 367 654 329 674 q 428 626 401 635 q 489 617 454 617 q 557 633 525 617 q 614 679 589 650 l 669 625 q 591 547 635 578 q 500 517 547 517 z "
    },
    "≠": {
      "ha": 732,
      "x_min": 97,
      "x_max": 635,
      "o": "m 167 169 l 233 285 l 97 285 l 97 363 l 278 363 l 365 515 l 97 515 l 97 593 l 410 593 l 499 747 l 565 708 l 499 593 l 635 593 l 635 515 l 454 515 l 367 363 l 635 363 l 635 285 l 322 285 l 233 131 l 167 169 z "
    },
    "≤": {
      "ha": 763,
      "x_min": 97,
      "x_max": 665,
      "o": "m 149 511 l 149 606 l 613 856 l 613 769 l 219 558 l 613 347 l 613 261 l 149 511 m 97 78 l 665 78 l 665 0 l 97 0 l 97 78 z "
    },
    "≥": {
      "ha": 763,
      "x_min": 97,
      "x_max": 665,
      "o": "m 150 347 l 543 558 l 150 769 l 150 856 l 614 606 l 614 511 l 150 261 l 150 347 m 97 78 l 665 78 l 665 0 l 97 0 l 97 78 z "
    },
    "◊": {
      "ha": 778,
      "x_min": 96,
      "x_max": 682,
      "o": "m 96 486 l 346 972 l 432 972 l 682 486 l 432 0 l 346 0 l 96 486 m 593 486 l 389 883 l 185 486 l 389 89 l 593 486 z "
    },
    "": {
      "ha": 1100,
      "x_min": 139,
      "x_max": 961,
      "o": "m 169 0 q 148 9 157 0 q 139 31 139 18 l 139 857 q 145 876 139 867 q 161 888 151 885 l 536 996 l 550 999 l 564 996 l 939 888 q 955 876 949 885 q 961 857 961 867 l 961 31 q 952 9 961 18 q 931 0 943 0 l 921 1 l 550 108 l 179 1 l 169 0 m 519 929 l 200 836 q 249 678 206 750 q 363 560 292 606 q 519 508 435 515 l 519 929 m 581 508 q 737 560 665 515 q 851 678 808 606 q 900 836 894 750 l 581 929 l 581 508 m 519 164 l 519 447 q 333 508 418 456 q 199 643 249 560 l 199 71 l 519 164 m 901 643 q 766 508 850 560 q 581 447 682 456 l 581 164 l 901 71 l 901 643 z "
    },
    "ﬁ": {
      "ha": 686,
      "x_min": 17,
      "x_max": 606,
      "o": "m 128 619 l 17 619 l 17 700 l 128 700 l 128 722 q 165 863 128 804 q 263 953 201 922 q 400 983 325 983 q 553 943 489 983 l 535 864 q 393 903 467 903 q 263 856 313 903 q 214 736 214 810 l 214 700 l 606 700 l 606 0 l 519 0 l 519 619 l 214 619 l 214 0 l 128 0 l 128 619 z "
    },
    "ﬂ": {
      "ha": 714,
      "x_min": 17,
      "x_max": 606,
      "o": "m 128 619 l 17 619 l 17 700 l 128 700 l 128 744 q 184 924 128 865 q 344 983 240 983 l 606 983 l 606 0 l 519 0 l 519 903 l 338 903 q 247 867 279 903 q 214 758 214 831 l 214 700 l 383 700 l 383 619 l 214 619 l 214 0 l 128 0 l 128 619 z "
    }
  },
  "familyName": "Apercu Pro Light",
  "ascender": 1094,
  "descender": -294,
  "underlinePosition": -179,
  "underlineThickness": 86,
  "boundingBox": {
    "yMin": -342,
    "xMin": -869,
    "yMax": 1546,
    "xMax": 1635
  },
  "resolution": 1000,
  "original_font_information": {
    "format": 0,
    "copyright": "Copyright (c) 2017 by Colophon Foundry. All rights reserved.",
    "fontFamily": "Apercu Pro Light",
    "fontSubfamily": "Regular",
    "uniqueID": "3.003;CF  ;ApercuPro-Light",
    "fullName": "Apercu Pro Light",
    "version": "Version 3.003; ttfautohint (v1.5)",
    "postScriptName": "ApercuPro-Light",
    "trademark": "Apercu is a trademark of Colophon Foundry.",
    "manufacturer": "The Entente (AS&EH)",
    "designer": "The Entente (AS&EH)",
    "description": "Copyright (c) 2010-2017 by Colophon Foundry. All rights reserved.",
    "manufacturerURL": "http://www.colophon-foundry.org",
    "designerURL": "http://the-entente.org",
    "licence": "For an up-to-date licence agreement please visit: http://www.colophon-foundry.org",
    "licenceURL": "http://www.colophon-foundry.org",
    "preferredFamily": "Apercu Pro",
    "preferredSubfamily": "Light"
  },
  "cssFontWeight": "normal",
  "cssFontStyle": "normal"
};
},{}],"assets/sounds/drop1.mp3":[function(require,module,exports) {
module.exports = "/drop1.7c8ec657.mp3";
},{}],"assets/sounds/drop2.mp3":[function(require,module,exports) {
module.exports = "/drop2.2321928a.mp3";
},{}],"assets/sounds/drop3.mp3":[function(require,module,exports) {
module.exports = "/drop3.b11e3f78.mp3";
},{}],"assets/sounds/drop4.mp3":[function(require,module,exports) {
module.exports = "/drop4.188943d6.mp3";
},{}],"assets/sounds/drop5.mp3":[function(require,module,exports) {
module.exports = "/drop5.d87f28b7.mp3";
},{}],"assets/sounds/drop6.mp3":[function(require,module,exports) {
module.exports = "/drop6.a426e890.mp3";
},{}],"assets/sounds/drop7.mp3":[function(require,module,exports) {
module.exports = "/drop7.3abb5c9e.mp3";
},{}],"assets/sounds/drop8.mp3":[function(require,module,exports) {
module.exports = "/drop8.4c701acf.mp3";
},{}],"assets/sounds/drop9.mp3":[function(require,module,exports) {
module.exports = "/drop9.a2aa98ba.mp3";
},{}],"assets/sounds/flower1.mp3":[function(require,module,exports) {
module.exports = "/flower1.ca65f129.mp3";
},{}],"assets/sounds/flower2.mp3":[function(require,module,exports) {
module.exports = "/flower2.775070b8.mp3";
},{}],"assets/sounds/flower3.mp3":[function(require,module,exports) {
module.exports = "/flower3.fcd539fe.mp3";
},{}],"assets/sounds/flower4.mp3":[function(require,module,exports) {
module.exports = "/flower4.75f510b8.mp3";
},{}],"assets/sounds/flower5.mp3":[function(require,module,exports) {
module.exports = "/flower5.540e801b.mp3";
},{}],"assets/sounds/flower6.mp3":[function(require,module,exports) {
module.exports = "/flower6.4a9776f9.mp3";
},{}],"assets/sounds/flower7.mp3":[function(require,module,exports) {
module.exports = "/flower7.74e45c3c.mp3";
},{}],"assets/sounds/flower8.mp3":[function(require,module,exports) {
module.exports = "/flower8.ccd7a469.mp3";
},{}],"assets/sounds/flower9.mp3":[function(require,module,exports) {
module.exports = "/flower9.1e259ba2.mp3";
},{}],"assets/sounds/flower10.mp3":[function(require,module,exports) {
module.exports = "/flower10.afaf527c.mp3";
},{}],"assets/sounds/flower11.mp3":[function(require,module,exports) {
module.exports = "/flower11.66e79a51.mp3";
},{}],"assets/sounds/grow1.mp3":[function(require,module,exports) {
module.exports = "/grow1.4f3914fb.mp3";
},{}],"assets/sounds/grow2.mp3":[function(require,module,exports) {
module.exports = "/grow2.01229d13.mp3";
},{}],"assets/sounds/grow3.mp3":[function(require,module,exports) {
module.exports = "/grow3.6cc2ef1d.mp3";
},{}],"assets/sounds/grow4.mp3":[function(require,module,exports) {
module.exports = "/grow4.459fb4cb.mp3";
},{}],"assets/sounds/grow5.mp3":[function(require,module,exports) {
module.exports = "/grow5.914b5572.mp3";
},{}],"assets/sounds/grow6.mp3":[function(require,module,exports) {
module.exports = "/grow6.0c5e0a35.mp3";
},{}],"assets/sounds/grow7.mp3":[function(require,module,exports) {
module.exports = "/grow7.9c35cb04.mp3";
},{}],"assets/sounds/grow8.mp3":[function(require,module,exports) {
module.exports = "/grow8.80016568.mp3";
},{}],"assets/sounds/wind.mp3":[function(require,module,exports) {
module.exports = "/wind.4ae17039.mp3";
},{}],"hardcodedSounds.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _drop = _interopRequireDefault(require("./assets/sounds/drop1.mp3"));

var _drop2 = _interopRequireDefault(require("./assets/sounds/drop2.mp3"));

var _drop3 = _interopRequireDefault(require("./assets/sounds/drop3.mp3"));

var _drop4 = _interopRequireDefault(require("./assets/sounds/drop4.mp3"));

var _drop5 = _interopRequireDefault(require("./assets/sounds/drop5.mp3"));

var _drop6 = _interopRequireDefault(require("./assets/sounds/drop6.mp3"));

var _drop7 = _interopRequireDefault(require("./assets/sounds/drop7.mp3"));

var _drop8 = _interopRequireDefault(require("./assets/sounds/drop8.mp3"));

var _drop9 = _interopRequireDefault(require("./assets/sounds/drop9.mp3"));

var _flower = _interopRequireDefault(require("./assets/sounds/flower1.mp3"));

var _flower2 = _interopRequireDefault(require("./assets/sounds/flower2.mp3"));

var _flower3 = _interopRequireDefault(require("./assets/sounds/flower3.mp3"));

var _flower4 = _interopRequireDefault(require("./assets/sounds/flower4.mp3"));

var _flower5 = _interopRequireDefault(require("./assets/sounds/flower5.mp3"));

var _flower6 = _interopRequireDefault(require("./assets/sounds/flower6.mp3"));

var _flower7 = _interopRequireDefault(require("./assets/sounds/flower7.mp3"));

var _flower8 = _interopRequireDefault(require("./assets/sounds/flower8.mp3"));

var _flower9 = _interopRequireDefault(require("./assets/sounds/flower9.mp3"));

var _flower10 = _interopRequireDefault(require("./assets/sounds/flower10.mp3"));

var _flower11 = _interopRequireDefault(require("./assets/sounds/flower11.mp3"));

var _grow = _interopRequireDefault(require("./assets/sounds/grow1.mp3"));

var _grow2 = _interopRequireDefault(require("./assets/sounds/grow2.mp3"));

var _grow3 = _interopRequireDefault(require("./assets/sounds/grow3.mp3"));

var _grow4 = _interopRequireDefault(require("./assets/sounds/grow4.mp3"));

var _grow5 = _interopRequireDefault(require("./assets/sounds/grow5.mp3"));

var _grow6 = _interopRequireDefault(require("./assets/sounds/grow6.mp3"));

var _grow7 = _interopRequireDefault(require("./assets/sounds/grow7.mp3"));

var _grow8 = _interopRequireDefault(require("./assets/sounds/grow8.mp3"));

var _wind = _interopRequireDefault(require("./assets/sounds/wind.mp3"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = {
  drop1: _drop.default,
  drop2: _drop2.default,
  drop3: _drop3.default,
  drop4: _drop4.default,
  drop5: _drop5.default,
  drop6: _drop6.default,
  drop7: _drop7.default,
  drop8: _drop8.default,
  drop9: _drop9.default,
  flower1: _flower.default,
  flower2: _flower2.default,
  flower3: _flower3.default,
  flower4: _flower4.default,
  flower5: _flower5.default,
  flower6: _flower6.default,
  flower7: _flower7.default,
  flower8: _flower8.default,
  flower9: _flower9.default,
  flower10: _flower10.default,
  flower11: _flower11.default,
  grow1: _grow.default,
  grow2: _grow2.default,
  grow3: _grow3.default,
  grow4: _grow4.default,
  grow5: _grow5.default,
  grow6: _grow6.default,
  grow7: _grow7.default,
  grow8: _grow8.default,
  wind: _wind.default
};
exports.default = _default;
},{"./assets/sounds/drop1.mp3":"assets/sounds/drop1.mp3","./assets/sounds/drop2.mp3":"assets/sounds/drop2.mp3","./assets/sounds/drop3.mp3":"assets/sounds/drop3.mp3","./assets/sounds/drop4.mp3":"assets/sounds/drop4.mp3","./assets/sounds/drop5.mp3":"assets/sounds/drop5.mp3","./assets/sounds/drop6.mp3":"assets/sounds/drop6.mp3","./assets/sounds/drop7.mp3":"assets/sounds/drop7.mp3","./assets/sounds/drop8.mp3":"assets/sounds/drop8.mp3","./assets/sounds/drop9.mp3":"assets/sounds/drop9.mp3","./assets/sounds/flower1.mp3":"assets/sounds/flower1.mp3","./assets/sounds/flower2.mp3":"assets/sounds/flower2.mp3","./assets/sounds/flower3.mp3":"assets/sounds/flower3.mp3","./assets/sounds/flower4.mp3":"assets/sounds/flower4.mp3","./assets/sounds/flower5.mp3":"assets/sounds/flower5.mp3","./assets/sounds/flower6.mp3":"assets/sounds/flower6.mp3","./assets/sounds/flower7.mp3":"assets/sounds/flower7.mp3","./assets/sounds/flower8.mp3":"assets/sounds/flower8.mp3","./assets/sounds/flower9.mp3":"assets/sounds/flower9.mp3","./assets/sounds/flower10.mp3":"assets/sounds/flower10.mp3","./assets/sounds/flower11.mp3":"assets/sounds/flower11.mp3","./assets/sounds/grow1.mp3":"assets/sounds/grow1.mp3","./assets/sounds/grow2.mp3":"assets/sounds/grow2.mp3","./assets/sounds/grow3.mp3":"assets/sounds/grow3.mp3","./assets/sounds/grow4.mp3":"assets/sounds/grow4.mp3","./assets/sounds/grow5.mp3":"assets/sounds/grow5.mp3","./assets/sounds/grow6.mp3":"assets/sounds/grow6.mp3","./assets/sounds/grow7.mp3":"assets/sounds/grow7.mp3","./assets/sounds/grow8.mp3":"assets/sounds/grow8.mp3","./assets/sounds/wind.mp3":"assets/sounds/wind.mp3"}],"sketch.js":[function(require,module,exports) {
"use strict";

var _p = _interopRequireWildcard(require("p5"));

var _globals = require("./globals.js");

var _util = require("./util.js");

var _threeapp = require("./threeapp.js");

var THREE = _interopRequireWildcard(require("three"));

var _wind_data_small = _interopRequireDefault(require("./wind_data_small.txt"));

var _ApercuProLight_FromTTF = _interopRequireDefault(require("./ApercuProLight_FromTTF.json"));

var _hardcodedSounds = _interopRequireDefault(require("./hardcodedSounds"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

//import soundsList from './assets/sounds/*.mp3'
console.log(_hardcodedSounds.default);
document.addEventListener("DOMContentLoaded", function () {
  // parcel bundles the json data in the project (e.g. no need to load it!)
  _globals.GLOBALS.font = new THREE.Font(_ApercuProLight_FromTTF.default);
  var howlerLoadPromises = Object.keys(_hardcodedSounds.default).map(function (soundPath) {
    return new Promise(function (resolve, reject) {
      var sound = new Howl({
        src: _hardcodedSounds.default[soundPath],
        volume: 0,
        onload: function onload() {
          if (soundPath.match(/^grow/)) {
            _globals.GLOBALS.growth_sounds.push(sound);
          } else if (soundPath.match(/^flower/)) {
            _globals.GLOBALS.flower_sounds.push(sound);
          } else if (soundPath.match(/^drop/)) {
            _globals.GLOBALS.rain_sounds.push(sound);
          } else if (soundPath === 'wind') {
            sound.loop(true);
            _globals.GLOBALS.wind_sound = sound;
          }

          resolve();
        }
      });
    });
  }); // load all sounds, then start sketch

  Promise.all(howlerLoadPromises).then(function () {
    startSketch();
  });
});

function startSketch() {
  (0, _threeapp.initThreeApp)();
  new _p.default(sketch);
  document.querySelector('body').addEventListener('click', function () {
    if (_globals.GLOBALS.sound_enabled === false) {
      // only set it once
      _globals.GLOBALS.sound_enabled = true;
      (0, _util.startSounds)();
    }
  });
  document.querySelector('body').addEventListener('touchstart', function () {
    if (_globals.GLOBALS.sound_enabled === false) {
      // only set it once
      _globals.GLOBALS.sound_enabled = true;
      (0, _util.startSounds)();
    }
  });
}

var windDataLoaded = false;

var sketch = function sketch(p5) {
  p5.preload = function () {// font = p5.loadFont('Apercu Pro Light.otf')
  };

  p5.setup = function () {
    // p5.randomSeed(99);
    // p5.noiseSeed(99);
    // loadStrings is ***broken*** for large-ish (>20k? line) files
    // do manual split (using code from p5.js) and submit a fix to p5.js!!
    fetch(_wind_data_small.default).then(function (response) {
      return response.text();
    }).then(function (data) {
      _globals.GLOBALS.wind_values = data.replace(/\r\n/g, '\r').replace(/\n/g, '\r').split(/\r/);
      windDataLoaded = true;
    });
    p5.noCanvas();
    (0, _util.populateHopes)();
    (0, _util.createTrees)(p5);
  };

  p5.draw = function () {
    // only use wind data if the file has been loaded via es6 fetch call
    // (typically takes 2-3 frames to load the wind (locally, at least...))
    if (windDataLoaded) {
      (0, _util.handleWind)(p5);
    }

    for (var i = 0; i < _globals.GLOBALS.trees.length; i++) {
      _globals.GLOBALS.trees[i].render(!_globals.GLOBALS.previz);

      _globals.GLOBALS.trees[i].setSway(_globals.GLOBALS.wind);

      _globals.GLOBALS.trees[i].update();

      _globals.GLOBALS.trees[i].advance();
    }

    for (var _i = _globals.GLOBALS.raindrops.length - 1; _i >= 0; _i--) {
      _globals.GLOBALS.raindrops[_i].render();

      _globals.GLOBALS.raindrops[_i].update();

      if (_globals.GLOBALS.raindrops[_i].kill) {
        _globals.GLOBALS.raindrops.splice(_i, 1);
      }
    }

    (0, _util.handleShowers)(p5);
  };
};
},{"p5":"node_modules/p5/lib/p5.min.js","./globals.js":"globals.js","./util.js":"util.js","./threeapp.js":"threeapp.js","three":"node_modules/three/build/three.module.js","./wind_data_small.txt":"wind_data_small.txt","./ApercuProLight_FromTTF.json":"ApercuProLight_FromTTF.json","./hardcodedSounds":"hardcodedSounds.js"}],"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "58322" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["../../../../AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/hmr-runtime.js","sketch.js"], null)
//# sourceMappingURL=/sketch.702e4367.js.map